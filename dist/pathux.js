if (typeof window === "undefined" && typeof global !== "undefined") {
  global.window = global;
}

(function () {
  let visitgen = 0;

  window.destroyAllCSS = function () {
    visitgen++;

    let visit = (n) => {
      if (n.__visit === visitgen) {
        return;
      }

      n.__visit = visitgen;
      if (n.tagName === "STYLE") {
        n.textContents = '';
      }

      if (n.style) {
        for (let k in n.style) {
          try {
            n.style[k] = "";
          } catch (error) {

          }
        }
      }

      if (!n.childNodes) {
        return;
      }

      for (let c of n.childNodes) {
        visit(c);
      }
    };

    visit(document.head);
    visit(document.body);

    for (let sheet of document.styleSheets) {
      for (let i = 0; i < sheet.rules.length; i++) {
        sheet.removeRule(sheet.rules[0]);
      }
    }
  };
})();

window.eventDebugModule = (function () {
  "use strict";

  return {
    start() {
      window.debugEventLists = {};
      window.debugEventList = [];

      this._addEventListener = EventTarget.prototype.addEventListener;
      this._removeEventListener = EventTarget.prototype.removeEventListener;
      this._dispatchEvent = EventTarget.prototype.dispatchEvent;

      EventTarget.prototype.addEventListener = this.onadd;
      EventTarget.prototype.removeEventListener = this.onrem;
      EventTarget.prototype.dispatchEvent = this.ondispatch;
    },

    add(type, data) {
      if (!(type in debugEventLists)) {
        debugEventLists[type] = [];
      }

      debugEventLists[type].push(data);
    },

    ondispatch() {
      let a = arguments;

      eventDebugModule.add("Dispatch", {
        event    : a[0],
        thisvar  : a[4],
        line     : a[5],
        filename : a[6].replace(/\\/g, "/"),
        filepath : location.origin + a[6].replace(/\\/g, "/") + ":" + a[5],
        ownerpath: a[7]
      });

      return eventDebugModule._dispatchEvent.apply(this, arguments);
    },

    onadd() {
      let a = arguments;

      eventDebugModule.add("Add", {
        type     : a[0],
        cb       : a[1],
        args     : a[2],
        thisvar  : a[4],
        line     : a[5],
        filename : a[6].replace(/\\/g, "/"),
        filepath : location.origin + a[6].replace(/\\/g, "/") + ":" + a[5],
        ownerpath: a[7]
      });


      return eventDebugModule._addEventListener.apply(this, arguments);
    },

    pruneConnected() {
      for (let k in debugEventLists) {
        let list = debugEventLists[k];

        for (let i = 0; i < list.length; i++) {
          let e = list[i];

          if (!e.thisvar || !(e.thisvar instanceof Node)) {
            continue;
          }

          if (!e.thisvar.isConnected) {
            list[i] = list[list.length - 1];
            list[list.length - 1] = undefined;
            list.length--;
            i--;
          }
        }
      }
    },


    onrem() {
      let a = arguments;

      eventDebugModule.add("Rem", {
        type     : a[0],
        cb       : a[1],
        args     : a[2],
        thisvar  : a[4],
        line     : a[5],
        filename : a[6].replace(/\\/g, "/"),
        filepath : location.origin + a[6].replace(/\\/g, "/") + ":" + a[5],
        ownerpath: a[7]
      });


      return eventDebugModule._removeEventListener.apply(this, arguments);
    }
  }
})();

if (typeof _debug_event_listeners !== "undefined" && _debug_event_listeners) {
  eventDebugModule.start();
}

/*
if (navigator.userAgent.toLowerCase().search("chrome") >= 0) {
  console.warn("Patching Google Chrome scrollbar bug");

  let cb = (e) => {
    if (e.touches.length == 1) {
      let e2 = Object.create(e);
      e2.pageX = e.touches[0].pageX;
      e2.pageY = e.touches[0].pageY;
      e2.x = e2.screenX = e2.pageX;
      e2.y = e2.screenY = e2.pageY;
      e2.button = 0;
      e2.buttons = 1;

      let type;
      if (e.type === "touchstart")
        type = "mousedown";
      else 
        type = "mousemove";

      console.log(e2);
        //console.log(e.target);
      e2 = new MouseEvent(type, e);
      e.target.dispatchEvent(e2);
    }
  };

  window.addEventListener("touchstart", (e) => cb(e));
  window.addEventListener("touchmove", (e) => cb(e));

  document.addEventListener("touchstart", (e) => cb(e));
  document.addEventListener("touchmove", (e) => cb(e));
}
//*/

if (window._disable_all_listeners) {
  console.warn("Disabling all event listeners");
  EventTarget.prototype.addEventListener = () => {
  };
  EventSource.prototype.addEventListener = () => {
  };
}

if (typeof visualViewport === "undefined") {
  (function () {
    class MyVisualViewport {
      get width() {
        return window.innerWidth;
      }

      get height() {
        return window.innerHeight;
      }

      get offsetLeft() {
        return 0;
      }

      get offsetTop() {
        return 0;
      }

      get pageLeft() {
        return 0;
      }

      get pageTop() {
        return 0;
      }

      get scale() {
        return 1.0;
      }
    }

    window.visualViewport = new MyVisualViewport();
  })();
}

if (Array.prototype.set === undefined) {
  Array.prototype.set = function set(array, src, dst, count) {
    if (arguments.length === 0) {
      //WASM somehow manages to call this
      return;
    }

    src = src === undefined ? 0 : src;
    dst = dst === undefined ? 0 : dst;
    count = count === undefined ? array.length : count;

    if (count < 0) {
      throw new RangeError("Count must be >= zero");
    }

    let len = Math.min(this.length - dst, array.length - src);
    len = Math.min(len, count);

    for (let i = 0; i < len; i++) {
      this[dst + i] = array[src + i];
    }

    return this;
  };

  Object.defineProperty(Array.prototype, "set", {
    enumerable  : false,
    configurable: true,
  });

  if (Float64Array.prototype.set === undefined) {
    Float64Array.prototype.set = Array.prototype.set;
    Float32Array.prototype.set = Array.prototype.set;
    Uint8Array.prototype.set = Array.prototype.set;
    Uint8ClampedArray.prototype.set = Array.prototype.set;
    Int32Array.prototype.set = Array.prototype.set;
    Int16Array.prototype.set = Array.prototype.set;
    Int8Array.prototype.set = Array.prototype.set;
  }
}

if (Array.prototype.reject === undefined) {
  Array.prototype.reject = function reject(func) {
    return this.filter((item) => !func(item));
  };

  Object.defineProperty(Array.prototype, "reject", {
    enumerable  : false,
    configurable: true,
  });
}

if (window.Symbol == undefined) { //eek!
  window.Symbol = {
    iterator: "$__iterator__$",
    keystr  : "$__keystr__$"
  };
} else if (Symbol.keystr === undefined) {
  Symbol.keystr = Symbol("keystr");
}

/* use util.list
window.list = function list(iter) {
  var ret = [];

  if (typeof iter == "string") {
    iter = new String();
  }

  if (Symbol.iterator in iter) {
    for (var item of iter) {
      ret.push(item);
    }
  } else {
    iter.forEach(function (item) {
      ret.push(item);
    }, this);
  }

  return ret;
};*/

//XXX surely browser vendors have fixed this by now. . .
/*Override array iterator to not allocate too much*/

/*
function ArrayIter(array) {
  this.array = array;
  this.i = 0;
  this.ret = {done : false, value : undefined};
}

ArrayIter.prototype[Symbol.iterator] = function() {
  return this;
}

ArrayIter.prototype.next = function() {
  var ret = this.ret;
  
  if (this.i >= this.array.length) {
    ret.done = true;
    ret.value = undefined;
    return ret;
  }
  
  ret.value = this.array[this.i++];
  return ret;
};//*/


//Array.prototype[Symbol.iterator] = function() {
//  return new ArrayIter(this);
//}

if (Math.fract === undefined) {
  Math.fract = function fract(f) {
    return f - Math.floor(f);
  };
}

if (Math.tent === undefined) {
  Math.tent = function tent(f) {
    return 1.0 - Math.abs(Math.fract(f) - 0.5)*2.0;
  };
}

if (Math.sign === undefined) {
  Math.sign = function sign(f) {
    return (f > 0.0)*2.0 - 1.0;
  };
}

if (Array.prototype.pop_i === undefined) {
  Array.prototype.pop_i = function (idx) {
    if (idx < 0 || idx >= this.length) {
      throw new Error("Index out of range");
    }

    while (idx < this.length) {
      this[idx] = this[idx + 1];
      idx++;
    }

    this.length -= 1;
  };

  Object.defineProperty(Array.prototype, "pop_i", {
    enumerable  : false,
    configurable: true,
  });
}

if (Array.prototype.remove === undefined) {
  Array.prototype.remove = function (item, suppress_error) {
    var i = this.indexOf(item);

    if (i < 0) {
      if (suppress_error)
        console.trace("Warning: item not in array", item);
      else
        throw new Error("Error: item not in array " + item);

      return;
    }

    this.pop_i(i);
  };

  Object.defineProperty(Array.prototype, "remove", {
    enumerable  : false,
    configurable: true,
  });
}

if (String.prototype.contains === undefined) {
  String.prototype.contains = function (substr) {
    return String.search(substr) >= 0;
  };
}

String.prototype[Symbol.keystr] = function () {
  return this;
};

Number.prototype[Symbol.keystr] = Boolean.prototype[Symbol.keystr] = function () {
  return "" + this;
};

Array.prototype[Symbol.keystr] = function () {
  let key = "";
  for (let item of this) {
    key += item[Symbol.keystr]() + ":";
  }

  return key;
};

"use strict";
/*
The lexical scanner in this module was inspired by PyPLY

http://www.dabeaz.com/ply/ply.html
*/

class token {
  constructor(type, val, lexpos, lineno, lexer, parser) {
    this.type = type;
    this.value = val;
    this.lexpos = lexpos;
    this.lineno = lineno;
    this.lexer = lexer;
    this.parser = parser;
  }

  toString() {
    if (this.value !== undefined)
      return "token(type=" + this.type + ", value='" + this.value + "')";
    else
      return "token(type=" + this.type + ")";
  }
}

class tokdef {
  constructor(name, regexpr, func, example) {
    this.name = name;
    this.re = regexpr;
    this.func = func;
    this.example = example;
    
    if (example === undefined && regexpr) {
      let s = "" + regexpr;
      if (s.startsWith("/") && s.endsWith("/")) {
        s = s.slice(1, s.length-1);
      }
      
      if (s.startsWith("\\")) {
        s = s.slice(1, s.length);
      }
      s = s.trim();
      
      if (s.length === 1) {
        this.example = s;
      }
    }
  }
}

class PUTIL_ParseError extends Error {
  constructor(msg) {
    super();
  }
}

class lexer {
  constructor(tokdef, errfunc) {
    this.tokdef = tokdef;
    this.tokens = new Array();
    this.lexpos = 0;
    this.lexdata = "";
    this.lineno = 0;
    this.errfunc = errfunc;
    this.tokints = {};
    for (let i = 0; i < tokdef.length; i++) {
      this.tokints[tokdef[i].name] = i;
    }
    this.statestack = [["__main__", 0]];
    this.states = {"__main__": [tokdef, errfunc]};
    this.statedata = 0;
  }

  add_state(name, tokdef, errfunc) {
    if (errfunc === undefined) {
      errfunc = function (lexer) {
        return true;
      };
    }
    this.states[name] = [tokdef, errfunc];
  }

  tok_int(name) {
  }

  push_state(state, statedata) {
    this.statestack.push([state, statedata]);
    state = this.states[state];
    this.statedata = statedata;
    this.tokdef = state[0];
    this.errfunc = state[1];
  }

  pop_state() {
    let item = this.statestack[this.statestack.length - 1];
    let state = this.states[item[0]];
    this.tokdef = state[0];
    this.errfunc = state[1];
    this.statedata = item[1];
  }

  input(str) {
    while (this.statestack.length > 1) {
      this.pop_state();
    }
    this.lexdata = str;
    this.lexpos = 0;
    this.lineno = 0;
    this.tokens = new Array();
    this.peeked_tokens = [];
  }

  error() {
    if (this.errfunc !== undefined && !this.errfunc(this))
      return;

    console.log("Syntax error near line " + this.lineno);

    let next = Math.min(this.lexpos + 8, this.lexdata.length);
    console.log("  " + this.lexdata.slice(this.lexpos, next));

    throw new PUTIL_ParseError("Parse error");
  }

  peek() {
    let tok = this.next(true);
    if (tok === undefined)
      return undefined;
    this.peeked_tokens.push(tok);
    return tok;
  }

  peeknext() {
    if (this.peeked_tokens.length > 0) {
      return this.peeked_tokens[0];
    }

    return this.peek();
  }

  at_end() {
    return this.lexpos >= this.lexdata.length && this.peeked_tokens.length === 0;
  }

  //ignore_peek is optional, false
  next(ignore_peek) {
    if (!ignore_peek && this.peeked_tokens.length > 0) {
      let tok = this.peeked_tokens[0];
      this.peeked_tokens.shift();
      return tok;
    }

    if (this.lexpos >= this.lexdata.length)
      return undefined;

    let ts = this.tokdef;
    let tlen = ts.length;
    let lexdata = this.lexdata.slice(this.lexpos, this.lexdata.length);
    let results = [];

    for (var i = 0; i < tlen; i++) {
      let t = ts[i];
      if (t.re === undefined)
        continue;
      let res = t.re.exec(lexdata);
      if (res !== null && res !== undefined && res.index === 0) {
        results.push([t, res]);
      }
    }

    let max_res = 0;
    let theres = undefined;
    for (var i = 0; i < results.length; i++) {
      let res = results[i];
      if (res[1][0].length > max_res) {
        theres = res;
        max_res = res[1][0].length;
      }
    }

    if (theres === undefined) {
      this.error();
      return;
    }

    let def = theres[0];
    let tok = new token(def.name, theres[1][0], this.lexpos, this.lineno, this, undefined);
    this.lexpos += tok.value.length;

    if (def.func) {
      tok = def.func(tok);
      if (tok === undefined) {
        return this.next();
      }
    }

    return tok;
  }
}

class parser {
  constructor(lexer, errfunc) {
    this.lexer = lexer;
    this.errfunc = errfunc;
    this.start = undefined;
  }

  parse(data, err_on_unconsumed) {
    if (err_on_unconsumed === undefined)
      err_on_unconsumed = true;

    if (data !== undefined)
      this.lexer.input(data);

    let ret = this.start(this);

    if (err_on_unconsumed && !this.lexer.at_end() && this.lexer.next() !== undefined) {
      this.error(undefined, "parser did not consume entire input");
    }
    return ret;
  }

  input(data) {
    this.lexer.input(data);
  }

  error(token, msg) {
    let estr;

    if (msg === undefined)
      msg = "";
    if (token === undefined)
      estr = "Parse error at end of input: " + msg;
    else
      estr = "Parse error at line " + (token.lineno + 1) + ": " + msg;

    let buf = "1| ";
    let ld = this.lexer.lexdata;
    let l = 1;
    for (var i = 0; i < ld.length; i++) {
      let c = ld[i];
      if (c === '\n') {
        l++;
        buf += "\n" + l + "| ";
      }
      else {
        buf += c;
      }
    }
    console.log("------------------");
    console.log(buf);
    console.log("==================");
    console.log(estr);
    if (this.errfunc && !this.errfunc(token)) {
      return;
    }
    throw new PUTIL_ParseError(estr);
  }

  peek() {
    let tok = this.lexer.peek();
    if (tok !== undefined)
      tok.parser = this;
    return tok;
  }

  peeknext() {
    let tok = this.lexer.peeknext();
    if (tok !== undefined)
      tok.parser = this;
    return tok;
  }

  next() {
    let tok = this.lexer.next();
    if (tok !== undefined)
      tok.parser = this;
    return tok;
  }

  optional(type) {
    let tok = this.peek();
    if (tok === undefined)
      return false;
    if (tok.type === type) {
      this.next();
      return true;
    }
    return false;
  }

  at_end() {
    return this.lexer.at_end();
  }

  expect(type, msg) {
    let tok = this.next();
    
    if (msg === undefined) {
      msg = type;
      
      for (let tk of this.lexer.tokdef) {
        if (tk.name === type && tk.example) {
          msg = tk.example;
        }
      }
    }
    
    if (tok === undefined || tok.type !== type) {
      this.error(tok, "Expected " + msg);
    }
    return tok.value;
  }
}

function test_parser() {
  let basic_types = new set(["int", "float", "double", "vec2", "vec3", "vec4", "mat4", "string"]);
  let reserved_tokens = new set(["int", "float", "double", "vec2", "vec3", "vec4", "mat4", "string", "static_string", "array"]);

  function tk(name, re, func) {
    return new tokdef(name, re, func);
  }

  let tokens = [tk("ID", /[a-zA-Z]+[a-zA-Z0-9_]*/, function (t) {
    if (reserved_tokens.has(t.value)) {
      t.type = t.value.toUpperCase();
    }
    return t;
  }), tk("OPEN", /\{/), tk("CLOSE", /}/), tk("COLON", /:/), tk("JSCRIPT", /\|/, function (t) {
    let js = "";
    let lexer = t.lexer;
    while (lexer.lexpos < lexer.lexdata.length) {
      let c = lexer.lexdata[lexer.lexpos];
      if (c === "\n")
        break;
      js += c;
      lexer.lexpos++;
    }
    if (js.endsWith(";")) {
      js = js.slice(0, js.length - 1);
      lexer.lexpos--;
    }
    t.value = js;
    return t;
  }), tk("LPARAM", /\(/), tk("RPARAM", /\)/), tk("COMMA", /,/), tk("NUM", /[0-9]/), tk("SEMI", /;/), tk("NEWLINE", /\n/, function (t) {
    t.lexer.lineno += 1;
  }), tk("SPACE", / |\t/, function (t) {
  })];
  let __iter_rt = __get_iter(reserved_tokens);
  let rt;
  while (1) {
    let __ival_rt = __iter_rt.next();
    if (__ival_rt.done) {
      break;
    }
    rt = __ival_rt.value;
    tokens.push(tk(rt.toUpperCase()));
  }
  let a = "\n  Loop {\n    eid : int;\n    flag : int;\n    index : int;\n    type : int;\n\n    co : vec3;\n    no : vec3;\n    loop : int | eid(loop);\n    edges : array(e, int) | e.eid;\n\n    loops : array(Loop);\n  }\n  ";

  function errfunc(lexer) {
    return true;
  }

  let lex = new lexer(tokens, errfunc);
  console.log("Testing lexical scanner...");
  lex.input(a);
  let token;
  while (token = lex.next()) {
    console.log(token.toString());
  }
  let parser = new parser(lex);
  parser.input(a);

  function p_Array(p) {
    p.expect("ARRAY");
    p.expect("LPARAM");
    let arraytype = p_Type(p);
    let itername = "";
    if (p.optional("COMMA")) {
      itername = arraytype;
      arraytype = p_Type(p);
    }
    p.expect("RPARAM");
    return {type: "array", data: {type: arraytype, iname: itername}}
  }

  function p_Type(p) {
    let tok = p.peek();
    if (tok.type === "ID") {
      p.next();
      return {type: "struct", data: "\"" + tok.value + "\""}
    }
    else if (basic_types.has(tok.type.toLowerCase())) {
      p.next();
      return {type: tok.type.toLowerCase()}
    }
    else if (tok.type === "ARRAY") {
      return p_Array(p);
    }
    else {
      p.error(tok, "invalid type " + tok.type);
    }
  }

  function p_Field(p) {
    let field = {};
    console.log("-----", p.peek().type);
    field.name = p.expect("ID", "struct field name");
    p.expect("COLON");
    field.type = p_Type(p);
    field.set = undefined;
    field.get = undefined;
    let tok = p.peek();
    if (tok.type === "JSCRIPT") {
      field.get = tok.value;
      p.next();
    }
    tok = p.peek();
    if (tok.type === "JSCRIPT") {
      field.set = tok.value;
      p.next();
    }
    p.expect("SEMI");
    return field;
  }

  function p_Struct(p) {
    let st = {};
    st.name = p.expect("ID", "struct name");
    st.fields = [];
    p.expect("OPEN");
    while (1) {
      if (p.at_end()) {
        p.error(undefined);
      }
      else if (p.optional("CLOSE")) {
        break;
      }
      else {
        st.fields.push(p_Field(p));
      }
    }
    return st;
  }

  let ret = p_Struct(parser);
  console.log(JSON.stringify(ret));
}

var struct_parseutil = /*#__PURE__*/Object.freeze({
  __proto__: null,
  token: token,
  tokdef: tokdef,
  PUTIL_ParseError: PUTIL_ParseError,
  lexer: lexer,
  parser: parser
});

"use strict";

class NStruct {
  constructor(name) {
    this.fields = [];
    this.id = -1;
    this.name = name;
  }
}

//the discontinuous id's are to make sure
//the version I originally wrote (which had a few application-specific types)
//and this one do not become totally incompatible.
const StructEnum = {
  T_INT          : 0,
  T_FLOAT        : 1,
  T_DOUBLE       : 2,
  T_STRING       : 7,
  T_STATIC_STRING: 8, //fixed-length string
  T_STRUCT       : 9,
  T_TSTRUCT      : 10,
  T_ARRAY        : 11,
  T_ITER         : 12,
  T_SHORT        : 13,
  T_BYTE         : 14,
  T_BOOL         : 15,
  T_ITERKEYS     : 16,
  T_UINT         : 17,
  T_USHORT       : 18,
  T_STATIC_ARRAY : 19,
  T_SIGNED_BYTE  : 20
};

const ValueTypes = new Set([
  StructEnum.T_INT,
  StructEnum.T_FLOAT,
  StructEnum.T_DOUBLE,
  StructEnum.T_STRING,
  StructEnum.T_STATIC_STRING,
  StructEnum.T_SHORT,
  StructEnum.T_BYTE,
  StructEnum.T_BOOL,
  StructEnum.T_UINT,
  StructEnum.T_USHORT,
  StructEnum.T_SIGNED_BYTE

]);

let StructTypes = {
  "int"          : StructEnum.T_INT,
  "uint"         : StructEnum.T_UINT,
  "ushort"       : StructEnum.T_USHORT,
  "float"        : StructEnum.T_FLOAT,
  "double"       : StructEnum.T_DOUBLE,
  "string"       : StructEnum.T_STRING,
  "static_string": StructEnum.T_STATIC_STRING,
  "struct"       : StructEnum.T_STRUCT,
  "abstract"     : StructEnum.T_TSTRUCT,
  "array"        : StructEnum.T_ARRAY,
  "iter"         : StructEnum.T_ITER,
  "short"        : StructEnum.T_SHORT,
  "byte"         : StructEnum.T_BYTE,
  "bool"         : StructEnum.T_BOOL,
  "iterkeys"     : StructEnum.T_ITERKEYS,
  "sbyte"        : StructEnum.T_SIGNED_BYTE
};

let StructTypeMap = {};

for (let k in StructTypes) {
  StructTypeMap[StructTypes[k]] = k;
}

function gen_tabstr(t) {
  let s = "";
  for (let i = 0; i < t; i++) {
    s += "  ";
  }
  return s;
}

function StructParser() {
  let basic_types = new Set([
    "int", "float", "double", "string", "short", "byte", "sbyte", "bool", "uint", "ushort"
  ]);

  let reserved_tokens = new Set([
    "int", "float", "double", "string", "static_string", "array",
    "iter", "abstract", "short", "byte", "sbyte", "bool", "iterkeys", "uint", "ushort",
    "static_array"
  ]);

  function tk(name, re, func) {
    return new tokdef(name, re, func);
  }

  let tokens = [
    tk("ID", /[a-zA-Z_$]+[a-zA-Z0-9_\.$]*/, function (t) {

      if (reserved_tokens.has(t.value)) {
        t.type = t.value.toUpperCase();
      }
      return t;
    }, "identifier"),
    tk("OPEN", /\{/),
    tk("EQUALS", /=/),
    tk("CLOSE", /}/),
    tk("COLON", /:/),
    tk("SOPEN", /\[/),
    tk("SCLOSE", /\]/),
    tk("JSCRIPT", /\|/, function (t) {
      let js = "";
      let lexer = t.lexer;
      while (lexer.lexpos < lexer.lexdata.length) {
        let c = lexer.lexdata[lexer.lexpos];
        if (c === "\n")
          break;
        js += c;
        lexer.lexpos++;
      }

      while (js.trim().endsWith(";")) {
        js = js.slice(0, js.length - 1);
        lexer.lexpos--;
      }
      t.value = js.trim();
      return t;
    }),
    tk("LPARAM", /\(/),
    tk("RPARAM", /\)/),
    tk("COMMA", /,/),
    tk("NUM", /[0-9]+/, undefined, "number"),
    tk("SEMI", /;/),
    tk("NEWLINE", /\n/, function (t) {
      t.lexer.lineno += 1;
    }, "newline"),
    tk("SPACE", / |\t/, function (t) {
    }, "whitespace")
  ];

  reserved_tokens.forEach(function (rt) {
    tokens.push(tk(rt.toUpperCase()));
  });

  function errfunc(lexer) {
    return true;
  }

  let lex = new lexer(tokens, errfunc);
  let parser$1 = new parser(lex);

  function p_Static_String(p) {
    p.expect("STATIC_STRING");
    p.expect("SOPEN");
    let num = p.expect("NUM");
    p.expect("SCLOSE");
    return {type: StructEnum.T_STATIC_STRING, data: {maxlength: num}}
  }

  function p_DataRef(p) {
    p.expect("DATAREF");
    p.expect("LPARAM");
    let tname = p.expect("ID");
    p.expect("RPARAM");
    return {type: StructEnum.T_DATAREF, data: tname}
  }

  function p_Array(p) {
    p.expect("ARRAY");
    p.expect("LPARAM");
    let arraytype = p_Type(p);

    let itername = "";
    if (p.optional("COMMA")) {
      itername = arraytype.data.replace(/"/g, "");
      arraytype = p_Type(p);
    }

    p.expect("RPARAM");
    return {type: StructEnum.T_ARRAY, data: {type: arraytype, iname: itername}}
  }

  function p_Iter(p) {
    p.expect("ITER");
    p.expect("LPARAM");

    let arraytype = p_Type(p);
    let itername = "";

    if (p.optional("COMMA")) {
      itername = arraytype.data.replace(/"/g, "");
      arraytype = p_Type(p);
    }

    p.expect("RPARAM");
    return {type: StructEnum.T_ITER, data: {type: arraytype, iname: itername}}
  }

  function p_StaticArray(p) {
    p.expect("STATIC_ARRAY");
    p.expect("SOPEN");
    let arraytype = p_Type(p);
    let itername = "";

    p.expect("COMMA");
    let size = p.expect("NUM");

    if (size < 0 || Math.abs(size - Math.floor(size)) > 0.000001) {
      console.log(Math.abs(size - Math.floor(size)));
      p.error("Expected an integer");
    }

    size = Math.floor(size);

    if (p.optional("COMMA")) {
      itername = p_Type(p).data;
    }

    p.expect("SCLOSE");
    return {type: StructEnum.T_STATIC_ARRAY, data: {type: arraytype, size: size, iname: itername}}
  }

  function p_IterKeys(p) {
    p.expect("ITERKEYS");
    p.expect("LPARAM");

    let arraytype = p_Type(p);
    let itername = "";

    if (p.optional("COMMA")) {
      itername = arraytype.data.replace(/"/g, "");
      arraytype = p_Type(p);
    }

    p.expect("RPARAM");
    return {type: StructEnum.T_ITERKEYS, data: {type: arraytype, iname: itername}}
  }

  function p_Abstract(p) {
    p.expect("ABSTRACT");
    p.expect("LPARAM");
    let type = p.expect("ID");
    p.expect("RPARAM");
    return {type: StructEnum.T_TSTRUCT, data: type}
  }

  function p_Type(p) {
    let tok = p.peek();

    if (tok.type === "ID") {
      p.next();
      return {type: StructEnum.T_STRUCT, data: tok.value}
    } else if (basic_types.has(tok.type.toLowerCase())) {
      p.next();
      return {type: StructTypes[tok.type.toLowerCase()]}
    } else if (tok.type === "ARRAY") {
      return p_Array(p);
    } else if (tok.type === "ITER") {
      return p_Iter(p);
    } else if (tok.type === "ITERKEYS") {
      return p_IterKeys(p);
    } else if (tok.type === "STATIC_ARRAY") {
      return p_StaticArray(p);
    } else if (tok.type === "STATIC_STRING") {
      return p_Static_String(p);
    } else if (tok.type === "ABSTRACT") {
      return p_Abstract(p);
    } else if (tok.type === "DATAREF") {
      return p_DataRef(p);
    } else {
      p.error(tok, "invalid type " + tok.type);
    }
  }

  function p_ID_or_num(p) {
    let t = p.peeknext();

    if (t.type === "NUM") {
      p.next();
      return t.value;
    } else {
      return p.expect("ID", "struct field name");
    }
  }

  function p_Field(p) {
    let field = {};

    field.name = p_ID_or_num(p);
    p.expect("COLON");

    field.type = p_Type(p);
    field.set = undefined;
    field.get = undefined;

    let check = 0;

    let tok = p.peek();
    if (tok.type === "JSCRIPT") {
      field.get = tok.value;
      check = 1;
      p.next();
    }

    tok = p.peek();
    if (tok.type === "JSCRIPT") {
      check = 1;
      field.set = tok.value;
      p.next();
    }

    p.expect("SEMI");

    return field;
  }

  function p_Struct(p) {
    let name = p.expect("ID", "struct name");

    let st = new NStruct(name);

    let tok = p.peek();
    let id = -1;

    if (tok.type === "ID" && tok.value === "id") {
      p.next();
      p.expect("EQUALS");
      st.id = p.expect("NUM");
    }

    p.expect("OPEN");
    while (1) {
      if (p.at_end()) {
        p.error(undefined);
      } else if (p.optional("CLOSE")) {
        break;
      } else {
        st.fields.push(p_Field(p));
      }
    }

    return st;
  }

  parser$1.start = p_Struct;
  return parser$1;
}

const struct_parse = StructParser();

var struct_parser = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NStruct: NStruct,
  StructEnum: StructEnum,
  ValueTypes: ValueTypes,
  StructTypes: StructTypes,
  StructTypeMap: StructTypeMap,
  struct_parse: struct_parse
});

/** dead file */

var struct_typesystem = /*#__PURE__*/Object.freeze({
  __proto__: null
});

"use strict";

var STRUCT_ENDIAN = true; //little endian

function setEndian(mode) {
  STRUCT_ENDIAN = !!mode;
}

let temp_dataview = new DataView(new ArrayBuffer(16));
let uint8_view = new Uint8Array(temp_dataview.buffer);

class unpack_context {
  constructor() {
    this.i = 0;
  }
}

function pack_byte(array, val) {
  array.push(val);
}

function pack_sbyte(array, val) {
  if (val < 0) {
    val = 256 + val;
  }

  array.push(val);
}

function pack_bytes(array, bytes) {
  for (let i = 0; i < bytes.length; i++) {
    array.push(bytes[i]);
  }
}

function pack_int(array, val) {
  temp_dataview.setInt32(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
  array.push(uint8_view[2]);
  array.push(uint8_view[3]);
}

function pack_uint(array, val) {
  temp_dataview.setUint32(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
  array.push(uint8_view[2]);
  array.push(uint8_view[3]);
}

function pack_ushort(array, val) {
  temp_dataview.setUint16(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
}

function pack_float(array, val) {
  temp_dataview.setFloat32(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
  array.push(uint8_view[2]);
  array.push(uint8_view[3]);
}

function pack_double(array, val) {
  temp_dataview.setFloat64(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
  array.push(uint8_view[2]);
  array.push(uint8_view[3]);
  array.push(uint8_view[4]);
  array.push(uint8_view[5]);
  array.push(uint8_view[6]);
  array.push(uint8_view[7]);
}

function pack_short(array, val) {
  temp_dataview.setInt16(0, val, STRUCT_ENDIAN);

  array.push(uint8_view[0]);
  array.push(uint8_view[1]);
}

function encode_utf8(arr, str) {
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);

    while (c !== 0) {
      let uc = c & 127;
      c = c >> 7;

      if (c !== 0)
        uc |= 128;

      arr.push(uc);
    }
  }
}

function decode_utf8(arr) {
  let str = "";
  let i = 0;

  while (i < arr.length) {
    let c = arr[i];
    let sum = c & 127;
    let j = 0;
    let lasti = i;

    while (i < arr.length && (c & 128)) {
      j += 7;
      i++;
      c = arr[i];

      c = (c & 127) << j;
      sum |= c;
    }

    if (sum === 0) break;

    str += String.fromCharCode(sum);
    i++;
  }

  return str;
}

function test_utf8() {
  let s = "a" + String.fromCharCode(8800) + "b";
  let arr = [];

  encode_utf8(arr, s);
  let s2 = decode_utf8(arr);

  if (s !== s2) {
    throw new Error("UTF-8 encoding/decoding test failed");
  }

  return true;
}

function truncate_utf8(arr, maxlen) {
  let len = Math.min(arr.length, maxlen);

  let last_codepoint = 0;
  let last2 = 0;

  let incode = false;
  let i = 0;
  let code = 0;
  while (i < len) {
    incode = arr[i] & 128;

    if (!incode) {
      last2 = last_codepoint + 1;
      last_codepoint = i + 1;
    }

    i++;
  }

  if (last_codepoint < maxlen)
    arr.length = last_codepoint;
  else
    arr.length = last2;

  return arr;
}

let _static_sbuf_ss = new Array(2048);

function pack_static_string(data, str, length) {
  if (length === undefined)
    throw new Error("'length' paremter is not optional for pack_static_string()");

  let arr = length < 2048 ? _static_sbuf_ss : new Array();
  arr.length = 0;

  encode_utf8(arr, str);
  truncate_utf8(arr, length);

  for (let i = 0; i < length; i++) {
    if (i >= arr.length) {
      data.push(0);
    } else {
      data.push(arr[i]);
    }
  }
}

let _static_sbuf = new Array(32);

/*strings are packed as 32-bit unicode codepoints*/
function pack_string(data, str) {
  _static_sbuf.length = 0;
  encode_utf8(_static_sbuf, str);

  pack_int(data, _static_sbuf.length);

  for (let i = 0; i < _static_sbuf.length; i++) {
    data.push(_static_sbuf[i]);
  }
}

function unpack_bytes(dview, uctx, len) {
  let ret = new DataView(dview.buffer.slice(uctx.i, uctx.i + len));
  uctx.i += len;

  return ret;
}

function unpack_byte(dview, uctx) {
  return dview.getUint8(uctx.i++);
}

function unpack_sbyte(dview, uctx) {
  return dview.getInt8(uctx.i++);
}

function unpack_int(dview, uctx) {
  uctx.i += 4;
  return dview.getInt32(uctx.i - 4, STRUCT_ENDIAN);
}

function unpack_uint(dview, uctx) {
  uctx.i += 4;
  return dview.getUint32(uctx.i - 4, STRUCT_ENDIAN);
}

function unpack_ushort(dview, uctx) {
  uctx.i += 2;
  return dview.getUint16(uctx.i - 2, STRUCT_ENDIAN);
}

function unpack_float(dview, uctx) {
  uctx.i += 4;
  return dview.getFloat32(uctx.i - 4, STRUCT_ENDIAN);
}

function unpack_double(dview, uctx) {
  uctx.i += 8;
  return dview.getFloat64(uctx.i - 8, STRUCT_ENDIAN);
}

function unpack_short(dview, uctx) {
  uctx.i += 2;
  return dview.getInt16(uctx.i - 2, STRUCT_ENDIAN);
}

let _static_arr_us = new Array(32);

function unpack_string(data, uctx) {
  let slen = unpack_int(data, uctx);

  if (!slen) {
    return "";
  }

  let str = "";
  let arr = slen < 2048 ? _static_arr_us : new Array(slen);

  arr.length = slen;
  for (let i = 0; i < slen; i++) {
    arr[i] = unpack_byte(data, uctx);
  }

  return decode_utf8(arr);
}

let _static_arr_uss = new Array(2048);

function unpack_static_string(data, uctx, length) {
  let str = "";

  if (length === undefined)
    throw new Error("'length' cannot be undefined in unpack_static_string()");

  let arr = length < 2048 ? _static_arr_uss : new Array(length);
  arr.length = 0;

  let done = false;
  for (let i = 0; i < length; i++) {
    let c = unpack_byte(data, uctx);

    if (c === 0) {
      done = true;
    }

    if (!done && c !== 0) {
      arr.push(c);
      //arr.length++;
    }
  }

  truncate_utf8(arr, length);
  return decode_utf8(arr);
}

var struct_binpack = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get STRUCT_ENDIAN () { return STRUCT_ENDIAN; },
  setEndian: setEndian,
  temp_dataview: temp_dataview,
  uint8_view: uint8_view,
  unpack_context: unpack_context,
  pack_byte: pack_byte,
  pack_sbyte: pack_sbyte,
  pack_bytes: pack_bytes,
  pack_int: pack_int,
  pack_uint: pack_uint,
  pack_ushort: pack_ushort,
  pack_float: pack_float,
  pack_double: pack_double,
  pack_short: pack_short,
  encode_utf8: encode_utf8,
  decode_utf8: decode_utf8,
  test_utf8: test_utf8,
  pack_static_string: pack_static_string,
  pack_string: pack_string,
  unpack_bytes: unpack_bytes,
  unpack_byte: unpack_byte,
  unpack_sbyte: unpack_sbyte,
  unpack_int: unpack_int,
  unpack_uint: unpack_uint,
  unpack_ushort: unpack_ushort,
  unpack_float: unpack_float,
  unpack_double: unpack_double,
  unpack_short: unpack_short,
  unpack_string: unpack_string,
  unpack_static_string: unpack_static_string
});

let warninglvl = 2;
let debug = 0;

let _static_envcode_null = "";
let packer_debug, packer_debug_start, packer_debug_end;
let packdebug_tablevel = 0;

function _get_pack_debug() {
  return {
    packer_debug, packer_debug_start, packer_debug_end,
    debug, warninglvl
  }
}

class cachering extends Array {
  constructor(cb, tot) {
    super();
    this.length = tot;
    this.cur = 0;

    for (let i = 0; i < tot; i++) {
      this[i] = cb();
    }
  }

  static fromConstructor(cls, tot) {
    return new cachering(() => new cls(), tot);
  }

  next() {
    let ret = this[this.cur];

    this.cur = (this.cur + 1)%this.length;

    return ret;
  }
}

function gen_tabstr$1(tot) {
  let ret = "";

  for (let i = 0; i < tot; i++) {
    ret += " ";
  }

  return ret;
}

function setWarningMode(t) {
  if (typeof t !== "number" || isNaN(t)) {
    throw new Error("Expected a single number (>= 0) argument to setWarningMode");
  }

  warninglvl = t;
}

function setDebugMode(t) {
  debug = t;

  if (debug) {
    packer_debug = function () {
      let tab = gen_tabstr$1(packdebug_tablevel);

      if (arguments.length > 0) {
        console.warn(tab, ...arguments);
      } else {
        console.warn("Warning: undefined msg");
      }
    };
    packer_debug_start = function (funcname) {
      packer_debug("Start " + funcname);
      packdebug_tablevel++;
    };

    packer_debug_end = function (funcname) {
      packdebug_tablevel--;

      if (funcname) {
        packer_debug("Leave " + funcname);
      }
    };
  } else {
    packer_debug = function () {
    };
    packer_debug_start = function () {
    };
    packer_debug_end = function () {
    };
  }
}

setDebugMode(debug);

const StructFieldTypes = [];
const StructFieldTypeMap = {};

function packNull(manager, data, field, type) {
  StructFieldTypeMap[type.type].packNull(manager, data, field, type);
};

function toJSON(manager, val, obj, field, type) {
  return StructFieldTypeMap[type.type].toJSON(manager, val, obj, field, type);
};

function fromJSON(manager, val, obj, field, type, instance) {
  return StructFieldTypeMap[type.type].fromJSON(manager, val, obj, field, type, instance);
};

function unpack_field(manager, data, type, uctx) {
  let name;

  if (debug) {
    name = StructFieldTypeMap[type.type].define().name;
    packer_debug_start("R " + name);
  }

  let ret = StructFieldTypeMap[type.type].unpack(manager, data, type, uctx);

  if (debug) {
    packer_debug_end();
  }

  return ret;
}

let fakeFields = new cachering(() => {
  return {type: undefined, get: undefined, set: undefined}
}, 256);

function fmt_type(type) {
  return StructFieldTypeMap[type.type].format(type);
}

function do_pack(manager, data, val, obj, field, type) {
  let name;

  if (debug) {
    name = StructFieldTypeMap[type.type].define().name;
    packer_debug_start("W " + name);
  }

  let typeid = type;
  if (typeof typeid !== "number") {
    typeid = typeid.type;
  }

  let ret = StructFieldTypeMap[typeid].pack(manager, data, val, obj, field, type);

  if (debug) {
    packer_debug_end();
  }

  return ret;
}

let _ws_env = [[undefined, undefined]];

class StructFieldType {
  static pack(manager, data, val, obj, field, type) {
  }

  static unpack(manager, data, type, uctx) {
  }

  static packNull(manager, data, field, type) {
    this.pack(manager, data, 0, 0, field, type);
  }

  static format(type) {
    return this.define().name;
  }

  static toJSON(manager, val, obj, field, type) {
    return val;
  }

  static fromJSON(manager, val, obj, field, type, instance) {
    return val;
  }

  /**
   return false to override default
   helper js for packing
   */
  static useHelperJS(field) {
    return true;
  }

  /**
   Define field class info.

   Example:
   <pre>
   static define() {return {
    type : StructEnum.T_INT,
    name : "int"
  }}
   </pre>
   */
  static define() {
    return {
      type: -1,
      name: "(error)"
    }
  }

  /**
   Register field packer/unpacker class.  Will throw an error if define() method is bad.
   */
  static register(cls) {
    if (StructFieldTypes.indexOf(cls) >= 0) {
      throw new Error("class already registered");
    }

    if (cls.define === StructFieldType.define) {
      throw new Error("you forgot to make a define() static method");
    }

    if (cls.define().type === undefined) {
      throw new Error("cls.define().type was undefined!");
    }

    if (cls.define().type in StructFieldTypeMap) {
      throw new Error("type " + cls.define().type + " is used by another StructFieldType subclass");
    }

    StructFieldTypes.push(cls);
    StructFieldTypeMap[cls.define().type] = cls;
  }
}

class StructIntField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_int(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_int(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_INT,
      name: "int"
    }
  }
}

StructFieldType.register(StructIntField);

class StructFloatField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_float(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_float(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_FLOAT,
      name: "float"
    }
  }
}

StructFieldType.register(StructFloatField);

class StructDoubleField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_double(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_double(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_DOUBLE,
      name: "double"
    }
  }
}

StructFieldType.register(StructDoubleField);

class StructStringField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    val = !val ? "" : val;

    pack_string(data, val);
  }

  static packNull(manager, data, field, type) {
    this.pack(manager, data, "", 0, field, type);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_string(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_STRING,
      name: "string"
    }
  }
}

StructFieldType.register(StructStringField);

class StructStaticStringField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    val = !val ? "" : val;

    pack_static_string(data, val, type.data.maxlength);
  }

  static format(type) {
    return `static_string[${type.data.maxlength}]`;
  }

  static packNull(manager, data, field, type) {
    this.pack(manager, data, "", 0, field, type);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_static_string(data, uctx, type.data.maxlength);
  }

  static define() {
    return {
      type: StructEnum.T_STATIC_STRING,
      name: "static_string"
    }
  }
}

StructFieldType.register(StructStaticStringField);

class StructStructField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    let stt = manager.get_struct(type.data);

    packer_debug("struct", stt.name);

    manager.write_struct(data, val, stt);
  }

  static format(type) {
    return type.data;
  }

  static fromJSON(manager, val, obj, field, type, instance) {
    let stt = manager.get_struct(type.data);

    return manager.readJSON(val, stt, instance);
  }

  static toJSON(manager, val, obj, field, type) {
    let stt = manager.get_struct(type.data);
    return manager.writeJSON(val, stt);
  }

  static unpackInto(manager, data, type, uctx, dest) {
    let cls2 = manager.get_struct_cls(type.data);

    packer_debug("struct", cls2 ? cls2.name : "(error)");
    return manager.read_object(data, cls2, uctx, dest);
  }

  static packNull(manager, data, field, type) {
    let stt = manager.get_struct(type.data);

    packer_debug("struct", type);

    for (let field2 of stt.fields) {
      let type2 = field2.type;

      packNull(manager, data, field2, type2);
    }
  }

  static unpack(manager, data, type, uctx) {
    let cls2 = manager.get_struct_cls(type.data);
    packer_debug("struct", cls2 ? cls2.name : "(error)");

    return manager.read_object(data, cls2, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_STRUCT,
      name: "struct"
    }
  }
}

StructFieldType.register(StructStructField);

class StructTStructField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    let cls = manager.get_struct_cls(type.data);
    let stt = manager.get_struct(type.data);

    //make sure inheritance is correct
    if (val.constructor.structName !== type.data && (val instanceof cls)) {
      //if (DEBUG.Struct) {
      //    console.log(val.constructor.structName+" inherits from "+cls.structName);
      //}
      stt = manager.get_struct(val.constructor.structName);
    } else if (val.constructor.structName === type.data) {
      stt = manager.get_struct(type.data);
    } else {
      console.trace();
      throw new Error("Bad struct " + val.constructor.structName + " passed to write_struct");
    }

    packer_debug("int " + stt.id);

    pack_int(data, stt.id);
    manager.write_struct(data, val, stt);
  }

  static fromJSON(manager, val, obj, field, type, instance) {
    let stt = manager.get_struct(val._structName);

    return manager.readJSON(val, stt, instance);
  }

  static toJSON(manager, val, obj, field, type) {
    let stt = manager.get_struct(val.constructor.structName);
    let ret = manager.writeJSON(val, stt);

    ret._structName = "" + stt.name;

    return ret;
  }

  static packNull(manager, data, field, type) {
    let stt = manager.get_struct(type.data);

    pack_int(data, stt.id);
    packNull(manager, data, field, {type: StructEnum.T_STRUCT, data: type.data});
  }

  static format(type) {
    return "abstract(" + type.data + ")";
  }

  static unpackInto(manager, data, type, uctx, dest) {
    let id = unpack_int(data, uctx);

    packer_debug("-int " + id);
    if (!(id in manager.struct_ids)) {
      packer_debug("tstruct id: " + id);
      console.trace();
      console.log(id);
      console.log(manager.struct_ids);
      throw new Error("Unknown struct type " + id + ".");
    }

    let cls2 = manager.get_struct_id(id);

    packer_debug("struct name: " + cls2.name);

    cls2 = manager.struct_cls[cls2.name];

    return manager.read_object(data, cls2, uctx, dest);
    //packer_debug("ret", ret);
  }

  static unpack(manager, data, type, uctx) {
    let id = unpack_int(data, uctx);

    packer_debug("-int " + id);
    if (!(id in manager.struct_ids)) {
      packer_debug("tstruct id: " + id);
      console.trace();
      console.log(id);
      console.log(manager.struct_ids);
      throw new Error("Unknown struct type " + id + ".");
    }

    let cls2 = manager.get_struct_id(id);

    packer_debug("struct name: " + cls2.name);
    cls2 = manager.struct_cls[cls2.name];

    return manager.read_object(data, cls2, uctx);
    //packer_debug("ret", ret);
  }

  static define() {
    return {
      type: StructEnum.T_TSTRUCT,
      name: "tstruct"
    }
  }
}

StructFieldType.register(StructTStructField);

class StructArrayField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    if (val === undefined) {
      console.trace();
      console.log("Undefined array fed to struct struct packer!");
      console.log("Field: ", field);
      console.log("Type: ", type);
      console.log("");
      packer_debug("int 0");
      pack_int(data, 0);
      return;
    }

    packer_debug("int " + val.length);
    pack_int(data, val.length);

    let d = type.data;

    let itername = d.iname;
    let type2 = d.type;

    let env = _ws_env;
    for (let i = 0; i < val.length; i++) {
      let val2 = val[i];
      if (itername !== "" && itername !== undefined && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);
      }

      //XXX not sure I really need this fakeField stub here. . .
      let fakeField = fakeFields.next();
      fakeField.type = type2;
      do_pack(manager, data, val2, obj, fakeField, type2);
    }
  }

  static packNull(manager, data, field, type) {
    pack_int(data, 0);
  }

  static format(type) {
    if (type.data.iname !== "" && type.data.iname !== undefined) {
      return "array(" + type.data.iname + ", " + fmt_type(type.data.type) + ")";
    } else {
      return "array(" + fmt_type(type.data.type) + ")";
    }
  }

  static useHelperJS(field) {
    return !field.type.data.iname;
  }

  static fromJSON(manager, val, obj, field, type, instance) {
    let ret = instance || [];

    ret.length = 0;

    for (let i = 0; i < val.length; i++) {
      let val2 = fromJSON(manager, val[i], val, field, type.data.type, undefined);

      if (val2 === undefined) {
        console.log(val2);
        console.error("eeek");
        process.exit();
      }

      ret.push(val2);
    }

    return ret;
  }

  static toJSON(manager, val, obj, field, type) {
    val = val || [];
    let json = [];

    let itername = type.data.iname;

    for (let i = 0; i < val.length; i++) {
      let val2 = val[i];
      let env = _ws_env;

      if (itername !== "" && itername !== undefined && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);

        //console.log("VAL2", val2, toJSON(manager, val2, val, field, type.data.type));
      }

      json.push(toJSON(manager, val2, val, field, type.data.type));
    }

    return json;
  }

  static unpackInto(manager, data, type, uctx, dest) {
    let len = unpack_int(data, uctx);
    dest.length = 0;

    for (let i = 0; i < len; i++) {
      dest.push(unpack_field(manager, data, type.data.type, uctx));
    }
  }

  static unpack(manager, data, type, uctx) {
    let len = unpack_int(data, uctx);
    packer_debug("-int " + len);

    let arr = new Array(len);
    for (let i = 0; i < len; i++) {
      arr[i] = unpack_field(manager, data, type.data.type, uctx);
    }

    return arr;
  }

  static define() {
    return {
      type: StructEnum.T_ARRAY,
      name: "array"
    }
  }
}

StructFieldType.register(StructArrayField);

class StructIterField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    //this was originally implemented to use ES6 iterators.
    function forEach(cb, thisvar) {
      if (val && val[Symbol.iterator]) {
        for (let item of val) {
          cb.call(thisvar, item);
        }
      } else if (val && val.forEach) {
        val.forEach(function (item) {
          cb.call(thisvar, item);
        });
      } else {
        console.trace();
        console.log("Undefined iterable list fed to struct struct packer!", val);
        console.log("Field: ", field);
        console.log("Type: ", type);
        console.log("");
      }
    }

    /* save space for length */
    let starti = data.length;
    data.length += 4;

    let d = type.data, itername = d.iname, type2 = d.type;
    let env = _ws_env;

    let i = 0;
    forEach(function (val2) {
      if (itername !== "" && itername !== undefined && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);
      }

      //XXX not sure I really need this fakeField stub here. . .
      let fakeField = fakeFields.next();
      fakeField.type = type2;
      do_pack(manager, data, val2, obj, fakeField, type2);

      i++;
    }, this);

    /* write length */
    temp_dataview.setInt32(0, i, STRUCT_ENDIAN);

    data[starti++] = uint8_view[0];
    data[starti++] = uint8_view[1];
    data[starti++] = uint8_view[2];
    data[starti++] = uint8_view[3];
  }

  static fromJSON() {
    return StructArrayField.fromJSON(...arguments);
  }

  static toJSON(manager, val, obj, field, type) {
    val = val || [];
    let json = [];

    let itername = type.data.iname;

    for (let val2 of val) {
      let env = _ws_env;

      if (itername !== "" && itername !== undefined && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);

        //console.log("VAL2", val2, toJSON(manager, val2, val, field, type.data.type));
      }

      json.push(toJSON(manager, val2, val, field, type.data.type));
    }

    return json;
  }

  static packNull(manager, data, field, type) {
    pack_int(data, 0);
  }

  static useHelperJS(field) {
    return !field.type.data.iname;
  }

  static format(type) {
    if (type.data.iname !== "" && type.data.iname !== undefined) {
      return "iter(" + type.data.iname + ", " + fmt_type(type.data.type) + ")";
    } else {
      return "iter(" + fmt_type(type.data.type) + ")";
    }
  }

  static unpackInto(manager, data, type, uctx, arr) {
    let len = unpack_int(data, uctx);
    packer_debug("-int " + len);

    arr.length = 0;

    for (let i = 0; i < len; i++) {
      arr.push(unpack_field(manager, data, type.data.type, uctx));
    }

    return arr;
  }

  static unpack(manager, data, type, uctx) {
    let len = unpack_int(data, uctx);
    packer_debug("-int " + len);

    let arr = new Array(len);
    for (let i = 0; i < len; i++) {
      arr[i] = unpack_field(manager, data, type.data.type, uctx);
    }

    return arr;
  }

  static define() {
    return {
      type: StructEnum.T_ITER,
      name: "iter"
    }
  }
}

StructFieldType.register(StructIterField);

class StructShortField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_short(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_short(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_SHORT,
      name: "short"
    }
  }
}

StructFieldType.register(StructShortField);

class StructByteField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_byte(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_byte(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_BYTE,
      name: "byte"
    }
  }
}

StructFieldType.register(StructByteField);

class StructSignedByteField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_sbyte(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_sbyte(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_SIGNED_BYTE,
      name: "sbyte"
    }
  }
}

StructFieldType.register(StructSignedByteField);

class StructBoolField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_byte(data, !!val);
  }

  static unpack(manager, data, type, uctx) {
    return !!unpack_byte(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_BOOL,
      name: "bool"
    }
  }
}

StructFieldType.register(StructBoolField);

class StructIterKeysField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    //this was originally implemented to use ES6 iterators.
    if ((typeof val !== "object" && typeof val !== "function") || val === null) {
      console.warn("Bad object fed to iterkeys in struct packer!", val);
      console.log("Field: ", field);
      console.log("Type: ", type);
      console.log("");

      pack_int(data, 0);
      return;
    }

    let len = 0.0;
    for (let k in val) {
      len++;
    }

    packer_debug("int " + len);
    pack_int(data, len);

    let d = type.data, itername = d.iname, type2 = d.type;
    let env = _ws_env;

    let i = 0;
    for (let val2 in val) {
      if (i >= len) {
        if (warninglvl > 0)
          console.warn("Warning: object keys magically replaced on us", val, i);
        return;
      }

      if (itername && itername.trim().length > 0 && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);
      } else {
        val2 = val[val2]; //fetch value
      }

      let f2 = {type: type2, get: undefined, set: undefined};
      do_pack(manager, data, val2, obj, f2, type2);

      i++;
    }
  }

  static fromJSON() {
    return StructArrayField.fromJSON(...arguments);
  }

  static toJSON(manager, val, obj, field, type) {
    val = val || [];
    let json = [];

    let itername = type.data.iname;

    for (let k in val) {
      let val2 = val[k];
      let env = _ws_env;

      if (itername !== "" && itername !== undefined && field.get) {
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);

        //console.log("VAL2", val2, toJSON(manager, val2, val, field, type.data.type));
      }

      json.push(toJSON(manager, val2, val, field, type.data.type));
    }

    return json;
  }

  static packNull(manager, data, field, type) {
    pack_int(data, 0);
  }

  static useHelperJS(field) {
    return !field.type.data.iname;
  }

  static format(type) {
    if (type.data.iname !== "" && type.data.iname !== undefined) {
      return "iterkeys(" + type.data.iname + ", " + fmt_type(type.data.type) + ")";
    } else {
      return "iterkeys(" + fmt_type(type.data.type) + ")";
    }
  }

  static unpackInto(manager, data, type, uctx, arr) {
    let len = unpack_int(data, uctx);
    packer_debug("-int " + len);

    arr.length = 0;

    for (let i = 0; i < len; i++) {
      arr.push(unpack_field(manager, data, type.data.type, uctx));
    }

    return arr;
  }

  static unpack(manager, data, type, uctx) {
    let len = unpack_int(data, uctx);
    packer_debug("-int " + len);

    let arr = new Array(len);
    for (let i = 0; i < len; i++) {
      arr[i] = unpack_field(manager, data, type.data.type, uctx);
    }

    return arr;
  }

  static define() {
    return {
      type: StructEnum.T_ITERKEYS,
      name: "iterkeys"
    }
  }
}

StructFieldType.register(StructIterKeysField);

class StructUintField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_uint(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_uint(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_UINT,
      name: "uint"
    }
  }
}

StructFieldType.register(StructUintField);


class StructUshortField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    pack_ushort(data, val);
  }

  static unpack(manager, data, type, uctx) {
    return unpack_ushort(data, uctx);
  }

  static define() {
    return {
      type: StructEnum.T_USHORT,
      name: "ushort"
    }
  }
}

StructFieldType.register(StructUshortField);

//let writeEmpty = writeEmpty = function writeEmpty(stt) {
//}

class StructStaticArrayField extends StructFieldType {
  static pack(manager, data, val, obj, field, type) {
    if (type.data.size === undefined) {
      throw new Error("type.data.size was undefined");
    }

    let itername = type.data.iname;

    if (val === undefined || !val.length) {
      this.packNull(manager, data, field, type);
      return;
    }

    for (let i = 0; i < type.data.size; i++) {
      let i2 = Math.min(i, Math.min(val.length - 1, type.data.size));
      let val2 = val[i2];

      //*
      if (itername !== "" && itername !== undefined && field.get) {
        let env = _ws_env;
        env[0][0] = itername;
        env[0][1] = val2;
        val2 = manager._env_call(field.get, obj, env);
      }

      do_pack(manager, data, val2, val, field, type.data.type);
    }
  }

  static useHelperJS(field) {
    return !field.type.data.iname;
  }

  static fromJSON() {
    return StructArrayField.fromJSON(...arguments);
  }

  static packNull(manager, data, field, type) {
    let size = type.data.size;
    for (let i = 0; i < size; i++) {
      packNull(manager, data, field, type.data.type);
    }
  }

  static toJSON(manager, val, obj, field, type) {
    return StructArrayField.toJSON(...arguments);
  }

  static format(type) {
    let type2 = StructFieldTypeMap[type.data.type.type].format(type.data.type);

    let ret = `static_array[${type2}, ${type.data.size}`;

    if (type.data.iname) {
      ret += `, ${type.data.iname}`;
    }
    ret += `]`;

    return ret;
  }

  static unpackInto(manager, data, type, uctx, ret) {
    packer_debug("-size: " + type.data.size);

    ret.length = 0;

    for (let i = 0; i < type.data.size; i++) {
      ret.push(unpack_field(manager, data, type.data.type, uctx));
    }

    return ret;
  }

  static unpack(manager, data, type, uctx) {
    packer_debug("-size: " + type.data.size);

    let ret = [];

    for (let i = 0; i < type.data.size; i++) {
      ret.push(unpack_field(manager, data, type.data.type, uctx));
    }

    return ret;
  }

  static define() {
    return {
      type: StructEnum.T_STATIC_ARRAY,
      name: "static_array"
    }
  }
}

StructFieldType.register(StructStaticArrayField);

var structEval = eval;

function setStructEval(val) {
  structEval = val;
}

var nGlobal;

if (typeof globalThis !== "undefined") {
  nGlobal = globalThis;
} else if (typeof window !== "undefined") {
  nGlobal = window;
} else if (typeof global !== "undefined") {
  nGlobal = global;
} else if (typeof globals !== "undefined") {
  nGlobal = globals;
} else if (typeof self !== "undefined") {
  nGlobal = self;
}

const DEBUG = {};

function updateDEBUG() {
  for (let k in Object.keys(DEBUG)) {
    delete DEBUG[k];
  }

  if (typeof nGlobal.DEBUG === "object") {
    for (let k in nGlobal.DEBUG) {
      DEBUG[k] = nGlobal.DEBUG[k];
    }
  }
}

"use strict";

let warninglvl$1 = 2;

var truncateDollarSign = true;
var manager;

function setTruncateDollarSign(v) {
  truncateDollarSign = !!v;
}

function _truncateDollarSign(s) {
  let i = s.search("$");

  if (i > 0) {
    return s.slice(0, i).trim();
  }

  return s;
}

function unmangle(name) {
  if (truncateDollarSign) {
    return _truncateDollarSign(name);
  } else {
    return name;
  }
}

let _static_envcode_null$1 = "";

//truncate webpack-mangled names

function gen_tabstr$2(tot) {
  let ret = "";

  for (let i = 0; i < tot; i++) {
    ret += " ";
  }

  return ret;
}

let packer_debug$1, packer_debug_start$1, packer_debug_end$1;

function update_debug_data() {
  let ret = _get_pack_debug();

  packer_debug$1 = ret.packer_debug;
  packer_debug_start$1 = ret.packer_debug_start;
  packer_debug_end$1 = ret.packer_debug_end;
  warninglvl$1 = ret.warninglvl;
}

update_debug_data();

function setWarningMode$1(t) {
  setWarningMode(t);

  if (typeof t !== "number" || isNaN(t)) {
    throw new Error("Expected a single number (>= 0) argument to setWarningMode");
  }

  warninglvl$1 = t;
}

function setDebugMode$1(t) {
  setDebugMode(t);
  update_debug_data();
}

let _ws_env$1 = [[undefined, undefined]];

function do_pack$1(data, val, obj, thestruct, field, type) {
  StructFieldTypeMap[field.type.type].pack(manager, data, val, obj, field, type);
}

function define_empty_class(name) {
  let cls = function () {
  };

  cls.prototype = Object.create(Object.prototype);
  cls.constructor = cls.prototype.constructor = cls;

  cls.STRUCT = name + " {\n  }\n";
  cls.structName = name;

  cls.prototype.loadSTRUCT = function (reader) {
    reader(this);
  };

  cls.newSTRUCT = function () {
    return new this();
  };

  return cls;
}

class STRUCT {
  constructor() {
    this.idgen = 0;
    this.allowOverriding = true;

    this.structs = {};
    this.struct_cls = {};
    this.struct_ids = {};

    this.compiled_code = {};
    this.null_natives = {};

    function define_null_native(name, cls) {
      let obj = define_empty_class(name);

      let stt = struct_parse.parse(obj.STRUCT);

      stt.id = this.idgen++;

      this.structs[name] = stt;
      this.struct_cls[name] = cls;
      this.struct_ids[stt.id] = stt;

      this.null_natives[name] = 1;
    }

    define_null_native.call(this, "Object", Object);
  }

  static inherit(child, parent, structName = child.name) {
    if (!parent.STRUCT) {
      return structName + "{\n";
    }

    let stt = struct_parse.parse(parent.STRUCT);
    let code = structName + "{\n";
    code += STRUCT.fmt_struct(stt, true);
    return code;
  }

  /** invoke loadSTRUCT methods on parent objects.  note that
   reader() is only called once.  it is called however.*/
  static Super(obj, reader) {
    if (warninglvl$1 > 0)
      console.warn("deprecated");

    reader(obj);

    function reader2(obj) {
    }

    let cls = obj.constructor;
    let bad = cls === undefined || cls.prototype === undefined || cls.prototype.__proto__ === undefined;

    if (bad) {
      return;
    }

    let parent = cls.prototype.__proto__.constructor;
    bad = bad || parent === undefined;

    if (!bad && parent.prototype.loadSTRUCT && parent.prototype.loadSTRUCT !== obj.loadSTRUCT) { //parent.prototype.hasOwnProperty("loadSTRUCT")) {
      parent.prototype.loadSTRUCT.call(obj, reader2);
    }
  }

  //defined_classes is an array of class constructors
  //with STRUCT scripts, *OR* another STRUCT instance
  //

  /** deprecated.  used with old fromSTRUCT interface. */
  static chain_fromSTRUCT(cls, reader) {
    if (warninglvl$1 > 0)
      console.warn("Using deprecated (and evil) chain_fromSTRUCT method, eek!");

    let proto = cls.prototype;
    let parent = cls.prototype.prototype.constructor;

    let obj = parent.fromSTRUCT(reader);
    let obj2 = new cls();

    let keys = Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
    //let keys=Object.keys(proto);

    for (let i = 0; i < keys.length; i++) {
      let k = keys[i];

      try {
        obj2[k] = obj[k];
      } catch (error) {
        if (warninglvl$1 > 0)
          console.warn("  failed to set property", k);
      }
      //let k=keys[i];
      //if (k=="__proto__")
      // continue;
      //obj[k] = proto[k];
    }

    /*
    if (proto.toString !== Object.prototype.toString)
      obj2.toString = proto.toString;
    //*/

    return obj2;
  }

  static formatStruct(stt, internal_only, no_helper_js) {
    return this.fmt_struct(stt, internal_only, no_helper_js);
  }

  static fmt_struct(stt, internal_only, no_helper_js) {
    if (internal_only === undefined)
      internal_only = false;
    if (no_helper_js === undefined)
      no_helper_js = false;

    let s = "";
    if (!internal_only) {
      s += stt.name;
      if (stt.id !== -1)
        s += " id=" + stt.id;
      s += " {\n";
    }
    let tab = "  ";

    function fmt_type(type) {
      return StructFieldTypeMap[type.type].format(type);

      if (type.type === StructEnum.T_ARRAY || type.type === StructEnum.T_ITER || type.type === StructEnum.T_ITERKEYS) {
        if (type.data.iname !== "" && type.data.iname !== undefined) {
          return "array(" + type.data.iname + ", " + fmt_type(type.data.type) + ")";
        } else {
          return "array(" + fmt_type(type.data.type) + ")";
        }
      } else if (type.type === StructEnum.T_STATIC_STRING) {
        return "static_string[" + type.data.maxlength + "]";
      } else if (type.type === StructEnum.T_STRUCT) {
        return type.data;
      } else if (type.type === StructEnum.T_TSTRUCT) {
        return "abstract(" + type.data + ")";
      } else {
        return StructTypeMap[type.type];
      }
    }

    let fields = stt.fields;
    for (let i = 0; i < fields.length; i++) {
      let f = fields[i];
      s += tab + f.name + " : " + fmt_type(f.type);
      if (!no_helper_js && f.get !== undefined) {
        s += " | " + f.get.trim();
      }
      s += ";\n";
    }
    if (!internal_only)
      s += "}";
    return s;
  }

  validateStructs(onerror) {
    function getType(type) {
      switch (type.type) {
        case StructEnum.T_ITERKEYS:
        case StructEnum.T_ITER:
        case StructEnum.T_STATIC_ARRAY:
        case StructEnum.T_ARRAY:
          return getType(type.data.type);
        case StructEnum.T_TSTRUCT:
          return type;
        case StructEnum.T_STRUCT:
        default:
          return type;
      }
    }

    function formatType(type) {
      let ret = {};

      ret.type = type.type;

      if (typeof ret.type === "number") {
        for (let k in StructEnum) {
          if (StructEnum[k] === ret.type) {
            ret.type = k;
            break;
          }
        }
      } else if (typeof ret.type === "object") {
        ret.type = formatType(ret.type);
      }

      if (typeof type.data === "object") {
        ret.data = formatType(type.data);
      } else {
        ret.data = type.data;
      }

      return ret;
    }

    function throwError(stt, field, msg) {
      let buf = STRUCT.formatStruct(stt);

      console.error(buf + "\n\n" + msg);

      if (onerror) {
        onerror(msg, stt, field);
      } else {
        throw new Error(msg);
      }
    }

    for (let k in this.structs) {
      let stt = this.structs[k];

      for (let field of stt.fields) {
        if (field.name === "this") {
          let type = field.type.type;

          if (ValueTypes.has(type)) {
            throwError(stt, field, "'this' cannot be used with value types");
          }
        }

        let type = getType(field.type);

        if (type.type !== StructEnum.T_STRUCT && type.type !== StructEnum.T_TSTRUCT) {
          continue;
        }

        if (!(type.data in this.structs)) {
          let msg = stt.name + ":" + field.name + ": Unknown struct " + type.data + ".";
          throwError(stt, field, msg);
        }
      }
    }
  }

  forEach(func, thisvar) {
    for (let k in this.structs) {
      let stt = this.structs[k];

      if (thisvar !== undefined)
        func.call(thisvar, stt);
      else
        func(stt);
    }
  }

  //defaults to structjs.manager
  parse_structs(buf, defined_classes) {
    if (defined_classes === undefined) {
      defined_classes = manager;
    }

    if (defined_classes instanceof STRUCT) {
      let struct2 = defined_classes;
      defined_classes = [];

      for (let k in struct2.struct_cls) {
        defined_classes.push(struct2.struct_cls[k]);
      }
    }

    if (defined_classes === undefined) {
      defined_classes = [];

      for (let k in manager.struct_cls) {
        defined_classes.push(manager.struct_cls[k]);
      }
    }

    let clsmap = {};

    for (let i = 0; i < defined_classes.length; i++) {
      let cls = defined_classes[i];

      if (!cls.structName && cls.STRUCT) {
        let stt = struct_parse.parse(cls.STRUCT.trim());
        cls.structName = stt.name;
      } else if (!cls.structName && cls.name !== "Object") {
        if (warninglvl$1 > 0)
          console.log("Warning, bad class in registered class list", unmangle(cls.name), cls);
        continue;
      }

      clsmap[cls.structName] = defined_classes[i];
    }

    struct_parse.input(buf);

    while (!struct_parse.at_end()) {
      let stt = struct_parse.parse(undefined, false);

      if (!(stt.name in clsmap)) {
        if (!(stt.name in this.null_natives))
          if (warninglvl$1 > 0)
            console.log("WARNING: struct " + stt.name + " is missing from class list.");

        let dummy = define_empty_class(stt.name);

        dummy.STRUCT = STRUCT.fmt_struct(stt);
        dummy.structName = stt.name;

        dummy.prototype.structName = dummy.name;

        this.struct_cls[dummy.structName] = dummy;
        this.structs[dummy.structName] = stt;

        if (stt.id !== -1)
          this.struct_ids[stt.id] = stt;
      } else {
        this.struct_cls[stt.name] = clsmap[stt.name];
        this.structs[stt.name] = stt;

        if (stt.id !== -1)
          this.struct_ids[stt.id] = stt;
      }

      let tok = struct_parse.peek();
      while (tok && (tok.value === "\n" || tok.value === "\r" || tok.value === "\t" || tok.value === " ")) {
        tok = struct_parse.peek();
      }
    }
  }

  /** adds all structs referenced by cls inside of srcSTRUCT
   *  to this */
  registerGraph(srcSTRUCT, cls) {
    if (!cls.structName) {
      console.warn("class was not in srcSTRUCT");
      return this.register(cls);
    }

    let recStruct;

    let recArray = (t) => {
      switch (t.type) {
        case StructEnum.T_ARRAY:
          return recArray(t.data.type);
        case StructEnum.T_ITERKEYS:
          return recArray(t.data.type);
        case StructEnum.T_STATIC_ARRAY:
          return recArray(t.data.type);
        case StructEnum.T_ITER:
          return recArray(t.data.type);
        case StructEnum.T_STRUCT:
        case StructEnum.T_TSTRUCT: {
          let st = srcSTRUCT.structs[t.data];
          let cls = srcSTRUCT.struct_cls[st.name];

          return recStruct(st, cls);
        }
      }
    };

    recStruct = (st, cls) => {
      if (!(cls.structName in this.structs)) {
        this.add_class(cls, cls.structName);
      }

      for (let f of st.fields) {
        if (f.type.type === StructEnum.T_STRUCT || f.type.type === StructEnum.T_TSTRUCT) {
          let st2 = srcSTRUCT.structs[f.type.data];
          let cls2 = srcSTRUCT.struct_cls[st2.name];

          recStruct(st2, cls2);
        } else if (f.type.type === StructEnum.T_ARRAY) {
          recArray(f.type);
        } else if (f.type.type === StructEnum.T_ITER) {
          recArray(f.type);
        } else if (f.type.type === StructEnum.T_ITERKEYS) {
          recArray(f.type);
        } else if (f.type.type === StructEnum.T_STATIC_ARRAY) {
          recArray(f.type);
        }
      }
    };

    let st = srcSTRUCT.structs[cls.structName];
    recStruct(st, cls);
  }

  register(cls, structName) {
    return this.add_class(cls, structName);
  }

  unregister(cls) {
    if (!cls || !cls.structName || !(cls.structName in this.struct_cls)) {
      console.warn("Class not registered with nstructjs", cls);
      return;
    }


    let st = this.structs[cls.structName];

    delete this.structs[cls.structName];
    delete this.struct_cls[cls.structName];
    delete this.struct_ids[st.id];
  }

  add_class(cls, structName) {
    //do not register Object
    if (cls === Object) {
      return;
    }

    if (cls.STRUCT) {
      let bad = false;

      let p = cls;
      while (p) {
        p = p.__proto__;

        if (p && p.STRUCT && p.STRUCT === cls.STRUCT) {
          bad = true;
          break;
        }
      }

      if (bad) {
        console.warn("Generating STRUCT script for derived class " + unmangle(cls.name));
        if (!structName) {
          structName = unmangle(cls.name);
        }

        cls.STRUCT = STRUCT.inherit(cls, p) + `\n}`;
      }
    }

    if (!cls.STRUCT) {
      throw new Error("class " + unmangle(cls.name) + " has no STRUCT script");
    }

    let stt = struct_parse.parse(cls.STRUCT);

    stt.name = unmangle(stt.name);

    cls.structName = stt.name;

    //create default newSTRUCT
    if (cls.newSTRUCT === undefined) {
      cls.newSTRUCT = function () {
        return new this();
      };
    }

    if (structName !== undefined) {
      stt.name = cls.structName = structName;
    } else if (cls.structName === undefined) {
      cls.structName = stt.name;
    } else {
      stt.name = cls.structName;
    }

    if (cls.structName in this.structs) {
      console.warn("Struct " + unmangle(cls.structName) + " is already registered", cls);

      if (!this.allowOverriding) {
        throw new Error("Struct " + unmangle(cls.structName) + " is already registered");
      }

      return;
    }

    if (stt.id === -1)
      stt.id = this.idgen++;

    this.structs[cls.structName] = stt;
    this.struct_cls[cls.structName] = cls;
    this.struct_ids[stt.id] = stt;
  }

  isRegistered(cls) {
    if (!cls.hasOwnProperty("structName")) {
      return false;
    }

    return cls === this.struct_cls[cls.structName];
  }

  get_struct_id(id) {
    return this.struct_ids[id];
  }

  get_struct(name) {
    if (!(name in this.structs)) {
      console.warn("Unknown struct", name);
      throw new Error("Unknown struct " + name);
    }
    return this.structs[name];
  }

  get_struct_cls(name) {
    if (!(name in this.struct_cls)) {
      console.trace();
      throw new Error("Unknown struct " + name);
    }
    return this.struct_cls[name];
  }

  _env_call(code, obj, env) {
    let envcode = _static_envcode_null$1;
    if (env !== undefined) {
      envcode = "";
      for (let i = 0; i < env.length; i++) {
        envcode = "let " + env[i][0] + " = env[" + i.toString() + "][1];\n" + envcode;
      }
    }
    let fullcode = "";
    if (envcode !== _static_envcode_null$1)
      fullcode = envcode + code;
    else
      fullcode = code;
    let func;

    //fullcode = fullcode.replace(/\bthis\b/, "obj");

    if (!(fullcode in this.compiled_code)) {
      let code2 = "func = function(obj, env) { " + envcode + "return " + code + "}";
      try {
        func = structEval(code2);
      } catch (err) {
        console.warn(err.stack);

        console.warn(code2);
        console.warn(" ");
        throw err;
      }
      this.compiled_code[fullcode] = func;
    } else {
      func = this.compiled_code[fullcode];
    }
    try {
      return func.call(obj, obj, env);
    } catch (err) {
      console.warn(err.stack);

      let code2 = "func = function(obj, env) { " + envcode + "return " + code + "}";
      console.warn(code2);
      console.warn(" ");
      throw err;
    }
  }

  write_struct(data, obj, stt) {
    function use_helper_js(field) {
      let type = field.type.type;
      let cls = StructFieldTypeMap[type];
      return cls.useHelperJS(field);
    }

    let fields = stt.fields;
    let thestruct = this;
    for (let i = 0; i < fields.length; i++) {
      let f = fields[i];
      let t1 = f.type;
      let t2 = t1.type;

      if (use_helper_js(f)) {
        let val;
        let type = t2;
        if (f.get !== undefined) {
          val = thestruct._env_call(f.get, obj);
        } else {
          val = f.name === "this" ? obj : obj[f.name];
        }

        if (DEBUG.tinyeval) {
          console.log("\n\n\n", f.get, "Helper JS Ret", val, "\n\n\n");
        }

        do_pack$1(data, val, obj, thestruct, f, t1);
      } else {
        let val = f.name === "this" ? obj : obj[f.name];
        do_pack$1(data, val, obj, thestruct, f, t1);
      }
    }
  }

  /**
   @param data : array to write data into,
   @param obj  : structable object
   */
  write_object(data, obj) {
    let cls = obj.constructor.structName;
    let stt = this.get_struct(cls);

    if (data === undefined) {
      data = [];
    }

    this.write_struct(data, obj, stt);
    return data;
  }

  /**
   Read an object from binary data

   @param data : DataView or Uint8Array instance
   @param cls_or_struct_id : Structable class
   @param uctx : internal parameter
   @return {cls_or_struct_id} Instance of cls_or_struct_id
   */
  readObject(data, cls_or_struct_id, uctx) {
    if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
      data = new DataView(data.buffer);
    } else if (data instanceof Array) {
      data = new DataView(new Uint8Array(data).buffer);
    }

    return this.read_object(data, cls_or_struct_id, uctx);
  }

  /**
   @param data array to write data into,
   @param obj structable object
   */
  writeObject(data, obj) {
    return this.write_object(data, obj);
  }

  writeJSON(obj, stt = undefined) {
    let cls = obj.constructor;
    stt = stt || this.get_struct(cls.structName);

    function use_helper_js(field) {
      let type = field.type.type;
      let cls = StructFieldTypeMap[type];
      return cls.useHelperJS(field);
    }

    let toJSON$1 = toJSON;

    let fields = stt.fields;
    let thestruct = this;
    let json = {};

    for (let i = 0; i < fields.length; i++) {
      let f = fields[i];
      let val;
      let t1 = f.type;

      let json2;

      if (use_helper_js(f)) {
        if (f.get !== undefined) {
          val = thestruct._env_call(f.get, obj);
        } else {
          val = f.name === "this" ? obj : obj[f.name];
        }

        if (DEBUG.tinyeval) {
          console.log("\n\n\n", f.get, "Helper JS Ret", val, "\n\n\n");
        }

        json2 = toJSON$1(this, val, obj, f, t1);
      } else {
        val = f.name === "this" ? obj : obj[f.name];
        json2 = toJSON$1(this, val, obj, f, t1);
      }

      if (f.name !== 'this') {
        json[f.name] = json2;
      } else { //f.name was 'this'?
        let isArray = Array.isArray(json2);
        isArray = isArray || f.type.type === StructTypes.T_ARRAY;
        isArray = isArray || f.type.type === StructTypes.T_STATIC_ARRAY;

        if (isArray) {
          json.length = json2.length;

          for (let i = 0; i < json2.length; i++) {
            json[i] = json2[i];
          }
        } else {
          Object.assign(json, json2);
        }
      }
    }

    return json;
  }

  /**
   @param data : DataView or Uint8Array instance
   @param cls_or_struct_id : Structable class
   @param uctx : internal parameter
   */
  read_object(data, cls_or_struct_id, uctx, objInstance) {
    let cls, stt;

    if (data instanceof Array) {
      data = new DataView(new Uint8Array(data).buffer);
    }

    if (typeof cls_or_struct_id === "number") {
      cls = this.struct_cls[this.struct_ids[cls_or_struct_id].name];
    } else {
      cls = cls_or_struct_id;
    }

    if (cls === undefined) {
      throw new Error("bad cls_or_struct_id " + cls_or_struct_id);
    }

    stt = this.structs[cls.structName];

    if (uctx === undefined) {
      uctx = new unpack_context();

      packer_debug$1("\n\n=Begin reading " + cls.structName + "=");
    }
    let thestruct = this;

    let this2 = this;

    function unpack_field(type) {
      return StructFieldTypeMap[type.type].unpack(this2, data, type, uctx);
    }

    function unpack_into(type, dest) {
      return StructFieldTypeMap[type.type].unpackInto(this2, data, type, uctx, dest);
    }

    let was_run = false;

    function makeLoader(stt) {
      return function load(obj) {
        if (was_run) {
          return;
        }

        was_run = true;

        let fields = stt.fields;
        let flen = fields.length;

        for (let i = 0; i < flen; i++) {
          let f = fields[i];

          if (f.name === 'this') {
            //load data into obj directly
            unpack_into(f.type, obj);
          } else {
            obj[f.name] = unpack_field(f.type);
          }
        }
      }
    }

    let load = makeLoader(stt);

    if (cls.prototype.loadSTRUCT !== undefined) {
      let obj = objInstance;

      if (!obj && cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT(load);
      } else if (!obj) {
        obj = new cls();
      }

      obj.loadSTRUCT(load);

      if (!was_run) {
        console.warn(""+cls.structName + ".prototype.loadSTRUCT() did not execute its loader callback!");
        load(obj);
      }

      return obj;
    } else if (cls.fromSTRUCT !== undefined) {
      if (warninglvl$1 > 1)
        console.warn("Warning: class " + unmangle(cls.name) + " is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead");
      return cls.fromSTRUCT(load);
    } else { //default case, make new instance and then call load() on it
      let obj = objInstance;

      if (!obj && cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT(load);
      } else if (!obj) {
        obj = new cls();
      }

      load(obj);

      return obj;
    }
  }

  readJSON(json, cls_or_struct_id, objInstance = undefined) {
    let cls, stt;

    if (typeof cls_or_struct_id === "number") {
      cls = this.struct_cls[this.struct_ids[cls_or_struct_id].name];
    } else if (cls_or_struct_id instanceof NStruct) {
      cls = this.get_struct_cls(cls_or_struct_id.name);
    } else {
      cls = cls_or_struct_id;
    }

    if (cls === undefined) {
      throw new Error("bad cls_or_struct_id " + cls_or_struct_id);
    }

    stt = this.structs[cls.structName];

    packer_debug$1("\n\n=Begin reading " + cls.structName + "=");
    let thestruct = this;
    let this2 = this;
    let was_run = false;
    let fromJSON$1 = fromJSON;

    function makeLoader(stt) {
      return function load(obj) {
        if (was_run) {
          return;
        }

        was_run = true;

        let fields = stt.fields;
        let flen = fields.length;

        for (let i = 0; i < flen; i++) {
          let f = fields[i];

          let val;

          if (f.name === 'this') {
            val = json;
          } else {
            val = json[f.name];
          }

          if (val === undefined) {
            console.warn("nstructjs.readJSON: Missing field " + f.name + " in struct " + stt.name);
            continue;
          }

          let instance = f.name === 'this' ? obj : objInstance;

          let ret = fromJSON$1(this2, val, obj, f, f.type, instance);

          if (f.name !== 'this') {
            obj[f.name] = ret;
          }
        }
      }
    }

    let load = makeLoader(stt);

    if (cls.prototype.loadSTRUCT !== undefined) {
      let obj = objInstance;

      if (!obj && cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT(load);
      } else if (!obj) {
        obj = new cls();
      }

      obj.loadSTRUCT(load);
      return obj;
    } else if (cls.fromSTRUCT !== undefined) {
      if (warninglvl$1 > 1)
        console.warn("Warning: class " + unmangle(cls.name) + " is using deprecated fromSTRUCT interface; use newSTRUCT/loadSTRUCT instead");
      return cls.fromSTRUCT(load);
    } else { //default case, make new instance and then call load() on it
      let obj = objInstance;

      if (!obj && cls.newSTRUCT !== undefined) {
        obj = cls.newSTRUCT(load);
      } else if (!obj) {
        obj = new cls();
      }

      load(obj);

      return obj;
    }
  }
};

//main struct script manager
manager = new STRUCT();

/**
 * Write all defined structs out to a string.
 *
 * @param nManager STRUCT instance, defaults to nstructjs.manager
 * @param include_code include save code snippets
 * */
function write_scripts(nManager = manager, include_code = false) {
  let buf = "";

  nManager.forEach(function (stt) {
    buf += STRUCT.fmt_struct(stt, false, !include_code) + "\n";
  });

  let buf2 = buf;
  buf = "";

  for (let i = 0; i < buf2.length; i++) {
    let c = buf2[i];
    if (c === "\n") {
      buf += "\n";
      let i2 = i;
      while (i < buf2.length && (buf2[i] === " " || buf2[i] === "\t" || buf2[i] === "\n")) {
        i++;
      }
      if (i !== i2)
        i--;
    } else {
      buf += c;
    }
  }

  return buf;
}

"use strict";

let nbtoa, natob;

if (typeof btoa === "undefined") {
  nbtoa = function btoa(str) {
    let buffer = new Buffer("" + str, 'binary');
    return buffer.toString('base64');
  };

  natob = function atob(str) {
    return new Buffer(str, 'base64').toString('binary');
  };
} else {
  natob = atob;
  nbtoa = btoa;
}

/*
file format:
  magic signature              : 4 bytes
  file version major           : 2 bytes
  file version minor           : 1 bytes
  file version micro           : 1 bytes
  length of struct scripts     : 4 bytes
  struct scripts for this file : ...
  
  block:
    magic signature for block              : 4 bytes
    length of data  (not including header) : 4 bytes
    id of struct type                      : 4 bytes
    
    data                                   : ...
*/

function versionToInt(v) {
  v = versionCoerce(v);
  let mul = 64;
  return ~~(v.major*mul*mul*mul + v.minor*mul*mul + v.micro*mul);
}

let ver_pat = /[0-9]+\.[0-9]+\.[0-9]+$/;

function versionCoerce(v) {
  if (!v) {
    throw new Error("empty version: " + v);
  }

  if (typeof v === "string") {
    if (!ver_pat.exec(v)) {
      throw new Error("invalid version string " + v);
    }

    let ver = v.split(".");
    return {
      major : parseInt(ver[0]),
      minor : parseInt(ver[1]),
      micro : parseInt(ver[2])
    }
  } else if (Array.isArray(v)) {
    return {
      major : v[0],
      minor : v[1],
      micro : v[2]
    }
  } else if (typeof v === "object") {
    let test = (k) => k in v && typeof v[k] === "number";

    if (!test("major") || !test("minor") || !test("micro")) {
      throw new Error("invalid version object: " + v);
    }

    return v;
  } else {
    throw new Error("invalid version " + v);
  }
}

function versionLessThan(a, b) {
  return versionToInt(a) < versionToInt(b);
}

class FileParams {
  constructor() {
    this.magic = "STRT";
    this.ext = ".bin";
    this.blocktypes = ["DATA"];

    this.version = {
      major: 0,
      minor: 0,
      micro: 1
    };
  }
}

//used to define blocks
class Block {
  constructor(type_magic, data) {
    this.type = type_magic;
    this.data = data;
  }
}

class FileeError extends Error {
}

class FileHelper {
  //params can be FileParams instance, or object literal
  //(it will convert to FileParams)
  constructor(params) {
    if (params === undefined) {
      params = new FileParams();
    } else {
      let fp = new FileParams();

      for (let k in params) {
        fp[k] = params[k];
      }
      params = fp;
    }

    this.version = params.version;
    this.blocktypes = params.blocktypes;
    this.magic = params.magic;
    this.ext = params.ext;
    this.struct = undefined;
    this.unpack_ctx = undefined;
  }

  read(dataview) {
    this.unpack_ctx = new unpack_context();

    let magic = unpack_static_string(dataview, this.unpack_ctx, 4);

    if (magic !== this.magic) {
      throw new FileError("corrupted file");
    }

    this.version = {};
    this.version.major = unpack_short(dataview, this.unpack_ctx);
    this.version.minor = unpack_byte(dataview, this.unpack_ctx);
    this.version.micro = unpack_byte(dataview, this.unpack_ctx);

    let struct = this.struct = new STRUCT();

    let scripts = unpack_string(dataview, this.unpack_ctx);
    this.struct.parse_structs(scripts, manager);

    let blocks = [];
    let dviewlen = dataview.buffer.byteLength;

    while (this.unpack_ctx.i < dviewlen) {
      //console.log("reading block. . .", this.unpack_ctx.i, dviewlen);

      let type = unpack_static_string(dataview, this.unpack_ctx, 4);
      let datalen = unpack_int(dataview, this.unpack_ctx);
      let bstruct = unpack_int(dataview, this.unpack_ctx);
      let bdata;

      //console.log(type, datalen, bstruct);

      if (bstruct === -2) { //string data, e.g. JSON
        bdata = unpack_static_string(dataview, this.unpack_ctx, datalen);
      } else {
        bdata = unpack_bytes(dataview, this.unpack_ctx, datalen);
        bdata = struct.read_object(bdata, bstruct, new unpack_context());
      }

      let block = new Block();
      block.type = type;
      block.data = bdata;

      blocks.push(block);
    }

    this.blocks = blocks;
    return blocks;
  }

  doVersions(old) {
    let blocks = this.blocks;

    if (versionLessThan(old, "0.0.1")) {
      //do something
    }
  }

  write(blocks) {
    this.struct = manager;
    this.blocks = blocks;

    let data = [];

    pack_static_string(data, this.magic, 4);
    pack_short(data, this.version.major);
    pack_byte(data, this.version.minor & 255);
    pack_byte(data, this.version.micro & 255);

    let scripts = write_scripts();
    pack_string(data, scripts);

    let struct = this.struct;

    for (let block of blocks) {
      if (typeof block.data === "string") { //string data, e.g. JSON
        pack_static_string(data, block.type, 4);
        pack_int(data, block.data.length);
        pack_int(data, -2); //flag as string data
        pack_static_string(data, block.data, block.data.length);
        continue;
      }

      let structName = block.data.constructor.structName;
      if (structName === undefined || !(structName in struct.structs)) {
        throw new Error("Non-STRUCTable object " + block.data);
      }

      let data2 = [];
      let stt = struct.structs[structName];

      struct.write_object(data2, block.data);

      pack_static_string(data, block.type, 4);
      pack_int(data, data2.length);
      pack_int(data, stt.id);

      pack_bytes(data, data2);
    }

    return new DataView(new Uint8Array(data).buffer);
  }

  writeBase64(blocks) {
    let dataview = this.write(blocks);

    let str = "";
    let bytes = new Uint8Array(dataview.buffer);

    for (let i = 0; i < bytes.length; i++) {
      str += String.fromCharCode(bytes[i]);
    }

    return nbtoa(str);
  }

  makeBlock(type, data) {
    return new Block(type, data);
  }

  readBase64(base64) {
    let data = natob(base64);
    let data2 = new Uint8Array(data.length);

    for (let i = 0; i < data.length; i++) {
      data2[i] = data.charCodeAt(i);
    }

    return this.read(new DataView(data2.buffer));
  }
}

var struct_filehelper = /*#__PURE__*/Object.freeze({
  __proto__: null,
  versionToInt: versionToInt,
  versionCoerce: versionCoerce,
  versionLessThan: versionLessThan,
  FileParams: FileParams,
  Block: Block,
  FileeError: FileeError,
  FileHelper: FileHelper
});

/** truncate webpack mangled names. defaults to true
 *  so Mesh$1 turns into Mesh */
function truncateDollarSign$1(value = true) {
  setTruncateDollarSign(value);
}

function validateStructs(onerror) {
  return manager.validateStructs(onerror);
}

/**
 true means little endian, false means big endian
 */
function setEndian$1(mode) {
  let ret = STRUCT_ENDIAN;

  setEndian(mode);

  return ret;
}

function getEndian() {
  return STRUCT_ENDIAN;
}

function setAllowOverriding(t) {
  return manager.allowOverriding = !!t;
}

function isRegistered(cls) {
  return manager.isRegistered(cls);
}

/** Register a class with nstructjs **/
function register(cls, structName) {
  return manager.register(cls, structName);
}

function unregister(cls) {
  manager.unregister(cls);
}

function inherit(child, parent, structName = child.name) {

  return STRUCT.inherit(...arguments);
}

/**
 @param data : DataView
 */
function readObject(data, cls, __uctx = undefined) {
  return manager.readObject(data, cls, __uctx);
}

/**
 @param data : Array instance to write bytes to
 */
function writeObject(data, obj) {
  return manager.writeObject(data, obj);
}

function writeJSON(obj) {
  return manager.writeJSON(obj);
}

function readJSON(json, class_or_struct_id) {
  return manager.readJSON(json, class_or_struct_id);
}

var nstructjs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  STRUCT: STRUCT,
  _truncateDollarSign: _truncateDollarSign,
  binpack: struct_binpack,
  filehelper: struct_filehelper,
  getEndian: getEndian,
  inherit: inherit,
  isRegistered: isRegistered,
  get manager () { return manager; },
  parser: struct_parser,
  parseutil: struct_parseutil,
  readJSON: readJSON,
  readObject: readObject,
  register: register,
  setAllowOverriding: setAllowOverriding,
  setDebugMode: setDebugMode$1,
  setEndian: setEndian$1,
  setTruncateDollarSign: setTruncateDollarSign,
  setWarningMode: setWarningMode$1,
  truncateDollarSign: truncateDollarSign$1,
  typesystem: struct_typesystem,
  unpack_context: unpack_context,
  unregister: unregister,
  validateStructs: validateStructs,
  writeJSON: writeJSON,
  writeObject: writeObject,
  write_scripts: write_scripts
});

// THIS FILE IS GENERATED - DO NOT EDIT!
/*!mobile-detect v1.4.4 2019-09-21*/
/*global module:false, define:false*/
/*jshint latedef:false*/
/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
(function (define, undefined$1) {
define(function () {
    'use strict';

    var impl = {};

    impl.mobileDetectRules = {
    "phones": {
        "iPhone": "\\biPhone\\b|\\biPod\\b",
        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
        "NokiaLumia": "Lumia [0-9]{3,4}",
        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
        "Palm": "PalmSource|Palm",
        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
        "Alcatel": "Alcatel",
        "Nintendo": "Nintendo (3DS|Switch)",
        "Amoi": "Amoi",
        "INQ": "INQ",
        "OnePlus": "ONEPLUS",
        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
    },
    "tablets": {
        "iPad": "iPad|iPad.*Mobile",
        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
        "GoogleTablet": "Android.*Pixel C",
        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V",
        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
        "BlackBerryTablet": "PlayBook|RIM Tablet",
        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X",
        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
        "IRUTablet": "M702pro",
        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
        "NokiaLumiaTablet": "Lumia 2520",
        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
        "FlyTablet": "IQ310|Fly Vision",
        "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
        "NecTablet": "\\bN-06D|\\bN-08D",
        "PantechTablet": "Pantech.*P4100",
        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
        "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
        "NabiTablet": "Android.*\\bNabi",
        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
        "PlaystationTablet": "Playstation.*(Portable|Vita)",
        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
        "DPSTablet": "DPS Dream 9|DPS Dual 7",
        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
        "iMobileTablet": "i-mobile i-note",
        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
        "AMPETablet": "Android.* A78 ",
        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
        "TecnoTablet": "TECNO P9|TECNO DP8D",
        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
        "CaptivaTablet": "CAPTIVA PAD",
        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
        "JaytechTablet": "TPC-PA762",
        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
        "UbislateTablet": "UbiSlate[\\s]?7C",
        "PocketBookTablet": "Pocketbook",
        "KocasoTablet": "\\b(TB-1207)\\b",
        "HisenseTablet": "\\b(F5281|E2371)\\b",
        "Hudl": "Hudl HT7S3|Hudl 2",
        "TelstraTablet": "T-Hub2",
        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
    },
    "oss": {
        "AndroidOS": "Android",
        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
        "iPadOS": "CPU OS 13",
        "MeeGoOS": "MeeGo",
        "MaemoOS": "Maemo",
        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
        "webOS": "webOS|hpwOS",
        "badaOS": "\\bBada\\b",
        "BREWOS": "BREW"
    },
    "uas": {
        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
        "Dolfin": "\\bDolfin\\b",
        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
        "Skyfire": "Skyfire",
        "Edge": "Mobile Safari\/[.0-9]* Edge",
        "IE": "IEMobile|MSIEMobile",
        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
        "Bolt": "bolt",
        "TeaShark": "teashark",
        "Blazer": "Blazer",
        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
        "WeChat": "\\bMicroMessenger\\b",
        "UCBrowser": "UC.*Browser|UCWEB",
        "baiduboxapp": "baiduboxapp",
        "baidubrowser": "baidubrowser",
        "DiigoBrowser": "DiigoBrowser",
        "Mercury": "\\bMercury\\b",
        "ObigoBrowser": "Obigo",
        "NetFront": "NF-Browser",
        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
    },
    "props": {
        "Mobile": "Mobile\/[VER]",
        "Build": "Build\/[VER]",
        "Version": "Version\/[VER]",
        "VendorID": "VendorID\/[VER]",
        "iPad": "iPad.*CPU[a-z ]+[VER]",
        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
        "iPod": "iPod.*CPU[a-z ]+[VER]",
        "Kindle": "Kindle\/[VER]",
        "Chrome": [
            "Chrome\/[VER]",
            "CriOS\/[VER]",
            "CrMo\/[VER]"
        ],
        "Coast": [
            "Coast\/[VER]"
        ],
        "Dolfin": "Dolfin\/[VER]",
        "Firefox": [
            "Firefox\/[VER]",
            "FxiOS\/[VER]"
        ],
        "Fennec": "Fennec\/[VER]",
        "Edge": "Edge\/[VER]",
        "IE": [
            "IEMobile\/[VER];",
            "IEMobile [VER]",
            "MSIE [VER];",
            "Trident\/[0-9.]+;.*rv:[VER]"
        ],
        "NetFront": "NetFront\/[VER]",
        "NokiaBrowser": "NokiaBrowser\/[VER]",
        "Opera": [
            " OPR\/[VER]",
            "Opera Mini\/[VER]",
            "Version\/[VER]"
        ],
        "Opera Mini": "Opera Mini\/[VER]",
        "Opera Mobi": "Version\/[VER]",
        "UCBrowser": [
            "UCWEB[VER]",
            "UC.*Browser\/[VER]"
        ],
        "MQQBrowser": "MQQBrowser\/[VER]",
        "MicroMessenger": "MicroMessenger\/[VER]",
        "baiduboxapp": "baiduboxapp\/[VER]",
        "baidubrowser": "baidubrowser\/[VER]",
        "SamsungBrowser": "SamsungBrowser\/[VER]",
        "Iron": "Iron\/[VER]",
        "Safari": [
            "Version\/[VER]",
            "Safari\/[VER]"
        ],
        "Skyfire": "Skyfire\/[VER]",
        "Tizen": "Tizen\/[VER]",
        "Webkit": "webkit[ \/][VER]",
        "PaleMoon": "PaleMoon\/[VER]",
        "Gecko": "Gecko\/[VER]",
        "Trident": "Trident\/[VER]",
        "Presto": "Presto\/[VER]",
        "Goanna": "Goanna\/[VER]",
        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
        "Android": "Android [VER]",
        "BlackBerry": [
            "BlackBerry[\\w]+\/[VER]",
            "BlackBerry.*Version\/[VER]",
            "Version\/[VER]"
        ],
        "BREW": "BREW [VER]",
        "Java": "Java\/[VER]",
        "Windows Phone OS": [
            "Windows Phone OS [VER]",
            "Windows Phone [VER]"
        ],
        "Windows Phone": "Windows Phone [VER]",
        "Windows CE": "Windows CE\/[VER]",
        "Windows NT": "Windows NT [VER]",
        "Symbian": [
            "SymbianOS\/[VER]",
            "Symbian\/[VER]"
        ],
        "webOS": [
            "webOS\/[VER]",
            "hpwOS\/[VER];"
        ]
    },
    "utils": {
        "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp",
        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
        "DesktopMode": "WPDesktop",
        "TV": "SonyDTV|HbbTV",
        "WebKit": "(webkit)[ \/]([\\w.]+)",
        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
        "Watch": "SM-V700"
    }
};

    // following patterns come from http://detectmobilebrowsers.com/
    impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
    };

    var hasOwnProp = Object.prototype.hasOwnProperty,
        isArray;

    impl.FALLBACK_PHONE = 'UnknownPhone';
    impl.FALLBACK_TABLET = 'UnknownTablet';
    impl.FALLBACK_MOBILE = 'UnknownMobile';

    isArray = ('isArray' in Array) ?
        Array.isArray : function (value) { return Object.prototype.toString.call(value) === '[object Array]'; };

    function equalIC(a, b) {
        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
    }

    function containsIC(array, value) {
        var valueLC, i, len = array.length;
        if (!len || !value) {
            return false;
        }
        valueLC = value.toLowerCase();
        for (i = 0; i < len; ++i) {
            if (valueLC === array[i].toLowerCase()) {
                return true;
            }
        }
        return false;
    }

    function convertPropsToRegExp(object) {
        for (var key in object) {
            if (hasOwnProp.call(object, key)) {
                object[key] = new RegExp(object[key], 'i');
            }
        }
    }

    function prepareUserAgent(userAgent) {
        return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
    }

    (function init() {
        var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
            if (hasOwnProp.call(mobileDetectRules.props, key)) {
                values = mobileDetectRules.props[key];
                if (!isArray(values)) {
                    values = [values];
                }
                len = values.length;
                for (i = 0; i < len; ++i) {
                    value = values[i];
                    verPos = value.indexOf('[VER]');
                    if (verPos >= 0) {
                        value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                    }
                    values[i] = new RegExp(value, 'i');
                }
                mobileDetectRules.props[key] = values;
            }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);

        // copy some patterns to oss0 which are tested first (see issue#15)
        mobileDetectRules.oss0 = {
            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
    }());

    /**
     * Test userAgent string against a set of rules and find the first matched key.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
     * @private
     */
    impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    return key;
                }
            }
        }
        return null;
    };

    /**
     * Test userAgent string against a set of rules and return an array of matched keys.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
     * @private
     */
    impl.findMatches = function(rules, userAgent) {
        var result = [];
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    result.push(key);
                }
            }
        }
        return result;
    };

    /**
     * Check the version of the given property in the User-Agent.
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {String} version or <tt>null</tt> if version not found
     * @private
     */
    impl.getVersionStr = function (propertyName, userAgent) {
        var props = impl.mobileDetectRules.props, patterns, i, len, match;
        if (hasOwnProp.call(props, propertyName)) {
            patterns = props[propertyName];
            len = patterns.length;
            for (i = 0; i < len; ++i) {
                match = patterns[i].exec(userAgent);
                if (match !== null) {
                    return match[1];
                }
            }
        }
        return null;
    };

    /**
     * Check the version of the given property in the User-Agent.
     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {Number} version or <tt>NaN</tt> if version not found
     * @private
     */
    impl.getVersion = function (propertyName, userAgent) {
        var version = impl.getVersionStr(propertyName, userAgent);
        return version ? impl.prepareVersionNo(version) : NaN;
    };

    /**
     * Prepare the version number.
     *
     * @param {String} version
     * @return {Number} the version number as a floating number
     * @private
     */
    impl.prepareVersionNo = function (version) {
        var numbers;

        numbers = version.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
            version = numbers[0];
        }
        if (numbers.length > 1) {
            version = numbers[0] + '.';
            numbers.shift();
            version += numbers.join('');
        }
        return Number(version);
    };

    impl.isMobileFallback = function (userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) ||
            impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0,4));
    };

    impl.isTabletFallback = function (userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
    };

    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
        if (cache.mobile !== undefined$1) {
            return;
        }
        var phone, tablet, phoneSized;

        // first check for stronger tablet rules, then phone (see issue#5)
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
            cache.mobile = cache.tablet = tablet;
            cache.phone = null;
            return; // unambiguously identified as tablet
        }

        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
            cache.mobile = cache.phone = phone;
            cache.tablet = null;
            return; // unambiguously identified as phone
        }

        // our rules haven't found a match -> try more general fallback rules
        if (impl.isMobileFallback(userAgent)) {
            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
            if (phoneSized === undefined$1) {
                cache.mobile = impl.FALLBACK_MOBILE;
                cache.tablet = cache.phone = null;
            } else if (phoneSized) {
                cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                cache.tablet = null;
            } else {
                cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                cache.phone = null;
            }
        } else if (impl.isTabletFallback(userAgent)) {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
        } else {
            // not mobile at all!
            cache.mobile = cache.tablet = cache.phone = null;
        }
    };

    // t is a reference to a MobileDetect instance
    impl.mobileGrade = function (t) {
        // impl note:
        // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
        // When changes are made in Mobile_Detect.php, copy this method and replace:
        //     $this-> / t.
        //     self::MOBILE_GRADE_(.) / '$1'
        //     , self::VERSION_TYPE_FLOAT / (nothing)
        //     isIOS() / os('iOS')
        //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
        var $isMobile = t.mobile() !== null;

        if (
            // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
            t.os('iOS') && t.version('iPad')>=4.3 ||
            t.os('iOS') && t.version('iPhone')>=3.1 ||
            t.os('iOS') && t.version('iPod')>=3.1 ||

            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
            ( t.version('Android')>2.1 && t.is('Webkit') ) ||

            // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
            t.version('Windows Phone OS')>=7.0 ||

            // Blackberry 7 - Tested on BlackBerry Torch 9810
            // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
            t.is('BlackBerry') && t.version('BlackBerry')>=6.0 ||
            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
            t.match('Playbook.*Tablet') ||

            // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
            ( t.version('webOS')>=1.4 && t.match('Palm|Pre|Pixi') ) ||
            // Palm WebOS 3.0  - Tested on HP TouchPad
            t.match('hp.*TouchPad') ||

            // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
            ( t.is('Firefox') && t.version('Firefox')>=12 ) ||

            // Chrome for Android - Tested on Android 4.0, 4.1 device
            ( t.is('Chrome') && t.is('AndroidOS') && t.version('Android')>=4.0 ) ||

            // Skyfire 4.1 - Tested on Android 2.3 device
            ( t.is('Skyfire') && t.version('Skyfire')>=4.1 && t.is('AndroidOS') && t.version('Android')>=2.3 ) ||

            // Opera Mobile 11.5-12: Tested on Android 2.3
            ( t.is('Opera') && t.version('Opera Mobi')>11 && t.is('AndroidOS') ) ||

            // Meego 1.2 - Tested on Nokia 950 and N9
            t.is('MeeGoOS') ||

            // Tizen (pre-release) - Tested on early hardware
            t.is('Tizen') ||

            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
            // @todo: more tests here!
            t.is('Dolfin') && t.version('Bada')>=2.0 ||

            // UC Browser - Tested on Android 2.3 device
            ( (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android')>=2.3 ) ||

            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
            ( t.match('Kindle Fire') ||
                t.is('Kindle') && t.version('Kindle')>=3.0 ) ||

            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
            t.is('AndroidOS') && t.is('NookTablet') ||

            // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
            t.version('Chrome')>=11 && !$isMobile ||

            // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
            t.version('Safari')>=5.0 && !$isMobile ||

            // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
            t.version('Firefox')>=4.0 && !$isMobile ||

            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
            t.version('MSIE')>=7.0 && !$isMobile ||

            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
            // @reference: http://my.opera.com/community/openweb/idopera/
            t.version('Opera')>=10 && !$isMobile

            ){
            return 'A';
        }

        if (
            t.os('iOS') && t.version('iPad')<4.3 ||
            t.os('iOS') && t.version('iPhone')<3.1 ||
            t.os('iOS') && t.version('iPod')<3.1 ||

            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
            t.is('Blackberry') && t.version('BlackBerry')>=5 && t.version('BlackBerry')<6 ||

            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
            ( t.version('Opera Mini')>=5.0 && t.version('Opera Mini')<=6.5 &&
                (t.version('Android')>=2.3 || t.is('iOS')) ) ||

            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
            t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

            // @todo: report this (tested on Nokia N71)
            t.version('Opera Mobi')>=11 && t.is('SymbianOS')
            ){
            return 'B';
        }

        if (
        // Blackberry 4.x - Tested on the Curve 8330
            t.version('BlackBerry')<5.0 ||
            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
            t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile')<=5.2

            ){
            return 'C';
        }

        //All older smartphone platforms and featurephones - Any device that doesn't support media queries
        //will receive the basic, C grade experience.
        return 'C';
    };

    impl.detectOS = function (ua) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua) ||
            impl.findMatch(impl.mobileDetectRules.oss, ua);
    };

    impl.getDeviceSmallerSide = function () {
        return window.screen.width < window.screen.height ?
            window.screen.width :
            window.screen.height;
    };

    /**
     * Constructor for MobileDetect object.
     * <br>
     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
     *     <strong>Find information how to download and install:</strong>
     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
     * </div>
     *
     * @example <pre>
     *     var md = new MobileDetect(window.navigator.userAgent);
     *     if (md.mobile()) {
     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
     *     }
     * </pre>
     *
     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
     *        as phone.
     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
     *        for Android</a>.<br>
     *        If you provide a value < 0, then this "fuzzy" check is disabled.
     * @constructor
     * @global
     */
    function MobileDetect(userAgent, maxPhoneWidth) {
        this.ua = prepareUserAgent(userAgent);
        this._cache = {};
        //600dp is typical 7" tablet minimum width
        this.maxPhoneWidth = maxPhoneWidth || 600;
    }

    MobileDetect.prototype = {
        constructor: MobileDetect,

        /**
         * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
         * <br>
         * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
         * <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
         * @function MobileDetect#mobile
         */
        mobile: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.mobile;
        },

        /**
         * Returns the detected phone type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
         * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
         * Wolfgang, Alcatel, Nintendo, Amoi, INQ, OnePlus, GenericPhone</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the phone family or producer, e.g. "iPhone"
         * @function MobileDetect#phone
         */
        phone: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.phone;
        },

        /**
         * Returns the detected tablet type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
         * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
         * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
         * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
         * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
         * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
         * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
         * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
         * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
         * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
         * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
         * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
         * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
         * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
         * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
         * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
         * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
         * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
         * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
         * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
         * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
         * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
         * GenericTablet</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
         * @function MobileDetect#tablet
         */
        tablet: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.tablet;
        },

        /**
         * Returns the (first) detected user-agent string or <tt>null</tt>.
         * <br>
         * The returned user-agent is one of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {String} the key for the detected user-agent or <tt>null</tt>
         * @function MobileDetect#userAgent
         */
        userAgent: function () {
            if (this._cache.userAgent === undefined$1) {
                this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgent;
        },

        /**
         * Returns all detected user-agent strings.
         * <br>
         * The array is empty or contains one or more of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
         * @function MobileDetect#userAgents
         */
        userAgents: function () {
            if (this._cache.userAgents === undefined$1) {
                this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgents;
        },

        /**
         * Returns the detected operating system string or <tt>null</tt>.
         * <br>
         * The operating system is one of following keys:<br>
         * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
         * iOS, iPadOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
         *
         * @returns {String} the key for the detected operating system.
         * @function MobileDetect#os
         */
        os: function () {
            if (this._cache.os === undefined$1) {
                this._cache.os = impl.detectOS(this.ua);
            }
            return this._cache.os;
        },

        /**
         * Get the version (as Number) of the given property in the User-Agent.
         * <br>
         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
         *          Be careful when comparing this value with '==' operator!
         * @function MobileDetect#version
         */
        version: function (key) {
            return impl.getVersion(key, this.ua);
        },

        /**
         * Get the version (as String) of the given property in the User-Agent.
         * <br>
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
         *
         * @function MobileDetect#versionStr
         */
        versionStr: function (key) {
            return impl.getVersionStr(key, this.ua);
        },

        /**
         * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
         *
         * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
         *        tablet family.<br>
         *        For a complete list of possible values, see {@link MobileDetect#userAgent},
         *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
         *        Additionally you have following keys:<br>
         * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
         *
         * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
         *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
         * @function MobileDetect#is
         */
        is: function (key) {
            return containsIC(this.userAgents(), key) ||
                   equalIC(key, this.os()) ||
                   equalIC(key, this.phone()) ||
                   equalIC(key, this.tablet()) ||
                   containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },

        /**
         * Do a quick test against navigator::userAgent.
         *
         * @param {String|RegExp} pattern the pattern, either as String or RegExp
         *                        (a string will be converted to a case-insensitive RegExp).
         * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
         * @function MobileDetect#match
         */
        match: function (pattern) {
            if (!(pattern instanceof RegExp)) {
                pattern = new RegExp(pattern, 'i');
            }
            return pattern.test(this.ua);
        },

        /**
         * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
         * <br>
         * Obviously this method makes sense in browser environments only (not for Node.js)!
         * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
         *        The argument is optional and if not present or falsy, the value of the constructor is taken.
         * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
         *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
         *          Will always return <code>undefined</code> server-side.
         */
        isPhoneSized: function (maxPhoneWidth) {
            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },

        /**
         * Returns the mobile grade ('A', 'B', 'C').
         *
         * @returns {String} one of the mobile grades ('A', 'B', 'C').
         * @function MobileDetect#mobileGrade
         */
        mobileGrade: function () {
            if (this._cache.grade === undefined$1) {
                this._cache.grade = impl.mobileGrade(this);
            }
            return this._cache.grade;
        }
    };

    // environment-dependent
    if (typeof window !== 'undefined' && window.screen) {
        MobileDetect.isPhoneSized = function (maxPhoneWidth) {
            return maxPhoneWidth < 0 ? undefined$1 : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
    } else {
        MobileDetect.isPhoneSized = function () {};
    }

    // should not be replaced by a completely new object - just overwrite existing methods
    MobileDetect._impl = impl;
    
    MobileDetect.version = '1.4.4 2019-09-21';

    return MobileDetect;
}); // end of call of define()
})((function (undefined$1) {
    if (typeof module !== 'undefined' && module.exports) {
        return function (factory) { module.exports = factory(); };
    } else if (typeof define === 'function' && define.amd) {
        return define;
    } else if (typeof window !== 'undefined') {
        return function (factory) { window.MobileDetect = factory(); };
    } else {
        // please file a bug if you get this error!
        throw new Error('unknown environment');
    }
})());

let f64tmp = new Float64Array(1);
let u16tmp = new Uint16Array(f64tmp.buffer);

function isDenormal(f) {
  f64tmp[0] = f;

  let a = u16tmp[0], b = u16tmp[1], c = u16tmp[2], d = u16tmp[3];

  //zero? check both positive and negative zero
  if (a === 0 && b === 0 && c === 0 && (d === 0 || d === 32768)) {
    return false;
  }

  let test = d & ~(1<<15);
  test = test>>4;

  //window.console.log(u16tmp[0], u16tmp[1], u16tmp[2], u16tmp[3], "|", test);

  return test === 0;
}

globalThis._isDenormal = isDenormal;


let colormap = {
  "black"   : 30,
  "red"     : 31,
  "green"   : 32,
  "yellow"  : 33,
  "blue"    : 34,
  "magenta" : 35,
  "cyan"    : 36,
  "teal"    : 36,
  "white"   : 37,
  "reset"   : 0,
  "grey"    : 2,
  "gray"    : 2,
  "orange"  : 202,
  "pink"    : 198,
  "brown"   : 314,
  "lightred": 91,
  "peach"   : 210
};

let termColorMap = {};
for (let k in colormap) {
  termColorMap[k] = colormap[k];
  termColorMap[colormap[k]] = k;
}

function termColor(s, c, d = 0) {
  if (typeof s === "symbol") {
    s = s.toString();
  } else {
    s = "" + s;
  }

  if (c in colormap)
    c = colormap[c];

  if (c > 107) {
    let s2 = '\u001b[38;5;' + c + "m";
    return s2 + s + '\u001b[39m'
  }

  return '\u001b[' + c + 'm' + s + '\u001b[39m';
};

function termPrint() {
  //let console = window.console;

  let s = '';
  for (let i = 0; i < arguments.length; i++) {
    if (i > 0) {
      s += ' ';
    }
    s += arguments[i];
  }

  let re1a = /\u001b\[[1-9][0-9]?m/;
  let re1b = /\u001b\[[1-9][0-9];[0-9][0-9]?;[0-9]+m/;
  let re2 = /\u001b\[39m/;

  let endtag = '\u001b[39m';

  function tok(s, type) {
    return {
      type : type,
      value: s
    }
  }

  let tokdef = [
    [re1a, "start"],
    [re1b, "start"],
    [re2, "end"]
  ];

  let s2 = s;

  let i = 0;
  let tokens = [];

  while (s2.length > 0) {
    let ok = false;

    let mintk = undefined, mini = undefined;
    let minslice = undefined, mintype = undefined;

    for (let tk of tokdef) {
      let i = s2.search(tk[0]);

      if (i >= 0 && (mini === undefined || i < mini)) {
        minslice = s2.slice(i, s2.length).match(tk[0])[0];
        mini = i;
        mintype = tk[1];
        mintk = tk;
        ok = true;
      }
    }

    if (!ok) {
      break;
    }

    if (mini > 0) {
      let chunk = s2.slice(0, mini);
      tokens.push(tok(chunk, "chunk"));
    }

    s2 = s2.slice(mini + minslice.length, s2.length);
    let t = tok(minslice, mintype);

    tokens.push(t);
  }

  if (s2.length > 0) {
    tokens.push(tok(s2, "chunk"));
  }

  let stack = [];
  let cur;

  let out = '';

  for (let t of tokens) {
    if (t.type === "chunk") {
      out += t.value;
    } else if (t.type === "start") {
      stack.push(cur);
      cur = t.value;

      out += t.value;
    } else if (t.type === "end") {
      cur = stack.pop();
      if (cur) {
        out += cur;
      } else {
        out += endtag;
      }
    }
  }

  return out;
}

globalThis.termColor = termColor;

class MovingAvg extends Array {
  constructor(size = 64) {
    super();

    this.length = size;
    this.cur = 0;
    this.used = 0;
    this.sum = 0;
  }

  reset() {
    this.cur = this.used = this.sum = 0.0;

    return this;
  }

  add(val) {
    if (this.used < this.length) {
      this[this.cur] = val;
      this.used++;
    } else {
      this.sum -= this[this.cur];
      this[this.cur] = val;
    }

    this.sum += val;
    this.cur = (this.cur + 1)%this.length;

    return this.sample();
  }

  sample() {
    return this.used ? this.sum/this.used : 0.0;
  }
}

let timers = {};

function pollTimer(id, interval) {
  if (!(id in timers)) {
    timers[id] = time_ms();
  }

  if (time_ms() - timers[id] >= interval) {
    timers[id] = time_ms();
    return true;
  }

  return false;
}

let mdetect = undefined;
let mret = undefined;

function isMobile() {
  if (!window.MobileDetect) {
    return;
  }

  if (mret === undefined) {
    mdetect = new MobileDetect(navigator.userAgent);
    let ret = mdetect.mobile();

    if (typeof ret === "string") {
      ret = ret.toLowerCase();
    }

    mret = ret;
  }

  return mret;
}

//window._isMobile = isMobile;

//let SmartConsoleTag = Symbol("SmartConsoleTag");
//let tagid = 0;

class SmartConsoleContext {
  constructor(name, console) {
    this.name = name;

    let c = [random(), random(), random()];
    let sum = Math.sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]);
    sum = 255/sum;

    let r = ~~(c[0]*sum);
    let g = ~~(c[1]*sum);
    let b = ~~(c[2]*sum);

    this.color = `rgb(${r},${g},${b})`;
    this.__console = console;

    //minimum time between prints of same message
    this.timeInterval = 375;

    //minimum time in general
    this.timeIntervalAll = 245;

    this._last = 0;
    this.last = 0;
    this.last2 = 0;
    this._data = {};
    this._data_length = 0;
    this.maxCache = 256;
  }


  hash(args) {
    let sum = 0;
    let mul = (1<<19) - 1, off = (1<<27) - 1;
    let i = 0;

    function dohash(h) {
      h = (h*mul + off + i*mul*0.25) & mul;

      i++;
      sum = sum ^ h;
    }

    let visit = new WeakSet();

    let recurse = (n) => {
      if (typeof n === "string") {
        dohash(strhash(n));
      } else if (typeof n === "undefined" || n === null) {
        dohash(0);
      } else if (typeof n === "object") {
        if (n === undefined) {
          //n[SmartConsoleTag] = tagid++;
        }

        if (visit.has(n)) {
          return;
        }

        visit.add(n); //[SmartConsoleTag]);

        let keys = getAllKeys(n);

        for (let k of keys) {
          let v;

          if (typeof k !== "string") {
            continue;
          }

          try {
            v = n[k];
          } catch (error) {
            continue;
          }

          recurse(v);
        }
      } else if (typeof n === "function") {
        dohash(strhash("" + n.name));
      }
    };

    //let str = "";

    for (let i = 0; i < args.length; i++) {
      recurse(args[i]);
      //str += args[i] + " ";
    }

    //window.console.log("HASH", sum, str);
    return sum;
  }

  clearCache() {
    this._data_length = 0;
    this._data = {};
    return this;
  }

  _getData(args) {
    let key = this.hash(args);

    if (!(key in this._data)) {
      if (this._data_length > this.maxCache) {
        this.clearCache();
      }

      this._data[key] = {
        time : 0,
        count: 0
      };

      this._data_length++;
    }

    return this._data[key];
  }

  _check(args) {
    if (this.timeIntervalAll > 0 && time_ms() - this.last2 < this.timeIntervalAll) {
      return false;
    }

    this.last2 = time_ms();

    return true;
    /*
    this.last2 = time_ms();

    let d = this._getData(args);
    let last = this.last;

    this.last = d;

    if (d !== last) {
      d.count = 0;
      d.time = time_ms();
      return true;
    }

    if (time_ms() - d.time > this.timeInterval) {
      d.time = time_ms();
      return true;
    }

    return false;*/
  }

  log() {
    if (this._check(arguments)) {
      window.console.log("%c", "color:" + this.color, ...arguments);
    }
  }

  warn() {
    if (this._check(arguments)) {
      window.console.log("%c" + this.name, "color : " + this.color, ...arguments);
    }
  }

  trace() {
    if (this._check(arguments)) {
      window.console.trace(...arguments);
    }
  }

  error() {
    if (this._check(arguments)) {
      window.console.error(...arguments);
    }
  }
}

class SmartConsole {
  constructor() {
    this.contexts = {};
  }

  context(name) {
    if (!(name in this.contexts)) {
      this.contexts[name] = new SmartConsoleContext(name, this);
    }

    return this.contexts[name];
  }

  log() {
    let c = this.context("default");
    return c.log(...arguments);
  }

  warn() {
    let c = this.context("default");
    return c.warn(...arguments);
  }

  trace() {
    let c = this.context("default");
    return c.trace(...arguments);
  }

  error() {
    let c = this.context("default");
    return c.error(...arguments);
  }
}

const console$1 = new SmartConsole();

globalThis.tm = 0.0;

var EmptySlot = {};

function getClassParent(cls) {
  let p = cls.prototype;

  if (p) p = p.__proto__;
  if (p) p = p.constructor
  ;
  return p;
}

//make global for debugging purposes in console
//window._getClassParent = getClassParent;

function list(iterable) {
  let ret = [];

  for (let item of iterable) {
    ret.push(item);
  }

  return ret;
}


/** Count items in list; if searchItem is not undefined then a count
 *  of the number of times searchItem occurs will be returned.*/
function count(iterable, searchItem=undefined) {
  let count = 0;

  if (searchItem !== undefined) {
    for (let item of iterable) {
      if (item === searchItem) {
        count++;
      }
    }
  } else {
    for (let item of iterable) {
      count++;
    }
  }

  return count;
}

/*
* returns all object keys, including
* inherited ones
* */
function getAllKeys(obj) {
  let keys = new Set();

  if (typeof obj !== "object" && typeof obj !== "function") {
    throw new Error("must pass an object ot getAllKeys; object was: " + obj);
  }

  let p;

  while (p && p !== Object) {
    for (let k in Object.getOwnPropertyDescriptors(obj)) {
      if (k === "__proto__")
        continue;

      keys.add(k);
    }

    for (let k of Object.getOwnPropertySymbols(obj)) {
      keys.add(k);
    }

    p = p.__proto__;
  }

  let cls = obj.constructor;
  if (!cls)
    return keys;

  while (cls) {
    let proto = cls.prototype;
    if (!proto) {
      cls = getClassParent(cls);
      continue;
    }

    for (let k in proto) {
      keys.add(k);
    }

    for (let k in Object.getOwnPropertyDescriptors(proto)) {
      keys.add(k);
    }

    cls = getClassParent(cls);
  }

  return keys;
}

//globalThis._getAllKeys = getAllKeys;

function btoa$1(buf) {
  if (buf instanceof ArrayBuffer) {
    buf = new Uint8Array(buf);
  }

  if (typeof buf == "string" || buf instanceof String) {
    return window.btoa(buf);
  }

  var ret = "";
  for (var i = 0; i < buf.length; i++) {
    ret += String.fromCharCode(buf[i]);
  }

  return btoa$1(ret);
};

function formatNumberUI(val, isInt = false, decimals = 5) {
  if (val === undefined || val === null) {
    val = "0";
  } else if (isNaN(val)) {
    val = "NaN";
  } else if (val === -Infinity) {
    val = "-" + String.fromCharCode(0x221E);
  } else if (val === Infinity) {
    val = "+" + String.fromCharCode(0x221E);
  } else if (!isInt) {
    val = val.toFixed(decimals);
  } else {
    val = "" + Math.floor(val);
  }

  return val;
}

//window.formatNumberUI = formatNumberUI;

function atob$1(buf) {
  let data = window.atob(buf);
  let ret = [];

  for (let i = 0; i < data.length; i++) {
    ret.push(data.charCodeAt(i));
  }

  return new Uint8Array(ret);
}

function time_ms() {
  if (window.performance)
    return window.performance.now();
  else
    return new Date().getMilliseconds();
}

function color2css$1(c) {
  var ret = c.length == 3 ? "rgb(" : "rgba(";

  for (var i = 0; i < 3; i++) {
    if (i > 0)
      ret += ",";

    ret += ~~(c[i]*255);
  }

  if (c.length == 4)
    ret += "," + c[3];
  ret += ")";

  return ret;
}

function merge(obja, objb) {
  return Object.assign({}, obja, objb);
  /*
  var ret = {};

  for (var k in obja) {
    ret[k] = obja[k];
  }

  for (var k in objb) {
    ret[k] = objb[k];
  }

  return ret;
  //*/
};

const debug_cacherings = false;

if (debug_cacherings) {
  window._cacherings = [];

  window._clear_all_cacherings = function (kill_all = false) {
    function copy(obj) {
      if (typeof obj.copy === "function") {
        return obj.copy();
      } else if (obj.constructor === Object) {
        let ret = {};

        for (let k of Reflect.ownKeys(obj)) {
          let v;

          try {
            v = obj[k];
          } catch (error) {
            continue;
          }

          if (typeof v !== "object") {
            ret[k] = v;
          } else {
            ret[k] = copy(v);
          }
        }

        return ret;
      } else {
        return new obj.constructor();
      }
    }

    for (let ch of window._cacherings) {
      let obj = ch[0];
      let len = ch.length;

      ch.length = 0;
      ch.cur = 0;

      if (kill_all) {
        continue;
      }

      for (let i = 0; i < len; i++) {
        ch.push(copy(obj));
      }
    }
  };

  window._nonvector_cacherings = function () {
    for (let ch of window._cacherings) {
      if (ch.length === 0) {
        continue;
      }

      let name = ch[0].constructor.name;
      let ok = !name.startsWith("Vector") && !name.startsWith("Quat");
      ok = ok && !name.startsWith("TriEditor");
      ok = ok && !name.startsWith("QuadEditor");
      ok = ok && !name.startsWith("PointEditor");
      ok = ok && !name.startsWith("LineEditor");

      if (ok) {
        console$1.log(name, ch);
      }
    }
  };

  window._stale_cacherings = function () {
    let ret = _cacherings.concat([]);

    ret.sort((a, b) => a.gen - b.gen);
    return ret;
  };
}

class cachering$1 extends Array {
  constructor(func, size, isprivate = false) {
    super();

    this.private = isprivate;
    this.cur = 0;

    if (!isprivate && debug_cacherings) {
      this.gen = 0;
      window._cacherings.push(this);
    }

    for (var i = 0; i < size; i++) {
      this.push(func());
    }
  }

  static fromConstructor(cls, size, isprivate = false) {
    var func = function () {
      return new cls();
    };

    return new cachering$1(func, size, isprivate);
  }

  next() {
    if (debug_cacherings) {
      this.gen++;
    }

    let ret = this[this.cur];
    this.cur = (this.cur + 1)%this.length;

    return ret;
  }
}

class SetIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.ret = {done: false, value: undefined};
  }

  [Symbol.iterator]() {
    return this;
  }

  next() {
    var ret = this.ret;

    while (this.i < this.set.items.length && this.set.items[this.i] === EmptySlot) {
      this.i++;
    }

    if (this.i >= this.set.items.length) {
      ret.done = true;
      ret.value = undefined;

      return ret;
    }


    ret.value = this.set.items[this.i++];
    return ret;
  }
}

/**
 Set

 Stores objects in a set; each object is converted to a value via
 a [Symbol.keystr] method, and if that value already exists in the set
 then the object is not added.


 * */
class set$1 {
  constructor(input) {
    this.items = [];
    this.keys = {};
    this.freelist = [];

    this.length = 0;

    if (typeof input == "string") {
      input = new String(input);
    }

    if (input !== undefined) {
      if (Symbol.iterator in input) {
        for (var item of input) {
          this.add(item);
        }
      } else if ("forEach" in input) {
        input.forEach(function (item) {
          this.add(item);
        }, this);
      } else if (input instanceof Array) {
        for (var i = 0; i < input.length; i++) {
          this.add(input[i]);
        }
      }
    }
  }

  get size() {
    return this.length;
  }

  [Symbol.iterator]() {
    return new SetIter(this);
  }

  equals(setb) {
    for (let item of this) {
      if (!setb.has(item)) {
        return false;
      }
    }

    for (let item of setb) {
      if (!this.has(item)) {
        return false;
      }
    }

    return true;
  }

  clear() {
    this.items.length = 0;
    this.keys = {};
    this.freelist.length = 0;
    this.length = 0;

    return this;
  }

  filter(f, thisvar) {
    let i = 0;
    let ret = new set$1();

    for (let item of this) {
      if (f.call(thisvar, item, i++, this)) {
        ret.add(item);
      }
    }

    return ret;

  }

  map(f, thisvar) {
    let ret = new set$1();

    let i = 0;

    for (let item of this) {
      ret.add(f.call(thisvar, item, i++, this));
    }

    return ret;
  }

  reduce(f, initial) {
    if (initial === undefined) {
      for (let item of this) {
        initial = item;
        break;
      }
    }

    let i = 0;
    for (let item of this) {
      initial = f(initial, item, i++, this);
    }

    return initial;
  }

  copy() {
    let ret = new set$1();
    for (let item of this) {
      ret.add(item);
    }

    return ret;
  }

  add(item) {
    var key = item[Symbol.keystr]();

    if (key in this.keys) return;

    if (this.freelist.length > 0) {
      var i = this.freelist.pop();

      this.keys[key] = i;
      this.items[i] = item;
    } else {
      var i = this.items.length;

      this.keys[key] = i;
      this.items.push(item);
    }

    this.length++;
  }

  delete(item, ignore_existence = true) {
    this.remove(item, ignore_existence);
  }

  remove(item, ignore_existence) {
    var key = item[Symbol.keystr]();

    if (!(key in this.keys)) {
      if (!ignore_existence) {
        console$1.warn("Warning, item", item, "is not in set");
      }
      return;
    }

    var i = this.keys[key];
    this.freelist.push(i);
    this.items[i] = EmptySlot;

    delete this.keys[key];

    this.length--;
  }

  has(item) {
    return item[Symbol.keystr]() in this.keys;
  }

  forEach(func, thisvar) {
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];

      if (item === EmptySlot)
        continue;

      thisvar !== undefined ? func.call(thisvar, item) : func(item);
    }
  }
}

class HashIter {
  constructor(hash) {
    this.hash = hash;
    this.i = 0;
    this.ret = {done: false, value: undefined};
  }

  next() {
    var items = this.hash._items;

    if (this.i >= items.length) {
      this.ret.done = true;
      this.ret.value = undefined;

      return this.ret;
    }

    do {
      this.i += 2;
    } while (this.i < items.length && items[i] === _hash_null);

    return this.ret;
  }
}

var _hash_null = {};

class hashtable {
  constructor() {
    this._items = [];
    this._keys = {};
    this.length = 0;
  }

  [Symbol.iterator]() {
    return new HashIter(this);
  }

  set(key, val) {
    var key2 = key[Symbol.keystr]();

    var i;
    if (!(key2 in this._keys)) {
      i = this._items.length;

      try {
        this._items.push(0);
        this._items.push(0);
      } catch (error) {
        console$1.log(":::", this._items.length, key, key2, val);
        throw error;
      }

      this._keys[key2] = i;
      this.length++;
    } else {
      i = this._keys[key2];
    }

    this._items[i] = key;
    this._items[i + 1] = val;
  }

  remove(key) {
    var key2 = key[Symbol.keystr]();

    if (!(key2 in this._keys)) {
      console$1.warn("Warning, key not in hashtable:", key, key2);
      return;
    }

    var i = this._keys[key2];

    this._items[i] = _hash_null;
    this._items[i + 1] = _hash_null;

    delete this._keys[key2];
    this.length--;
  }

  has(key) {
    var key2 = key[Symbol.keystr]();

    return key2 in this._keys;
  }

  get(key) {
    var key2 = key[Symbol.keystr]();

    if (!(key2 in this._keys)) {
      console$1.warn("Warning, item not in hash", key, key2);
      return undefined;
    }

    return this._items[this._keys[key2] + 1];
  }

  add(key, val) {
    return this.set(key, val);
  }

  keys() {
    var ret = [];

    for (var i = 0; i < this._items.length; i += 2) {
      var key = this._items[i];

      if (key !== _hash_null) {
        ret.push(key);
      }
    }

    return ret;
  }

  values() {
    var ret = [];

    for (var i = 0; i < this._items.length; i += 2) {
      var item = this._items[i + 1];

      if (item !== _hash_null) {
        ret.push(item);
      }
    }

    return ret;
  }

  forEach(cb, thisvar) {
    if (thisvar == undefined)
      thisvar = self;

    for (var k in this._keys) {
      var i = this._keys[k];

      cb.call(thisvar, k, this._items[i]);
    }
  }
}

let IDGenInternalIDGen = 0;

class IDGen {
  constructor() {
    this.__cur = 1;

    this._debug = false;
    this._internalID = IDGenInternalIDGen++;
  }

  /*
  get _cur() {
    return this.__cur;
  }

  set _cur(v) {
    if (this._debug && pollTimer("_idgen_debug", 450)) {
      window.console.warn("_cur access", v);
    }

    this.__cur = v;
  }

  // */

  get cur() {
    return this.__cur;
  }

  set cur(v) {
    if (isNaN(v) || !isFinite(v)) {
      throw new Error("NaN error in util.IDGen");
    }

    this.__cur = v;
  }

  get _cur() {
    return this.cur;
  }

  set _cur(v) {
    window.console.warn("Deprecated use of IDGen._cur");
    this.cur = v;
  }

  static fromJSON(obj) {
    let ret = new IDGen();

    ret.cur = obj.cur === undefined ? obj._cur : obj.cur;

    return ret;
  }

  next() {
    return this.cur++;
  }

  copy() {
    let ret = new IDGen();
    ret.cur = this.cur;

    return ret;
  }

  max_cur(id) {
    this.cur = Math.max(this.cur, id + 1);
  }

  toJSON() {
    return {
      cur: this.cur
    };
  }

  loadSTRUCT(reader) {
    reader(this);
  }
}

IDGen.STRUCT = `
IDGen {
  cur : int;
}
`;
nstructjs.register(IDGen);


function get_callstack(err) {
  return (""+err.stack).split("\n");
}

function print_stack$1(err) {
  if (!err) {
    window.console.trace();
  } else {
    window.console.log(err.stack);
  }
}


globalThis.get_callstack = get_callstack;
globalThis.print_stack = print_stack$1;

function fetch_file(path) {
  var url = location.origin + "/" + path;

  var req = new XMLHttpRequest(
  );

  return new Promise(function (accept, reject) {
    req.open("GET", url);
    req.onreadystatechange = function (e) {
      if (req.status == 200 && req.readyState == 4) {
        accept(req.response);
      } else if (req.status >= 400) {
        reject(req.status, req.statusText);
      }
    };
    req.send();
  });
}

//from:https://en.wikipedia.org/wiki/Mersenne_Twister
function _int32(x) {
  // Get the 31 least significant bits.
  return ~~(((1<<30) - 1) & (~~x))
}

class MersenneRandom {
  constructor(seed) {
    // Initialize the index to 0
    this.index = 624;
    this.mt = new Uint32Array(624);

    this.seed(seed);
  }

  random() {
    return this.extract_number()/(1<<30);
  }

  /** normal-ish distribution */
  nrandom(n=3) {
    let ret = 0.0;

    for (let i=0; i<n; i++) {
      ret += this.random();
    }

    return ret / n;
  }

  seed(seed) {
    seed = ~~(seed*8192);

    // Initialize the index to 0
    this.index = 624;
    this.mt.fill(0, 0, this.mt.length);

    this.mt[0] = seed;  // Initialize the initial state to the seed

    for (var i = 1; i < 624; i++) {
      this.mt[i] = _int32(
        1812433253*(this.mt[i - 1] ^ this.mt[i - 1]>>30) + i);
    }
  }

  extract_number() {
    if (this.index >= 624)
      this.twist();

    var y = this.mt[this.index];

    // Right shift by 11 bits
    y = y ^ y>>11;
    // Shift y left by 7 and take the bitwise and of 2636928640
    y = y ^ y<<7 & 2636928640;
    // Shift y left by 15 and take the bitwise and of y and 4022730752
    y = y ^ y<<15 & 4022730752;
    // Right shift by 18 bits
    y = y ^ y>>18;

    this.index = this.index + 1;

    return _int32(y);
  }

  twist() {
    for (var i = 0; i < 624; i++) {
      // Get the most significant bit and add it to the less significant
      // bits of the next number
      var y = _int32((this.mt[i] & 0x80000000) +
        (this.mt[(i + 1)%624] & 0x7fffffff));
      this.mt[i] = this.mt[(i + 397)%624] ^ y>>1;

      if (y%2 != 0)
        this.mt[i] = this.mt[i] ^ 0x9908b0df;
    }

    this.index = 0;
  }
}

var _mt = new MersenneRandom(0);

function random() {
  return _mt.extract_number()/(1<<30);
}

function seed(n) {
//  console.trace("seed called");
  _mt.seed(n);
}

let smallstr_hashes = {};

function strhash(str) {
  if (str.length <= 64) {
    let hash = smallstr_hashes[str];

    if (hash !== undefined) {
      return hash;
    }
  }

  var hash = 0;

  for (var i = 0; i < str.length; i++) {
    var ch = str.charCodeAt(i);

    hash = hash < 0 ? -hash : hash;

    hash ^= (ch*524287 + 4323543) & ((1<<19) - 1);
  }

  if (str.length <= 64) {
    smallstr_hashes[str] = hash;
  }

  return hash;
}

var hashsizes = [
  /*2, 5, 11, 19, 37, 67, 127, */223, 383, 653, 1117, 1901, 3251,
                                 5527, 9397, 15991, 27191, 46229, 78593, 133631, 227177, 38619,
                                 656587, 1116209, 1897561, 3225883, 5484019, 9322861, 15848867,
                                 26943089, 45803279, 77865577, 132371489, 225031553
];

var FTAKEN = 0, FKEY = 1, FVAL = 2, FTOT = 3;

class FastHash extends Array {
  constructor() {
    super();

    this.cursize = 0;
    this.size = hashsizes[this.cursize];
    this.used = 0;

    this.length = this.size*FTOT;
    this.fill(0, 0, this.length);
  }

  resize(size) {
    var table = this.slice(0, this.length);

    this.length = size*FTOT;
    this.size = size;
    this.fill(0, 0, this.length);

    for (var i = 0; i < table.length; i += FTOT) {
      if (!table[i + FTAKEN]) continue;

      var key = table[i + FKEY], val = table[i + FVAL];
      this.set(key, val);
    }

    return this;
  }

  get(key) {
    var hash = typeof key == "string" ? strhash(key) : key;
    hash = typeof hash == "object" ? hash.valueOf() : hash;

    var probe = 0;

    var h = (hash + probe)%this.size;

    var _i = 0;
    while (_i++ < 50000 && this[h*FTOT + FTAKEN]) {
      if (this[h*FTOT + FKEY] == key) {
        return this[h*FTOT + FVAL];
      }

      probe = (probe + 1)*2;
      h = (hash + probe)%this.size;
    }

    return undefined;
  }

  has(key) {
    var hash = typeof key == "string" ? strhash(key) : key;
    hash = typeof hash == "object" ? hash.valueOf() : hash;

    var probe = 0;

    var h = (hash + probe)%this.size;

    var _i = 0;
    while (_i++ < 50000 && this[h*FTOT + FTAKEN]) {
      if (this[h*FTOT + FKEY] == key) {
        return true;
      }

      probe = (probe + 1)*2;
      h = (hash + probe)%this.size;
    }

    return false;
  }

  set(key, val) {
    var hash = typeof key == "string" ? strhash(key) : key;
    hash = typeof hash == "object" ? hash.valueOf() : hash;

    if (this.used > this.size/3) {
      this.resize(hashsizes[this.cursize++]);
    }

    var probe = 0;

    var h = (hash + probe)%this.size;

    var _i = 0;
    while (_i++ < 50000 && this[h*FTOT + FTAKEN]) {
      if (this[h*FTOT + FKEY] == key) {
        this[h*FTOT + FVAL] = val;
        return;
      }

      probe = (probe + 1)*2;
      h = (hash + probe)%this.size;
    }

    this[h*FTOT + FTAKEN] = 1;
    this[h*FTOT + FKEY] = key;
    this[h*FTOT + FVAL] = val;

    this.used++;
  }
}

function test_fasthash() {
  var h = new FastHash();
  console$1.log("bleh hash:", strhash("bleh"));

  h.set("bleh", 1);
  h.set("bleh", 2);
  h.set("bleh", 3);

  console$1.log(h);

  return h;
};

class ImageReader {
  load_image() {
    let input = document.createElement("input");
    input.type = "file";

    let doaccept;

    let promise = new Promise((accept, reject) => {
      doaccept = accept;
    });

    input.addEventListener("change", function (e) {
      let files = this.files;
      console$1.log("got file", e, files);

      if (files.length == 0) return;

      var reader = new FileReader();
      var this2 = this;

      reader.onload = (e) => {
        let data = e.target.result;
        let image = new Image();

        image.src = data;
        image.onload = (e) => {
          console$1.log("got image", image.width, image.height);

          let canvas = document.createElement("canvas");
          let g = canvas.getContext("2d");

          canvas.width = image.width;
          canvas.height = image.height;

          g.drawImage(image, 0, 0);
          let idata = g.getImageData(0, 0, image.width, image.height);

          doaccept(idata);
        };
      };

      reader.readAsDataURL(files[0]);
    });

    input.click();
    return promise;
  }

  example() {
    this.load_image().then((idata) => {
      console$1.log(idata);
    });
  }
};

let digestcache;

/** NOT CRYPTOGRAPHIC */
class HashDigest {
  constructor() {
    this.i = 0;
    this.hash = 0;
  }

  static cachedDigest() {
    return digestcache.next().reset();
  }

  reset() {
    this.i = 0;
    this.hash = 0;

    return this;
  }

  get() {
    return this.hash;
  }

  add(v) {
    if (typeof v === "string") {
      v = strhash(v);
    }

    if (v >= -5 && v <= 5) {
      v *= 32;
    }

    //try to deal with subdecimal floating point error

    let f = Math.fract(v)*(1024*512);
    f = (~~f)/(1024*512);
    v = Math.floor(v) + f;

    //glibc linear congruel generator
    this.i = ((this.i + (~~v))*1103515245 + 12345) & ((1<<29) - 1);
    //according to wikipedia only the top 16 bits are random
    //this.i = this.i>>16;

    let v2 = (v*1024*1024) & ((1<<29) - 1);
    v = v | v2;

    v = ~~v;

    this.hash ^= v ^ this.i;

    return this;
  }
}

window._test_hash2 = () => {
  let h = new HashDigest();

  let tests = [
    [0, 0, 0, 0],
    [0, 0, 0],
    [0, 0],
    [0],
    [1],
    [2],
    [3],
    [strhash("yay")],
    [strhash("yay"), strhash("yay")],
    [strhash("yay"), strhash("yay"), strhash("yay")]
  ];

  for (let test of tests) {
    let h = new HashDigest();
    for (let f of test) {
      h.add(f);
    }

    window.console.log(h.get());
  }
  for (let i = 0; i < 50; i++) {
    h.add(0);
    //window.console.log(h.i/((1<<30)-1), h.hash);
  }
};

digestcache = cachering$1.fromConstructor(HashDigest, 512);

//globalThis._HashDigest = HashDigest;

function hashjoin(hash, val) {
  let sum = 0;
  let mul = (1<<19) - 1, off = (1<<27) - 1;
  let i = 0;

  h = (h*mul + off + i*mul*0.25) & mul;
}

let NullItem = {};

class MapIter {
  constructor(ownermap) {
    this.ret = {done: true, value: undefined};
    this.value = new Array(2);
    this.i = 0;
    this.map = ownermap;
    this.done = true;
  }

  finish() {
    if (!this.done) {
      this.done = true;
      this.map.itercur--;
    }
  }

  next() {
    let ret = this.ret;
    let i = this.i;
    let map = this.map, list = map._list;
    //window.console.log(this)

    while (i < list.length && list[i] === NullItem) {
      i += 2;
    }

    //window.console.log("  --", i, list[i], list[i+1]);

    if (i >= list.length) {
      ret.done = true;
      ret.value = undefined;

      this.finish();
      return ret;
    }

    this.i = i + 2;

    ret.value = this.value;
    ret.value[0] = list[i];
    ret.value[1] = list[i + 1];
    ret.done = false;

    return ret;
  }

  return() {
    this.finish();

    return this.ret;
  }

  reset() {
    this.i = 0;
    this.value[0] = undefined;
    this.value[1] = undefined;
    this.done = false;

    return this;
  }
}

class map {
  constructor() {
    this._items = {};
    this._list = [];

    this.size = 0;

    this.iterstack = new Array(8);
    this.itercur = 0;
    for (let i = 0; i < this.iterstack.length; i++) {
      this.iterstack[i] = new MapIter(this);
    }

    this.freelist = [];
  }

  has(key) {
    return key[Symbol.keystr]() in this._items;
  }

  set(key, v) {
    let k = key[Symbol.keystr]();

    let i = this._items[k];

    if (i === undefined) {
      if (this.freelist.length > 0) {
        i = this.freelist.pop();
      } else {
        i = this._list.length;
        this._list.length += 2;
      }

      this.size++;
    }

    this._list[i] = key;
    this._list[i + 1] = v;

    this._items[k] = i;
  }

  keys() {
    let this2 = this;
    return (function* () {
      for (let [key, val] of this2) {
        yield key;
      }
    })()
  }

  values() {
    let this2 = this;
    return (function* () {
      for (let [key, val] of this2) {
        yield val;
      }
    })()
  }

  get(k) {
    k = k[Symbol.keystr]();

    let i = this._items[k];
    if (i !== undefined) {
      return this._list[i + 1];
    }
  }

  delete(k) {
    k = k[Symbol.keystr]();

    if (!(k in this._items)) {
      return false;
    }

    let i = this._items[k];

    this.freelist.push(i);

    this._list[i] = NullItem;
    this._list[i + 1] = NullItem;

    delete this._items[k];
    this.size--;

    return true;
  }

  [Symbol.iterator]() {
    let ret = this.iterstack[this.itercur].reset();
    this.itercur++;

    if (this.itercur === this.iterstack.length) {
      this.iterstack.push(new MapIter(this));
    }

    return ret;
  }

}

globalThis._test_map = function () {
  let m = new map();

  m.set("1", 2);
  m.set(11, 3);
  m.set("5", 4);
  m.set("3", 5);
  m.set("3", 6);
  m.delete("3");

  for (let [key, item] of m) {
    for (let [key2, item2] of m) {
      window.console.log(key, item, key2, item2);
    }
    break;
  }

  console$1.log("itercur", m.itercur);

  return m;
};

function validateId(id) {
  let bad = typeof id !== "number";
  bad = bad || id !== ~~id;
  bad = bad || isNaN(id);

  if (bad) {
    throw new Error("bad number " + id);
  }

  return bad;
}

let UndefinedTag = {};

class IDMap extends Array {
  constructor() {
    super();

    this._keys = new Set();
    this.size = 0;
  }

  has(id) {
    validateId(id);

    if (id < 0 || id >= this.length) {
      return false;
    }

    return this[id] !== undefined;
  }

  set(id, val) {
    validateId(id);

    if (id < 0) {
      console$1.warn("got -1 id in IDMap");
      return;
    }

    if (id >= this.length) {
      this.length = id + 1;
    }

    if (val === undefined) {
      val = UndefinedTag;
    }

    let ret = false;

    if (this[id] === undefined) {
      this.size++;
      this._keys.add(id);
      ret = true;
    }

    this[id] = val;
    return ret;
  }

  /* we allow -1, which always returns undefined*/
  get(id) {
    validateId(id);

    if (id === -1) {
      return undefined;
    } else if (id < 0) {
      console$1.warn("id was negative");
      return undefined;
    }

    let ret = id < this.length ? this[id] : undefined;
    ret = ret === UndefinedTag ? undefined : ret;

    return ret;
  }

  delete(id) {
    if (!this.has(id)) {
      return false;
    }

    this._keys.remove(id);
    this[id] = undefined;
    this.size--;

    return true;
  }

  keys() {
    let this2 = this;
    return (function* () {
      for (let id of this2._keys) {
        yield id;
      }
    })();
  }

  values() {
    let this2 = this;
    return (function* () {
      for (let id of this2._keys) {
        yield this2[id];
      }
    })();
  }

  [Symbol.iterator]() {
    let this2 = this;
    let iteritem = [0, 0];

    return (function* () {
      for (let id of this2._keys) {
        iteritem[0] = id;
        iteritem[1] = this2[id];

        if (iteritem[1] === UndefinedTag) {
          iteritem[1] = undefined;
        }

        yield iteritem;
      }
    })();
  }
}

globalThis._test_idmap = function () {
  let map = new IDMap();

  for (let i = 0; i < 5; i++) {
    let id = ~~(Math.random()*55);

    map.set(id, "yay" + i);
  }

  for (let [key, val] of map) {
    window.console.log(key, val, map.has(key), map.get(key));
  }

  return map;
};

let HW = 0, HELEM = 1, HTOT = 2;

function heaplog() {
  //window.console.log(...arguments);
}

class MinHeapQueue {
  constructor(iter, iterw = iter) {
    this.heap = [];
    this.freelist = [];
    this.length = 0;
    this.end = 0;

    if (iter) {
      let witer = iterw[Symbol.iterator]();

      for (let item of iter) {
        let w = witer.next().value;
        this.push(item, w);
      }
    }
  }

  push(e, w) {
    if (typeof w !== "number") {
      throw new Error("w must be a number");
    }

    if (isNaN(w)) {
      throw new Error("NaN");
    }

    this.length++;
    let depth = Math.ceil(Math.log(this.length)/Math.log(2.0));
    let tot = Math.pow(2, depth) + 1;

    heaplog(depth, tot);

    if (this.heap.length < tot*HTOT) {
      let start = this.heap.length/HTOT;

      for (let i = start; i < tot; i++) {
        this.freelist.push(i*HTOT);
      }
    }

    let heap = this.heap;
    heap.length = tot*HTOT;

    let n = this.freelist.pop();

    heaplog("freelist", this.freelist);
    this.end = Math.max(this.end, n);

    heap[n] = w;
    heap[n + 1] = e;

    while (n > 0) {
      n /= HTOT;

      let p = (n - 1)>>1;
      n *= HTOT;
      p *= HTOT;

      if (heap[p] === undefined || heap[p] > w) {
        if (n === this.end) {
          this.end = p;
        }

        heap[n] = heap[p];
        heap[n + 1] = heap[p + 1];

        heap[p] = w;
        heap[p + 1] = e;

        n = p;
      } else {
        break;
      }
    }
  }

  pop() {
    if (this.length === 0) {
      return undefined;
      //throw new Error("heap is empty");
    }

    let heap = this.heap;

    if (this.end === 0) {
      let ret = heap[1];
      this.freelist.push(0);
      heap[0] = undefined;

      this.length = 0;

      return ret;
    }

    let ret = heap[1];

    let end = this.end;

    function swap(n1, n2) {
      let t = heap[n1];
      heap[n1] = heap[n2];
      heap[n2] = t;

      t = heap[n1 + 1];
      heap[n1 + 1] = heap[n2 + 1];
      heap[n2 + 1] = t;
    }

    heaplog("end", end);
    heaplog(heap.concat([]));

    heap[0] = heap[end];
    heap[1] = heap[end + 1];
    heap[end] = undefined;
    heap[end + 1] = undefined;

    let n = 0;
    while (n < heap.length) {
      n /= HTOT;

      let n1 = n*2 + 1;
      let n2 = n*2 + 2;

      n1 = ~~(n1*HTOT);
      n2 = ~~(n2*HTOT);
      n = ~~(n*HTOT);

      heaplog("  ", heap[n], heap[n1], heap[n2]);

      if (heap[n1] !== undefined && heap[n2] !== undefined) {
        if (heap[n1] > heap[n2]) {
          let t = n1;
          n1 = n2;
          n2 = t;
        }

        if (heap[n] > heap[n1]) {
          swap(n, n1);
          n = n1;
        } else if (heap[n] > heap[n2]) {
          swap(n, n2);
          n = n2;
        } else {
          break;
        }
      } else if (heap[n1] !== undefined) {
        if (heap[n] > heap[n1]) {
          swap(n, n1);
          n = n1;
        } else {
          break;
        }
      } else if (heap[n2] !== undefined) {
        if (heap[n] > heap[n2]) {
          swap(n, n2);
          n = n2;
        } else {
          break;
        }
      } else {
        break;
      }
    }

    this.freelist.push(this.end);

    heap[this.end] = undefined;
    heap[this.end + 1] = undefined;

    while (this.end > 0 && heap[this.end] === undefined) {
      this.end -= HTOT;
    }

    this.length--;

    return ret;
  }
}

globalThis.testHeapQueue = function (list1 = [1, 8, -3, 11, 33]) {
  let h = new MinHeapQueue(list1);

  window.console.log(h.heap.concat([]));

  let list = [];
  let len = h.length;

  for (let i = 0; i < len; i++) {
    list.push(h.pop());
  }

  window.console.log(h.heap.concat([]));

  return list;
};

class Queue {
  constructor(n = 32) {
    n = Math.max(n, 8);

    this.initialSize = n;

    this.queue = new Array(n);
    this.a = 0;
    this.b = 0;
    this.length = 0;
  }

  enqueue(item) {
    let qlen = this.queue.length;

    let b = this.b;

    this.queue[b] = item;
    this.b = (this.b + 1)%qlen;

    if (this.length >= qlen || this.a === this.b) {
      let newsize = qlen<<1;
      let queue = new Array(newsize);

      for (let i = 0; i < qlen; i++) {
        let i2 = (i + this.a)%qlen;

        queue[i] = this.queue[i2];
      }

      this.a = 0;
      this.b = qlen;
      this.queue = queue;
    }

    this.length++;
  }

  clear(clearData = true) {
    this.queue.length = this.initialSize;

    if (clearData) {
      for (let i = 0; i < this.queue.length; i++) {
        this.queue[i] = undefined;
      }
    }

    this.a = this.b = 0;
    this.length = 0;

    return this;
  }

  dequeue() {
    if (this.length === 0) {
      return undefined;
    }
    this.length--;

    let ret = this.queue[this.a];

    this.queue[this.a] = undefined;

    this.a = (this.a + 1)%this.queue.length;
    return ret;
  }
}

globalThis._testQueue = function (steps = 15, samples = 15) {
  let queue = new Queue(3);

  for (let i = 0; i < steps; i++) {
    let list = [];

    for (let j = 0; j < samples; j++) {
      let item = {f: Math.random()};
      list.push(item);

      queue.enqueue(item);
    }

    let j = 0;

    while (queue.length > 0) {
      let item = queue.dequeue();

      if (item !== list[j]) {
        console$1.log(item, list);
        throw new Error("got wrong item", item);
      }

      j++;

      if (j > 10000) {
        console$1.error("Infinite loop error");
        break;
      }
    }
  }
};


class ArrayPool {
  constructor() {
    this.pools = new Map();
    this.map = new Array(1024);
  }

  get(n, clear) {
    let pool;

    if (n < 1024) {
      pool = this.map[n];
    } else {
      pool = this.pools.get(n);
    }

    if (!pool) {
      let tot;

      if (n > 512) {
        tot = 32;
      } else if (n > 256) {
        tot = 64;
      } else if (n > 128) {
        tot = 256;
      } else if (n > 64) {
        tot = 512;
      } else {
        tot = 1024;
      }

      pool = new cachering$1(() => new Array(n), tot);
      if (n < 1024) {
        this.map[n] = pool;
      }
      this.pools.set(n, pool);

      return this.get(n, clear);
    }

    let ret = pool.next();
    if (ret.length !== n) {
      console$1.warn("Array length was set", n, ret);
      ret.length = n;
    }

    if (clear) {
      for (let i = 0; i < n; i++) {
        ret[i] = undefined;
      }
    }

    return ret;
  }
}

/** jsFiddle-friendly */
class DivLogger {
  constructor(elemId, maxLines=16) {
    this.elemId = elemId;
    this.elem = undefined;
    this.lines = new Array();
    this.maxLines = maxLines;
  }

  push(line) {
    if (this.lines.length > this.maxLines) {
      this.lines.shift();
      this.lines.push(line);
    } else {
      this.lines.push(line);
    }

    this.update();
  }

  update() {
    let buf = this.lines.join(`<br>`);
    buf = buf.replace(/[ \t]/g, "&nbsp;");

    if (!this.elem) {
      this.elem = document.getElementById(this.elemId);
    }

    this.elem.innerHTML = buf;
  }

  toString(obj, depth=0) {
    let s = '';

    let tab = '';
    for (let i=0; i<depth; i++) {
      tab += '$TAB';
    }

    if (typeof obj === "symbol") {
      return `[${obj.description}]`;
    }

    const DEPTH_LIMIT = 1;
    const CHAR_LIMIT = 100;

    if (typeof obj === "object" && Array.isArray(obj)) {
      s = "[$NL";
      for (let i=0; i<obj.length; i++) {
        let v = obj[i];

        if (depth >= DEPTH_LIMIT) {
          v = typeof v;
        } else {
          v = this.toString(v, depth+1);
        }

        s += tab + "$TAB";
        s += v + (i !== obj.length - 1 ? "," : "") + "$NL";
      }

      let keys = Reflect.ownKeys(obj);
      for (let i=0; i<keys.length; i++) {
        let k = keys[i];
        let n;

        let k2 = this.toString(k);

        if (typeof k !== "symbol" && !isNaN(n = parseInt(k))) {
          if (n >= 0 && n < obj.length) {
            continue;
          }
        }

        let v;
        try {
          v = obj[k];
        } catch (error) {
          v = "(error)";
        }

        s += tab + `$TAB${k2} : ${v}`;

        if (i < keys.length-1) {
          s += ",";
        }

        if (!s.endsWith("$NL") && !s.endsWith("\n")) {
          s += "$NL";
        }
      }
      s += "$TAB]$NL";

      if (s.length < CHAR_LIMIT) {
        s = s.replace(/\$NL/g, "");
        s = s.replace(/(\$TAB)+/g, " ");
      } else {
        s = s.replace(/\$NL/g, "\n");
        s = s.replace(/\$TAB/g, "  ");
      }
    } else if (typeof obj === "object") {
      s = '{$NL';

      let keys = Reflect.ownKeys(obj);
      for (let i=0; i<keys.length; i++) {
        let k = keys[i];
        let k2 = this.toString(k);

        let v;
        try {
          v = obj[k];
        } catch (error) {
          v = '(error)';
        }

        if (depth >= DEPTH_LIMIT) {
          v = typeof v;
        } else {
          v = this.toString(v, depth+1);
        }

        s += tab + `$TAB${k2} : ${v}`;

        if (i < keys.length-1) {
          s += ",";
        }

        if (!s.endsWith("$NL") && !s.endsWith("\n")) {
          s += "$NL";
        }
      }
      s += tab + "}$NL";

      if (s.length < CHAR_LIMIT) {
        s = s.replace(/\$NL/g, "");
        s = s.replace(/(\$TAB)+/g, " ");
      } else {
        s = s.replace(/\$NL/g, "\n");
        s = s.replace(/\$TAB/g, "  ");
      }
    } else if (typeof obj === "undefined") {
      s = 'undefined';
    } else if (typeof obj === "function") {
      s = 'function ' + obj.name;
    } else {
      s = "" + obj;
    }

    return s;
  }
}

var util1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isDenormal: isDenormal,
  termColorMap: termColorMap,
  termColor: termColor,
  termPrint: termPrint,
  MovingAvg: MovingAvg,
  timers: timers,
  pollTimer: pollTimer,
  isMobile: isMobile,
  SmartConsoleContext: SmartConsoleContext,
  SmartConsole: SmartConsole,
  console: console$1,
  getClassParent: getClassParent,
  list: list,
  count: count,
  getAllKeys: getAllKeys,
  btoa: btoa$1,
  formatNumberUI: formatNumberUI,
  atob: atob$1,
  time_ms: time_ms,
  color2css: color2css$1,
  merge: merge,
  cachering: cachering$1,
  SetIter: SetIter,
  set: set$1,
  HashIter: HashIter,
  hashtable: hashtable,
  IDGen: IDGen,
  print_stack: print_stack$1,
  fetch_file: fetch_file,
  MersenneRandom: MersenneRandom,
  random: random,
  seed: seed,
  strhash: strhash,
  FastHash: FastHash,
  test_fasthash: test_fasthash,
  ImageReader: ImageReader,
  HashDigest: HashDigest,
  hashjoin: hashjoin,
  MapIter: MapIter,
  map: map,
  IDMap: IDMap,
  MinHeapQueue: MinHeapQueue,
  Queue: Queue,
  ArrayPool: ArrayPool,
  DivLogger: DivLogger
});

const EulerOrders = {
  XYZ: 0,
  XZY: 1,
  YXZ: 2,
  YZX: 3,
  ZXY: 4,
  ZYX: 5
};

/**
 * @param mode one of 'es', 'commonjs', 'rjs'
 */
window.makeCompiledVectormathCode = function (mode = "es") {
  let s = "";
  let es6exports = mode === "es";

  function doExports(name) {
    if (es6exports) {
      return "export";
    } else {
      return `var ${name} = exports.${name} =`;
    }
  }

  let classes = [Vector2, Vector3, Vector4, a];
  let lens = {
    Vector2: 2,
    Vector3: 3,
    Vector4: 4,
    Quat   : 4
  };

  let modecode = "";

  let nstructjscode = `
  let g = typeof window !== "undefined" ? window : "undefined";
  
  g = g || (typeof global !== "undefined" ? global : "undefined");
  g = g || (typeof self !== "undefined" ? self : "undefined");
  g = g || (typeof globals !== "undefined" ? globals : "undefined");

  if (typeof nstructjs === "undefined") {
    //add nstructjs stub
    g.nstructjs = {
      register : function() {}
    }
  }
  `;

  if (mode !== "rjs") {
    if (mode === "commonjs") {
      modecode = `if (typeof module !== "undefined" && typeof exports === "undefined") {
      if (module.exports === undefined) {
        module.exports = {};
      }
      
      g.exports = module.exports;
    } else if (typeof module === "undefined") {
      g.exports = g.vectormath = {};
    }\n`;
    }

    s += `{
      ${nstructjscode}
    ${modecode}
  }`;
  }

  s += `
class cachering extends Array {
  constructor(func, size) {
    super()

    this.cur = 0;

    for (var i=0; i<size; i++) {
      this.push(func());
    }
  }

  static fromConstructor(cls, size) {
    var func = function() {
      return new cls();
    }

    return new cachering(func, size);
  }

  next() {
    var ret = this[this.cur];
    this.cur = (this.cur+1)%this.length;

    return ret;
  }
}
`;
  s += `

var M_SQRT2 = Math.sqrt(2.0);
var FLT_EPSILON = 2.22e-16;  
var sin=Math.sin, cos=Math.cos, abs=Math.abs, log=Math.log,
    asin=Math.asin, exp=Math.exp, acos=Math.acos, fract=Math.fract,
    sign=Math.sign, tent=Math.tent, atan2=Math.atan2, atan=Math.atan,
    pow=Math.pow, sqrt=Math.sqrt, floor=Math.floor, ceil=Math.ceil,
    min=Math.min, max=Math.max, PI=Math.PI, E=2.718281828459045;

var DOT_NORM_SNAP_LIMIT = 0.00000000001;

${doExports("BaseVector")} class BaseVector extends Array {
  constructor() {
    super();
    
    this.vec = undefined; //for compatibility with old files
  }

  copy() {
    return new this.constructor(this);
  }

  load(data) {
    throw new Error("Implement me!");
  }
  
  vectorLength() {
    return sqrt(this.dot(this));
  }
  
  normalize() {
    var l = this.vectorLength();
    if (l > 0.00000001) {
      this.mulScalar(1.0/l);
    }
    
    return this;
  }
}
  
`;

  function indent(s, pad = "  ") {
    let l = s.split("\n");
    let s2 = "";

    for (let l2 of l) {
      s2 += pad + l2 + "\n";
    }

    return s2;
  }

  let i = 0;
  for (let cls of classes) {
    s += doExports(cls.name) + " class " + cls.name + " extends BaseVector {\n";

    let keys = Reflect.ownKeys(cls.prototype);

    for (let k of keys) {
      let v = cls.prototype[k];

      if (typeof v !== "function") {
        continue;
      }

      if (typeof k === "symbol") {
        k = "  [" + k.toString() + "]";
      }

      v = ("" + v).trim();
      if (v.startsWith("function(") || v.startsWith("function (")) {
        v = k + v.slice(8, v.length).trim();
      } else if (v.startsWith("function")) {
        v = v.slice(8, v.length).trim();
      }

      if (v.endsWith(";}")) {
        v = v.slice(0, v.length - 1) + "\n  }\n";
      }

      let zero = "";
      let l = lens[cls.name];

      for (let j = 0; j < l; j++) {
        if (j > 0) {
          zero += " = ";
        }
        zero += `this[${j}]`;
      }

      zero += " = 0.0";

      if (k === "constructor") {
        s += `  constructor(data) {
    super(${l});
        
    this.vec = undefined; //for compatibility with old files
    
    if (arguments.length > 1) {
      throw new Error("unexpected argument");
    }

    //this.length = ${l};
    ${zero};

    if (data !== undefined) {
      this.load(data);
    }
  }
`;
      } else {
        s += indent(v);
      }

      s += "\n";
      i++;
    }
    s += "}\n\n";

    s += `${cls.name}.STRUCT = \`${cls.STRUCT}\`;\n`;
    s += `nstructjs.register(${cls.name});\n\n`;
  }

  s += "\n\n" + ("" + internal_matrix).trim() + "\n";
  s += "\n" + doExports("Matrix4") + Matrix4;

  s += `\n  Matrix4.STRUCT = \`${Matrix4.STRUCT}\`;\n`;
  s += "nstructjs.register(Matrix4)\n";

  s += `
  var _quat_vs3_temps = cachering.fromConstructor(Vector3, 64);
  var _v3nd4_n1_normalizedDot4 = new Vector3();
  var _v3nd4_n2_normalizedDot4 = new Vector3();
  var _v3nd_n1_normalizedDot = new Vector3();
  var _v3nd_n2_normalizedDot = new Vector3();

  var $_v3nd4_n1_normalizedDot4 = new Vector3();
  var $_v3nd4_n2_normalizedDot4 = new Vector3();
  var $_v3nd_n1_normalizedDot = new Vector3();
  var $_v3nd_n2_normalizedDot = new Vector3();

  var lookat_cache_vs3 = cachering.fromConstructor(Vector3, 64);
  var lookat_cache_vs4 = cachering.fromConstructor(Vector4, 64);

  var makenormalcache = cachering.fromConstructor(Vector3, 64);
`;

  if (mode === "rjs") {
    s = `define([], function() {
  "use strict";

  let exports = {};

  {
    ${nstructjscode}
  }
  ${indent(s)}

  return exports;
});
`;
  }

  return s;
};

var sin                                                          = Math.sin, cos                                          = Math.cos, abs                          = Math.abs, log = Math.log,
    asin                                                         = Math.asin, exp                                        = Math.exp, acos = Math.acos, fract = Math.fract,
    sign = Math.sign, tent = Math.tent, atan2 = Math.atan2, atan = Math.atan,
    pow                                                          = Math.pow, sqrt = Math.sqrt, floor                      = Math.floor, ceil = Math.ceil,
    min                                                          = Math.min, max = Math.max, PI = Math.PI, E = 2.718281828459045;

var DOT_NORM_SNAP_LIMIT = 0.00000000001;
var M_SQRT2 = Math.sqrt(2.0);
var FLT_EPSILON = 2.22e-16;

var basic_funcs = {
  equals   : [["b"], "this[X] === b[X]", "&&"],
  /*dot is made manually so it's safe for acos
  dot     : [["b"], "this[X]*b[X]", "+"],
   */
  zero     : [[], "0.0;"],
  negate   : [[], "-this[X];"],
  combine  : [["b", "u", "v"], "this[X]*u + this[X]*v;"],
  interp   : [["b", "t"], "this[X] + (b[X] - this[X])*t;"],
  add      : [["b"], "this[X] + b[X];"],
  addFac   : [["b", "F"], "this[X] + b[X]*F;"],
  fract    : [[], "Math.fract(this[X]);"],
  sub      : [["b"], "this[X] - b[X];"],
  mul      : [["b"], "this[X] * b[X];"],
  div      : [["b"], "this[X] / b[X];"],
  mulScalar: [["b"], "this[X] * b;"],
  divScalar: [["b"], "this[X] / b;"],
  addScalar: [["b"], "this[X] + b;"],
  subScalar: [["b"], "this[X] - b;"],
  minScalar: [["b"], "Math.min(this[X], b);"],
  maxScalar: [["b"], "Math.max(this[X], b);"],
  ceil     : [[], "Math.ceil(this[X])"],
  floor    : [[], "Math.floor(this[X])"],
  abs      : [[], "Math.abs(this[X])"],
  min      : [["b"], "Math.min(this[X], b[X])"],
  max      : [["b"], "Math.max(this[X], b[X])"],
  clamp    : [["MIN", "MAX"], "min(max(this[X], MAX), MIN)"],
};

function bounded_acos(fac) {
  if (fac <= -1.0)
    return Math.pi;
  else if (fac >= 1.0)
    return 0.0;
  else
    return Math.acos(fac);
}

function make_norm_safe_dot(cls) {
  var _dot = cls.prototype.dot;

  cls.prototype._dot = _dot;
  cls.prototype.dot = function (b) {
    var ret = _dot.call(this, b);

    if (ret >= 1.0 - DOT_NORM_SNAP_LIMIT && ret <= 1.0 + DOT_NORM_SNAP_LIMIT)
      return 1.0;
    if (ret >= -1.0 - DOT_NORM_SNAP_LIMIT && ret <= -1.0 + DOT_NORM_SNAP_LIMIT)
      return -1.0;

    return ret;
  };
}

function getBaseVector(parent) {
  return class BaseVector extends parent {
    constructor() {
      super(...arguments);

      this.vec = undefined; //for compatibility with old nstructjs-saved files

      //this.xyzw = this.init_swizzle(4);
      //this.xyz = this.init_swizzle(3);
      //this.xy = this.init_swizzle(2);
    }

    static inherit(cls, vectorsize) {
      make_norm_safe_dot(cls);

      var f;

      var vectorDotDistance = "f = function vectorDotDistance(b) {\n";
      for (var i = 0; i < vectorsize; i++) {
        vectorDotDistance += "  let d" + i + " = this[" + i + "]-b[" + i + "];\n\n  ";
      }

      vectorDotDistance += "  return ";
      for (var i = 0; i < vectorsize; i++) {
        if (i > 0)
          vectorDotDistance += " + ";
        vectorDotDistance += "d" + i + "*d" + i;
      }
      vectorDotDistance += ";\n";
      vectorDotDistance += "};";
      cls.prototype.vectorDotDistance = eval(vectorDotDistance);

      var f;
      var vectorDistance = "f = function vectorDistance(b) {\n";
      for (var i = 0; i < vectorsize; i++) {
        vectorDistance += `  let d${i} = this[${i}] - (b[${i}]||0);\n\n  `;
        //vectorDistance += "  let d"+i+" = this["+i+"]-(b["+i+"]||0);\n\n  ";
      }

      vectorDistance += "  return Math.sqrt(";
      for (var i = 0; i < vectorsize; i++) {
        if (i > 0)
          vectorDistance += " + ";
        vectorDistance += "d" + i + "*d" + i;
      }
      vectorDistance += ");\n";
      vectorDistance += "};";
      cls.prototype.vectorDistance = eval(vectorDistance);

      var vectorDistanceSqr = "f = function vectorDistanceSqr(b) {\n";
      for (var i = 0; i < vectorsize; i++) {
        vectorDistanceSqr += `  let d${i} = this[${i}] - (b[${i}]||0);\n\n  `;
        //vectorDistanceSqr += "  let d"+i+" = this["+i+"]-(b["+i+"]||0);\n\n  ";
      }

      vectorDistanceSqr += "  return (";
      for (var i = 0; i < vectorsize; i++) {
        if (i > 0)
          vectorDistanceSqr += " + ";
        vectorDistanceSqr += "d" + i + "*d" + i;
      }
      vectorDistanceSqr += ");\n";
      vectorDistanceSqr += "};";
      cls.prototype.vectorDistanceSqr = eval(vectorDistanceSqr);


      for (var k in basic_funcs) {
        var func = basic_funcs[k];
        var args = func[0];
        var line = func[1];
        var f;

        var code = "f = function " + k + "(";
        for (var i = 0; i < args.length; i++) {
          if (i > 0)
            code += ", ";

          line = line.replace(args[i], args[i].toLowerCase());
          code += args[i].toLowerCase();
        }
        code += ") {\n";

        if (func.length > 2) {
          //make summation
          code += "  return ";

          for (var i = 0; i < vectorsize; i++) {
            if (i > 0)
              code += func[2];

            code += "(" + line.replace(/X/g, "" + i) + ")";
          }
          code += ";\n";
        } else {
          for (var i = 0; i < vectorsize; i++) {
            var line2 = line.replace(/X/g, "" + i);
            code += "  this[" + i + "] = " + line2 + ";\n";
          }
          code += "  return this;\n";
        }

        code += "}\n";

        //console.log(code);
        var f = eval(code);

        cls.prototype[k] = f;
        //console.log(k, f);
      }
    }

    copy() {
      return new this.constructor(this);
    }

    load(data) {
      throw new Error("Implement me!");
    }

    init_swizzle(size) {
      var ret = {};
      var cls = size === 4 ? Vector4 : (size === 3 ? Vector3 : Vector2);

      for (var k in cls.prototype) {
        var v = cls.prototype[k];
        if (typeof v !== "function" && !(v instanceof Function))
          continue;

        ret[k] = v.bind(this);
      }

      return ret;
    }

    vectorLength() {
      return sqrt(this.dot(this));
    }

    swapAxes(axis1, axis2) {
      let t = this[axis1];
      this[axis1] = this[axis2];
      this[axis2] = t;

      return this;
    }

    normalize() {
      /*
      for (let i=0; i<this.length; i++) {
        if (util.isDenormal(this[i])) {
          console.error("Denormal error", i, this[i]);
          this[i] = 0.0;
        }
      }
      //*/

      let l = this.vectorLength();

      /*
      if (util.isDenormal(l)) {
        console.error("Denormal error", l);
      }
      //*/

      if (l > 0.00000001) {
        this.mulScalar(1.0/l);
      }

      return this;
    }
  }
}

const BaseVector = getBaseVector(Array);
const F64BaseVector = getBaseVector(Float64Array);
const F32BaseVector = getBaseVector(Float32Array);

function myclamp(f, a, b) {
  return Math.min(Math.max(f, a), b);
}

class Vector4 extends BaseVector {
  constructor(data) {
    super(4);

    if (arguments.length > 1) {
      throw new Error("unexpected argument");
    }

    this[0] = this[1] = this[2] = this[3] = 0.0;

    if (data !== undefined) {
      this.load(data);
    }
  }

  toCSS() {
    let r = ~~(this[0]*255);
    let g = ~~(this[1]*255);
    let b = ~~(this[2]*255);
    let a = this[3];
    return `rgba(${r},${g},${b},${a})`
  }

  loadXYZW(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;

    return this;
  }

  loadXYZ(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;

    return this;
  }

  load(data) {
    if (data === undefined)
      return this;

    this[0] = data[0];
    this[1] = data[1];
    this[2] = data[2];
    this[3] = data[3];

    return this;
  }

  dot(b) {
    return this[0]*b[0] + this[1]*b[1] + this[2]*b[2] + this[3]*b[3];
  }

  mulVecQuat(q) {
    let t0 = -q[1] * this[0] - q[2] * this[1] - q[3] * this[2];
    let t1 = q[0] * this[0] + q[2] * this[2] - q[3] * this[1];
    let t2 = q[0] * this[1] + q[3] * this[0] - q[1] * this[2];

    this[2] = q[0] * this[2] + q[1] * this[1] - q[2] * this[0];
    this[0] = t1;
    this[1] = t2;

    t1 = t0 * -q[1] + this[0] * q[0] - this[1] * q[3] + this[2] * q[2];
    t2 = t0 * -q[2] + this[1] * q[0] - this[2] * q[1] + this[0] * q[3];

    this[2] = t0 * -q[3] + this[2] * q[0] - this[0] * q[2] + this[1] * q[1];
    this[0] = t1;
    this[1] = t2;

    return this;
  }

  multVecMatrix(matrix) {
    var x = this[0];
    var y = this[1];
    var z = this[2];
    var w = this[3];

    this[0] = w*matrix.$matrix.m41 + x*matrix.$matrix.m11 + y*matrix.$matrix.m21 + z*matrix.$matrix.m31;
    this[1] = w*matrix.$matrix.m42 + x*matrix.$matrix.m12 + y*matrix.$matrix.m22 + z*matrix.$matrix.m32;
    this[2] = w*matrix.$matrix.m43 + x*matrix.$matrix.m13 + y*matrix.$matrix.m23 + z*matrix.$matrix.m33;
    this[3] = w*matrix.$matrix.m44 + x*matrix.$matrix.m14 + y*matrix.$matrix.m24 + z*matrix.$matrix.m34;

    return this[3];
  }

  cross(v) {
    var x = this[1]*v[2] - this[2]*v[1];
    var y = this[2]*v[0] - this[0]*v[2];
    var z = this[0]*v[1] - this[1]*v[0];

    this[0] = x;
    this[1] = y;
    this[2] = z;

    return this;
  }

  preNormalizedAngle(v2) {
    let th = this.dot(v2)*0.99999;
    return Math.acos(th);
  }

  loadSTRUCT(reader) {
    reader(this);

    if (typeof this.vec !== "undefined") {
      this.load(this.vec);
      this.vec = undefined;
    }
  }
};
Vector4.STRUCT = `
vec4 {
  0 : float;
  1 : float;
  2 : float;
  3 : float;
}
`;
nstructjs.manager.add_class(Vector4);


var _v3nd_n1_normalizedDot, _v3nd_n2_normalizedDot;
var _v3nd4_n1_normalizedDot4, _v3nd4_n2_normalizedDot4;

class Vector3 extends F64BaseVector {
  constructor(data) {
    super(3);

    if (arguments.length > 1) {
      throw new Error("unexpected argument");
    }

    this[0] = this[1] = this[2] = 0.0;

    if (data !== undefined) {
      this.load(data);
    }

    if (this.constructor === Vector3) {
      Object.preventExtensions(this);
    }
  }

  //normalizedDot4
  static normalizedDot4(v1, v2, v3, v4) {
    $_v3nd4_n1_normalizedDot4.load(v2).sub(v1).normalize();
    $_v3nd4_n2_normalizedDot4.load(v4).sub(v3).normalize();

    return $_v3nd4_n1_normalizedDot4.dot($_v3nd4_n2_normalizedDot4);
  }

  static normalizedDot3(v1, center, v2) {
    $_v3nd4_n1_normalizedDot3.load(v1).sub(center).normalize();
    $_v3nd4_n2_normalizedDot3.load(v2).sub(center).normalize();

    return $_v3nd4_n1_normalizedDot3.dot($_v3nd4_n2_normalizedDot3);
  }

  toCSS() {
    let r = ~~(this[0]*255);
    let g = ~~(this[1]*255);
    let b = ~~(this[2]*255);
    return `rgb(${r},${g},${b})`
  }

  loadXYZ(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;

    return this;
  }

  loadXY(x, y) {
    this[0] = x;
    this[1] = y;

    return this;
  }

  toJSON() {
    return [this[0], this[1], this[2]];
  }

  loadJSON(obj) {
    return this.load(obj);
  }

  initVector3() {
    this.length = 3;
    this[0] = this[1] = this[2] = 0;
    return this;
  }

  load(data) {
    if (data === undefined)
      return this;

    //if (isNaN(data[0]) || isNaN(data[1]) || isNaN(data[2])) {
    //  throw new Error("NaN");
    //}

    this[0] = data[0];
    this[1] = data[1];
    this[2] = data[2];

    return this;
  }

  dot(b) {
    return this[0]*b[0] + this[1]*b[1] + this[2]*b[2];
  }

  normalizedDot(v) {
    $_v3nd_n1_normalizedDot.load(this);
    $_v3nd_n2_normalizedDot.load(v);
    $_v3nd_n1_normalizedDot.normalize();
    $_v3nd_n2_normalizedDot.normalize();
    return $_v3nd_n1_normalizedDot.dot($_v3nd_n2_normalizedDot);
  }

  mulVecQuat(q) {
    let t0 = -q[1] * this[0] - q[2] * this[1] - q[3] * this[2];
    let t1 = q[0] * this[0] + q[2] * this[2] - q[3] * this[1];
    let t2 = q[0] * this[1] + q[3] * this[0] - q[1] * this[2];

    this[2] = q[0] * this[2] + q[1] * this[1] - q[2] * this[0];
    this[0] = t1;
    this[1] = t2;

    t1 = t0 * -q[1] + this[0] * q[0] - this[1] * q[3] + this[2] * q[2];
    t2 = t0 * -q[2] + this[1] * q[0] - this[2] * q[1] + this[0] * q[3];

    this[2] = t0 * -q[3] + this[2] * q[0] - this[0] * q[2] + this[1] * q[1];
    this[0] = t1;
    this[1] = t2;

    return this;
  }

  multVecMatrix(matrix, ignore_w) {
    if (ignore_w === undefined) {
      ignore_w = false;
    }
    var x = this[0];
    var y = this[1];
    var z = this[2];
    this[0] = matrix.$matrix.m41 + x*matrix.$matrix.m11 + y*matrix.$matrix.m21 + z*matrix.$matrix.m31;
    this[1] = matrix.$matrix.m42 + x*matrix.$matrix.m12 + y*matrix.$matrix.m22 + z*matrix.$matrix.m32;
    this[2] = matrix.$matrix.m43 + x*matrix.$matrix.m13 + y*matrix.$matrix.m23 + z*matrix.$matrix.m33;
    var w = matrix.$matrix.m44 + x*matrix.$matrix.m14 + y*matrix.$matrix.m24 + z*matrix.$matrix.m34;

    if (!ignore_w && w !== 1 && w !== 0 && matrix.isPersp) {
      this[0] /= w;
      this[1] /= w;
      this[2] /= w;
    }
    return w;
  }

  cross(v) {
    var x = this[1]*v[2] - this[2]*v[1];
    var y = this[2]*v[0] - this[0]*v[2];
    var z = this[0]*v[1] - this[1]*v[0];

    this[0] = x;
    this[1] = y;
    this[2] = z;

    return this;
  }

  //axis is optional, 0
  rot2d(A, axis) {
    var x = this[0];
    var y = this[1];

    if (axis === 1) {
      this[0] = x*cos(A) + y*sin(A);
      this[1] = y*cos(A) - x*sin(A);
    } else {
      this[0] = x*cos(A) - y*sin(A);
      this[1] = y*cos(A) + x*sin(A);
    }

    return this;
  }

  preNormalizedAngle(v2) {
    let th = this.dot(v2)*0.99999;
    return Math.acos(th);
  }

  loadSTRUCT(reader) {
    reader(this);

    if (typeof this.vec !== "undefined") {
      this.load(this.vec);
      this.vec = undefined;
    }
  }
}

Vector3.STRUCT = `
vec3 {
  0 : float;
  1 : float;
  2 : float;
}
`;
nstructjs.manager.add_class(Vector3);

class Vector2 extends BaseVector {
  constructor(data) {
    super(2);

    if (arguments.length > 1) {
      throw new Error("unexpected argument");
    }

    this[0] = this[1] = 0.0;

    if (data !== undefined) {
      this.load(data);
    }
  }

  initVector2(co) {
    this.length = 2;

    if (co !== undefined) {
      this[0] = co[0];
      this[1] = co[1];
    } else {
      this[0] = this[1] = 0.0;
    }

    return this;
  }

  loadXY(x, y) {
    this[0] = x;
    this[1] = y;

    return this;
  }

  toJSON() {
    return [this[0], this[1]];
  }

  loadJSON(obj) {
    return this.load(obj);
  }

  loadXY(x, y) {
    this[0] = x;
    this[1] = y;

    return this;
  }

  load(data) {
    if (data === undefined)
      return this;

    this[0] = data[0];
    this[1] = data[1];

    return this;
  }

  //axis is optional, 0
  rot2d(A, axis) {
    var x = this[0];
    var y = this[1];

    if (axis === 1) {
      this[0] = x*cos(A) + y*sin(A);
      this[1] = y*cos(A) - x*sin(A);
    } else {
      this[0] = x*cos(A) - y*sin(A);
      this[1] = y*cos(A) + x*sin(A);
    }

    return this;
  }

  dot(b) {
    return this[0]*b[0] + this[1]*b[1];
  }

  multVecMatrix(matrix) {
    var x = this[0];
    var y = this[1];

    var w = 1.0;

    this[0] = w*matrix.$matrix.m41 + x*matrix.$matrix.m11 + y*matrix.$matrix.m21;
    this[1] = w*matrix.$matrix.m42 + x*matrix.$matrix.m12 + y*matrix.$matrix.m22;

    if (matrix.isPersp) {
      let w2 = w*matrix.$matrix.m44 + x*matrix.$matrix.m14 + y*matrix.$matrix.m24;

      if (w2  !==  0.0) {
        this[0] /= w2;
        this[1] /= w2;
      }
    }

    return this;
  }

  mulVecQuat(q) {
    let t0 = -q[1] * this[0] - q[2] * this[1];
    let t1 = q[0] * this[0] - q[3] * this[1];
    let t2 = q[0] * this[1] + q[3] * this[0];

    let z  = q[1] * this[1] - q[2] * this[0];
    this[0] = t1;
    this[1] = t2;

    t1 = t0 * -q[1] + this[0] * q[0] - this[1] * q[3] + z * q[2];
    t2 = t0 * -q[2] + this[1] * q[0] - z * q[1] + this[0] * q[3];

    this[0] = t1;
    this[1] = t2;

    return this;
  }

  vectorLengthSqr() {
    return this.dot(this);
  }

  loadSTRUCT(reader) {
    reader(this);

    if (typeof this.vec !== undefined) {
      this.load(this.vec);
      this.vec = undefined;
    }
  }
};
Vector2.STRUCT = `
vec2 {
  0 : float;
  1 : float;
}
`;
nstructjs.manager.add_class(Vector2);

let _quat_vs3_temps = cachering$1.fromConstructor(Vector3, 64);

class Quat extends Vector4 {
  makeUnitQuat() {
    this[0] = 1.0;
    this[1] = this[2] = this[3] = 0.0;
  }

  isZero() {
    return (this[0] === 0 && this[1] === 0 && this[2] === 0 && this[3] === 0);
  }

  mulQuat(qt) {
    var a = this[0]*qt[0] - this[1]*qt[1] - this[2]*qt[2] - this[3]*qt[3];
    var b = this[0]*qt[1] + this[1]*qt[0] + this[2]*qt[3] - this[3]*qt[2];
    var c = this[0]*qt[2] + this[2]*qt[0] + this[3]*qt[1] - this[1]*qt[3];
    this[3] = this[0]*qt[3] + this[3]*qt[0] + this[1]*qt[2] - this[2]*qt[1];
    this[0] = a;
    this[1] = b;
    this[2] = c;
  }

  conjugate() {
    this[1] = -this[1];
    this[2] = -this[2];
    this[3] = -this[3];
  }

  dotWithQuat(q2) {
    return this[0]*q2[0] + this[1]*q2[1] + this[2]*q2[2] + this[3]*q2[3];
  }

  invert() {
    var f = this.dot(this);

    if (f === 0.0)
      return;

    conjugate_qt(q);
    this.mulscalar(1.0/f);
  }

  sub(q2) {
    var nq2 = new Quat();

    nq2[0] = -q2[0];
    nq2[1] = q2[1];
    nq2[2] = q2[2];
    nq2[3] = q2[3];

    this.mul(nq2);
  }

  mulScalarWithFactor(fac) {
    var angle = fac*bounded_acos(this[0]);
    var co = Math.cos(angle);
    var si = Math.sin(angle);

    this[0] = co;

    var last3 = Vector3([this[1], this[2], this[3]]);
    last3.normalize();
    last3.mulScalar(si);
    this[1] = last3[0];
    this[2] = last3[1];
    this[3] = last3[2];
    return this;
  }

  toMatrix(m) {
    if (m === undefined) {
      m = new Matrix4();
    }

    var q0 = M_SQRT2*this[0];
    var q1 = M_SQRT2*this[1];
    var q2 = M_SQRT2*this[2];
    var q3 = M_SQRT2*this[3];
    var qda = q0*q1;
    var qdb = q0*q2;
    var qdc = q0*q3;
    var qaa = q1*q1;
    var qab = q1*q2;
    var qac = q1*q3;
    var qbb = q2*q2;
    var qbc = q2*q3;
    var qcc = q3*q3;
    m.$matrix.m11 = (1.0 - qbb - qcc);
    m.$matrix.m12 = (qdc + qab);
    m.$matrix.m13 = (-qdb + qac);
    m.$matrix.m14 = 0.0;
    m.$matrix.m21 = (-qdc + qab);
    m.$matrix.m22 = (1.0 - qaa - qcc);
    m.$matrix.m23 = (qda + qbc);
    m.$matrix.m24 = 0.0;
    m.$matrix.m31 = (qdb + qac);
    m.$matrix.m32 = (-qda + qbc);
    m.$matrix.m33 = (1.0 - qaa - qbb);
    m.$matrix.m34 = 0.0;
    m.$matrix.m41 = m.$matrix.m42 = m.$matrix.m43 = 0.0;
    m.$matrix.m44 = 1.0;

    return m;
  }

  matrixToQuat(wmat) {
    var mat = temp_mats.next();
    mat.load(wmat);

    mat.$matrix.m41 = mat.$matrix.m42 = mat.$matrix.m43 = 0;
    mat.$matrix.m44 = 1.0;

    var r1 = new Vector3([mat.$matrix.m11, mat.$matrix.m12, mat.$matrix.m13]);
    var r2 = new Vector3([mat.$matrix.m21, mat.$matrix.m22, mat.$matrix.m23]);
    var r3 = new Vector3([mat.$matrix.m31, mat.$matrix.m32, mat.$matrix.m33]);

    r1.normalize();
    r2.normalize();
    r3.normalize();

    mat.$matrix.m11 = r1[0];
    mat.$matrix.m12 = r1[1];
    mat.$matrix.m13 = r1[2];
    mat.$matrix.m21 = r2[0];
    mat.$matrix.m22 = r2[1];
    mat.$matrix.m23 = r2[2];
    mat.$matrix.m31 = r3[0];
    mat.$matrix.m32 = r3[1];
    mat.$matrix.m33 = r3[2];
    var tr = 0.25*(1.0 + mat.$matrix.m11 + mat.$matrix.m22 + mat.$matrix.m33);
    var s = 0;
    if (tr > FLT_EPSILON) {
      s = Math.sqrt(tr);
      this[0] = s;
      s = 1.0/(4.0*s);
      this[1] = ((mat.$matrix.m23 - mat.$matrix.m32)*s);
      this[2] = ((mat.$matrix.m31 - mat.$matrix.m13)*s);
      this[3] = ((mat.$matrix.m12 - mat.$matrix.m21)*s);
    } else {
      if (mat.$matrix.m11 > mat.$matrix.m22 && mat.$matrix.m11 > mat.$matrix.m33) {
        s = 2.0*Math.sqrt(1.0 + mat.$matrix.m11 - mat.$matrix.m22 - mat.$matrix.m33);
        this[1] = (0.25*s);
        s = 1.0/s;
        this[0] = ((mat.$matrix.m32 - mat.$matrix.m23)*s);
        this[2] = ((mat.$matrix.m21 + mat.$matrix.m12)*s);
        this[3] = ((mat.$matrix.m31 + mat.$matrix.m13)*s);
      } else if (mat.$matrix.m22 > mat.$matrix.m33) {
        s = 2.0*Math.sqrt(1.0 + mat.$matrix.m22 - mat.$matrix.m11 - mat.$matrix.m33);
        this[2] = (0.25*s);
        s = 1.0/s;
        this[0] = ((mat.$matrix.m31 - mat.$matrix.m13)*s);
        this[1] = ((mat.$matrix.m21 + mat.$matrix.m12)*s);
        this[3] = ((mat.$matrix.m32 + mat.$matrix.m23)*s);
      } else {
        s = 2.0*Math.sqrt(1.0 + mat.$matrix.m33 - mat.$matrix.m11 - mat.$matrix.m22);
        this[3] = (0.25*s);
        s = 1.0/s;
        this[0] = ((mat.$matrix.m21 - mat.$matrix.m12)*s);
        this[1] = ((mat.$matrix.m31 + mat.$matrix.m13)*s);
        this[2] = ((mat.$matrix.m32 + mat.$matrix.m23)*s);
      }
    }
    this.normalize();
  }

  normalize() {
    var len = Math.sqrt(this.dot(this));

    if (len !== 0.0) {
      this.mulScalar(1.0/len);
    } else {
      this[1] = 1.0;
      this[0] = this[2] = this[3] = 0.0;
    }
    return this;
  }

  axisAngleToQuat(axis, angle) {
    let nor = _quat_vs3_temps.next().load(axis);
    nor.normalize();

    if (nor.dot(nor) !== 0.0) {
      var phi = angle/2.0;
      var si = Math.sin(phi);
      this[0] = Math.cos(phi);
      this[1] = nor[0]*si;
      this[2] = nor[1]*si;
      this[3] = nor[2]*si;
    } else {
      this.makeUnitQuat();
    }

    return this;
  }

  rotationBetweenVecs(v1, v2, fac = 1.0) {
    v1 = new Vector3(v1);
    v2 = new Vector3(v2);
    v1.normalize();
    v2.normalize();

    if (Math.abs(v1.dot(v2)) > 0.9999) {
      this.makeUnitQuat();
      return this;
    }

    let axis = new Vector3(v1);
    axis.cross(v2);

    let angle = v1.preNormalizedAngle(v2)*fac;

    this.axisAngleToQuat(axis, angle);

    return this;
  }

  quatInterp(quat2, t) {
    let quat = new Quat();
    let cosom = this[0]*quat2[0] + this[1]*quat2[1] + this[2]*quat2[2] + this[3]*quat2[3];
    if (cosom < 0.0) {
      cosom = -cosom;
      quat[0] = -this[0];
      quat[1] = -this[1];
      quat[2] = -this[2];
      quat[3] = -this[3];
    } else {
      quat[0] = this[0];
      quat[1] = this[1];
      quat[2] = this[2];
      quat[3] = this[3];
    }

    let omega, sinom, sc1, sc2;
    if ((1.0 - cosom) > 0.0001) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      sc1 = Math.sin((1.0 - t)*omega)/sinom;
      sc2 = Math.sin(t*omega)/sinom;
    } else {
      sc1 = 1.0 - t;
      sc2 = t;
    }
    this[0] = sc1*quat[0] + sc2*quat2[0];
    this[1] = sc1*quat[1] + sc2*quat2[1];
    this[2] = sc1*quat[2] + sc2*quat2[2];
    this[3] = sc1*quat[3] + sc2*quat2[3];

    return this;
  }
};

Quat.STRUCT = nstructjs.inherit(Quat, Vector4, 'quat') + `
}
`;
nstructjs.register(Quat);

_v3nd4_n1_normalizedDot4 = new Vector3();
_v3nd4_n2_normalizedDot4 = new Vector3();
_v3nd_n1_normalizedDot = new Vector3();
_v3nd_n2_normalizedDot = new Vector3();

BaseVector.inherit(Vector4, 4);
F64BaseVector.inherit(Vector3, 3);
BaseVector.inherit(Vector2, 2);

lookat_cache_vs3 = cachering$1.fromConstructor(Vector3, 64);
lookat_cache_vs4 = cachering$1.fromConstructor(Vector4, 64);

makenormalcache = cachering$1.fromConstructor(Vector3, 64);

var $_v3nd_n1_normalizedDot = new Vector3();
var $_v3nd_n2_normalizedDot = new Vector3();
var $_v3nd4_n1_normalizedDot4 = new Vector3();
var $_v3nd4_n2_normalizedDot4 = new Vector3();
var $_v3nd4_n1_normalizedDot3 = new Vector3();
var $_v3nd4_n2_normalizedDot3 = new Vector3();

var M_SQRT2 = Math.sqrt(2.0);
var FLT_EPSILON = 2.22e-16;

class internal_matrix {
  constructor() {
    this.m11 = 1.0;
    this.m12 = 0.0;
    this.m13 = 0.0;
    this.m14 = 0.0;
    this.m21 = 0.0;
    this.m22 = 1.0;
    this.m23 = 0.0;
    this.m24 = 0.0;
    this.m31 = 0.0;
    this.m32 = 0.0;
    this.m33 = 1.0;
    this.m34 = 0.0;
    this.m41 = 0.0;
    this.m42 = 0.0;
    this.m43 = 0.0;
    this.m44 = 1.0;
  }
}

var lookat_cache_vs3;
var lookat_cache_vs4;
var lookat_cache_ms;
var euler_rotate_mats;
var makenormalcache;
var temp_mats;

let preMultTemp;

class Matrix4 {
  constructor(m) {
    this.$matrix = new internal_matrix();
    this.isPersp = false;

    if (typeof m === 'object') {
      if ("length" in m && m.length >= 16) {
        this.load(m);
      } else if (m instanceof Matrix4) {
        this.load(m);
      }
    }
  }

  static fromJSON() {
    var mat = new Matrix4();
    mat.load(json.items);
    mat.isPersp = json.isPersp;
    return mat;
  }

  copy() {
    return this.clone();
  }

  clone() {
    return new Matrix4(this);
  }

  addToHashDigest(hash) {
    let m = this.$matrix;

    hash.add(m.m11);
    hash.add(m.m12);
    hash.add(m.m13);
    hash.add(m.m14);

    hash.add(m.m21);
    hash.add(m.m22);
    hash.add(m.m23);
    hash.add(m.m24);

    hash.add(m.m31);
    hash.add(m.m32);
    hash.add(m.m33);
    hash.add(m.m34);

    hash.add(m.m41);
    hash.add(m.m42);
    hash.add(m.m43);
    hash.add(m.m44);

    return this;
  }

  equals(m) {
    let m1 = this.$matrix;
    let m2 = m.$matrix;

    let ok = 1;

    ok = ok && m1.m11 === m2.m11;
    ok = ok && m1.m12 === m2.m12;
    ok = ok && m1.m13 === m2.m13;
    ok = ok && m1.m14 === m2.m14;

    ok = ok && m1.m21 === m2.m21;
    ok = ok && m1.m22 === m2.m22;
    ok = ok && m1.m23 === m2.m23;
    ok = ok && m1.m24 === m2.m24;

    ok = ok && m1.m31 === m2.m31;
    ok = ok && m1.m32 === m2.m32;
    ok = ok && m1.m33 === m2.m33;
    ok = ok && m1.m34 === m2.m34;

    ok = ok && m1.m41 === m2.m41;
    ok = ok && m1.m42 === m2.m42;
    ok = ok && m1.m43 === m2.m43;
    ok = ok && m1.m44 === m2.m44;

    return ok;
  }

  loadColumn(i, vec) {
    let m = this.$matrix;
    let have4 = vec.length > 3;

    switch (i) {
      case 0:
        m.m11 = vec[0];
        m.m21 = vec[1];
        m.m31 = vec[2];
        if (have4) {
          m.m41 = vec[3];
        }
        break;
      case 1:
        m.m12 = vec[0];
        m.m22 = vec[1];
        m.m32 = vec[2];
        if (have4) {
          m.m42 = vec[3];
        }
        break;
      case 2:
        m.m13 = vec[0];
        m.m23 = vec[1];
        m.m33 = vec[2];
        if (have4) {
          m.m43 = vec[3];
        }
        break;
      case 3:
        m.m14 = vec[0];
        m.m24 = vec[1];
        m.m34 = vec[2];
        if (have4) {
          m.m44 = vec[3];
        }
        break;
    }

    return this;
  }

  copyColumnTo(i, vec) {
    let m = this.$matrix;
    let have4 = vec.length > 3;

    switch (i) {
      case 0:
        vec[0] = m.m11;
        vec[1] = m.m21;
        vec[2] = m.m31;
        if (have4) {
          vec[3] = m.m41;
        }
        break;
      case 1:
        vec[0] = m.m12;
        vec[1] = m.m22;
        vec[2] = m.m32;
        if (have4) {
          vec[3] = m.m42;
        }
        break;
      case 2:
        vec[0] = m.m13;
        vec[1] = m.m23;
        vec[2] = m.m33;
        if (have4) {
          vec[3] = m.m43;
        }
        break;
      case 3:
        vec[0] = m.m14;
        vec[1] = m.m24;
        vec[2] = m.m34;
        if (have4) {
          vec[3] = m.m44;
        }
        break;
    }

    return vec;
  }

  copyColumn(i) {
    return this.copyColumnTo(i, new Vector3());
  }

  load() {
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var matrix;
      if (arguments[0] instanceof Matrix4) {
        matrix = arguments[0].$matrix;
        this.isPersp = arguments[0].isPersp;
        this.$matrix.m11 = matrix.m11;
        this.$matrix.m12 = matrix.m12;
        this.$matrix.m13 = matrix.m13;
        this.$matrix.m14 = matrix.m14;
        this.$matrix.m21 = matrix.m21;
        this.$matrix.m22 = matrix.m22;
        this.$matrix.m23 = matrix.m23;
        this.$matrix.m24 = matrix.m24;
        this.$matrix.m31 = matrix.m31;
        this.$matrix.m32 = matrix.m32;
        this.$matrix.m33 = matrix.m33;
        this.$matrix.m34 = matrix.m34;
        this.$matrix.m41 = matrix.m41;
        this.$matrix.m42 = matrix.m42;
        this.$matrix.m43 = matrix.m43;
        this.$matrix.m44 = matrix.m44;
        return this;
      } else
        matrix = arguments[0];
      if ("length" in matrix && matrix.length >= 16) {
        this.$matrix.m11 = matrix[0];
        this.$matrix.m12 = matrix[1];
        this.$matrix.m13 = matrix[2];
        this.$matrix.m14 = matrix[3];
        this.$matrix.m21 = matrix[4];
        this.$matrix.m22 = matrix[5];
        this.$matrix.m23 = matrix[6];
        this.$matrix.m24 = matrix[7];
        this.$matrix.m31 = matrix[8];
        this.$matrix.m32 = matrix[9];
        this.$matrix.m33 = matrix[10];
        this.$matrix.m34 = matrix[11];
        this.$matrix.m41 = matrix[12];
        this.$matrix.m42 = matrix[13];
        this.$matrix.m43 = matrix[14];
        this.$matrix.m44 = matrix[15];
        return this;
      }
    }

    this.makeIdentity();

    return this;
  }

  toJSON() {
    return {isPersp: this.isPersp, items: this.getAsArray()}
  }

  getAsArray() {
    return [this.$matrix.m11, this.$matrix.m12, this.$matrix.m13, this.$matrix.m14, this.$matrix.m21, this.$matrix.m22,
            this.$matrix.m23, this.$matrix.m24, this.$matrix.m31, this.$matrix.m32, this.$matrix.m33, this.$matrix.m34,
            this.$matrix.m41, this.$matrix.m42, this.$matrix.m43, this.$matrix.m44];
  }

  getAsFloat32Array() {
    return new Float32Array(this.getAsArray());
  }

  setUniform(ctx, loc, transpose) {
    if (Matrix4.setUniformArray === undefined) {
      Matrix4.setUniformWebGLArray = new Float32Array(16);
      Matrix4.setUniformArray = new Array(16);
    }

    Matrix4.setUniformArray[0] = this.$matrix.m11;
    Matrix4.setUniformArray[1] = this.$matrix.m12;
    Matrix4.setUniformArray[2] = this.$matrix.m13;
    Matrix4.setUniformArray[3] = this.$matrix.m14;
    Matrix4.setUniformArray[4] = this.$matrix.m21;
    Matrix4.setUniformArray[5] = this.$matrix.m22;
    Matrix4.setUniformArray[6] = this.$matrix.m23;
    Matrix4.setUniformArray[7] = this.$matrix.m24;
    Matrix4.setUniformArray[8] = this.$matrix.m31;
    Matrix4.setUniformArray[9] = this.$matrix.m32;
    Matrix4.setUniformArray[10] = this.$matrix.m33;
    Matrix4.setUniformArray[11] = this.$matrix.m34;
    Matrix4.setUniformArray[12] = this.$matrix.m41;
    Matrix4.setUniformArray[13] = this.$matrix.m42;
    Matrix4.setUniformArray[14] = this.$matrix.m43;
    Matrix4.setUniformArray[15] = this.$matrix.m44;

    Matrix4.setUniformWebGLArray.set(Matrix4.setUniformArray);

    ctx.uniformMatrix4fv(loc, transpose, Matrix4.setUniformWebGLArray);

    return this;
  }

  makeIdentity() {
    this.$matrix.m11 = 1;
    this.$matrix.m12 = 0;
    this.$matrix.m13 = 0;
    this.$matrix.m14 = 0;
    this.$matrix.m21 = 0;
    this.$matrix.m22 = 1;
    this.$matrix.m23 = 0;
    this.$matrix.m24 = 0;
    this.$matrix.m31 = 0;
    this.$matrix.m32 = 0;
    this.$matrix.m33 = 1;
    this.$matrix.m34 = 0;
    this.$matrix.m41 = 0;
    this.$matrix.m42 = 0;
    this.$matrix.m43 = 0;
    this.$matrix.m44 = 1;

    //drop isPersp
    this.isPersp = false;

    return this;
  }

  transpose() {
    var tmp = this.$matrix.m12;
    this.$matrix.m12 = this.$matrix.m21;
    this.$matrix.m21 = tmp;
    tmp = this.$matrix.m13;
    this.$matrix.m13 = this.$matrix.m31;
    this.$matrix.m31 = tmp;
    tmp = this.$matrix.m14;
    this.$matrix.m14 = this.$matrix.m41;
    this.$matrix.m41 = tmp;
    tmp = this.$matrix.m23;
    this.$matrix.m23 = this.$matrix.m32;
    this.$matrix.m32 = tmp;
    tmp = this.$matrix.m24;
    this.$matrix.m24 = this.$matrix.m42;
    this.$matrix.m42 = tmp;
    tmp = this.$matrix.m34;
    this.$matrix.m34 = this.$matrix.m43;
    this.$matrix.m43 = tmp;

    return this;
  }

  determinant() {
    return this._determinant4x4();
  }

  invert() {
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-08)
      return null;

    this._makeAdjoint();

    this.$matrix.m11 /= det;
    this.$matrix.m12 /= det;
    this.$matrix.m13 /= det;
    this.$matrix.m14 /= det;
    this.$matrix.m21 /= det;
    this.$matrix.m22 /= det;
    this.$matrix.m23 /= det;
    this.$matrix.m24 /= det;
    this.$matrix.m31 /= det;
    this.$matrix.m32 /= det;
    this.$matrix.m33 /= det;
    this.$matrix.m34 /= det;
    this.$matrix.m41 /= det;
    this.$matrix.m42 /= det;
    this.$matrix.m43 /= det;
    this.$matrix.m44 /= det;

    return this;
  }

  translate(x, y, z) {
    if (typeof x === 'object' && "length" in x) {
      var t = x;

      x = t[0];
      y = t[1];
      z = t[2];
    }

    x = x === undefined ? 0 : x;
    y = y === undefined ? 0 : y;
    z = z === undefined ? 0 : z;

    var matrix = temp_mats.next().makeIdentity();

    matrix.$matrix.m41 = x;
    matrix.$matrix.m42 = y;
    matrix.$matrix.m43 = z;

    this.multiply(matrix);
    return this;
  }

  preTranslate(x, y, z) {
    if (typeof x === 'object' && "length" in x) {
      var t = x;

      x = t[0];
      y = t[1];
      z = t[2];
    }

    x = x === undefined ? 0 : x;
    y = y === undefined ? 0 : y;
    z = z === undefined ? 0 : z;

    var matrix = temp_mats.next().makeIdentity();

    matrix.$matrix.m41 = x;
    matrix.$matrix.m42 = y;
    matrix.$matrix.m43 = z;

    this.preMultiply(matrix);
    return this;
  }

  scale(x, y, z, w = 1.0) {
    if (typeof x === 'object' && "length" in x) {
      var t = x;
      x = t[0];
      y = t[1];
      z = t[2];
    } else {
      if (x === undefined)
        x = 1;

      if (z === undefined) {
        if (y === undefined) {
          y = x;
          z = x;
        } else {
          z = x;
        }
      } else if (y === undefined) {
        y = x;
      }
    }


    var matrix = temp_mats.next().makeIdentity();
    matrix.$matrix.m11 = x;
    matrix.$matrix.m22 = y;
    matrix.$matrix.m33 = z;
    matrix.$matrix.m44 = w;
    this.multiply(matrix);
    return this
  }

  preScale(x, y, z, w = 1.0) {
    let mat = temp_mats.next().makeIdentity();
    mat.scale(x, y, z, w);

    this.preMultiply(mat);
    return this
  }

  /*
  on factor;
  off period;

  c1 := cx; comment: cos(thx);
  s1 := sx; comment: sin(thx);

  c2 := cy; comment: cos(thy);
  s2 := sy; comment: sin(thy);

  c3 := cz; comment: cos(thz);
  s3 := sz; comment: sin(thz);

  cx := cos(thx);
  sx := sin(thx);
  cy := cos(thy);
  sy := sin(thy);
  cz := cos(thz);
  sz := sin(thz);

  imat := mat((1, 0, 0, 0),
              (0, 1, 0, 0),
              (0, 0, 1, 0),
              (0, 0, 0, 1));

  xmat :=mat((1,  0,  0,  0),
             (0, c1, -s1, 0),
             (0, s1,  c1, 0),
             (0,  0,  0,  0));

  ymat :=mat((c2, 0, s2, 0),
             (0,  1,  0,  0),
             (-s2, 0,  c2, 0),
             (0,  0,  0,  0));

  zmat :=mat(( c3, -s3, 0, 0),
             (s3, c3, 0, 0),
             ( 0,  0,  1, 0),
             ( 0,  0,  0, 0));

  mmat := mat((m11, m21, m31, 0),
              (m12, m22, m32, 0),
              (m13, m23, m33, 0),
              (0,   0,   0,   0));

  fmat := zmat * ymat * xmat;

  f1 := m11**2 + m12**2 + m13**2 - 1.0;
  f2 := m21**2 + m22**2 + m23**2 - 1.0;
  f3 := m31**2 + m32**2 + m33**2 - 1.0;

  tmat := fmat * mmat;
  f1 := tmat(1, 1) - 1.0;
  f2 := tmat(2, 2) - 1.0;
  f3 := tmat(3, 3) - 1.0;

  operator myasin;

  fthy := asin(mmat(3, 1));
  f1 := mmat(3,1)**2 + mmat(2,1)**2 + mmat(1,1)**2 = 1.0;

  fmat2 := sub(thy=fthy, fmat);

  fmat3 := fmat2 * (tp mmat);
  ffz := solve(fmat2(1, 1) - m11, thz);
  ffx := solve(fmat2(3, 3) - m33, thx);

  fthz := part(ffz, 1, 2);
  fthx := part(ffx, 1, 2);

  sub(thx=fthx, thy=fthy, thz=fthz, fmat);

(cos(thy)*cos(thz),         cos(thx)*sin(thz)-cos(thz)*sin(thx)*sin(thy),  -(cos(thx)*cos(thz)*sin(thy)+sin(thx)*sin(thz)), 0),

(-cos(thy)*sin(thz),        cos(thx)*cos(thz) + sin(thx)*sin(thy)*sin(thz),  cos(thx)*sin(thy)*sin(thz)-cos(thz)*sin(thx), 0),

(sin(thy),                  cos(thy)*sin(thx),                               cos(thx)*cos(thy),  0),

    (0,0,0,1))

  */

  euler_rotate_order(x, y, z, order = EulerOrders.XYZ) {
    if (y === undefined) {
      y = 0.0;
    }
    if (z === undefined) {
      z = 0.0;
    }

    x = -x;
    y = -y;
    z = -z;

    let xmat = euler_rotate_mats.next().makeIdentity();

    let m = xmat.$matrix;

    let c = Math.cos(x), s = Math.sin(x);

    m.m22 = c;
    m.m23 = s;
    m.m32 = -s;
    m.m33 = c;

    let ymat = euler_rotate_mats.next().makeIdentity();
    c = Math.cos(y);
    s = Math.sin(y);
    m = ymat.$matrix;

    m.m11 = c;
    m.m13 = -s;
    m.m31 = s;
    m.m33 = c;

    let zmat = euler_rotate_mats.next().makeIdentity();
    c = Math.cos(z);
    s = Math.sin(z);
    m = zmat.$matrix;

    m.m11 = c;
    m.m12 = s;
    m.m21 = -s;
    m.m22 = c;

    let a, b;

    switch (order) {
      case EulerOrders.XYZ:
        a = xmat;
        b = ymat;
        c = zmat;
        break;
      case EulerOrders.XZY:
        a = xmat;
        b = zmat;
        c = ymat;
        break;
      case EulerOrders.YXZ:
        a = ymat;
        b = xmat;
        c = zmat;
        break;
      case EulerOrders.YZX:
        a = ymat;
        b = zmat;
        c = xmat;
        break;
      case EulerOrders.ZXY:
        a = zmat;
        b = xmat;
        c = ymat;
        break;
      case EulerOrders.ZYX:
        a = zmat;
        b = ymat;
        c = xmat;
        break;
    }

    b.preMultiply(c);
    b.multiply(a);

    this.preMultiply(b);

    return this;
  }

  euler_rotate(x, y, z) {
    if (y === undefined) {
      y = 0.0;
    }
    if (z === undefined) {
      z = 0.0;
    }
    window.Matrix4 = Matrix4;

    var xmat = euler_rotate_mats.next().makeIdentity();
    var m = xmat.$matrix;

    var c = Math.cos(x), s = Math.sin(x);

    m.m22 = c;
    m.m23 = s;
    m.m32 = -s;
    m.m33 = c;

    var ymat = euler_rotate_mats.next().makeIdentity();
    c = Math.cos(y);
    s = Math.sin(y);
    var m = ymat.$matrix;

    m.m11 = c;
    m.m13 = -s;
    m.m31 = s;
    m.m33 = c;

    ymat.multiply(xmat);

    var zmat = euler_rotate_mats.next().makeIdentity();
    c = Math.cos(z);
    s = Math.sin(z);
    var m = zmat.$matrix;

    m.m11 = c;
    m.m12 = s;
    m.m21 = -s;
    m.m22 = c;

    zmat.multiply(ymat);

    //console.log(""+ymat);
    //this.multiply(zmat);
    this.preMultiply(zmat);

    return this;
  }

  toString() {
    var s = "";
    var m = this.$matrix;

    function dec(d) {
      var ret = d.toFixed(3);

      if (ret[0] !== "-") //make room for negative signs
        ret = " " + ret;
      return ret
    }

    s = dec(m.m11) + ", " + dec(m.m12) + ", " + dec(m.m13) + ", " + dec(m.m14) + "\n";
    s += dec(m.m21) + ", " + dec(m.m22) + ", " + dec(m.m23) + ", " + dec(m.m24) + "\n";
    s += dec(m.m31) + ", " + dec(m.m32) + ", " + dec(m.m33) + ", " + dec(m.m34) + "\n";
    s += dec(m.m41) + ", " + dec(m.m42) + ", " + dec(m.m43) + ", " + dec(m.m44) + "\n";

    return s
  }

  rotate(angle, x, y, z) {
    if (typeof x === 'object' && "length" in x) {
      var t = x;
      x = t[0];
      y = t[1];
      z = t[2];
    } else {
      if (arguments.length === 1) {
        x = y = 0;
        z = 1;
      } else if (arguments.length === 3) {
        this.rotate(angle, 1, 0, 0);
        this.rotate(x, 0, 1, 0);
        this.rotate(y, 0, 0, 1);
        return;
      }
    }

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA*sinA;
    var len = Math.sqrt(x*x + y*y + z*z);

    if (len === 0) {
      x = 0;
      y = 0;
      z = 1;
    } else if (len !== 1) {
      x /= len;
      y /= len;
      z /= len;
    }

    var mat = temp_mats.next().makeIdentity();

    if (x === 1 && y === 0 && z === 0) {
      mat.$matrix.m11 = 1;
      mat.$matrix.m12 = 0;
      mat.$matrix.m13 = 0;
      mat.$matrix.m21 = 0;
      mat.$matrix.m22 = 1 - 2*sinA2;
      mat.$matrix.m23 = 2*sinA*cosA;
      mat.$matrix.m31 = 0;
      mat.$matrix.m32 = -2*sinA*cosA;
      mat.$matrix.m33 = 1 - 2*sinA2;
      mat.$matrix.m14 = mat.$matrix.m24 = mat.$matrix.m34 = 0;
      mat.$matrix.m41 = mat.$matrix.m42 = mat.$matrix.m43 = 0;
      mat.$matrix.m44 = 1;
    } else if (x === 0 && y === 1 && z === 0) {
      mat.$matrix.m11 = 1 - 2*sinA2;
      mat.$matrix.m12 = 0;
      mat.$matrix.m13 = -2*sinA*cosA;
      mat.$matrix.m21 = 0;
      mat.$matrix.m22 = 1;
      mat.$matrix.m23 = 0;
      mat.$matrix.m31 = 2*sinA*cosA;
      mat.$matrix.m32 = 0;
      mat.$matrix.m33 = 1 - 2*sinA2;
      mat.$matrix.m14 = mat.$matrix.m24 = mat.$matrix.m34 = 0;
      mat.$matrix.m41 = mat.$matrix.m42 = mat.$matrix.m43 = 0;
      mat.$matrix.m44 = 1;
    } else if (x === 0 && y === 0 && z === 1) {
      mat.$matrix.m11 = 1 - 2*sinA2;
      mat.$matrix.m12 = 2*sinA*cosA;
      mat.$matrix.m13 = 0;
      mat.$matrix.m21 = -2*sinA*cosA;
      mat.$matrix.m22 = 1 - 2*sinA2;
      mat.$matrix.m23 = 0;
      mat.$matrix.m31 = 0;
      mat.$matrix.m32 = 0;
      mat.$matrix.m33 = 1;
      mat.$matrix.m14 = mat.$matrix.m24 = mat.$matrix.m34 = 0;
      mat.$matrix.m41 = mat.$matrix.m42 = mat.$matrix.m43 = 0;
      mat.$matrix.m44 = 1;
    } else {
      var x2 = x*x;
      var y2 = y*y;
      var z2 = z*z;
      mat.$matrix.m11 = 1 - 2*(y2 + z2)*sinA2;
      mat.$matrix.m12 = 2*(x*y*sinA2 + z*sinA*cosA);
      mat.$matrix.m13 = 2*(x*z*sinA2 - y*sinA*cosA);
      mat.$matrix.m21 = 2*(y*x*sinA2 - z*sinA*cosA);
      mat.$matrix.m22 = 1 - 2*(z2 + x2)*sinA2;
      mat.$matrix.m23 = 2*(y*z*sinA2 + x*sinA*cosA);
      mat.$matrix.m31 = 2*(z*x*sinA2 + y*sinA*cosA);
      mat.$matrix.m32 = 2*(z*y*sinA2 - x*sinA*cosA);
      mat.$matrix.m33 = 1 - 2*(x2 + y2)*sinA2;
      mat.$matrix.m14 = mat.$matrix.m24 = mat.$matrix.m34 = 0;
      mat.$matrix.m41 = mat.$matrix.m42 = mat.$matrix.m43 = 0;
      mat.$matrix.m44 = 1;
    }
    this.multiply(mat);

    return this;
  }

  normalize() {
    let m = this.$matrix;

    let v1 = new Vector4([m.m11, m.m12, m.m13, m.m14]);
    let v2 = new Vector4([m.m21, m.m22, m.m23, m.m24]);
    let v3 = new Vector4([m.m31, m.m32, m.m33, m.m34]);
    let v4 = new Vector4([m.m41, m.m42, m.m43, m.m44]);

    v1.normalize();
    v2.normalize();
    v3.normalize();

    let flat = new Array().concat(v1).concat(v2).concat(v3).concat(v4);
    this.load(flat);

    return this;
  }

  clearTranslation(set_w_to_one = false) {
    let m = this.$matrix;

    m.m41 = m.m42 = m.m43 = 0.0;

    if (set_w_to_one) {
      m.m44 = 1.0;
    }

    return this;
  }

  setTranslation(x, y, z, resetW = true) {
    if (typeof x === "object") {
      y = x[1];
      z = x[2];
      x = x[0];
    }

    let m = this.$matrix;

    m.m41 = x;
    m.m42 = y;
    m.m43 = z;

    if (resetW) {
      m.m44 = 1.0;
    }

    return this;
  }

  //this is really like the lookAt method, isn't it.
  makeNormalMatrix(normal, up = undefined) {
    if (normal === undefined) {
      throw new Error("normal cannot be undefined");
    }

    let n = makenormalcache.next().load(normal).normalize();

    if (up === undefined) {
      up = makenormalcache.next().zero();

      if (Math.abs(n[2]) > 0.95) {
        up[1] = 1.0;
      } else {
        up[2] = 1.0;
      }
    }

    up = makenormalcache.next().load(up);

    up.normalize();

    if (up.dot(normal) > 0.99) {
      this.makeIdentity();
      return this;
    } else if (up.dot(normal) < -0.99) {
      this.makeIdentity();
      this.scale(1.0, 1.0, -1.0);
      return this;
    }

    let x = makenormalcache.next();
    let y = makenormalcache.next();

    x.load(n).cross(up).normalize();
    y.load(x).cross(n).normalize();
    //y.negate();

    this.makeIdentity();
    let m = this.$matrix;

    m.m11 = x[0];
    m.m12 = x[1];
    m.m13 = x[2];

    m.m21 = y[0];
    m.m22 = y[1];
    m.m23 = y[2];

    m.m31 = n[0];
    m.m32 = n[1];
    m.m33 = n[2];
    m.m44 = 1.0;

    return this;
  }

  preMultiply(mat) {
    preMultTemp.load(mat);
    preMultTemp.multiply(this);

    this.load(preMultTemp);

    return this;
  }

  multiply(mat) {
    let mm = this.$matrix;
    let mm2 = mat.$matrix;

    let m11 = (mm2.m11*mm.m11 + mm2.m12*mm.m21 + mm2.m13*mm.m31 + mm2.m14*mm.m41);
    let m12 = (mm2.m11*mm.m12 + mm2.m12*mm.m22 + mm2.m13*mm.m32 + mm2.m14*mm.m42);
    let m13 = (mm2.m11*mm.m13 + mm2.m12*mm.m23 + mm2.m13*mm.m33 + mm2.m14*mm.m43);
    let m14 = (mm2.m11*mm.m14 + mm2.m12*mm.m24 + mm2.m13*mm.m34 + mm2.m14*mm.m44);
    let m21 = (mm2.m21*mm.m11 + mm2.m22*mm.m21 + mm2.m23*mm.m31 + mm2.m24*mm.m41);
    let m22 = (mm2.m21*mm.m12 + mm2.m22*mm.m22 + mm2.m23*mm.m32 + mm2.m24*mm.m42);
    let m23 = (mm2.m21*mm.m13 + mm2.m22*mm.m23 + mm2.m23*mm.m33 + mm2.m24*mm.m43);
    let m24 = (mm2.m21*mm.m14 + mm2.m22*mm.m24 + mm2.m23*mm.m34 + mm2.m24*mm.m44);
    let m31 = (mm2.m31*mm.m11 + mm2.m32*mm.m21 + mm2.m33*mm.m31 + mm2.m34*mm.m41);
    let m32 = (mm2.m31*mm.m12 + mm2.m32*mm.m22 + mm2.m33*mm.m32 + mm2.m34*mm.m42);
    let m33 = (mm2.m31*mm.m13 + mm2.m32*mm.m23 + mm2.m33*mm.m33 + mm2.m34*mm.m43);
    let m34 = (mm2.m31*mm.m14 + mm2.m32*mm.m24 + mm2.m33*mm.m34 + mm2.m34*mm.m44);
    let m41 = (mm2.m41*mm.m11 + mm2.m42*mm.m21 + mm2.m43*mm.m31 + mm2.m44*mm.m41);
    let m42 = (mm2.m41*mm.m12 + mm2.m42*mm.m22 + mm2.m43*mm.m32 + mm2.m44*mm.m42);
    let m43 = (mm2.m41*mm.m13 + mm2.m42*mm.m23 + mm2.m43*mm.m33 + mm2.m44*mm.m43);
    let m44 = (mm2.m41*mm.m14 + mm2.m42*mm.m24 + mm2.m43*mm.m34 + mm2.m44*mm.m44);

    mm.m11 = m11;
    mm.m12 = m12;
    mm.m13 = m13;
    mm.m14 = m14;
    mm.m21 = m21;
    mm.m22 = m22;
    mm.m23 = m23;
    mm.m24 = m24;
    mm.m31 = m31;
    mm.m32 = m32;
    mm.m33 = m33;
    mm.m34 = m34;
    mm.m41 = m41;
    mm.m42 = m42;
    mm.m43 = m43;
    mm.m44 = m44;

    return this;
  }

  divide(divisor) {
    this.$matrix.m11 /= divisor;
    this.$matrix.m12 /= divisor;
    this.$matrix.m13 /= divisor;
    this.$matrix.m14 /= divisor;
    this.$matrix.m21 /= divisor;
    this.$matrix.m22 /= divisor;
    this.$matrix.m23 /= divisor;
    this.$matrix.m24 /= divisor;
    this.$matrix.m31 /= divisor;
    this.$matrix.m32 /= divisor;
    this.$matrix.m33 /= divisor;
    this.$matrix.m34 /= divisor;
    this.$matrix.m41 /= divisor;
    this.$matrix.m42 /= divisor;
    this.$matrix.m43 /= divisor;
    this.$matrix.m44 /= divisor;

    return this;
  }

  ortho(left, right, bottom, top, near, far) {
    console.warn("Matrix4.ortho() is deprecated, use .orthographic() instead");

    var tx = (left + right)/(left - right);
    var ty = (top + bottom)/(top - bottom);
    var tz = (far + near)/(far - near);
    var matrix = temp_mats.next().makeIdentity();

    matrix.$matrix.m11 = 2/(left - right);
    matrix.$matrix.m12 = 0;
    matrix.$matrix.m13 = 0;
    matrix.$matrix.m14 = 0;
    matrix.$matrix.m21 = 0;
    matrix.$matrix.m22 = 2/(top - bottom);
    matrix.$matrix.m23 = 0;
    matrix.$matrix.m24 = 0;
    matrix.$matrix.m31 = 0;
    matrix.$matrix.m32 = 0;
    matrix.$matrix.m33 = -2/(far - near);
    matrix.$matrix.m34 = 0;
    matrix.$matrix.m41 = tx;
    matrix.$matrix.m42 = ty;
    matrix.$matrix.m43 = tz;
    matrix.$matrix.m44 = 1;

    this.multiply(matrix);

    return this;
  }

  frustum(left, right, bottom, top, near, far) {
    var matrix = temp_mats.next().makeIdentity();

    var A = (right + left)/(right - left);
    var B = (top + bottom)/(top - bottom);
    var C = -(far + near)/(far - near);
    var D = -(2*far*near)/(far - near);

    matrix.$matrix.m11 = (2*near)/(right - left);
    matrix.$matrix.m12 = 0;
    matrix.$matrix.m13 = 0;
    matrix.$matrix.m14 = 0;
    matrix.$matrix.m21 = 0;
    matrix.$matrix.m22 = 2*near/(top - bottom);
    matrix.$matrix.m23 = 0;
    matrix.$matrix.m24 = 0;
    matrix.$matrix.m31 = A;
    matrix.$matrix.m32 = B;
    matrix.$matrix.m33 = C;
    matrix.$matrix.m34 = -1;
    matrix.$matrix.m41 = 0;
    matrix.$matrix.m42 = 0;
    matrix.$matrix.m43 = D;
    matrix.$matrix.m44 = 0;

    this.isPersp = true;
    this.multiply(matrix);

    return this;
  }

  orthographic(scale, aspect, near, far) {
    let mat = temp_mats.next().makeIdentity();

    let zscale = far - near;

    mat.scale(2.0/aspect, 2.0, -1.0/scale/zscale, 1.0/scale);
    mat.translate(0.0, 0.0, 0.5*zscale - near);

    this.isPersp = true; //we still make use of auto homogenous divide in BaseVector.multVecMatrix
    this.multiply(mat);

    return mat;
  }

  perspective(fovy, aspect, zNear, zFar) {
    var top = Math.tan(fovy*Math.PI/360)*zNear;
    var bottom = -top;
    var left = aspect*bottom;
    var right = aspect*top;

    this.frustum(left, right, bottom, top, zNear, zFar);

    return this;
  }

  lookat(pos, target, up) {
    var matrix = lookat_cache_ms.next();
    matrix.makeIdentity();

    var vec = lookat_cache_vs3.next().load(pos).sub(target);
    var len = vec.vectorLength();
    vec.normalize();

    var zvec = vec;
    var yvec = lookat_cache_vs3.next().load(up).normalize();
    var xvec = lookat_cache_vs3.next().load(yvec).cross(zvec).normalize();

    let mm = matrix.$matrix;

    mm.m11 = xvec[0];
    mm.m12 = yvec[0];
    mm.m13 = zvec[0];
    mm.m14 = 0;
    mm.m21 = xvec[1];
    mm.m22 = yvec[1];
    mm.m23 = zvec[1];
    mm.m24 = 0;
    mm.m31 = xvec[2];
    mm.m32 = yvec[2];
    mm.m33 = zvec[2];

    //*
    mm.m11 = xvec[0];
    mm.m12 = xvec[1];
    mm.m13 = xvec[2];
    mm.m14 = 0;
    mm.m21 = yvec[0];
    mm.m22 = yvec[1];
    mm.m23 = yvec[2];
    mm.m24 = 0;
    mm.m31 = zvec[0];
    mm.m32 = zvec[1];
    mm.m33 = zvec[2];
    mm.m34 = 0;
    mm.m41 = pos[0];
    mm.m42 = pos[1];
    mm.m43 = pos[2];
    mm.m44 = 1;
    //*/

    this.multiply(matrix);


    return this;
  }

  makeRotationOnly() {
    var m = this.$matrix;

    m.m41 = m.m42 = m.m43 = 0.0;
    m.m44 = 1.0;

    let l1 = Math.sqrt(m.m11*m.m11 + m.m12*m.m12 + m.m13*m.m13);
    let l2 = Math.sqrt(m.m21*m.m21 + m.m22*m.m22 + m.m23*m.m23);
    let l3 = Math.sqrt(m.m31*m.m31 + m.m32*m.m32 + m.m33*m.m33);

    if (l1) {
      m.m11 /= l1;
      m.m12 /= l1;
      m.m13 /= l1;
    }

    if (l2) {
      m.m21 /= l2;
      m.m22 /= l2;
      m.m23 /= l2;
    }

    if (l3) {
      m.m31 /= l3;
      m.m32 /= l3;
      m.m33 /= l3;
    }

    return this;
  }

  alignAxis(axis, vec) {
    vec = new Vector3(vec);
    vec.normalize();

    let mat = this.inputs.transformMatrix.getValue();
    let m = mat.$matrix;

    let mat2 = new Matrix4(mat);
    let loc = new Vector3(), scale = new Vector3(), rot = new Vector3();

    //we don't use rot
    mat2.decompose(loc, rot, scale);

    mat2.makeRotationOnly();
    let axes = mat2.getAsVecs();

    let axis2 = (axis + 1) % 3;
    let axis3 = (axis + 2) % 3;

    axes[axis].load(vec);
    axes[axis2].cross(axes[axis]).cross(axes[axis]);
    axes[axis3].load(axes[axis]).cross(axes[axis2]);

    axes[0][3] = 1.0;
    axes[1][3] = 1.0;
    axes[2][3] = 1.0;

    axes[0].normalize();
    axes[1].normalize();
    axes[2].normalize();

    this.loadFromVecs(axes);
    this.scale(scale[0], scale[1], scale[2]);

    m.m41 = loc[0];
    m.m42 = loc[1];
    m.m43 = loc[2];

    return this;
  }

  decompose(_translate, _rotate, _scale, _skew, _perspective, order = EulerOrders.XYZ) {
    if (this.$matrix.m44 === 0)
      return false;

    let mat = temp_mats.next().load(this);
    let m = mat.$matrix;

    let t = _translate, r = _rotate, s = _scale;
    if (t) {
      t[0] = m.m41;
      t[1] = m.m42;
      t[2] = m.m43;
    }

    let l1 = Math.sqrt(m.m11*m.m11 + m.m12*m.m12 + m.m13*m.m13);
    let l2 = Math.sqrt(m.m21*m.m21 + m.m22*m.m22 + m.m23*m.m23);
    let l3 = Math.sqrt(m.m31*m.m31 + m.m32*m.m32 + m.m33*m.m33);

    if (l1) {
      m.m11 /= l1;
      m.m12 /= l1;
      m.m13 /= l1;
    }
    if (l2) {
      m.m21 /= l2;
      m.m22 /= l2;
      m.m23 /= l2;
    }
    if (l3) {
      m.m31 /= l3;
      m.m32 /= l3;
      m.m33 /= l3;
    }

    if (s) {
      s[0] = l1;
      s[1] = l2;
      s[2] = l3;
    }

    if (r) { //THREE.js code
      let clamp = myclamp;

      let rmat = temp_mats.next().load(this);
      rmat.normalize();

      m = rmat.$matrix;

      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

      let m11 = m.m11, m12 = m.m12, m13 = m.m13, m14 = m.m14;
      let m21 = m.m21, m22 = m.m22, m23 = m.m23, m24 = m.m24;
      let m31 = m.m31, m32 = m.m32, m33 = m.m33, m34 = m.m34;
      //let m41 = m.m41, m42 = m.m42, m43 = m.m43, m44 = m.m44;

      if (order === EulerOrders.XYZ) {

        r[1] = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {

          r[0] = Math.atan2(-m23, m33);
          r[2] = Math.atan2(-m12, m11);

        } else {

          r[0] = Math.atan2(m32, m22);
          r[2] = 0;

        }

      } else if (order === EulerOrders.YXZ) {

        r[0] = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {

          r[1] = Math.atan2(m13, m33);
          r[2] = Math.atan2(m21, m22);

        } else {

          r[1] = Math.atan2(-m31, m11);
          r[2] = 0;

        }

      } else if (order === EulerOrders.ZXY) {

        r[0] = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {

          r[1] = Math.atan2(-m31, m33);
          r[2] = Math.atan2(-m12, m22);

        } else {

          r[1] = 0;
          r[2] = Math.atan2(m21, m11);

        }

      } else if (order === EulerOrders.ZYX) {

        r[1] = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {

          r[0] = Math.atan2(m32, m33);
          r[2] = Math.atan2(m21, m11);

        } else {

          r[0] = 0;
          r[2] = Math.atan2(-m12, m22);

        }

      } else if (order === EulerOrders.YZX) {

        r[2] = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {

          r[0] = Math.atan2(-m23, m22);
          r[1] = Math.atan2(-m31, m11);

        } else {

          r[0] = 0;
          r[1] = Math.atan2(m13, m33);

        }

      } else if (order === EulerOrders.XZY) {

        r[2] = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {

          r[0] = Math.atan2(m32, m22);
          r[1] = Math.atan2(m13, m11);

        } else {

          r[0] = Math.atan2(-m23, m33);
          r[1] = 0;

        }

      } else {
        console.warn('unsupported euler order:', order);
      }
      //r[0] = Math.atan2(m.m23, m.m33);
      //r[1] = Math.atan2(-m.m13, Math.sqrt(m.m23*m.m23 + m.m33*m.m33));
      //r[2] = Math.atan2(m.m12, m.m11);
    }
  }

  _determinant2x2(a, b, c, d) {
    return a*d - b*c;
  }

  _determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    return a1*this._determinant2x2(b2, b3, c2, c3) - b1*this._determinant2x2(a2, a3, c2, c3) + c1*this._determinant2x2(a2, a3, b2, b3);
  }

  determinant() {
    return this._determinant4x4();
  }

  _determinant4x4() {
    var a1 = this.$matrix.m11;
    var b1 = this.$matrix.m12;
    var c1 = this.$matrix.m13;
    var d1 = this.$matrix.m14;
    var a2 = this.$matrix.m21;
    var b2 = this.$matrix.m22;
    var c2 = this.$matrix.m23;
    var d2 = this.$matrix.m24;
    var a3 = this.$matrix.m31;
    var b3 = this.$matrix.m32;
    var c3 = this.$matrix.m33;
    var d3 = this.$matrix.m34;
    var a4 = this.$matrix.m41;
    var b4 = this.$matrix.m42;
    var c4 = this.$matrix.m43;
    var d4 = this.$matrix.m44;
    return a1*this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) - b1*this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) + c1*this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) - d1*this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
  }

  _makeAdjoint() {
    var a1 = this.$matrix.m11;
    var b1 = this.$matrix.m12;
    var c1 = this.$matrix.m13;
    var d1 = this.$matrix.m14;
    var a2 = this.$matrix.m21;
    var b2 = this.$matrix.m22;
    var c2 = this.$matrix.m23;
    var d2 = this.$matrix.m24;
    var a3 = this.$matrix.m31;
    var b3 = this.$matrix.m32;
    var c3 = this.$matrix.m33;
    var d3 = this.$matrix.m34;
    var a4 = this.$matrix.m41;
    var b4 = this.$matrix.m42;
    var c4 = this.$matrix.m43;
    var d4 = this.$matrix.m44;

    this.$matrix.m11 = this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.$matrix.m21 = -this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.$matrix.m31 = this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.$matrix.m41 = -this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
    this.$matrix.m12 = -this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.$matrix.m22 = this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.$matrix.m32 = -this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.$matrix.m42 = this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
    this.$matrix.m13 = this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.$matrix.m23 = -this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.$matrix.m33 = this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.$matrix.m43 = -this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
    this.$matrix.m14 = -this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.$matrix.m24 = this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.$matrix.m34 = -this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.$matrix.m44 = this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
  }

  loadSTRUCT(reader) {
    reader(this);

    this.load(this.mat);
    this.__mat = this.mat;
    //delete this.mat;
  }
}

Matrix4.STRUCT = `
mat4 {
  mat      : array(float) | this.getAsArray();
  isPersp  : int          | this.isPersp;
}
`;
nstructjs.register(Matrix4);

preMultTemp = new Matrix4();

window.testmat = (x = 0, y = 0, z = Math.PI*0.5) => {
  let m1 = new Matrix4();
  m1.euler_rotate(x, y, z);
  //m1.scale(2.0, 0.5, 3.0);

  let t = [0, 0, 0], r = [0, 0, 0], s = [0, 0, 0];

  m1.decompose(t, r, s);

  window.console.log("\n");
  window.console.log(t);
  window.console.log(r);
  window.console.log(s);


  let mat = m1.clone();
  mat.transpose();
  mat.multiply(m1);

  console.log(mat.toString());
  return r;
};

lookat_cache_ms = cachering$1.fromConstructor(Matrix4, 64);
euler_rotate_mats = cachering$1.fromConstructor(Matrix4, 64);
temp_mats = cachering$1.fromConstructor(Matrix4, 64);

var vectormath1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  EulerOrders: EulerOrders,
  BaseVector: BaseVector,
  F64BaseVector: F64BaseVector,
  F32BaseVector: F32BaseVector,
  Vector4: Vector4,
  Vector3: Vector3,
  Vector2: Vector2,
  Quat: Quat,
  Matrix4: Matrix4
});

"use strict";

let PropTypes = {
  INT        : 1,
  STRING     : 2,
  BOOL       : 4,
  ENUM       : 8,
  FLAG       : 16,
  FLOAT      : 32,
  VEC2       : 64,
  VEC3       : 128,
  VEC4       : 256,
  MATRIX4    : 512,
  QUAT       : 1024,
  PROPLIST   : 4096,
  STRSET     : 8192,
  CURVE      : 8192<<1,
  FLOAT_ARRAY: 8192<<2,
  REPORT     : 8192<<3
  //ITER : 8192<<1
};

const PropSubTypes = {
  COLOR: 1
};

//flags
const PropFlags = {
  SELECT                : 1,
  PRIVATE               : 2,
  LABEL                 : 4,
  USE_ICONS             : 64,
  USE_CUSTOM_GETSET     : 128, //used by controller.js interface
  SAVE_LAST_VALUE       : 256,
  READ_ONLY             : 512,
  SIMPLE_SLIDER         : 1<<10,
  FORCE_ROLLER_SLIDER   : 1<<11,
  USE_BASE_UNDO         : 1<<12, //internal to simple_controller.js
  EDIT_AS_BASE_UNIT     : 1<<13, //user textbox input should be interpreted in display unit
  NO_UNDO               : 1<<14,
  USE_CUSTOM_PROP_GETTER: 1<<15, //hrm, not sure I need this
};

class ToolPropertyIF {
  constructor(type, subtype, apiname, uiname, description, flag, icon) {
    this.data = undefined;

    this.type = type;
    this.subtype = subtype;

    this.apiname = apiname;
    this.uiname = uiname;
    this.description = description;
    this.flag = flag;
    this.icon = icon;
  }

  equals(b) {
    throw new Error("implement me");
  }

  copyTo(b) {

  }

  copy() {

  }

  _fire(type, arg1, arg2) {
  }

  on(type, cb) {
  }

  off(type, cb) {
  }

  getValue() {
  }

  setValue(val) {
  }

  setStep(step) {
  }

  setRange(min, max) {
  }

  setUnit(unit) {
  }

  //some clients have seperate ui range
  setUIRange(min, max) {
  }

  setIcon(icon) {
  }
}

class StringPropertyIF extends ToolPropertyIF {
  constructor() {
    super(PropTypes.STRING);
  }
}

class NumPropertyIF extends ToolPropertyIF {
};

class IntPropertyIF extends ToolPropertyIF {
  constructor() {
    super(PropTypes.INT);
  }

  setRadix(radix) {
    throw new Error("implement me");
  }
}

class FloatPropertyIF extends ToolPropertyIF {
  constructor() {
    super(PropTypes.FLOAT);
  }

  setDecimalPlaces(n) {
  }
}

class EnumPropertyIF extends ToolPropertyIF {
  constructor(value, valid_values) {
    super(PropTypes.ENUM);

    this.values = {};
    this.keys = {};
    this.ui_value_names = {};
    this.iconmap = {};

    if (valid_values === undefined) return this;

    if (valid_values instanceof Array || valid_values instanceof String) {
      for (var i = 0; i < valid_values.length; i++) {
        this.values[valid_values[i]] = valid_values[i];
        this.keys[valid_values[i]] = valid_values[i];
      }
    } else {
      for (var k in valid_values) {
        this.values[k] = valid_values[k];
        this.keys[valid_values[k]] = k;
      }
    }

    for (var k in this.values) {
      var uin = k[0].toUpperCase() + k.slice(1, k.length);

      uin = uin.replace(/\_/g, " ");
      this.ui_value_names[k] = uin;
    }
  }

  addIcons(iconmap) {
    if (this.iconmap === undefined) {
      this.iconmap = {};
    }
    for (var k in iconmap) {
      this.iconmap[k] = iconmap[k];
    }
  }
}

class FlagPropertyIF extends EnumPropertyIF {
  constructor(valid_values) {
    super(PropTypes.FLAG);
  }
}

class Vec2PropertyIF extends ToolPropertyIF {
  constructor(valid_values) {
    super(PropTypes.VEC2);
  }
}

class Vec3PropertyIF extends ToolPropertyIF {
  constructor(valid_values) {
    super(PropTypes.VEC3);
  }
}

class Vec4PropertyIF extends ToolPropertyIF {
  constructor(valid_values) {
    super(PropTypes.VEC4);
  }
}

/**
 * List of other tool props (all of one type)
 */
class ListPropertyIF extends ToolPropertyIF {
  /*
  * Prop must be a ToolProperty subclass instance
  * */
  constructor(prop) {
    super(PropTypes.PROPLIST);

    this.prop = prop;
  }

  get length() {
  }

  set length(val) {
  }

  copyTo(b) {
  }

  copy() {
  }

  /**
   * clear list
   * */
  clear() {

  }

  push(item = this.prop.copy()) {
  }

  [Symbol.iterator]() {
  }
}

//like FlagsProperty but uses strings
class StringSetPropertyIF extends ToolPropertyIF {
  constructor(value = undefined, definition = []) {
    super(PropTypes.STRSET);
  }

  /*
  * Values can be a string, undefined/null, or a list/set/object-literal of strings.
  * If destructive is true, then existing set will be cleared.
  * */
  setValue(values, destructive = true, soft_fail = true) {
  }

  getValue() {
  }

  addIcons(iconmap) {
  }


  addUINames(map) {
  }

  addDescriptions(map) {
  }

  copyTo(b) {
  }

  copy() {
  }
}

class Curve1DPropertyIF extends ToolPropertyIF {
  constructor(curve, uiname) {
    super(PropTypes.CURVE);

    this.data = curve;
  }

  getValue() {
    return this.curve;
  }

  setValue(curve) {
    if (curve === undefined) {
      return;
    }

    let json = JSON.parse(JSON.stringify(curve));
    this.data.load(json);
  }

  copyTo(b) {
    b.setValue(this.data);
  }
}

var toolprop_abstract1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  PropTypes: PropTypes,
  PropSubTypes: PropSubTypes,
  PropFlags: PropFlags,
  ToolPropertyIF: ToolPropertyIF,
  StringPropertyIF: StringPropertyIF,
  NumPropertyIF: NumPropertyIF,
  IntPropertyIF: IntPropertyIF,
  FloatPropertyIF: FloatPropertyIF,
  EnumPropertyIF: EnumPropertyIF,
  FlagPropertyIF: FlagPropertyIF,
  Vec2PropertyIF: Vec2PropertyIF,
  Vec3PropertyIF: Vec3PropertyIF,
  Vec4PropertyIF: Vec4PropertyIF,
  ListPropertyIF: ListPropertyIF,
  StringSetPropertyIF: StringSetPropertyIF,
  Curve1DPropertyIF: Curve1DPropertyIF
});

/*
all units convert to meters
*/

const FLT_EPSILONE = 1.192092895507812e-07;

function myfloor(f) {
  return Math.floor(f + FLT_EPSILONE*2.0);
}

function normString(s) {
  //remove all whitespace
  s = s.replace(/ /g, "").replace(/\t/g, "");
  return s.toLowerCase();
}

function myToFixed(f, decimals) {
  if (typeof f !== "number") {
    return "(error)";
  }

  f = f.toFixed(decimals);
  while (f.endsWith("0") && f.search(/\./) >= 0) {
    f = f.slice(0, f.length - 1);
  }

  if (f.endsWith(".")) {
    f = f.slice(0, f.length - 1);
  }

  if (f.length === 0)
    f = "0";

  return f.trim();
}

const Units = [];

class Unit {
  static getUnit(name) {
    if (name === "none" || name === undefined) {
      return undefined;
    }

    for (let cls of Units) {
      if (cls.unitDefine().name === name) {
        return cls;
      }
    }

    throw new Error("Unknown unit " + name);
  }

  static register(cls) {
    Units.push(cls);
  }

  //subclassed static methods start here
  static unitDefine() {
    return {
      name   : "",
      uiname : "",
      type   : "", //e.g. distance
      icon   : -1,
      pattern: undefined //a re literal to validate strings
    }
  }

  static parse(string) {

  }

  static validate(string) {
    string = normString(string);
    let def = this.unitDefine();

    let m = string.match(def.pattern);
    if (!m)
      return false;

    return m[0] === string;
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {

  }

  static fromInternal(value) {

  }

  static buildString(value, decimals = 2) {

  }
}

class MeterUnit extends Unit {
  static unitDefine() {
    return {
      name   : "meter",
      uiname : "Meter",
      type   : "distance",
      icon   : -1,
      pattern: /-?\d+(\.\d*)?m$/
    }
  }

  static parse(string) {
    string = normString(string);
    if (string.endsWith("m")) {
      string = string.slice(0, string.length - 1);
    }

    return parseFloat(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value;
  }

  static fromInternal(value) {
    return value;
  }

  static buildString(value, decimals = 2) {
    return "" + myToFixed(value, decimals) + " m";
  }
}

Unit.register(MeterUnit);

class InchUnit extends Unit {
  static unitDefine() {
    return {
      name   : "inch",
      uiname : "Inch",
      type   : "distance",
      icon   : -1,
      pattern: /-?\d+(\.\d*)?(in|inch)$/
    }
  }

  static parse(string) {
    string = string.toLowerCase();
    let i = string.indexOf("i");

    if (i >= 0) {
      string = string.slice(0, i);
    }

    return parseInt(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value*0.0254;
  }

  static fromInternal(value) {
    return value/0.0254;
  }

  static buildString(value, decimals = 2) {
    return "" + myToFixed(value, decimals) + "in";
  }
}

Unit.register(InchUnit);

let foot_re = /((-?\d+(\.\d*)?ft)(-?\d+(\.\d*)?(in|inch))?)|(-?\d+(\.\d*)?(in|inch))$/;

class FootUnit extends Unit {
  static unitDefine() {
    return {
      name   : "foot",
      uiname : "Foot",
      type   : "distance",
      icon   : -1,
      pattern: foot_re
    }
  }

  static parse(string) {
    string = normString(string);
    let i = string.search("ft");
    let parts = [];
    let vft = 0.0, vin = 0.0;

    if (i >= 0) {
      parts = string.split("ft");
      let j = parts[1].search("in");

      if (j >= 0) {
        parts = [parts[0]].concat(parts[1].split("in"));
        vin = parseFloat(parts[1]);
      }

      vft = parseFloat(parts[0]);
    } else {
      string = string.replace(/in/g, "");
      vin = parseFloat(string);
    }

    return vin/12.0 + vft;
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value*0.3048;
  }

  static fromInternal(value) {
    return value/0.3048;
  }

  static buildString(value, decimals = 2) {
    let vft = myfloor(value);
    let vin = ((value + FLT_EPSILONE*2)*12)%12;

    if (vft === 0.0) {
      return myToFixed(vin, decimals) + " in";
    }

    let s = "" + vft + " ft";
    if (vin !== 0.0) {
      s += " " + myToFixed(vin, decimals) + " in";
    }

    return s;
  }
}

Unit.register(FootUnit);


let square_foot_re = /((-?\d+(\.\d*)?ft(\u00b2)?)(-?\d+(\.\d*)?(in|inch)(\u00b2)?)?)|(-?\d+(\.\d*)?(in|inch)(\u00b2)?)$/;

class SquareFootUnit extends FootUnit {
  static unitDefine() {
    return {
      name   : "square_foot",
      uiname : "Square Feet",
      type   : "area",
      icon   : -1,
      pattern: square_foot_re
    }
  }

  static parse(string) {
    string = string.replace(/\u00b2/g, "");
    return super.parse(string);
  }


  static buildString(value, decimals = 2) {
    let vft = myfloor(value);
    let vin = ((value + FLT_EPSILONE*2)*12)%12;

    if (vft === 0.0) {
      return myToFixed(vin, decimals) + " in\u00b2";
    }

    let s = "" + vft + " ft\u00b2";
    if (vin !== 0.0) {
      s += " " + myToFixed(vin, decimals) + " in\u00b2";
    }

    return s;
  }
}

Unit.register(SquareFootUnit);


class MileUnit extends Unit {
  static unitDefine() {
    return {
      name   : "mile",
      uiname : "Mile",
      type   : "distance",
      icon   : -1,
      pattern: /-?\d+(\.\d+)?miles$/
    }
  }

  static parse(string) {
    string = normString(string);
    string = string.replace(/miles/, "");
    return parseFloat(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value*1609.34;
  }

  static fromInternal(value) {
    return value/1609.34;
  }

  static buildString(value, decimals = 3) {
    return "" + myToFixed(value, decimals) + " miles";
  }
}

Unit.register(MileUnit);

class DegreeUnit extends Unit {
  static unitDefine() {
    return {
      name   : "degree",
      uiname : "Degrees",
      type   : "angle",
      icon   : -1,
      pattern: /-?\d+(\.\d+)?(\u00B0|degree|deg|d|degree|degrees)$/
    }
  }

  static parse(string) {
    string = normString(string);
    if (string.search("d") >= 0) {
      string = string.slice(0, string.search("d")).trim();
    } else if (string.search("\u00B0") >= 0) {
      string = string.slice(0, string.search("\u00B0")).trim();
    }

    return parseFloat(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value/180.0*Math.PI;
  }

  static fromInternal(value) {
    return value*180.0/Math.PI;
  }

  static buildString(value, decimals = 3) {
    return "" + myToFixed(value, decimals) + " \u00B0";
  }
};
Unit.register(DegreeUnit);

class RadianUnit extends Unit {
  static unitDefine() {
    return {
      name   : "radian",
      uiname : "Radians",
      type   : "angle",
      icon   : -1,
      pattern: /-?\d+(\.\d+)?(r|rad|radian|radians)$/
    }
  }

  static parse(string) {
    string = normString(string);
    if (string.search("r") >= 0) {
      string = string.slice(0, string.search("r")).trim();
    }

    return parseFloat(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value;
  }

  static fromInternal(value) {
    return value;
  }

  static buildString(value, decimals = 3) {
    return "" + myToFixed(value, decimals) + " r";
  }
};

Unit.register(RadianUnit);

function setBaseUnit(unit) {
  Unit.baseUnit = unit;
}

window._getBaseUnit = () => Unit.baseUnit;

function setMetric(val) {
  Unit.isMetric = val;
}

Unit.isMetric = true;
Unit.baseUnit = "meter";

let numre1 = /[+\-]?[0-9]+(\.[0-9]*)?$/;
let numre2 = /[+\-]?[0-9]?(\.[0-9]*)+$/;
let hexre1 = /[+\-]?[0-9a-fA-F]+h$/;
let hexre2 = /[+\-]?0x[0-9a-fA-F]+$/;
let binre = /[+\-]?0b[01]+$/;
let expre = /[+\-]?[0-9]+(\.[0-9]*)?[eE]\-?[0-9]+$/;
let intre = /[+\-]?[0-9]+$/;

function isnumber(s) {
  s = ("" + s).trim();

  function test(re) {
    return s.search(re) === 0;
  }

  return test(intre) || test(numre1) || test(numre2) || test(hexre1) || test(hexre2) || test(binre) || test(expre);
}


function parseValueIntern(string, baseUnit = undefined) {
  string = string.trim();
  if (string[0] === ".") {
    string = "0" + string;
  }

  if (typeof baseUnit === "string") {
    let base = Unit.getUnit(baseUnit);

    if (base === undefined && baseUnit !== "none") {
      console.warn("Unknown unit " + baseUnit);
      return NaN;
    }

    baseUnit = base;
  }

  //unannotated string?
  if (isnumber(string)) {
    //assume base unit
    let f = parseFloat(string);

    return f;
  }

  if (baseUnit === undefined) {
    console.warn("No base unit in units.js:parseValueIntern");
  }

  for (let unit of Units) {
    let def = unit.unitDefine();

    if (unit.validate(string)) {
      console.log(unit);
      let value = unit.parse(string);

      if (baseUnit) {
        value = unit.toInternal(value);
        return baseUnit.fromInternal(value);
      } else {
        return value;
      }
    }
  }

  return NaN;
}

/* if displayUnit is undefined, final value will be converted from displayUnit to baseUnit */
function parseValue(string, baseUnit = undefined, displayUnit = undefined) {
  displayUnit = Unit.getUnit(displayUnit);
  baseUnit = Unit.getUnit(baseUnit);

  let f = parseValueIntern(string, displayUnit || baseUnit);

  if (baseUnit) {
    if (displayUnit) {
      f = displayUnit.toInternal(f);
    }

    f = baseUnit.fromInternal(f);
  }

  return f;
}

function isNumber(string) {
  if (isnumber(string)) {
    return true;
  }

  for (let unit of Units) {
    let def = unit.unitDefine();

    if (unit.validate(string)) {
      return true;
    }
  }

  return false;
}

class PixelUnit extends Unit {
  static unitDefine() {
    return {
      name   : "pixel",
      uiname : "Pixel",
      type   : "distance",
      icon   : -1,
      pattern: /-?\d+(\.\d*)?px$/
    }
  }

  static parse(string) {
    string = normString(string);
    if (string.endsWith("px")) {
      string = string.slice(0, string.length - 2).trim();
    }

    return parseFloat(string);
  }

  //convert to internal units,
  //e.g. meters for distance
  static toInternal(value) {
    return value;
  }

  static fromInternal(value) {
    return value;
  }

  static buildString(value, decimals = 2) {
    return "" + myToFixed(value, decimals) + "px";
  }
}

Unit.register(PixelUnit);

function convert(value, unita, unitb) {
  if (typeof unita === "string")
    unita = Unit.getUnit(unita);

  if (typeof unitb === "string")
    unitb = Unit.getUnit(unitb);

  return unitb.fromInternal(unita.toInternal(value));
}

/**
 *
 * @param value Note: is not converted to internal unit
 * @param unit: Unit to use, should be a string referencing unit type, see unitDefine().name
 * @returns {*}
 */
function buildString(value, baseUnit = Unit.baseUnit, decimalPlaces = 3, displayUnit = Unit.baseUnit) {
  if (typeof baseUnit === "string" && baseUnit !== "none") {
    baseUnit = Unit.getUnit(baseUnit);
  }
  if (typeof displayUnit === "string" && displayUnit !== "none") {
    displayUnit = Unit.getUnit(displayUnit);
  }


  if (baseUnit !== "none" && displayUnit !== baseUnit && displayUnit !== "none") {
    value = convert(value, baseUnit, displayUnit);
  }

  if (displayUnit !== "none") {
    return displayUnit.buildString(value, decimalPlaces);
  } else {
    return myToFixed(value, decimalPlaces);
  }
}

window._parseValueTest = parseValue;
window._buildStringTest = buildString;

let config = {
  doubleClickTime : 500,

  //auto load 1d bspline templates, can hurt startup time
  autoLoadSplineTemplates : true,

  //timeout for press-and-hold (touch) version of double clicking
  doubleClickHoldTime : 750,
  DEBUG : {

  }
};

function setConfig(obj) {
  for (let k in obj) {
    config[k] = obj[k];
  }
}

var config1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  config: config,
  setConfig: setConfig,
  'default': config
});

let modalstack = [];
let singleMouseCBs = {};

function singletonMouseEvents() {
  let keys = ["mousedown", "mouseup", "mousemove"];
  for (let k of keys) {
    singleMouseCBs[k] = new Set();
  }

  let ddd = -1.0;
  window.testSingleMouseUpEvent = (type = "mousedown") => {
    let id = ddd++;
    singleMouseEvent(() => {
      console.log("mouse event", id);
    }, type);
  };

  let _mpos = new Vector2();

  function doSingleCbs(e, type) {
    let list = singleMouseCBs[type];
    singleMouseCBs[type] = new Set();

    if (e.type !== "touchend" && e.type !== "touchcancel") {
      _mpos[0] = e.touches && e.touches.length > 0 ? e.touches[0].pageX : e.x;
      _mpos[1] = e.touches && e.touches.length > 0 ? e.touches[0].pageY : e.y;
    }

    if (e.touches) {
      e = copyEvent(e);

      e.type = type;
      if (e.touches.length > 0) {
        e.x = e.pageX = e.touches[0].pageX;
        e.y = e.pageY = e.touches[0].pageY;
      } else {
        e.x = _mpos[0];
        e.y = _mpos[1];
      }
    }

    for (let cb of list) {
      try {
        cb(e);
      } catch (error) {
        print_stack$1(error);
        console.warn("Error in event callback");
      }
    }
  }

  window.addEventListener("mouseup", (e) => {
    doSingleCbs(e, "mouseup");
  }, {capture: true});
  window.addEventListener("touchcancel", (e) => {
    doSingleCbs(e, "mouseup");
  }, {capture: true});
  document.addEventListener("touchend", (e) => {
    doSingleCbs(e, "mouseup");
  }, {capture: true});

  document.addEventListener("mousedown", (e) => {
    doSingleCbs(e, "mousedown");
  }, {capture: true});
  document.addEventListener("touchstart", (e) => {
    doSingleCbs(e, "mousedown");
  }, {capture: true});

  document.addEventListener("mousemove", (e) => {
    doSingleCbs(e, "mousemove");
  }, {capture: true});
  document.addEventListener("touchmove", (e) => {
    doSingleCbs(e, "mousemove");
  }, {capture: true});

  return {
    singleMouseEvent(cb, type) {
      if (!(type in singleMouseCBs)) {
        throw new Error("not a mouse event");
      }

      singleMouseCBs[type].add(cb);
    }
  };
};

singletonMouseEvents = singletonMouseEvents();

/**
 * adds a mouse event callback that only gets called once
 * */
function singleMouseEvent(cb, type) {
  return singletonMouseEvents.singleMouseEvent(cb, type);
}


/*tests if either the left mouse button is down,
* or a touch event has happened and e.touches.length == 1*/
function isLeftClick(e) {
  if (e.touches !== undefined) {
    return e.touches.length === 1;
  }

  return e.button === 0;
}

class DoubleClickHandler {
  constructor() {
    this.down = 0;
    this.last = 0;
    this.dblEvent = undefined;

    this.start_mpos = new Vector2();

    this._on_mouseup = this._on_mouseup.bind(this);
    this._on_mousemove = this._on_mousemove.bind(this);
  }

  _on_mouseup(e) {
    //console.log("mup", e);
    this.mdown = false;
  }

  _on_mousemove(e) {
    let mpos = new Vector2();
    mpos[0] = e.x;
    mpos[1] = e.y;

    let dist = mpos.vectorDistance(this.start_mpos)*devicePixelRatio;

    if (dist > 11) {
      //console.log("cancel", dist);
      this.mdown = false;
    }

    if (this.mdown) {
      singleMouseEvent(this._on_mousemove, "mousemove");
    }

    this.update();
  }

  mousedown(e) {
    //console.log("mdown", e.x, e.y);

    if (!this.last) {
      this.last = 0;
    }
    if (!this.down) {
      this.down = 0;
    }
    if (!this.up) {
      this.up = 0;
    }

    if (isMouseDown(e)) {
      this.mdown = true;

      let cpy = Object.assign({}, e);

      this.start_mpos[0] = e.x;
      this.start_mpos[1] = e.y;

      singleMouseEvent(this._on_mousemove, "mousemove");

      if (e.type.search("touch") >= 0 && e.touches.length > 0) {
        cpy.x = cpy.pageX = e.touches[0].pageX;
        cpy.y = cpy.pageY = e.touches[1].pageY;
      } else {
        cpy.x = cpy.pageX = e.x;
        cpy.y = cpy.pageY = e.y;
      }

      //stupid real MouseEvent class zeros .x/.y
      //continue using hackish copyEvent for now...

      this.dblEvent = copyEvent(e);
      this.dblEvent.type = "dblclick";

      this.last = this.down;
      this.down = time_ms();

      if (this.down - this.last < config.doubleClickTime) {
        this.mdown = false;
        this.ondblclick(this.dblEvent);

        this.down = this.last = 0.0;
      } else {
        singleMouseEvent(this._on_mouseup, "mouseup");
      }
    } else {
      this.mdown = false;
    }
  }

  //you may override this
  ondblclick(e) {

  }

  update() {
    if (modalstack.length > 0) {
      //cancel double click requests
      this.mdown = false;
    }

    if (this.mdown && time_ms() - this.down > config.doubleClickHoldTime) {
      this.mdown = false;
      this.ondblclick(this.dblEvent);
    }
  }

  abort() {
    this.last = this.down = 0;
  }
}

function isMouseDown(e) {
  let mdown = 0;

  if (e.touches !== undefined) {
    mdown = e.touches.length > 0;
  } else {
    mdown = e.buttons;
  }

  mdown = mdown & 1;

  return mdown;
}

function pathDebugEvent(e, extra) {
  e.__prevdef = e.preventDefault;
  e.__stopprop = e.stopPropagation;

  e.preventDefault = function () {
    console.warn("preventDefault", extra);
    return this.__prevdef();
  };

  e.stopPropagation = function () {
    console.warn("stopPropagation", extra);
    return this.__stopprop();
  };
}

/** Returns true if event came from a touchscreen or pen device */
function eventWasTouch(e) {
  let ret = e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents;
  ret = ret || e.was_touch;
  ret = ret || e instanceof TouchEvent;
  ret = ret || e.touches !== undefined;

  if (e instanceof PointerEvent) {
    ret = ret || (e.pointerType === "pen" || e.pointerType === "touch");
  }

  return ret;
}

function copyEvent(e) {
  let ret = {};
  let keys = [];

  for (let k in e) {
    keys.push(k);
  }

  keys = keys.concat(Object.getOwnPropertySymbols(e));
  keys = keys.concat(Object.getOwnPropertyNames(e));

  for (let k of keys) {
    let v;

    try {
      v = e[k];
    } catch (error) {
      console.warn("read error for event key", k);
      continue;
    }

    if (typeof v == "function") {
      ret[k] = v.bind(e);
    } else {
      ret[k] = v;
    }
  }

  ret.original = e;

  return ret;
}

let Screen;

function _setScreenClass(cls) {
  Screen = cls;
}

function findScreen() {
  let rec = (n) => {
    for (let n2 of n.childNodes) {
      if (n2 && typeof n2 === "object" && n2 instanceof Screen) {
        return n2;
      }
    }

    for (let n2 of n.childNodes) {
      let ret = rec(n2);
      if (ret) {
        return ret;
      }
    }
  };

  return rec(document.body);
}

window._findScreen = findScreen;

let ContextAreaClass;

function _setModalAreaClass(cls) {
  ContextAreaClass = cls;
}

function pushPointerModal(obj, elem, pointerId, autoStopPropagation = true) {
  return pushModalLight(obj, autoStopPropagation, elem, pointerId);
}

function pushModalLight(obj, autoStopPropagation = true, elem, pointerId) {
  let keys;

  if (pointerId === undefined) {
    keys = new Set([
      "keydown", "keyup", "keypress", "mousedown", "mouseup", "touchstart", "touchend",
      "touchcancel", "mousewheel", "mousemove", "mouseover", "mouseout", "mouseenter",
      "mouseleave", "dragstart", "drag", "dragend", "dragexit", "dragleave", "dragover",
      "dragenter", "drop", "pointerdown", "pointermove", "pointerup", "pointercancel",
      "pointerstart", "pointerend", "pointerleave", "pointerexit", "pointerenter",
      "pointerover"
    ]);
  } else {
    keys = new Set([
      "keydown", "keyup", "keypress", "mousewheel"
    ]);
  }

  let ret = {
    keys     : keys,
    handlers : {},
    last_mpos: [0, 0]
  };

  let touchmap = {
    "touchstart" : "mousedown",
    "touchmove"  : "mousemove",
    "touchend"   : "mouseup",
    "touchcancel": "mouseup"
  };

  let mpos = [0, 0];

  let screen = findScreen();
  if (screen) {
    mpos[0] = screen.mpos[0];
    mpos[1] = screen.mpos[1];
    screen = undefined;
  }

  function handleAreaContext() {
    let screen = findScreen();
    if (screen) {
      let sarea = screen.findScreenArea(mpos[0], mpos[1]);
      if (sarea && sarea.area) {
        sarea.area.push_ctx_active();
        sarea.area.pop_ctx_active();
      }
    }
  }

  function make_default_touchhandler(type, state) {
    return function (e) {
      //console.warn("touch event!", type, touchmap[type], e.touches.length);
      if (config.DEBUG.domEvents) {
        pathDebugEvent(e);
      }

      if (touchmap[type] in ret.handlers) {
        let type2 = touchmap[type];

        let e2 = copyEvent(e);

        e2.was_touch = true;
        e2.type = type2;
        e2.button = type == "touchcancel" ? 1 : 0;
        e2.touches = e.touches;

        if (e.touches.length > 0) {
          let dpi = window.devicePixelRatio; //UIBase.getDPI();
          let t = e.touches[0];

          mpos[0] = t.pageX;
          mpos[1] = t.pageY;

          e2.pageX = e2.x = t.pageX;// * dpi;
          e2.pageY = e2.y = t.pageY;// * dpi;
          e2.clientX = t.clientX;// * dpi;
          e2.clientY = t.clientY;// * dpi;
          e2.x = t.clientX;// * dpi;
          e2.y = t.clientY;// * dpi;

          ret.last_mpos[0] = e2.x;
          ret.last_mpos[1] = e2.y;
        } else {
          e2.x = e2.clientX = e2.pageX = e2.screenX = ret.last_mpos[0];
          e2.y = e2.clientY = e2.pageY = e2.screenY = ret.last_mpos[1];
        }

        e2.was_touch = true;

        handleAreaContext();
        //console.log(e2.x, e2.y);
        ret.handlers[type2](e2);
      }

      if (autoStopPropagation) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }

  function make_handler(type, key) {
    return function (e) {
      if (config.DEBUG.domEvents) {
        pathDebugEvent(e);
      }

      if (typeof key !== "string") {
        //console.warn("key was undefined", key, type);
        return;
      }

      if (key.startsWith("mouse")) {
        mpos[0] = e.pageX;
        mpos[1] = e.pageY;
      }

      handleAreaContext();

      if (key !== undefined)
        obj[key](e);

      if (autoStopPropagation) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }

  let found = {};

  for (let k of keys) {
    let key;

    if (obj[k])
      key = k;
    else if (obj["on" + k])
      key = "on" + k;
    else if (obj["on_" + k])
      key = "on_" + k;
    else if (k in touchmap)
      continue; //default touch event handlers will be done seperately
    else
      key = undefined; //make handler that still blocks events

    //check we don't override other mouse pointer event handlers
    if (key === undefined && k.search("pointer") === 0) {
      continue;
    }

    if (key !== undefined) {
      found[k] = 1;
    }

    let handler = make_handler(k, key);
    ret.handlers[k] = handler;

    let settings = handler.settings = {passive: false, capture: true};
    window.addEventListener(k, handler, settings);
  }

  for (let k in touchmap) {
    if (!(k in found)) {
      //console.log("making touch handler for", '"' + k + '"', ret.handlers[k]);

      ret.handlers[k] = make_default_touchhandler(k, ret);

      let settings = ret.handlers[k].settings = {passive: false, capture: true};
      window.addEventListener(k, ret.handlers[k], settings);
    }
  }

  if (pointerId !== undefined) {
    ret.pointer = {
      elem, pointerId
    };

    function make_pointer(k) {
      let k2 = "on_" + k;

      ret.pointer[k] = function (e) {
        if (obj[k2] !== undefined) {
          obj[k2](e);
        }

        if (autoStopPropagation) {
          e.stopPropagation();
          e.preventDefault();
        }
      };
    }

    make_pointer("pointerdown");
    make_pointer("pointermove");
    make_pointer("pointerup");
    make_pointer("pointerstart");
    make_pointer("pointerend");
    make_pointer("pointerleave");
    make_pointer("pointerenter");
    make_pointer("pointerout");
    make_pointer("pointerover");
    make_pointer("pointerexit");
    make_pointer("pointercancel");

    for (let k in ret.pointer) {
      if (k !== "elem" && k !== "pointerId") {
        elem.addEventListener(k, ret.pointer[k]);
      }
    }

    try {
      elem.setPointerCapture(pointerId);
    } catch (error) {
      print_stack$1(error);

      console.log("attempting fallback");
      for (let k in ret.pointer) {
        if (k !== "elem" && k !== "pointerId") {
          elem.removeEventListener(k, ret.pointer[k]);
        }
      }

      delete ret.pointer;

      modalstack.push(ret);
      popModalLight(ret);

      for (let k in obj) {
        if (k === "pointercancel" || k === "pointerend" || k === "pointerstart") {
          continue;
        }

        if (k.startsWith("pointer")) {
          let k2 = k.replace(/pointer/, "mouse");
          if (k2 in obj) {
            console.warn("warning, existing mouse handler", k2);
            continue;
          }

          let v = obj[k];
          obj[k] = undefined;

          obj[k2] = v;
        }
      }

      console.log(obj);

      return pushModalLight(obj, autoStopPropagation);
    }
  }

  modalstack.push(ret);
  ContextAreaClass.lock();

  if (config.DEBUG.modalEvents) {
    console.warn("pushModalLight", ret.pointer ? "(pointer events)" : "");
  }

  return ret;
}

if (0) {
  let addevent = EventTarget.prototype.addEventListener;
  let remevent = EventTarget.prototype.removeEventListener;

  const funckey = Symbol("eventfunc");

  EventTarget.prototype.addEventListener = function (name, func, args) {
    //if (name.startsWith("key")) {
    console.warn("listener added", name, func, args);
    //}

    let func2 = function (e) {
      let proxy = new Proxy(e, {
        get(target, p, receiver) {
          if (p === "preventDefault") {
            return function () {
              console.warn("preventDefault", name, arguments);
              return e.preventDefault(...arguments);
            }
          } else if (p === "stopPropagation") {
            return function () {
              console.warn("stopPropagation", name, arguments);
              return e.preventDefault(...arguments);
            }
          }

          return e[p];
        }
      });

      return func.call(this, proxy);
    };

    func[funckey] = func2;

    return addevent.call(this, name, func2, args);
  };

  EventTarget.prototype.removeEventListener = function (name, func, args) {
    //if (name.startsWith("key")) {
    console.warn("listener removed", name, func, args);
    //}

    func = func[funckey];

    return remevent.call(this, name, func, args);
  };
}

function popModalLight(state) {
  if (state === undefined) {
    console.warn("Bad call to popModalLight: state was undefined");
    return;
  }

  if (state !== modalstack[modalstack.length - 1]) {
    if (modalstack.indexOf(state) < 0) {
      console.warn("Error in popModalLight; modal handler not found");
      return;
    } else {
      console.warn("Error in popModalLight; called in wrong order");
    }
  }

  for (let k in state.handlers) {
    //console.log(k);
    window.removeEventListener(k, state.handlers[k], state.handlers[k].settings);
  }

  state.handlers = {};
  modalstack.remove(state);
  ContextAreaClass.unlock();

  if (config.DEBUG.modalEvents) {
    console.warn("popModalLight", modalstack, state.pointer ? "(pointer events)" : "");
  }

  if (state.pointer) {
    let elem = state.pointer.elem;

    for (let k in state.pointer) {
      if (k !== "elem" && k !== "pointerId") {
        elem.removeEventListener(k, state.pointer[k]);
      }
    }

    try {
      elem.releasePointerCapture(state.pointer.pointerId);
    } catch (error) {
      print_stack$1(error);
    }
  }
}

function haveModal() {
  return modalstack.length > 0;
}

window._haveModal = haveModal; //for debugging console

var keymap_latin_1 = {
  "Space" : 32,
  "Escape": 27,
  "Enter" : 13,
  "Return": 13,
  "Up"    : 38,
  "Down"  : 40,
  "Left"  : 37,
  "Right" : 39,

  "Num0"     : 96,
  "Num1"     : 97,
  "Num2"     : 98,
  "Num3"     : 99,
  "Num4"     : 100,
  "Num5"     : 101,
  "Num6"     : 102,
  "Num7"     : 103,
  "Num8"     : 104,
  "Num9"     : 105,
  "Home"     : 36,
  "End"      : 35,
  "Delete"   : 46,
  "Backspace": 8,
  "Insert"   : 45,
  "PageUp"   : 33,
  "PageDown" : 34,
  "Tab"      : 9,
  "-"        : 189,
  "="        : 187,
  "."        : 190,
  "/"        : 191,
  ","        : 188,
  ";"        : 186,
  "'"        : 222,
  "["        : 219,
  "]"        : 221,
  "NumPlus"  : 107,
  "NumMinus" : 109,
  "Shift"    : 16,
  "Ctrl"     : 17,
  "Control"  : 17,
  "Alt"      : 18
};

for (var i$1 = 0; i$1 < 26; i$1++) {
  keymap_latin_1[String.fromCharCode(i$1 + 65)] = i$1 + 65;
}
for (var i$1 = 0; i$1 < 10; i$1++) {
  keymap_latin_1[String.fromCharCode(i$1 + 48)] = i$1 + 48;
}

for (var k$1 in keymap_latin_1) {
  if (!(k$1 in keymap_latin_1)) {
    keymap_latin_1[keymap_latin_1[k$1]] = k$1;
  }
}

var keymap_latin_1_rev = {};
for (var k$1 in keymap_latin_1) {
  keymap_latin_1_rev[keymap_latin_1[k$1]] = k$1;
}

var keymap = keymap_latin_1;
var reverse_keymap = keymap_latin_1_rev;

class HotKey {
  /**action can be a callback or a toolpath string*/
  constructor(key, modifiers, action, uiname) {
    this.action = action;
    this.mods = modifiers;
    this.key = keymap[key];
    this.uiname = uiname;
  }

  exec(ctx) {
    if (typeof this.action == "string") {
      ctx.api.execTool(ctx, this.action);
    } else {
      this.action(ctx);
    }
  }

  buildString() {
    let s = "";

    for (let i = 0; i < this.mods.length; i++) {
      if (i > 0) {
        s += " + ";
      }

      let k = this.mods[i].toLowerCase();
      k = k[0].toUpperCase() + k.slice(1, k.length).toLowerCase();

      s += k;
    }

    if (this.mods.length > 0) {
      s += "+";
    }

    s += reverse_keymap[this.key];

    return s.trim();
  }
}

class KeyMap extends Array {
  /**
   *
   * @param pathid{string} Id of keymap, used when patching hotkeys, when
   *                       that is implemented
   * */
  constructor(hotkeys = [], pathid = "undefined") {
    super();

    this.pathid = pathid;

    for (let hk of hotkeys) {
      this.add(hk);
    }
  }

  handle(ctx, e) {
    let mods = new set$1();
    if (e.shiftKey)
      mods.add("shift");
    if (e.altKey)
      mods.add("alt");
    if (e.ctrlKey) {
      mods.add("ctrl");
    }
    if (e.commandKey) {
      mods.add("command");
    }

    for (let hk of this) {
      let ok = e.keyCode === hk.key;
      if (!ok) continue;

      let count = 0;
      for (let m of hk.mods) {
        m = m.toLowerCase().trim();

        if (!mods.has(m)) {
          ok = false;
          break;
        }

        count++;
      }

      if (count !== mods.length) {
        ok = false;
      }

      if (ok) {
        try {
          hk.exec(ctx);
        } catch (error) {
          print_stack$1(error);
          console.log("failed to execute a hotkey", keymap[e.keyCode]);
        }
        return true;
      }
    }
  }

  add(hk) {
    this.push(hk);
  }

  push(hk) {
    super.push(hk);
  }
}

"use strict";

class EventDispatcher {
  constructor() {
    this._cbs = {};
  }

  _fireEvent(type, data) {
    let stop = false;

    data = {
      stopPropagation() {
        stop = true;
      },

      data : data
    };

    if (type in this._cbs) {
      for (let cb of this._cbs[type]) {
        cb(data);
        if (stop) {
          break;
        }
      }
    }
  }

  on(type, cb) {
    if (!(type in this._cbs)) {
      this._cbs[type] = [];
    }

    this._cbs[type].push(cb);
    return this;
  }

  off(type, cb) {
    if (!(type in this._cbs)) {
      console.warn("event handler not in list", type, cb);
      return this;
    }

    let stack = this._cbs[type];
    if (stack.indexOf(cb) < 0) {
      console.warn("event handler not in list", type, cb);
      return this;
    }

    stack.remove(cb);
    return this;
  }
}
function copyMouseEvent(e) {
  let ret = {};
  
  function bind(func, obj) {
    return function() {
      return this._orig.apply(func, arguments);
    }
  }
  
  let exclude = new Set([
    //"prototype",
    //"constructor",
    "__proto__"
  ]);
  
  ret._orig = e;
  
  for (let k in e) {
    let v = e[k];
    
    if (exclude.has(k)) {
      continue;
    }
    
    if (typeof v == "function") {
      v = bind(v);
    }
    
    ret[k] = v;
  }

  ret.ctrlKey = e.ctrlKey;
  ret.shiftKey = e.shiftKey;
  ret.altKey = e.altKey;

  for (let i=0; i<2; i++) {
    let key = i ? "targetTouches" : "touches";

    if (e[key]) {
      ret[key] = [];

      for (let t of e[key]) {
        let t2 = {};
        ret[key].push(t2);

        for (let k in t) {
          t2[k] = t[k];
        }
      }
    }
  }

  return ret;
}

const DomEventTypes = {
  on_mousemove   : 'mousemove',
  on_mousedown   : 'mousedown',
  on_mouseup     : 'mouseup',
  on_touchstart  : 'touchstart',
  on_touchcancel : 'touchcanel',
  on_touchmove   : 'touchmove',
  on_touchend    : 'touchend',
  on_mousewheel  : 'mousewheel',
  on_keydown     : 'keydown',
  on_keyup       : 'keyup',
  on_pointerdown : 'pointerdown',
  on_pointermove : 'pointermove',
  on_pointercancel : 'pointercancel',
  on_pointerup   : 'pointerup',

  //on_keypress    : 'keypress'
};

function getDom(dom, eventtype) {
  if (eventtype.startsWith("key"))
    return window;
  return dom;
}

let modalStack = [];
function isModalHead(owner) {
  return modalStack.length === 0 ||
         modalStack[modalStack.length-1] === owner;
}

class EventHandler {
  pushPointerModal(dom, pointerId) {
    this._modalstate = pushPointerModal(this, dom, pointerId);
  }
  pushModal(dom, _is_root) {
    this._modalstate = pushModalLight(this);
  }
  
  popModal() {
    if (this._modalstate !== undefined) {
      let modalstate = this._modalstate;

      //window.setTimeout(() => {
        popModalLight(modalstate);
      //});

      this._modalstate = undefined;
    }
  }
}

function pushModal(dom, handlers) {
  console.warn("Deprecated call to pathux.events.pushModal; use api in simple_events.js instead");
  let h = new EventHandler();
  
  for (let k in handlers) {
    h[k] = handlers[k];
  }
  
  handlers.popModal = () => {
    return h.popModal(dom);
  };
  
  h.pushModal(dom, false);
  
  return h;
}

const CurveConstructors = [];
const CURVE_VERSION = 1.0;

const CurveFlags = {
  SELECT: 1
};


const TangentModes = {
  SMOOTH: 1,
  BREAK : 2
};

function getCurve(type, throw_on_error = true) {
  for (let cls of CurveConstructors) {
    if (cls.name === type)
      return cls;
    if (cls.define().name === type)
      return cls;
  }

  if (throw_on_error) {
    throw new Error("Unknown curve type " + type)
  } else {
    console.warn("Unknown curve type", type);
    return getCurve("ease");
  }
}

let _udigest = new HashDigest();

class CurveTypeData {
  constructor() {
    this.type = this.constructor.define().typeName;
  }

  get hasGUI() {
    throw new Error("get hasGUI(): implement me!");
  }

  static register(cls) {
    if (cls.define === CurveTypeData.define) {
      throw new Error("missing define() static method");
    }

    let def = cls.define();

    if (!def.name) {
      throw new Error(cls.name + ".define() result is missing 'name' field");
    }

    if (!def.typeName) {
      throw new Error(cls.name + ".define() is missing .typeName, which should equal class name; needed for minificaiton");
    }

    CurveConstructors.push(cls);
  }

  static define() {
    return {
      uiname  : "Some Curve",
      name    : "somecurve",
      typeName: CurveTypeData
    }
  }

  calcHashKey(digest = _udigest.reset()) {
    let d = digest;

    d.add(this.type);

    return d.get();
  }

  toJSON() {
    return {
      type: this.type
    }
  }

  equals(b) {
    return this.type === b.type;
  }

  loadJSON(obj) {
    this.type = obj.type;

    return this;
  }

  redraw() {
    if (this.parent)
      this.parent.redraw();
  }

  makeGUI(container) {

  }

  killGUI(container) {
    container.clear();
  }

  evaluate(s) {
    throw new Error("implement me!");
  }

  integrate(s1, quadSteps = 64) {
    let ret = 0.0, ds = s1/quadSteps;

    for (let i = 0, s = 0; i < quadSteps; i++, s += ds) {
      ret += this.evaluate(s)*ds;
    }

    return ret;
  }

  derivative(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.evaluate(s) - this.evaluate(s - df))/df;
    } else if (s < df*3) {
      return (this.evaluate(s + df) - this.evaluate(s))/df;
    } else {
      return (this.evaluate(s + df) - this.evaluate(s - df))/(2*df);
    }
  }

  derivative2(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.derivative(s) - this.derivative(s - df))/df;
    } else if (s < df*3) {
      return (this.derivative(s + df) - this.derivative(s))/df;
    } else {
      return (this.derivative(s + df) - this.derivative(s - df))/(2*df);
    }
  }

  inverse(y) {
    let steps = 9;
    let ds = 1.0/steps, s = 0.0;
    let best = undefined;
    let ret = undefined;

    for (let i = 0; i < steps; i++, s += ds) {
      let s1 = s, s2 = s + ds;

      let mid;

      for (let j = 0; j < 11; j++) {
        let y1 = this.evaluate(s1);
        let y2 = this.evaluate(s2);
        mid = (s1 + s2)*0.5;

        if (Math.abs(y1 - y) < Math.abs(y2 - y)) {
          s2 = mid;
        } else {
          s1 = mid;
        }
      }

      let ymid = this.evaluate(mid);

      if (best === undefined || Math.abs(y - ymid) < best) {
        best = Math.abs(y - ymid);
        ret = mid;
      }
    }

    return ret === undefined ? 0.0 : ret;
  }

  onActive(parent, draw_transform) {
  }

  onInactive(parent, draw_transform) {
  }

  reset() {

  }

  destroy() {
  }

  update() {
    if (this.parent)
      this.parent._on_change();
  }

  draw(canvas, g, draw_transform) {
  }

  loadSTRUCT(reader) {
    reader(this);
  }
}

CurveTypeData.STRUCT = `
CurveTypeData {
  type : string;
}
`;
nstructjs.register(CurveTypeData);


function evalHermiteTable(table, t) {
  let s = t*(table.length/4);

  let i = Math.floor(s);
  s -= i;

  i *= 4;

  let a = table[i] + (table[i + 1] - table[i])*s;
  let b = table[i + 2] + (table[i + 3] - table[i + 2])*s;

  return a + (b - a)*s;
  //return table[i] + (table[i + 3] - table[i])*s;
}

function genHermiteTable(evaluate, steps) {
  //console.log("building spline approx");

  let table = new Array(steps);

  let eps = 0.00001;
  let dt = (1.0 - eps*4.001)/(steps - 1);
  let t = eps*4;
  let lastdv1, lastf3;

  for (let j = 0; j < steps; j++, t += dt) {
    //let f1 = evaluate(t - eps*2);
    let f2 = evaluate(t - eps);
    let f3 = evaluate(t);
    let f4 = evaluate(t + eps);
    //let f5 = evaluate(t + eps*2);

    let dv1 = (f4 - f2)/(eps*2);
    dv1 /= steps;

    if (j > 0) {
      let j2 = j - 1;

      table[j2*4] = lastf3;
      table[j2*4 + 1] = lastf3 + lastdv1/3.0;
      table[j2*4 + 2] = f3 - dv1/3.0;
      table[j2*4 + 3] = f3;
    }

    lastdv1 = dv1;
    lastf3 = f3;
  }

  return table;
}

"use strict";
//import {EventDispatcher} from "../util/events.js";

let Vector2$1 = Vector2;

const SplineTemplates = {
  CONSTANT      : 0,
  LINEAR        : 1,
  SHARP         : 2,
  SQRT          : 3,
  SMOOTH        : 4,
  SMOOTHER      : 5,
  SHARPER       : 6,
  SPHERE        : 7,
  REVERSE_LINEAR: 8,
  GUASSIAN      : 9
};

const templates = {
  [SplineTemplates.CONSTANT]      : [
    [1, 1], [1, 1]
  ],
  [SplineTemplates.LINEAR]        : [
    [0, 0], [1, 1]
  ],
  [SplineTemplates.SHARP]         : [
    [0, 0], [0.9999, 0.0001], [1, 1]
  ],
  [SplineTemplates.SQRT]          : [
    [0, 0], [0.05, 0.25], [0.33, 0.65], [1, 1]
  ],
  [SplineTemplates.SMOOTH]        : [
    "DEG", 2, [0, 0], [1.0/3.0, 0], [2.0/3.0, 1.0], [1, 1]
  ],
  [SplineTemplates.SMOOTHER]      : [
    "DEG", 6, [0, 0], [1.0/2.25, 0], [2.0/3.0, 1.0], [1, 1]
  ],
  [SplineTemplates.SHARPER]       : [
    [0, 0], [0.3, 0.03], [0.7, 0.065], [0.9, 0.16], [1, 1]
  ],
  [SplineTemplates.SPHERE]        : [
    [0, 0], [0.01953, 0.23438], [0.08203, 0.43359], [0.18359, 0.625], [0.35938, 0.81641], [0.625, 0.97656], [1, 1]
  ],
  [SplineTemplates.REVERSE_LINEAR]: [
    [0, 1], [1, 0]
  ],
  [SplineTemplates.GUASSIAN]      : [
    "DEG", 5, [0, 0], [0.17969, 0.007], [0.48958, 0.01172], [0.77995, 0.99609], [1, 1]
  ]
};

//is initialized below
const SplineTemplateIcons = {};

let RecalcFlags = {
  BASIS: 1,
  FULL : 2,
  ALL  : 3,

  //private flag
  FULL_BASIS: 4
};

function mySafeJSONStringify(obj) {
  return JSON.stringify(obj.toJSON(), function (key) {
    let v = this[key];

    if (typeof v === "number") {
      if (v !== Math.floor(v)) {
        v = parseFloat(v.toFixed(5));
      } else {
        v = v;
      }
    }

    return v;
  });
}

function mySafeJSONParse(buf) {
  return JSON.parse(buf, (key, val) => {

  });
};

window.mySafeJSONStringify = mySafeJSONStringify;


let bin_cache = {};
window._bin_cache = bin_cache;

let eval2_rets = cachering$1.fromConstructor(Vector2$1, 32);

/*
  I hate these stupid curve widgets.  This horrible one here works by
  root-finding the x axis on a two dimensional b-spline (which works
  surprisingly well).
*/

function bez3(a, b, c, t) {
  let r1 = a + (b - a)*t;
  let r2 = b + (c - b)*t;

  return r1 + (r2 - r1)*t;
}

function bez4(a, b, c, d, t) {
  let r1 = bez3(a, b, c, t);
  let r2 = bez3(b, c, d, t);

  return r1 + (r2 - r1)*t;
}

function binomial(n, i) {
  if (i > n) {
    throw new Error("Bad call to binomial(n, i), i was > than n");
  }

  if (i === 0 || i === n) {
    return 1;
  }

  let key = "" + n + "," + i;

  if (key in bin_cache)
    return bin_cache[key];

  let ret = binomial(n - 1, i - 1) + bin(n - 1, i);
  bin_cache[key] = ret;

  return ret;
}

window.bin = binomial;

class Curve1DPoint extends Vector2$1 {
  constructor(co) {
    super(co);

    this.rco = new Vector2$1(co);
    this.sco = new Vector2$1(co);

    //for transform
    this.startco = new Vector2$1();
    this.eid = -1;
    this.flag = 0;

    this.tangent = TangentModes.SMOOTH;

    Object.seal(this);
  }

  set deg(v) {
    console.warn("old file data detected");
  }

  static fromJSON(obj) {
    let ret = new Curve1DPoint(obj);

    ret.eid = obj.eid;
    ret.flag = obj.flag;
    ret.tangent = obj.tangent;

    ret.rco.load(obj.rco);

    return ret;
  }

  copy() {
    let ret = new Curve1DPoint(this);

    ret.tangent = this.tangent;
    ret.flag = this.flag;
    ret.eid = this.eid;

    ret.startco.load(this.startco);
    ret.rco.load(this.rco);
    ret.sco.load(this.sco);

    return ret;
  }

  toJSON() {
    return {
      0: this[0],
      1: this[1],

      eid    : this.eid,
      flag   : this.flag,
      tangent: this.tangent,

      rco: this.rco
    };
  }

  loadSTRUCT(reader) {
    reader(this);

    this.sco.load(this);
    this.rco.load(this);

    splineCache.update(this);
  }
};
Curve1DPoint.STRUCT = `
Curve1DPoint {
  0       : float;
  1       : float;
  eid     : int;
  flag    : int;
  tangent : int;
  rco     : vec2;
}
`;
nstructjs.register(Curve1DPoint);

let _udigest$1 = new HashDigest();

class BSplineCache {
  constructor() {
    this.curves = [];
    this.map = new Map();
    this.maxCurves = 32;
    this.gen = 0;
  }

  limit() {
    if (this.curves.length <= this.maxCurves) {
      return;
    }

    this.curves.sort((a, b) => b.cache_w - a.cache_w);
    while (this.curves.length > this.maxCurves) {
      let curve = this.curves.pop();
      this.map.delete(curve.calcHashKey());
    }
  }

  has(curve) {
    let curve2 = this.map.get(curve.calcHashKey());
    return curve2 && curve2.equals(curve);
  }

  get(curve) {
    let key = curve.calcHashKey();
    curve._last_cache_key = key;

    let curve2 = this.map.get(key);
    if (curve2 && curve2.equals(curve)) {
      curve2.cache_w = this.gen++;
      return curve2;
    }

    curve2 = curve.copy();
    curve2._last_cache_key = key;

    curve2.updateKnots();
    curve2.regen_basis();
    curve2.regen_hermite();

    this.map.set(curve2);
    this.curves.push(curve2);

    curve2.cache_w = this.gen++;

    this.limit();

    return curve2;
  }

  _remove(key) {
    let curve = this.map.get(key);
    this.map.delete(key);
    this.curves.remove(curve);
  }

  update(curve) {
    let key = curve._last_cache_key;

    if (this.map.has(key)) {
      this._remove(curve);
      this.get(curve);
    }
  }
}

let splineCache = new BSplineCache();
window._splineCache = splineCache;

class BSplineCurve extends CurveTypeData {
  constructor() {
    super();

    this.cache_w = 0;
    this._last_cache_key = 0;

    this._last_update_key = "";

    this.fastmode = false;
    this.points = [];
    this.length = 0;
    this.interpolating = false;

    this.range = [new Vector2$1([0, 1]), new Vector2$1([0, 1])];

    this._ps = [];
    this.hermite = [];
    this.fastmode = false;

    this.deg = 6;
    this.recalc = RecalcFlags.ALL;
    this.basis_tables = [];
    this.eidgen = new IDGen();

    this.add(0, 0);
    this.add(1, 1);

    this.mpos = new Vector2$1();

    this.on_mousedown = this.on_mousedown.bind(this);
    this.on_mousemove = this.on_mousemove.bind(this);
    this.on_mouseup = this.on_mouseup.bind(this);
    this.on_keydown = this.on_keydown.bind(this);
    this.on_touchstart = this.on_touchstart.bind(this);
    this.on_touchmove = this.on_touchmove.bind(this);
    this.on_touchend = this.on_touchend.bind(this);
    this.on_touchcancel = this.on_touchcancel.bind(this);
  }

  get hasGUI() {
    return this.uidata !== undefined;
  }

  static define() {
    return {
      uiname  : "B-Spline",
      name    : "bspline",
      typeName: "BSplineCurve"
    }
  }

  calcHashKey(digest = _udigest$1.reset()) {
    let d = digest;

    super.calcHashKey(d);

    d.add(this.deg);
    d.add(this.interpolating);

    for (let p of this.points) {
      let x = ~~(p[0]*1024);
      let y = ~~(p[1]*1024);

      d.add(x);
      d.add(y);
      d.add(p.tangent); //is an enum
    }

    d.add(this.range[0][0]);
    d.add(this.range[0][1]);
    d.add(this.range[1][0]);
    d.add(this.range[1][1]);

    return d.get();
  }

  copyTo(b) {
    b.deg = this.deg;
    b.interpolating = this.interpolating;
    b.fastmode = this.fastmode;

    for (let p of this.points) {
      let p2 = p.copy();

      b.points.push(p2);
    }

    return b;
  }

  copy() {
    let curve = new BSplineCurve();
    this.copyTo(curve);
    return curve;
  }

  equals(b) {
    if (b.type !== this.type) {
      return false;
    }

    let bad = this.points.length !== b.points.length;

    bad = bad || this.deg !== b.deg;
    bad = bad || this.interpolating !== b.interpolating;

    if (bad) {
      return false;
    }

    for (let i = 0; i < this.points.length; i++) {
      let p1 = this.points[i];
      let p2 = b.points[i];

      let dist = p1.vectorDistance(p2);

      if (p1.vectorDistance(p2) > 0.00001) {
        return false;
      }

      if (p1.tangent !== p2.tangent) {
        return false;
      }
    }

    return true;
  }

  remove(p) {
    let ret = this.points.remove(p);
    this.length = this.points.length;

    return ret;
  }

  add(x, y, no_update = false) {
    let p = new Curve1DPoint();
    this.recalc = RecalcFlags.ALL;

    p.eid = this.eidgen.next();

    p[0] = x;
    p[1] = y;

    p.sco.load(p);
    p.rco.load(p);

    this.points.push(p);
    if (!no_update) {
      this.update();
    }

    this.length = this.points.length;

    return p;
  }

  update() {
    super.update();
  }

  _sortPoints() {
    if (!this.interpolating) {
      for (let i = 0; i < this.points.length; i++) {
        this.points[i].rco.load(this.points[i]);
      }
    }

    this.points.sort(function (a, b) {
      return a[0] - b[0];
    });

    return this;
  }

  updateKnots(recalc = true, points = this.points) {
    if (recalc) {
      this.recalc = RecalcFlags.ALL;
    }

    this._sortPoints();

    this._ps = [];
    if (points.length < 2) {
      return;
    }
    let a = points[0][0], b = points[points.length - 1][0];

    for (let i = 0; i < points.length - 1; i++) {
      this._ps.push(points[i]);
    }

    if (points.length < 3) {
      return;
    }

    let l1 = points[points.length - 1];
    let l2 = points[points.length - 2];

    let p = l1.copy();
    p.rco[0] = l1.rco[0] - 0.00004;
    p.rco[1] = l2.rco[1] + (l1.rco[1] - l2.rco[1])/3.0;
    //this._ps.push(p);

    p = l1.copy();
    p.rco[0] = l1.rco[0] - 0.00003;
    p.rco[1] = l2.rco[1] + (l1.rco[1] - l2.rco[1])/3.0;
    //this._ps.push(p);

    p = l1.copy();
    p.rco[0] = l1.rco[0] - 0.00001;
    p.rco[1] = l2.rco[1] + (l1.rco[1] - l2.rco[1])/3.0;
    this._ps.push(p);

    p = l1.copy();
    p.rco[0] = l1.rco[0] - 0.00001;
    p.rco[1] = l2.rco[1] + (l1.rco[1] - l2.rco[1])*2.0/3.0;
    this._ps.push(p);

    this._ps.push(l1);

    if (!this.interpolating) {
      for (let i = 0; i < this._ps.length; i++) {
        this._ps[i].rco.load(this._ps[i]);
      }
    }

    for (let i = 0; i < points.length; i++) {
      let p = points[i];
      let x = p[0], y = p[1];//this.evaluate(x);

      p.sco[0] = x;
      p.sco[1] = y;
    }
  }

  toJSON() {
    this._sortPoints();

    let ret = super.toJSON();

    ret = Object.assign(ret, {
      points       : this.points.map(p => p.toJSON()),
      deg          : this.deg,
      interpolating: this.interpolating,
      eidgen       : this.eidgen.toJSON(),
      range        : this.range
    });

    return ret;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    this.interpolating = obj.interpolating;
    this.deg = obj.deg;

    this.length = 0;
    this.points = [];
    this._ps = [];

    if (obj.range) {
      this.range = [new Vector2$1(obj.range[0]), new Vector2$1(obj.range[1])];
    }

    this.hightlight = undefined;
    this.eidgen = IDGen.fromJSON(obj.eidgen);
    this.recalc = RecalcFlags.ALL;
    this.mpos = [0, 0];

    for (let i = 0; i < obj.points.length; i++) {
      this.points.push(Curve1DPoint.fromJSON(obj.points[i]));
    }

    this.updateKnots();
    this.redraw();

    return this;
  }

  basis(t, i) {
    if (this.recalc & RecalcFlags.FULL_BASIS) {
      return this._basis(t, i);
    }

    if (this.recalc & RecalcFlags.BASIS) {
      this.regen_basis();
      this.recalc &= ~RecalcFlags.BASIS;
    }

    i = Math.min(Math.max(i, 0), this._ps.length - 1);
    t = Math.min(Math.max(t, 0.0), 1.0)*0.999999999;

    let table = this.basis_tables[i];

    let s = t*(table.length/4)*0.99999;

    let j = ~~s;
    s -= j;

    j *= 4;
    return table[j] + (table[j + 3] - table[j])*s;

    return bez4(table[j], table[j + 1], table[j + 2], table[j + 3], s);
  }

  reset(empty = false) {
    this.length = 0;
    this.points = [];
    this._ps = [];

    if (!empty) {
      this.add(0, 0, true);
      this.add(1, 1, true);
    }

    this.recalc = 1;
    this.updateKnots();
    this.update();

    return this;
  }

  regen_hermite(steps) {
    if (splineCache.has(this)) {
      console.log("loading spline approx from cached bspline data");

      this.hermite = splineCache.get(this).hermite;
      return;
    }

    if (steps === undefined) {
      steps = this.fastmode ? 120 : 340;
    }

    if (this.interpolating) {
      steps *= 2;
    }

    this.hermite = new Array(steps);
    let table = this.hermite;

    let eps = 0.00001;
    let dt = (1.0 - eps*4.001)/(steps - 1);
    let t = eps*4;
    let lastdv1, lastf3;

    for (let j = 0; j < steps; j++, t += dt) {
      let f1 = this._evaluate(t - eps*2);
      let f2 = this._evaluate(t - eps);
      let f3 = this._evaluate(t);
      let f4 = this._evaluate(t + eps);
      let f5 = this._evaluate(t + eps*2);

      let dv1 = (f4 - f2)/(eps*2);
      dv1 /= steps;

      if (j > 0) {
        let j2 = j - 1;

        table[j2*4] = lastf3;
        table[j2*4 + 1] = lastf3 + lastdv1/3.0;
        table[j2*4 + 2] = f3 - dv1/3.0;
        table[j2*4 + 3] = f3;
      }

      lastdv1 = dv1;
      lastf3 = f3;
    }
  }

  solve_interpolating() {
    //this.recalc |= RecalcFlags.FULL_BASIS;

    for (let p of this._ps) {
      p.rco.load(p);
    }

    let points = this.points.concat(this.points);


    this._evaluate2(0.5);

    let error1 = (p) => {
      //return p.vectorDistance(this._evaluate2(p[0]));
      return this._evaluate(p[0]) - p[1];
    };

    let error = (p) => {
      return error1(p);

      /*
      let err = 0.0;
      for (let p of this.points) {
        //err += error1(p)**2;
        err += Math.abs(error1(p));
      }

      //return Math.sqrt(err);
      return err;
      //*/
    };

    let err = 0.0;
    let g = new Vector2$1();

    for (let step = 0; step < 25; step++) {
      err = 0.0;

      for (let p of this._ps) {
        let r1 = error(p);
        const df = 0.000001;

        err += Math.abs(r1);

        if (p === this._ps[this._ps.length - 1]) {
          continue;
        }

        g.zero();

        for (let i = 0; i < 2; i++) {
          let orig = p.rco[i];
          p.rco[i] += df;
          let r2 = error(p);
          p.rco[i] = orig;

          g[i] = (r2 - r1)/df;
        }

        let totgs = g.dot(g);

        if (totgs < 0.00000001) {
          continue;
        }

        r1 /= totgs;
        let k = 0.5;

        p.rco[0] += -r1*g[0]*k;
        p.rco[1] += -r1*g[1]*k;
      }

      let th = this.fastmode ? 0.001 : 0.00005;
      if (err < th) {
        break;
      }
    }

    //this.recalc &= ~RecalcFlags.FULL_BASIS;
  }

  regen_basis() {
    if (splineCache.has(this)) {
      console.log("loading from cached bspline data");

      this.basis_tables = splineCache.get(this).basis_tables;
      return;
    }

    //let steps = this.fastmode && !this.interpolating ? 64 : 128;
    let steps = this.fastmode ? 64 : 128;

    if (this.interpolating) {
      steps *= 2;
    }

    this.basis_tables = new Array(this._ps.length);

    for (let i = 0; i < this._ps.length; i++) {
      let table = this.basis_tables[i] = new Array((steps - 1)*4);

      let eps = 0.00001;
      let dt = (1.0 - eps*8)/(steps - 1);
      let t = eps*4;
      let lastdv1 = 0.0, lastf3 = 0.0;

      for (let j = 0; j < steps; j++, t += dt) {
        //let f1 = this._basis(t - eps*2, i);
        let f2 = this._basis(t - eps, i);
        let f3 = this._basis(t, i);
        let f4 = this._basis(t + eps, i);
        //let f5 = this._basis(t + eps*2, i);

        let dv1 = (f4 - f2)/(eps*2);
        dv1 /= steps;

        if (j > 0) {
          let j2 = j - 1;

          table[j2*4] = lastf3;
          table[j2*4 + 1] = lastf3 + lastdv1/3.0;
          table[j2*4 + 2] = f3 - dv1/3.0;
          table[j2*4 + 3] = f3;
        }

        lastdv1 = dv1;
        lastf3 = f3;
      }
    }
  }

  _basis(t, i) {
    let len = this._ps.length;
    let ps = this._ps;

    function safe_inv(n) {
      return n === 0 ? 0 : 1.0/n;
    }

    function bas(s, i, n) {
      let kp = Math.min(Math.max(i - 1, 0), len - 1);
      let kn = Math.min(Math.max(i + 1, 0), len - 1);
      let knn = Math.min(Math.max(i + n, 0), len - 1);
      let knn1 = Math.min(Math.max(i + n + 1, 0), len - 1);
      let ki = Math.min(Math.max(i, 0), len - 1);

      if (n === 0) {
        return s >= ps[ki].rco[0] && s < ps[kn].rco[0] ? 1 : 0;
      } else {

        let a = (s - ps[ki].rco[0])*safe_inv(ps[knn].rco[0] - ps[ki].rco[0] + 0.0001);
        let b = (ps[knn1].rco[0] - s)*safe_inv(ps[knn1].rco[0] - ps[kn].rco[0] + 0.0001);

        return a*bas(s, i, n - 1) + b*bas(s, i + 1, n - 1);
      }
    }

    let p = this._ps[i].rco, nk, pk;
    let deg = this.deg;

    let b = bas(t, i - deg, deg);

    return b;
  }

  evaluate(t) {
    let a = this.points[0].rco, b = this.points[this.points.length - 1].rco;

    if (t < a[0]) return a[1];
    if (t > b[0]) return b[1];

    if (this.points.length === 2) {
      t = (t - a[0])/(b[0] - a[0]);
      return a[1] + (b[1] - a[1])*t;
    }

    if (this.recalc) {
      this.regen_basis();

      if (this.interpolating) {
        this.solve_interpolating();
      }

      this.regen_hermite();
      this.recalc = 0;
    }

    t *= 0.999999;

    let table = this.hermite;
    let s = t*(table.length/4);

    let i = Math.floor(s);
    s -= i;

    i *= 4;

    return table[i] + (table[i + 3] - table[i])*s;
  }

  _evaluate(t) {
    let start_t = t;

    if (this.points.length > 1) {
      let a = this.points[0], b = this.points[this.points.length - 1];

      //if (t < a[0]) return a[1];
      //if (t >= b[0]) return b[1];
    }

    for (let i = 0; i < 35; i++) {
      let df = 0.0001;
      let ret1 = this._evaluate2(t < 0.5 ? t : t - df);
      let ret2 = this._evaluate2(t < 0.5 ? t + df : t);

      let f1 = Math.abs(ret1[0] - start_t);
      let f2 = Math.abs(ret2[0] - start_t);
      let g = (f2 - f1)/df;

      if (f1 === f2) break;

      //if (f1 < 0.0005) break;

      if (f1 === 0.0 || g === 0.0)
        return this._evaluate2(t)[1];

      let fac = -(f1/g)*0.5;
      if (fac === 0.0) {
        fac = 0.01;
      } else if (Math.abs(fac) > 0.1) {
        fac = 0.1*Math.sign(fac);
      }

      t += fac;
      let eps = 0.00001;
      t = Math.min(Math.max(t, eps), 1.0 - eps);
    }

    return this._evaluate2(t)[1];
  }

  _evaluate2(t) {
    let ret = eval2_rets.next();

    t *= 0.9999999;

    let totbasis = 0;
    let sumx = 0;
    let sumy = 0;

    for (let i = 0; i < this._ps.length; i++) {
      let p = this._ps[i].rco;
      let b = this.basis(t, i);

      sumx += b*p[0];
      sumy += b*p[1];

      totbasis += b;
    }

    if (totbasis !== 0.0) {
      sumx /= totbasis;
      sumy /= totbasis;
    }

    ret[0] = sumx;
    ret[1] = sumy;

    return ret;
  }

  _wrapTouchEvent(e) {
    return {
      x              : e.touches.length ? e.touches[0].pageX : this.mpos[0],
      y              : e.touches.length ? e.touches[0].pageY : this.mpos[1],
      button         : 0,
      shiftKey       : e.shiftKey,
      altKey         : e.altKey,
      ctrlKey        : e.ctrlKey,
      isTouch        : true,
      commandKey     : e.commandKey,
      stopPropagation: () => e.stopPropagation(),
      preventDefault : () => e.preventDefault()
    };
  }

  on_touchstart(e) {
    this.mpos[0] = e.touches[0].pageX;
    this.mpos[1] = e.touches[0].pageY;

    let e2 = this._wrapTouchEvent(e);

    this.on_mousemove(e2);
    this.on_mousedown(e2);
  }

  loadTemplate(templ) {
    if (templ === undefined || !templates[templ]) {
      console.warn("Unknown bspline template", templ);
      return;
    }

    templ = templates[templ];

    this.reset(true);
    this.deg = 3.0;

    for (let i = 0; i < templ.length; i++) {
      let p = templ[i];

      if (p === "DEG") {
        this.deg = templ[i + 1];
        i++;
        continue;
      }

      this.add(p[0], p[1], true);
    }

    this.recalc = 1;
    this.updateKnots();
    this.update();
    this.redraw();
  }

  on_touchmove(e) {
    this.mpos[0] = e.touches[0].pageX;
    this.mpos[1] = e.touches[0].pageY;

    let e2 = this._wrapTouchEvent(e);
    this.on_mousemove(e2);
  }

  on_touchend(e) {
    this.on_mouseup(this._wrapTouchEvent(e));
  }

  on_touchcancel(e) {
    this.on_touchend(e);
  }

  makeGUI(container, canvas, drawTransform) {
    this.uidata = {
      start_mpos : new Vector2$1(),
      transpoints: [],

      dom         : container,
      canvas      : canvas,
      g           : canvas.g,
      transforming: false,
      draw_trans  : drawTransform
    };

    canvas.addEventListener("touchstart", this.on_touchstart);
    canvas.addEventListener("touchmove", this.on_touchmove);
    canvas.addEventListener("touchend", this.on_touchend);
    canvas.addEventListener("touchcancel", this.on_touchcancel);

    canvas.addEventListener("mousedown", this.on_mousedown);
    canvas.addEventListener("mousemove", this.on_mousemove);
    canvas.addEventListener("mouseup", this.on_mouseup);
    canvas.addEventListener("keydown", this.on_keydown);

    let bstrip = container.row().strip();

    let makebutton = (strip, k) => {
      let uiname = k[0] + k.slice(1, k.length).toLowerCase();
      uiname = uiname.replace(/_/g, " ");

      let icon = strip.iconbutton(-1, uiname, () => {
        this.loadTemplate(SplineTemplates[k]);
      });

      icon.iconsheet = 0;
      icon.customIcon = SplineTemplateIcons[k];
    };

    for (let k in SplineTemplates) {
      makebutton(bstrip, k);
    }

    let row = container.row();

    let fullUpdate = () => {
      this.updateKnots();
      this.update();
      this.regen_basis();
      this.recalc = RecalcFlags.ALL;
      this.redraw();
    };

    let Icons = row.constructor.getIconEnum();

    row.iconbutton(Icons.TINY_X, "Delete Point", () => {
      for (let i = 0; i < this.points.length; i++) {
        let p = this.points[i];

        if (p.flag & CurveFlags.SELECT) {
          this.points.remove(p);
          i--;
        }
      }

      fullUpdate();
    });

    row.button("Reset", () => {
      this.reset();
    });

    let slider = row.simpleslider(undefined, "Degree", this.deg, 1, 6, 1, true, true, (slider) => {
      this.deg = Math.floor(slider.value);

      fullUpdate();
    });

    slider.baseUnit = "none";
    slider.displayUnit = "none";

    row = container.row();
    let check = row.check(undefined, "Interpolating");
    check.checked = this.interpolating;

    check.onchange = () => {
      this.interpolating = check.value;
      fullUpdate();
    };

    let panel = container.panel("Range");

    let xmin = panel.slider(undefined, "X Min", this.range[0][0], -10, 10, 0.1, false, undefined, (val) => {
      this.range[0][0] = val.value;
    });

    let xmax = panel.slider(undefined, "X Max", this.range[0][1], -10, 10, 0.1, false, undefined, (val) => {
      this.range[0][1] = val.value;
    });

    let ymin = panel.slider(undefined, "Y Min", this.range[1][0], -10, 10, 0.1, false, undefined, (val) => {
      this.range[1][0] = val.value;
    });

    let ymax = panel.slider(undefined, "Y Max", this.range[1][1], -10, 10, 0.1, false, undefined, (val) => {
      this.range[1][1] = val.value;
    });

    xmin.displayUnit = xmin.baseUnit = "none";
    ymin.displayUnit = ymin.baseUnit = "none";
    xmax.displayUnit = xmax.baseUnit = "none";
    ymax.displayUnit = ymax.baseUnit = "none";

    panel.closed = true;

    container.update.after(() => {
      let key = this.calcHashKey();
      if (key !== this._last_update_key) {
        this._last_update_key = key;

        slider.setValue(this.deg);
        xmin.setValue(this.range[0][0]);
        xmax.setValue(this.range[0][1]);

        ymin.setValue(this.range[1][0]);
        ymax.setValue(this.range[1][1]);
      }
    });

    return this;
  }

  killGUI(container, canvas) {
    if (this.uidata !== undefined) {
      let ud = this.uidata;
      this.uidata = undefined;

      canvas.removeEventListener("touchstart", this.on_touchstart);
      canvas.removeEventListener("touchmove", this.on_touchmove);
      canvas.removeEventListener("touchend", this.on_touchend);
      canvas.removeEventListener("touchcancel", this.on_touchcancel);

      canvas.removeEventListener("mousedown", this.on_mousedown);
      canvas.removeEventListener("mousemove", this.on_mousemove);
      canvas.removeEventListener("mouseup", this.on_mouseup);
      canvas.removeEventListener("keydown", this.on_keydown);
    }

    return this;
  }

  start_transform() {
    this.uidata.transpoints = [];

    for (let p of this.points) {
      if (p.flag & CurveFlags.SELECT) {
        this.uidata.transpoints.push(p);
        p.startco.load(p);
      }
    }
  }

  on_mousedown(e) {
    this.uidata.start_mpos.load(this.transform_mpos(e.x, e.y));
    this.fastmode = true;

    let mpos = this.transform_mpos(e.x, e.y);
    let x = mpos[0], y = mpos[1];
    this.do_highlight(x, y);

    if (this.points.highlight !== undefined) {
      if (!e.shiftKey) {
        for (let i = 0; i < this.points.length; i++) {
          this.points[i].flag &= ~CurveFlags.SELECT;
        }

        this.points.highlight.flag |= CurveFlags.SELECT;
      } else {
        this.points.highlight.flag ^= CurveFlags.SELECT;
      }


      this.uidata.transforming = true;

      this.start_transform();

      this.updateKnots();
      this.update();
      this.redraw();
      return;
    } else { //if (!e.isTouch) {
      let p = this.add(this.uidata.start_mpos[0], this.uidata.start_mpos[1]);
      this.points.highlight = p;

      this.updateKnots();
      this.update();
      this.redraw();

      this.points.highlight.flag |= CurveFlags.SELECT;

      this.uidata.transforming = true;
      this.uidata.transpoints = [this.points.highlight];
      this.uidata.transpoints[0].startco.load(this.uidata.transpoints[0]);
    }
  }

  do_highlight(x, y) {
    let trans = this.uidata.draw_trans;
    let mindis = 1e17, minp = undefined;
    let limit = 19/trans[0], limitsqr = limit*limit;

    for (let i = 0; i < this.points.length; i++) {
      let p = this.points[i];
      let dx = x - p.sco[0], dy = y - p.sco[1], dis = dx*dx + dy*dy;

      if (dis < mindis && dis < limitsqr) {
        mindis = dis;
        minp = p;
      }
    }

    if (this.points.highlight !== minp) {
      this.points.highlight = minp;
      this.redraw();
    }
  }

  do_transform(x, y) {
    let off = new Vector2$1([x, y]).sub(this.uidata.start_mpos);

    for (let i = 0; i < this.uidata.transpoints.length; i++) {
      let p = this.uidata.transpoints[i];
      p.load(p.startco).add(off);

      p[0] = Math.min(Math.max(p[0], this.range[0][0]), this.range[0][1]);
      p[1] = Math.min(Math.max(p[1], this.range[1][0]), this.range[1][1]);
    }

    this.updateKnots();
    this.update();
    this.redraw();
  }

  transform_mpos(x, y) {
    let r = this.uidata.canvas.getClientRects()[0];
    let dpi = devicePixelRatio; //evil module cycle: UIBase.getDPI();

    x -= parseInt(r.left);
    y -= parseInt(r.top);

    x *= dpi;
    y *= dpi;

    let trans = this.uidata.draw_trans;

    x = x/trans[0] - trans[1][0];
    y = -y/trans[0] - trans[1][1];

    return [x, y];
  }

  on_mousemove(e) {
    if (e.isTouch && this.uidata.transforming) {
      e.preventDefault();
    }

    let mpos = this.transform_mpos(e.x, e.y);
    let x = mpos[0], y = mpos[1];

    if (this.uidata.transforming) {
      this.do_transform(x, y);
      this.evaluate(0.5);
      //this.update();
      //this.doSave();
    } else {
      this.do_highlight(x, y);
    }
  }

  end_transform() {
    this.uidata.transforming = false;
    this.fastmode = false;
    this.updateKnots();
    this.update();

    splineCache.update(this);
  }

  on_mouseup(e) {
    this.end_transform();
  }

  on_keydown(e) {
    switch (e.keyCode) {
      case 88: //xkeey
      case 46: //delete
        if (this.points.highlight !== undefined) {
          this.points.remove(this.points.highlight);
          this.recalc = RecalcFlags.ALL;

          this.points.highlight = undefined;
          this.updateKnots();
          this.update();

          if (this._save_hook !== undefined) {
            this._save_hook();
          }
        }
        break;
    }
  }

  draw(canvas, g, draw_trans) {
    g.save();

    if (this.uidata === undefined) {
      return;
    }

    this.uidata.canvas = canvas;
    this.uidata.g = g;
    this.uidata.draw_trans = draw_trans;

    let sz = draw_trans[0], pan = draw_trans[1];
    g.lineWidth *= 3.0;

    for (let ssi = 0; ssi < 2; ssi++) {
      break; //uncomment to draw basis functions
      for (let si = 0; si < this.points.length; si++) {
        g.beginPath();

        let f = 0;
        for (let i = 0; i < steps; i++, f += df) {
          let totbasis = 0;

          for (let j = 0; j < this.points.length; j++) {
            totbasis += this.basis(f, j);
          }

          let val = this.basis(f, si);

          if (ssi)
            val /= (totbasis === 0 ? 1 : totbasis);

          (i === 0 ? g.moveTo : g.lineTo).call(g, f, ssi ? val : val*0.5, w, w);
        }

        let color, alpha = this.points[si] === this.points.highlight ? 1.0 : 0.7;

        if (ssi) {
          color = "rgba(105, 25, 5," + alpha + ")";
        } else {
          color = "rgba(25, 145, 45," + alpha + ")";
        }
        g.strokeStyle = color;
        g.stroke();
      }
    }

    g.lineWidth /= 3.0;

    let w = 0.03;

    for (let p of this.points) {
      g.beginPath();

      if (p === this.points.highlight) {
        g.fillStyle = "green";
      } else if (p.flag & CurveFlags.SELECT) {
        g.fillStyle = "red";
      } else {
        g.fillStyle = "orange";
      }

      g.rect(p.sco[0] - w/2, p.sco[1] - w/2, w, w);

      g.fill();
    }

    g.restore();
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);

    this.updateKnots();
    this.recalc = RecalcFlags.ALL;
  }
}

BSplineCurve.STRUCT = nstructjs.inherit(BSplineCurve, CurveTypeData) + `
  points        : array(Curve1DPoint);
  deg           : int;
  eidgen        : IDGen;
  interpolating : bool;
  range         : array(vec2);
}
`;
nstructjs.register(BSplineCurve);
CurveTypeData.register(BSplineCurve);


function makeSplineTemplateIcons(size = 64) {
  let dpi = devicePixelRatio;
  size = ~~(size*dpi);

  for (let k in SplineTemplates) {
    let curve = new BSplineCurve();
    curve.loadTemplate(SplineTemplates[k]);

    curve.fastmode = true;

    let canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;

    let g = canvas.getContext("2d");
    let steps = 64;

    curve.update();

    let scale = 0.5;

    g.translate(-0.5, -0.5);
    g.scale(size*scale, size*scale);
    g.translate(0.5, 0.5);

    //margin
    let m = 0.0;

    let tent = f => 1.0 - Math.abs(Math.fract(f) - 0.5)*2.0;

    for (let i = 0; i < steps; i++) {
      let s = i/(steps - 1);
      let f = 1.0 - curve.evaluate(tent(s));

      s = s*(1.0 - m*2.0) + m;
      f = f*(1.0 - m*2.0) + m;

      //s += 0.5;
      //f += 0.5;

      if (i === 0) {
        g.moveTo(s, f);
      } else {
        g.lineTo(s, f);
      }
    }

    const ls = 7.0;

    g.lineCap = "round";
    g.strokeStyle = "black";
    g.lineWidth = ls*3*dpi/(size*scale);
    g.stroke();

    g.strokeStyle = "white";
    g.lineWidth = ls*dpi/(size*scale);
    g.stroke();

    let url = canvas.toDataURL();
    let img = document.createElement("img");
    img.src = url;

    SplineTemplateIcons[k] = img;
    SplineTemplateIcons[SplineTemplates[k]] = img;
  }
}

let splineTemplatesLoaded = false;

function initSplineTemplates() {
  if (splineTemplatesLoaded) {
    return;
  }

  splineTemplatesLoaded = true;
  
  for (let k in SplineTemplates) {
    let curve = new BSplineCurve();
    curve.loadTemplate(SplineTemplates[k]);
    splineCache.get(curve);
  }

  makeSplineTemplateIcons();
  window._SplineTemplateIcons = SplineTemplateIcons;
}

//delay to ensure config is fully loaded
window.setTimeout(() => {
  if (config.autoLoadSplineTemplates) {
    initSplineTemplates();
  }
}, 0);

let _udigest$2 = new HashDigest();

function feq(a, b) {
  return Math.abs(a - b) < 0.00001;
}

class EquationCurve extends CurveTypeData {
  constructor(type) {
    super();

    this.equation = "x";
    this._last_equation = "";
    this.hermite = undefined;
  }

  get hasGUI() {
    return this.uidata !== undefined;
  }

  static define() {
    return {
      uiname  : "Equation",
      name    : "equation",
      typeName: "EquationCurve"
    }
  }

  calcHashKey(digest = _udigest$2.reset()) {
    let d = digest;

    super.calcHashKey(d);

    d.add(this.equation);

    return d.get();
  }

  equals(b) {
    return super.equals(b) && this.equation === b.equation;
  }

  toJSON() {
    let ret = super.toJSON();

    return Object.assign(ret, {
      equation: this.equation
    });
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    if (obj.equation !== undefined) {
      this.equation = obj.equation;
    }

    return this;
  }

  makeGUI(container, canvas, drawTransform) {
    this.uidata = {
      canvas    : canvas,
      g         : canvas.g,
      draw_trans: drawTransform,
    };

    let row = container.row();

    let text = this.uidata.textbox = row.textbox(undefined, ""+this.equation);
    text.onchange = (val) => {
      console.log(val);
      this.equation = val;
      this.update();
      this.redraw();
    };

    container.label("Equation");

  }

  killGUI(dom, gui, canvas, g, draw_transform) {
    if (this.uidata !== undefined) {
      this.uidata.textbox.remove();
    }

    this.uidata = undefined;
  }

  updateTextBox() {
    if (this.uidata && this.uidata.textbox) {
      this.uidata.textbox.text = this.equation;
    }
  }

  evaluate(s) {
    if (!this.hermite || this._last_equation !== this.equation) {
      this._last_equation = this.equation;

      this.updateTextBox();

      this._evaluate(0.0);

      if (this._haserror) {
        console.warn("ERROR!");
        return 0.0;
      }

      let steps = 32;
      this.hermite = genHermiteTable((s) => this._evaluate(s), steps);
    }

    return evalHermiteTable(this.hermite, s);
  }

  _evaluate(s) {
    let sin = Math.sin, cos = Math.cos, pi = Math.PI, PI = Math.PI,
        e                                                = Math.E, E                                    = Math.E, tan                      = Math.tan, abs      = Math.abs,
        floor                                            = Math.floor, ceil                         = Math.ceil, acos = Math.acos,
        asin                                             = Math.asin, atan                           = Math.atan, cosh = Math.cos,
        sinh                                             = Math.sinh, log                            = Math.log, pow = Math.pow,
        exp                                              = Math.exp, sqrt                             = Math.sqrt, cbrt = Math.cbrt,
        min                                              = Math.min, max = Math.max;

    try {
      let x = s;
      let ret = eval(this.equation);

      this._haserror = false;

      return ret;
    } catch (error) {
      this._haserror = true;
      console.warn("ERROR!");
      return 0.0;
    }
  }

  derivative(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.evaluate(s) - this.evaluate(s - df))/df;
    } else if (s < df*3) {
      return (this.evaluate(s + df) - this.evaluate(s))/df;
    } else {
      return (this.evaluate(s + df) - this.evaluate(s - df))/(2*df);
    }
  }

  derivative2(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.derivative(s) - this.derivative(s - df))/df;
    } else if (s < df*3) {
      return (this.derivative(s + df) - this.derivative(s))/df;
    } else {
      return (this.derivative(s + df) - this.derivative(s - df))/(2*df);
    }
  }

  inverse(y) {
    let steps = 9;
    let ds = 1.0/steps, s = 0.0;
    let best = undefined;
    let ret = undefined;

    for (let i = 0; i < steps; i++, s += ds) {
      let s1 = s, s2 = s + ds;

      let mid;

      for (let j = 0; j < 11; j++) {
        let y1 = this.evaluate(s1);
        let y2 = this.evaluate(s2);
        mid = (s1 + s2)*0.5;

        if (Math.abs(y1 - y) < Math.abs(y2 - y)) {
          s2 = mid;
        } else {
          s1 = mid;
        }
      }

      let ymid = this.evaluate(mid);

      if (best === undefined || Math.abs(y - ymid) < best) {
        best = Math.abs(y - ymid);
        ret = mid;
      }
    }

    return ret === undefined ? 0.0 : ret;
  }

  onActive(parent, draw_transform) {
  }

  onInactive(parent, draw_transform) {
  }

  reset() {
    this.equation = "x";
  }

  destroy() {
  }

  draw(canvas, g, draw_transform) {
    g.save();
    if (this._haserror) {

      g.fillStyle = g.strokeStyle = "rgba(255, 50, 0, 0.25)";
      g.beginPath();
      g.rect(0, 0, 1, 1);
      g.fill();

      g.beginPath();
      g.moveTo(0, 0);
      g.lineTo(1, 1);
      g.moveTo(0, 1);
      g.lineTo(1, 0);

      g.lineWidth *= 3;
      g.stroke();

      g.restore();
      return;
    }

    g.restore();
  }
}

EquationCurve.STRUCT = nstructjs.inherit(EquationCurve, CurveTypeData) + `
  equation : string;
}
`;
nstructjs.register(EquationCurve);
CurveTypeData.register(EquationCurve);


class GuassianCurve extends CurveTypeData {
  constructor(type) {
    super();

    this.height = 1.0;
    this.offset = 1.0;
    this.deviation = 0.3; //standard deviation
  }

  get hasGUI() {
    return this.uidata !== undefined;
  }

  static define() {
    return {
      uiname  : "Guassian",
      name    : "guassian",
      typeName: "GuassianCurve"
    }
  }

  calcHashKey(digest = _udigest$2.reset()) {
    super.calcHashKey(digest);

    let d = digest;

    d.add(this.height);
    d.add(this.offset);
    d.add(this.deviation);

    return d.get();
  }

  equals(b) {
    let r = super.equals(b);

    r = r && feq(this.height, b.height);
    r = r && feq(this.offset, b.offset);
    r = r && feq(this.deviation, b.deviation);

    return r;
  }

  toJSON() {
    let ret = super.toJSON();

    return Object.assign(ret, {
      height   : this.height,
      offset   : this.offset,
      deviation: this.deviation
    });
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    this.height = obj.height !== undefined ? obj.height : 1.0;
    this.offset = obj.offset;
    this.deviation = obj.deviation;

    return this;
  }

  makeGUI(container, canvas, drawTransform) {
    this.uidata = {
      canvas    : canvas,
      g         : canvas.g,
      draw_trans: drawTransform,
    };

    this.uidata.hslider = container.slider(undefined, "Height", this.height, -10, 10, 0.0001);
    this.uidata.hslider.onchange = () => {
      this.height = this.uidata.hslider.value;
      this.redraw();
      this.update();
    };
    this.uidata.oslider = container.slider(undefined, "Offset", this.offset, -10, 10, 0.0001);
    this.uidata.oslider.onchange = () => {
      this.offset = this.uidata.oslider.value;
      this.redraw();
      this.update();
    };
    this.uidata.dslider = container.slider(undefined, "STD Deviation", this.deviation, -10, 10, 0.0001);
    this.uidata.dslider.onchange = () => {
      this.deviation = this.uidata.dslider.value;
      this.redraw();
      this.update();
    };

    /*
    this.uidata.oslider = gui.slider(undefined, "Offset", this.offset,
      -2.5, 2.5, 0.0001, false, false, (val) => {this.offset = val, this.update(), this.redraw();});
    this.uidata.dslider = gui.slider(undefined, "STD Deviation", this.deviation,
      0.0001, 1.25, 0.0001, false, false, (val) => {this.deviation = val, this.update(), this.redraw();});
    //*/
  }

  killGUI(dom, gui, canvas, g, draw_transform) {
    if (this.uidata !== undefined) {
      this.uidata.hslider.remove();
      this.uidata.oslider.remove();
      this.uidata.dslider.remove();
    }

    this.uidata = undefined;
  }

  evaluate(s) {
    let r = this.height*Math.exp(-((s - this.offset)*(s - this.offset))/(2*this.deviation*this.deviation));
    return r;
  }

  derivative(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.evaluate(s) - this.evaluate(s - df))/df;
    } else if (s < df*3) {
      return (this.evaluate(s + df) - this.evaluate(s))/df;
    } else {
      return (this.evaluate(s + df) - this.evaluate(s - df))/(2*df);
    }
  }

  derivative2(s) {
    let df = 0.0001;

    if (s > 1.0 - df*3) {
      return (this.derivative(s) - this.derivative(s - df))/df;
    } else if (s < df*3) {
      return (this.derivative(s + df) - this.derivative(s))/df;
    } else {
      return (this.derivative(s + df) - this.derivative(s - df))/(2*df);
    }
  }

  inverse(y) {
    let steps = 9;
    let ds = 1.0/steps, s = 0.0;
    let best = undefined;
    let ret = undefined;

    for (let i = 0; i < steps; i++, s += ds) {
      let s1 = s, s2 = s + ds;

      let mid;

      for (let j = 0; j < 11; j++) {
        let y1 = this.evaluate(s1);
        let y2 = this.evaluate(s2);
        mid = (s1 + s2)*0.5;

        if (Math.abs(y1 - y) < Math.abs(y2 - y)) {
          s2 = mid;
        } else {
          s1 = mid;
        }
      }

      let ymid = this.evaluate(mid);

      if (best === undefined || Math.abs(y - ymid) < best) {
        best = Math.abs(y - ymid);
        ret = mid;
      }
    }

    return ret === undefined ? 0.0 : ret;
  }
}

GuassianCurve.STRUCT = nstructjs.inherit(GuassianCurve, CurveTypeData) + `
  height    : float;
  offset    : float;
  deviation : float;
}
`;
nstructjs.register(GuassianCurve);
CurveTypeData.register(GuassianCurve);

/*
* Ease
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

/**
* @module TweenJS
*/


/**
 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
 *
 * Most methods on Ease can be passed directly as easing functions:
 *
 *      createjs.Tween.get(target).to({x:100}, 500, createjs.Ease.linear);
 *
 * However, methods beginning with "get" will return an easing function based on parameter values:
 *
 *      createjs.Tween.get(target).to({y:200}, 500, createjs.Ease.getPowIn(2.2));
 *
 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
 *
 * <em>Equations derived from work by Robert Penner.</em>
 * @class Ease
 * @static
 **/


function Ease() {
  throw "Ease cannot be instantiated.";
}

// static methods and properties
/**
 * @method linear
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.linear = function(t) { return t; };

/**
 * Identical to linear.
 * @method none
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.none = Ease.linear;

/**
 * Mimics the simple -100 to 100 easing in Adobe Flash/Animate.
 * @method get
 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
 * @static
 * @return {Function}
 **/
Ease.get = function(amount) {
  if (amount < -1) { amount = -1; }
  else if (amount > 1) { amount = 1; }
  return function(t) {
    if (amount==0) { return t; }
    if (amount<0) { return t*(t*-amount+1+amount); }
    return t*((2-t)*amount+(1-amount));
  };
};

/**
 * Configurable exponential ease.
 * @method getPowIn
 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
 * @static
 * @return {Function}
 **/
Ease.getPowIn = function(pow) {
  return function(t) {
    return Math.pow(t,pow);
  };
};

/**
 * Configurable exponential ease.
 * @method getPowOut
 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
 * @static
 * @return {Function}
 **/
Ease.getPowOut = function(pow) {
  return function(t) {
    return 1-Math.pow(1-t,pow);
  };
};

/**
 * Configurable exponential ease.
 * @method getPowInOut
 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
 * @static
 * @return {Function}
 **/
Ease.getPowInOut = function(pow) {
  return function(t) {
    if ((t*=2)<1) return 0.5*Math.pow(t,pow);
    return 1-0.5*Math.abs(Math.pow(2-t,pow));
  };
};

/**
 * @method quadIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quadIn = Ease.getPowIn(2);
/**
 * @method quadOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quadOut = Ease.getPowOut(2);
/**
 * @method quadInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quadInOut = Ease.getPowInOut(2);

/**
 * @method cubicIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.cubicIn = Ease.getPowIn(3);
/**
 * @method cubicOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.cubicOut = Ease.getPowOut(3);
/**
 * @method cubicInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.cubicInOut = Ease.getPowInOut(3);

/**
 * @method quartIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quartIn = Ease.getPowIn(4);
/**
 * @method quartOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quartOut = Ease.getPowOut(4);
/**
 * @method quartInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quartInOut = Ease.getPowInOut(4);

/**
 * @method quintIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quintIn = Ease.getPowIn(5);
/**
 * @method quintOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quintOut = Ease.getPowOut(5);
/**
 * @method quintInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.quintInOut = Ease.getPowInOut(5);

/**
 * @method sineIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.sineIn = function(t) {
  return 1-Math.cos(t*Math.PI/2);
};

/**
 * @method sineOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.sineOut = function(t) {
  return Math.sin(t*Math.PI/2);
};

/**
 * @method sineInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.sineInOut = function(t) {
  return -0.5*(Math.cos(Math.PI*t) - 1);
};

/**
 * Configurable "back in" ease.
 * @method getBackIn
 * @param {Number} amount The strength of the ease.
 * @static
 * @return {Function}
 **/
Ease.getBackIn = function(amount) {
  return function(t) {
    return t*t*((amount+1)*t-amount);
  };
};
/**
 * @method backIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.backIn = Ease.getBackIn(1.7);

/**
 * Configurable "back out" ease.
 * @method getBackOut
 * @param {Number} amount The strength of the ease.
 * @static
 * @return {Function}
 **/
Ease.getBackOut = function(amount) {
  return function(t) {
    return (--t*t*((amount+1)*t + amount) + 1);
  };
};
/**
 * @method backOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.backOut = Ease.getBackOut(1.7);

/**
 * Configurable "back in out" ease.
 * @method getBackInOut
 * @param {Number} amount The strength of the ease.
 * @static
 * @return {Function}
 **/
Ease.getBackInOut = function(amount) {
  amount*=1.525;
  return function(t) {
    if ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));
    return 0.5*((t-=2)*t*((amount+1)*t+amount)+2);
  };
};
/**
 * @method backInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.backInOut = Ease.getBackInOut(1.7);

/**
 * @method circIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.circIn = function(t) {
  return -(Math.sqrt(1-t*t)- 1);
};

/**
 * @method circOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.circOut = function(t) {
  return Math.sqrt(1-(--t)*t);
};

/**
 * @method circInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.circInOut = function(t) {
  if ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);
  return 0.5*(Math.sqrt(1-(t-=2)*t)+1);
};

/**
 * @method bounceIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.bounceIn = function(t) {
  return 1-Ease.bounceOut(1-t);
};

/**
 * @method bounceOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.bounceOut = function(t) {
  if (t < 1/2.75) {
    return (7.5625*t*t);
  } else if (t < 2/2.75) {
    return (7.5625*(t-=1.5/2.75)*t+0.75);
  } else if (t < 2.5/2.75) {
    return (7.5625*(t-=2.25/2.75)*t+0.9375);
  } else {
    return (7.5625*(t-=2.625/2.75)*t +0.984375);
  }
};

/**
 * @method bounceInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.bounceInOut = function(t) {
  if (t<0.5) return Ease.bounceIn (t*2) * .5;
  return Ease.bounceOut(t*2-1)*0.5+0.5;
};

/**
 * Configurable elastic ease.
 * @method getElasticIn
 * @param {Number} amplitude
 * @param {Number} period
 * @static
 * @return {Function}
 **/
Ease.getElasticIn = function(amplitude,period) {
  var pi2 = Math.PI*2;
  return function(t) {
    if (t==0 || t==1) return t;
    var s = period/pi2*Math.asin(1/amplitude);
    return -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));
  };
};
/**
 * @method elasticIn
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.elasticIn = Ease.getElasticIn(1,0.3);

/**
 * Configurable elastic ease.
 * @method getElasticOut
 * @param {Number} amplitude
 * @param {Number} period
 * @static
 * @return {Function}
 **/
Ease.getElasticOut = function(amplitude,period) {
  var pi2 = Math.PI*2;
  return function(t) {
    if (t==0 || t==1) return t;
    var s = period/pi2 * Math.asin(1/amplitude);
    return (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);
  };
};
/**
 * @method elasticOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.elasticOut = Ease.getElasticOut(1,0.3);

/**
 * Configurable elastic ease.
 * @method getElasticInOut
 * @param {Number} amplitude
 * @param {Number} period
 * @static
 * @return {Function}
 **/
Ease.getElasticInOut = function(amplitude,period) {
  var pi2 = Math.PI*2;
  return function(t) {
    var s = period/pi2 * Math.asin(1/amplitude);
    if ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));
    return amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;
  };
};
/**
 * @method elasticInOut
 * @param {Number} t
 * @static
 * @return {Number}
 **/
Ease.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);

function bez3$1(a, b, c, t) {
  var r1 = a + (b - a)*t;
  var r2 = b + (c - b)*t;

  return r1 + (r2 - r1)*t;
}

function bez4$1(a, b, c, d, t) {
  var r1 = bez3$1(a, b, c, t);
  var r2 = bez3$1(b, c, d, t);

  return r1 + (r2 - r1)*t;
}

class ParamKey {
  constructor(key, val) {
    this.key = key;
    this.val = val;
  }
}

ParamKey.STRUCT = `
ParamKey {
  key : string;
  val : float;
}
`;
nstructjs.register(ParamKey);
let BOOL_FLAG = 1e17;

let _udigest$3 = new HashDigest();

class SimpleCurveBase extends CurveTypeData {
  constructor() {
    super();

    this.type = this.constructor.name;

    let def = this.constructor.define();
    let params = def.params;

    this.params = {};
    for (let k in params) {
      this.params[k] = params[k][1];
    }
  }

  get hasGUI() {
    return true;
  }

  calcHashKey(digest = _udigest$3.reset()) {
    let d = digest;
    super.calcHashKey(d);

    for (let k in this.params) {
      digest.add(k);
      digest.add(this.params[k]);
    }

    return d.get();
  }

  equals(b) {
    if (this.type !== b.type) {
      return false;
    }

    for (let k in this.params) {
      if (Math.abs(this.params[k] - b.params[k]) > 0.000001) {
        return false;
      }
    }

    return true;
  }

  redraw() {
    if (this.parent)
      this.parent.redraw();
  }

  makeGUI(container) {
    let def = this.constructor.define();
    let params = def.params;

    for (let k in params) {
      let p = params[k];

      if (p[2] === BOOL_FLAG) {
        let check = container.check(undefined, p[0]);
        check.checked = !!this.params[k];
        check.key = k;

        let this2 = this;
        check.onchange = function () {
          this2.params[this.key] = this.checked ? 1 : 0;
          this2.update();
          this2.redraw();
        };
      } else {
        let slider = container.slider(undefined, {
          name      : p[0],
          defaultval: this.params[k],
          min       : p[2],
          max       : p[3]
        });
        slider.baseUnit = slider.displayUnit = "none";

        slider.key = k;

        let this2 = this;
        slider.onchange = function () {
          this2.params[this.key] = this.value;
          this2.update();
          this2.redraw();
        };
      }
    }
  }

  killGUI(container) {
    container.clear();
  }

  evaluate(s) {
    throw new Error("implement me!");
  }

  reset() {

  }

  update() {
    super.update();
  }

  draw(canvas, g, draw_transform) {
    let steps = 128;
    let s = 0, ds = 1.0/(steps - 1);

    g.beginPath();
    for (let i = 0; i < steps; i++, s += ds) {
      let co = this.evaluate(s);

      if (i) {
        g.lineTo(co[0], co[1]);
      } else {
        g.moveTo(co[0], co[1]);
      }
    }

    g.stroke();
  }

  _saveParams() {
    let ret = [];
    for (let k in this.params) {
      ret.push(new ParamKey(k, this.params[k]));
    }

    return ret;
  }

  toJSON() {
    return Object.assign(super.toJSON(), {
      params: this.params
    });
  }

  loadJSON(obj) {
    for (let k in obj.params) {
      this.params[k] = obj.params[k];
    }

    return this;
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);

    let ps = this.params;
    this.params = {};

    let pdef = this.constructor.define().params;
    if (!pdef) {
      console.warn("Missing define function for curve", this.constructor.name);
      return;
    }

    for (let pair of ps) {
      if (pair.key in pdef) {
        this.params[pair.key] = pair.val;
      }
    }

    for (let k in pdef) {
      if (!(k in this.params)) {
        this.params[k] = pdef[k][1];
      }
    }
  }
}

SimpleCurveBase.STRUCT = nstructjs.inherit(SimpleCurveBase, CurveTypeData) + `
  params : array(ParamKey) | obj._saveParams();
}
`;
nstructjs.register(SimpleCurveBase);

class BounceCurve extends SimpleCurveBase {
  static define() {
    return {
      params  : {
        decay : ["Decay", 1.0, 0.1, 5.0],
        scale : ["Scale", 1.0, 0.01, 10.0],
        freq  : ["Freq", 1.0, 0.01, 50.0],
        phase : ["Phase", 0.0, -Math.PI*2.0, Math.PI*2.0],
        offset: ["Offset", 0.0, -2.0, 2.0]
      },
      name    : "bounce",
      uiname  : "Bounce",
      typeName: "BounceCurve"

    }
  }

  _evaluate(t) {
    let params = this.params;
    let decay = params.decay + 1.0;
    let scale = params.scale;
    let freq = params.freq;
    let phase = params.phase;
    let offset = params.offset;

    t *= freq;
    let t2 = Math.abs(Math.cos(phase + t*Math.PI*2.0))*scale;
    ;//+ (1.0-scale);

    t2 *= Math.exp(decay*t)/Math.exp(decay);

    return t2;
  }

  evaluate(t) {
    let s = this._evaluate(0.0);
    let e = this._evaluate(1.0);

    return (this._evaluate(t) - s)/(e - s) + this.params.offset;
  }
}

CurveTypeData.register(BounceCurve);
BounceCurve.STRUCT = nstructjs.inherit(BounceCurve, SimpleCurveBase) + `
}`;
nstructjs.register(BounceCurve);


class ElasticCurve extends SimpleCurveBase {
  constructor() {
    super();

    this._func = undefined;
    this._last_hash = undefined;
  }

  static define() {
    return {
      params  : {
        mode     : ["Out Mode", false, BOOL_FLAG, BOOL_FLAG],
        amplitude: ["Amplitude", 1.0, 0.01, 10.0],
        period   : ["Period", 1.0, 0.01, 5.0]
      },
      name    : "elastic",
      uiname  : "Elastic",
      typeName: "ElasticCurve",
    }
  }

  evaluate(t) {
    let hash = ~~(this.params.mode*127 + this.params.amplitude*256 + this.params.period*512);

    if (hash !== this._last_hash || !this._func) {
      this._last_hash = hash;

      if (this.params.mode) {
        this._func = Ease.getElasticOut(this.params.amplitude, this.params.period);
      } else {
        this._func = Ease.getElasticIn(this.params.amplitude, this.params.period);
      }
    }
    return this._func(t);
  }
}

CurveTypeData.register(ElasticCurve);
ElasticCurve.STRUCT = nstructjs.inherit(ElasticCurve, SimpleCurveBase) + `
}`;
nstructjs.register(ElasticCurve);


class EaseCurve extends SimpleCurveBase {
  constructor() {
    super();
  }

  static define() {
    return {
      params  : {
        mode_in  : ["in", true, BOOL_FLAG, BOOL_FLAG],
        mode_out : ["out", true, BOOL_FLAG, BOOL_FLAG],
        amplitude: ["Amplitude", 1.0, 0.01, 4.0]
      },
      name    : "ease",
      uiname  : "Ease",
      typeName: "EaseCurve"
    }
  }

  evaluate(t) {
    let amp = this.params.amplitude;
    let a1 = this.params.mode_in ? 1.0 - amp : 1.0/3.0;
    let a2 = this.params.mode_out ? amp : 2.0/3.0;

    return bez4$1(0.0, a1, a2, 1.0, t);
  }
}

CurveTypeData.register(EaseCurve);
EaseCurve.STRUCT = nstructjs.inherit(EaseCurve, SimpleCurveBase) + `
}`;
nstructjs.register(EaseCurve);


class RandCurve extends SimpleCurveBase {
  constructor() {
    super();
    this.random = new MersenneRandom();
    this.seed = 0;
  }

  get seed() {
    return this._seed;
  }

  set seed(v) {
    this.random.seed(v);
    this._seed = v;
  }

  static define() {
    return {
      params  : {
        amplitude: ["Amplitude", 1.0, 0.01, 4.0],
        decay    : ["Decay", 1.0, 0.0, 5.0],
        in_mode  : ["In", true, BOOL_FLAG, BOOL_FLAG]
      },
      name    : "random",
      uiname  : "Random",
      typeName: "RandCurve"
    }
  }

  evaluate(t) {
    let r = this.random.random();
    let decay = this.params.decay + 1.0;
    let amp = this.params.amplitude;
    let in_mode = this.params.in_mode;

    if (in_mode) {
      t = 1.0 - t;
    }
    //r *= t;

    let d;

    //r *= 0.5;

    if (in_mode) {
      d = Math.exp(t*decay)/Math.exp(decay);
    } else {
      d = Math.exp(t*decay)/Math.exp(decay);
    }

    t = t + (r - t)*d;

    if (in_mode) {
      t = 1.0 - t;
    }

    return t;
  }
}

CurveTypeData.register(RandCurve);
RandCurve.STRUCT = nstructjs.inherit(RandCurve, SimpleCurveBase) + `
}`;
nstructjs.register(RandCurve);

"use strict";

var Vector2$2 = Vector2;

function mySafeJSONStringify$1(obj) {
  return JSON.stringify(obj.toJSON(), function (key) {
    let v = this[key];

    if (typeof v === "number") {
      if (v !== Math.floor(v)) {
        v = parseFloat(v.toFixed(5));
      } else {
        v = v;
      }
    }

    return v;
  });
}

function mySafeJSONParse$1(buf) {
  return JSON.parse(buf, (key, val) => {

  });
};

window.mySafeJSONStringify = mySafeJSONStringify$1;

let _udigest$4 = new HashDigest();

class Curve1D extends EventDispatcher {
  constructor() {
    super();

    this.uiZoom = 1.0;

    this.generators = [];
    this.VERSION = CURVE_VERSION;

    for (let gen of CurveConstructors) {
      gen = new gen();

      gen.parent = this;
      this.generators.push(gen);
    }

    //this.generators.active = this.generators[0];
    this.setGenerator("bspline");
  }

  get generatorType() {
    return this.generators.active ? this.generators.active.type : undefined;
  }

  get fastmode() {
    return this._fastmode;
  }

  set fastmode(val) {
    this._fastmode = val;

    for (let gen of this.generators) {
      gen.fastmode = val;
    }
  }

  calcHashKey(digest = _udigest$4.reset()) {
    let d = digest;

    for (let g of this.generators) {
      g.calcHashKey(d);
    }

    return d.get();
  }

  equals(b) {
    let gen1 = this.generators.active;
    let gen2 = b.generators.active;

    if (!gen1 || !gen2 || gen1.constructor !== gen2.constructor) {
      return false;
    }

    return gen1.equals(gen2);
  }

  load(b) {
    if (b === undefined) {
      return;
    }

    let buf1 = mySafeJSONStringify$1(b);
    let buf2 = mySafeJSONStringify$1(this);

    if (buf1 === buf2) {
      return;
    }

    this.loadJSON(JSON.parse(buf1));
    this._on_change();
    this.redraw();

    return this;
  }

  copy() {
    let ret = new Curve1D();
    ret.loadJSON(JSON.parse(mySafeJSONStringify$1(this)));
    return ret;
  }

  _on_change() {

  }

  redraw() {
    this._fireEvent("draw", this);
  }

  setGenerator(type) {
    for (let gen of this.generators) {
      if (gen.constructor.define().name === type
        || gen.type === type
        || gen.constructor.define().typeName === type
        || gen.constructor === type) {
        if (this.generators.active) {
          this.generators.active.onInactive();
        }

        this.generators.active = gen;
        gen.onActive();

        return;
      }
    }

    throw new Error("unknown curve type " + type);
  }

  toJSON() {
    let ret = {
      generators      : [],
      uiZoom          : this.uiZoom,
      VERSION         : this.VERSION,
      active_generator: this.generatorType
    };

    for (let gen of this.generators) {
      ret.generators.push(gen.toJSON());
    }

    ret.generators.sort((a, b) => a.type.localeCompare(b.type));

    return ret;
  }

  getGenerator(type, throw_on_error = true) {
    for (let gen of this.generators) {
      if (gen.type === type) {
        return gen;
      }
    }

    //was a new generator registerd?
    for (let cls of CurveConstructors) {
      if (cls.define().typeName === type) {
        let gen = new cls();
        gen.type = type;
        this.generators.push(gen);
        return gen;
      }
    }

    if (throw_on_error) {
      throw new Error("Unknown generator " + type + ".");
    } else {
      return undefined;
    }
  }

  switchGenerator(type) {
    let gen = this.getGenerator(type);

    if (gen !== this.generators.active) {
      let old = this.generators.active;

      this.generators.active = gen;

      old.onInactive(this);
      gen.onActive(this);
    }

    return gen;
  }

  destroy() {
    return this;
  }

  loadJSON(obj) {
    this.VERSION = obj.VERSION;

    this.uiZoom = parseFloat(obj.uiZoom) || this.uiZoom;

    //this.generators = [];
    for (let gen of obj.generators) {
      let gen2 = this.getGenerator(gen.type, false);

      if (!gen2 || !(gen2 instanceof CurveTypeData)) {
        //old curve class?
        console.warn("Bad curve generator class:", gen2);
        if (gen2) {
          this.generators.remove(gen2);
        }
        continue;
      }

      gen2.parent = undefined;
      gen2.reset();
      gen2.loadJSON(gen);
      gen2.parent = this;

      if (gen.type === obj.active_generator) {
        this.generators.active = gen2;
      }

      //this.generators.push(gen2);
    }

    return this;
  }

  evaluate(s) {
    return this.generators.active.evaluate(s);
  }

  integrate(s, quadSteps) {
    return this.generators.active.integrate(s, quadSteps);
  }

  derivative(s) {
    return this.generators.active.derivative(s);
  }

  derivative2(s) {
    return this.generators.active.derivative2(s);
  }

  inverse(s) {
    return this.generators.active.inverse(s);
  }

  reset() {
    this.generators.active.reset();
  }

  update() {
    return this.generators.active.update();
  }

  draw(canvas, g, draw_transform) {
    let w = canvas.width, h = canvas.height;

    g.save();

    let sz = draw_transform[0], pan = draw_transform[1];

    g.beginPath();
    g.moveTo(-1, 0);
    g.lineTo(1, 0);
    g.strokeStyle = "red";
    g.stroke();

    g.beginPath();
    g.moveTo(0, -1);
    g.lineTo(0, 1);
    g.strokeStyle = "green";
    g.stroke();

    //g.rect(0, 0, 1, 1);
    //g.fillStyle = "rgb(50, 50, 50)";
    //g.fill();

    let f = 0, steps = 64;
    let df = 1/(steps - 1);
    w = 6.0/sz;

    let curve = this.generators.active;

    g.beginPath();
    for (let i = 0; i < steps; i++, f += df) {
      let val = curve.evaluate(f);

      (i === 0 ? g.moveTo : g.lineTo).call(g, f, val, w, w);
    }

    g.strokeStyle = "grey";
    g.stroke();

    if (this.overlay_curvefunc !== undefined) {
      g.beginPath();
      f = 0.0;

      for (let i = 0; i < steps; i++, f += df) {
        let val = this.overlay_curvefunc(f);

        (i === 0 ? g.moveTo : g.lineTo).call(g, f, val, w, w);
      }

      g.strokeStyle = "green";
      g.stroke();
    }

    this.generators.active.draw(canvas, g, draw_transform);

    g.restore();
    return this;
  }

  loadSTRUCT(reader) {
    this.generators = [];
    reader(this);

    //console.log("VERSION", this.VERSION);

    if (this.VERSION <= 0.75) {
      this.generators = [];

      for (let cls of CurveConstructors) {
        this.generators.push(new cls());
      }

      this.generators.active = this.getGenerator("BSplineCurve");
    }

    for (let gen of this.generators.concat([])) {
      if (!(gen instanceof CurveTypeData)) {
        console.warn("Bad generator data found:", gen);
        this.generators.remove(gen);
        continue;
      }

      if (gen.type === this._active) {
        this.generators.active = gen;
      }
    }

    delete this._active;
  }
}

Curve1D.STRUCT = `
Curve1D {
  generators  : array(abstract(CurveTypeData));
  _active     : string | obj.generators.active.type;
  VERSION     : float;
  uiZoom      : float;
}
`;
nstructjs.register(Curve1D);

const NumberConstraintsBase = new Set([
  'range', 'expRate', 'step', 'uiRange', 'baseUnit', 'displayUnit', 'stepIsRelative',
  'slideSpeed'
]);

const IntegerConstraints = new Set([
  'radix'
].concat(list(NumberConstraintsBase)));

const FloatConstrinats = new Set([
  'decimalPlaces'
].concat(list(NumberConstraintsBase)));

const NumberConstraints = new Set(list(IntegerConstraints).concat(list(FloatConstrinats)));

const PropSubTypes$1 = {
  COLOR: 1
};

let first = (iter) => {
  if (iter === undefined) {
    return undefined;
  }

  if (!(Symbol.iterator in iter)) {
    for (let item in iter) {
      return item;
    }

    return undefined;
  }

  for (let item of iter) {
    return item;
  }
};

//set PropTypes to custom type integers
function setPropTypes(types) {
  for (let k in types) {
    PropTypes[k] = types[k];
  }
}

let customPropertyTypes = [];
let PropClasses = {};

let customPropTypeBase = 17;

let wordmap = {
  sel  : "select",
  unsel: "deselect",
  eid  : "id",
  props: "properties",
  res  : "resource",

};

var defaultRadix = 10;
var defaultDecimalPlaces = 4;

class OnceTag {
  constructor(cb) {
    this.cb = cb;
  }
}

class ToolProperty$1 extends ToolPropertyIF {
  constructor(type, subtype, apiname, uiname = "", description = "", flag = 0, icon = -1) {
    super();

    this.data = undefined;

    if (type === undefined) {
      type = this.constructor.PROP_TYPE_ID;
    }

    this.type = type;
    this.subtype = subtype;

    //is false if this property still has its default value,
    //i.e. it hasn't been set by the user or anyone else
    this.wasSet = false;

    this.apiname = apiname;
    this.uiname = uiname !== undefined ? uiname : apiname;
    this.description = description;
    this.flag = flag;
    this.icon = icon;
    this.icon2 = icon; //another icon, e.g. unchecked state

    //remember to update NumberConstraintsBase et al when adding new number
    //constraints

    this.decimalPlaces = defaultDecimalPlaces;
    this.radix = defaultRadix;
    this.step = 0.05;

    this.callbacks = {};
  }

  static internalRegister(cls) {
    PropClasses[new cls().type] = cls;
  }

  static getClass(type) {
    return PropClasses[type];
  }

  static setDefaultRadix(n) {
    defaultRadix = n;
  }

  static setDefaultDecimalPlaces(n) {
    defaultDecimalPlaces = n;
  }

  static makeUIName(name) {
    let parts = [""];
    let lastc = undefined;

    let ischar = (c) => {
      c = c.charCodeAt(0);

      let upper = c >= "A".charCodeAt(0);
      upper = upper && c <= "Z".charCodeAt(0);

      let lower = c >= "a".charCodeAt(0);
      lower = lower && c <= "z".charCodeAt(0);

      return upper || lower;
    };

    for (let i = 0; i < name.length; i++) {
      let c = name[i];

      if (c === '_' || c === '-' || c === '$') {
        lastc = c;
        c = ' ';
        parts.push('');
        continue;
      }

      if (i > 0 && c === c.toUpperCase() && lastc !== lastc.toUpperCase()) {
        if (ischar(c) && ischar(lastc)) {
          parts.push('');
        }
      }

      parts[parts.length - 1] += c;
      lastc = c;
    }


    let subst = (word) => {
      if (word in wordmap) {
        return wordmap[word];
      } else {
        return word;
      }
    };

    parts = parts
      .filter(f => f.trim().length > 0)
      .map(f => subst(f))
      .map(f => f[0].toUpperCase() + f.slice(1, f.length).toLowerCase())
      .join(" ").trim();
    return parts;
  }

  static register(cls) {
    cls.PROP_TYPE_ID = (1<<customPropTypeBase);
    PropTypes[cls.name] = cls.PROP_TYPE_ID;

    customPropTypeBase++;
    customPropertyTypes.push(cls);

    PropClasses[new cls().type] = cls;

    return cls.PROP_TYPE_ID;
  }

  static calcRelativeStep(step, value, logBase = 1.5) {
    value = Math.log(Math.abs(value) + 1.0)/Math.log(logBase);
    value = Math.max(value, step);

    this.report(termColor("STEP", "red"), value);
    return value;
  }

  setDescription(s) {
    this.description = s;
    return this;
  }

  setUIName(s) {
    this.uiname = s;
    return this;
  }

  calcMemSize() {
    function strlen(s) {
      //length of string plus an assumed member pointer
      return s !== undefined ? s.length + 8 : 8;
    }

    let tot = 0;

    tot += strlen(this.apiname) + strlen(this.uiname);
    tot += strlen(this.description);

    tot += 11*8; //assumed member pointers
    for (let k in this.callbacks) {
      tot += 24;
    }

    return tot;
  }

  equals(b) {
    throw new Error("implement me");
  }

  private() {
    this.flag |= PropFlags.PRIVATE;
    return this;
  }

  saveLastValue() {
    this.flag |= PropFlags.SAVE_LAST_VALUE;
    return this;
  }

  report() {
    console.warn(...arguments);
  }

  _fire(type, arg1, arg2) {
    if (this.callbacks[type] === undefined) {
      return;
    }

    let stack = this.callbacks[type];
    stack = stack.concat([]); //copy

    for (let i = 0; i < stack.length; i++) {
      let cb = stack[i];

      if (cb instanceof OnceTag) {
        let j = i;

        //remove callback;
        while (j < stack.length - 1) {
          stack[j] = stack[j + 1];
          j++;
        }

        stack[j] = undefined;
        stack.length--;

        i--;

        cb.cb.call(this, arg1, arg2);
      } else {
        cb.call(this, arg1, arg2);
      }
    }

    return this;
  }

  clearEventCallbacks() {
    this.callbacks = {};
    return this;
  }

  once(type, cb) {
    if (this.callbacks[type] === undefined) {
      this.callbacks[type] = [];
    }

    //check if cb is already in callback list inside a OnceTag
    for (let cb2 of this.callbacks[type]) {
      if (cb2 instanceof OnceTag && cb2.cb === cb) {
        return;
      }
    }

    cb = new OnceTag(cb);

    this.callbacks[type].push(cb);

    return this;
  }

  on(type, cb) {
    if (this.callbacks[type] === undefined) {
      this.callbacks[type] = [];
    }

    this.callbacks[type].push(cb);
    return this;
  }

  off(type, cb) {
    this.callbacks[type].remove(cb);
    return this;
  }

  toJSON() {
    return {
      type       : this.type,
      subtype    : this.subtype,
      apiname    : this.apiname,
      uiname     : this.uiname,
      description: this.description,
      flag       : this.flag,
      icon       : this.icon,
      data       : this.data,
      range      : this.range,
      uiRange    : this.uiRange,
      step       : this.step
    };
  }

  loadJSON(obj) {
    this.type = obj.type;
    this.subtype = obj.subtype;
    this.apiname = obj.apiname;
    this.uiname = obj.uiname;
    this.description = obj.description;
    this.flag = obj.flag;
    this.icon = obj.icon;
    this.data = obj.data;

    return this;
  }

  getValue() {
    return this.data;
  }

  setValue(val) {
    if (this.constructor === ToolProperty$1) {
      throw new Error("implement me!");
    }

    this.wasSet = true;

    this._fire("change", val);
  }

  copyTo(b) {
    b.apiname = this.apiname;

    b.uiname = this.uiname;
    b.description = this.description;
    b.icon = this.icon;
    b.icon2 = this.icon2;

    b.baseUnit = this.baseUnit;
    b.subtype = this.subtype;
    b.displayUnit = this.displayUnit;

    b.flag = this.flag;

    for (let k in this.callbacks) {
      b.callbacks[k] = this.callbacks[k];
    }
  }

  copy() { //default copy method
    let ret = new this.constructor();

    this.copyTo(ret);

    return ret;
  }

  setStep(step) {
    this.step = step;
    return this;
  }

  getStep(value = 1.0) {
    if (this.stepIsRelative) {
      return ToolProperty$1.calcRelativeStep(this.step, value);
    } else {
      return this.step;
    }
  }

  setRelativeStep(step) {
    this.step = step;
    this.stepIsRelative = true;
  }

  setRange(min, max) {
    if (min === undefined || max === undefined) {
      throw new Error("min and/or max cannot be undefined");
    }

    this.range = [min, max];
    return this;
  }

  noUnits() {
    this.baseUnit = this.displayUnit = "none";
    return this;
  }

  setBaseUnit(unit) {
    this.baseUnit = unit;
    return this;
  }

  setDisplayUnit(unit) {
    this.displayUnit = unit;
    return this;
  }

  setFlag(f, combine = false) {
    this.flag = combine ? this.flag | f : f;
    return this;
  }

  setUIRange(min, max) {
    if (min === undefined || max === undefined) {
      throw new Error("min and/or max cannot be undefined");
    }

    this.uiRange = [min, max];
    return this;
  }

  setIcon(icon) {
    this.icon = icon;

    return this;
  }

  setIcon2(icon) {
    this.icon2 = icon;

    return this;
  }

  loadSTRUCT(reader) {
    reader(this);
  }
}

ToolProperty$1.STRUCT = `
ToolProperty { 
  type           : int;
  flag           : int;
  subtype        : int;
  icon           : int;
  icon2          : int;
  baseUnit       : string | ""+this.baseUnit;
  displayUnit    : string | ""+this.displayUnit;
  range          : array(float) | this.range ? this.range : [-1e17, 1e17];
  uiRange        : array(float) | this.range ? this.range : [-1e17, 1e17];
  description    : string;
  stepIsRelative : bool;
  step           : float;
  expRate        : float;
  radix          : float;
  decimalPlaces  : int;
}
`;
nstructjs.register(ToolProperty$1);

window.ToolProperty = ToolProperty$1;

class FloatArrayProperty extends ToolProperty$1 {
  constructor(value, apiname, uiname, description, flag, icon) {
    super(PropTypes.FLOAT_ARRAY, undefined, apiname, uiname, description, flag, icon);

    this.value = [];

    if (value !== undefined) {
      this.setValue(value);
    }
  }

  [Symbol.iterator]() {
    return this.value[Symbol.iterator]();
  }

  setValue(value) {
    super.setValue();

    if (value === undefined) {
      throw new Error("value was undefined in FloatArrayProperty's setValue method");
    }

    this.value.length = 0;

    for (let item of value) {
      if (typeof item !== "number" && typeof item !== "boolean") {
        console.log(value);
        throw new Error("bad item for FloatArrayProperty " + item);
      }

      this.value.push(item);
    }
  }

  push(item) {
    if (typeof item !== "number" && typeof item !== "boolean") {
      console.log(value);
      throw new Error("bad item for FloatArrayProperty " + item);
    }

    this.value.push(item);
  }

  getValue() {
    return this.value;
  }

  clear() {
    this.value.length = 0;
    return this;
  }
}

FloatArrayProperty.STRUCT = nstructjs.inherit(FloatArrayProperty, ToolProperty$1) + `
  value : array(float);
}`;
nstructjs.register(FloatArrayProperty);

class StringProperty extends ToolProperty$1 {
  constructor(value, apiname, uiname, description, flag, icon) {
    super(PropTypes.STRING, undefined, apiname, uiname, description, flag, icon);

    this.multiLine = false;

    if (value) {
      this.setValue(value);
    } else {
      this.setValue("");
    }

    this.wasSet = false;
  }

  calcMemSize() {
    return super.calcMemSize() + (this.data !== undefined ? this.data.length*4 : 0) + 8;
  }

  equals(b) {
    return this.data === b.data;
  }

  copyTo(b) {
    super.copyTo(b);

    b.data = this.data;
    b.multiLine = this.multiLine;

    return this;
  }

  getValue() {
    return this.data;
  }

  setValue(val) {
    //fire events
    super.setValue(val);
    this.data = val;
  }
}

StringProperty.STRUCT = nstructjs.inherit(StringProperty, ToolProperty$1) + `
  data : string;
}
`;
nstructjs.register(StringProperty);
ToolProperty$1.internalRegister(StringProperty);
/*
export function isNumber(f) {
  if (f === "NaN" || (typeof f == "number" && isNaN(f))) {
    return false;
  }

  f = ("" + f).trim();

  let ok = false;

  for (let re of num_res) {
    let ret = f.match(re)
    if (!ret) {
      ok = false;
      continue;
    }

    ok = ret[0].length === f.length;
    if (ok) {
      break;
    }
  }

  return ok;
}*/

//window.isNumber = isNumber;

class NumProperty extends ToolProperty$1 {
  constructor(type, value, apiname,
              uiname, description, flag, icon) {
    super(type, undefined, apiname, uiname, description, flag, icon);

    this.data = 0;
    this.range = [0, 0];
  }

  equals(b) {
    return this.data == b.data;
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
};
NumProperty.STRUCT = nstructjs.inherit(NumProperty, ToolProperty$1) + `
  range : array(float);
  data  : float;
}
`;

class _NumberPropertyBase extends ToolProperty$1 {
  constructor(type, value, apiname,
              uiname, description, flag, icon) {
    super(type, null, apiname, uiname, description, flag, icon);

    this.data = 0.0;

    //remember to update NumberConstraintsBase et al when adding new number
    //constraints

    /** controls roller slider rate */
    this.slideSpeed = 1.0;

    /** exponential rate, used by roller sliders */
    this.expRate = 1.33;
    this.step = 0.1;

    this.stepIsRelative = false;

    this.range = [-1e17, 1e17];

    /** if undefined this.range will be used */
    this.uiRange = undefined;

    if (value !== undefined && value !== null) {
      this.setValue(value);
      this.wasSet = false;
    }
  }

  get ui_range() {
    this.report("NumberProperty.ui_range is deprecated");
    return this.uiRange;
  }

  set ui_range(val) {
    this.report("NumberProperty.ui_range is deprecated");
    this.uiRange = val;
  }

  calcMemSize() {
    return super.calcMemSize() + 8*8;
  }

  equals(b) {
    return this.data === b.data;
  }

  toJSON() {
    let json = super.toJSON();

    json.data = this.data;
    json.expRate = this.expRate;

    return json;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    this.data = obj.data || this.data;
    this.expRate = obj.expRate || this.expRate;

    return this;
  }

  copyTo(b) {
    super.copyTo(b);

    b.displayUnit = this.displayUnit;
    b.baseUnit = this.baseUnit;
    b.expRate = this.expRate;
    b.step = this.step;
    b.range = this.range;
    b.uiRange = this.uiRange;

    b.data = this.data;
  }


  setSlideSpeed(f) {
    this.slideSpeed = f;

    return this;
  }

  /*
  * non-linear exponent for number sliders
  * in roll mode
  * */
  setExpRate(exp) {
    this.expRate = exp;
  }

  setValue(val) {
    if (val === undefined || val === null) {
      return;
    }

    if (typeof val !== "number") {
      throw new Error("Invalid number " + val);
    }

    this.data = val;

    super.setValue(val);
    return this;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    let get = (key) => {
      if (key in obj) {
        this[key] = obj[key];
      }
    };

    get("range");
    get("step");
    get("expRate");
    get("ui_range");

    return this;
  }
};
_NumberPropertyBase.STRUCT = nstructjs.inherit(_NumberPropertyBase, ToolProperty$1) + `
  range      : array(float);
  expRate    : float;
  data       : float;
  step       : float;
  slideSpeed : float;
}
`;
nstructjs.register(_NumberPropertyBase);

class IntProperty extends _NumberPropertyBase {
  constructor(value, apiname,
              uiname, description, flag, icon) {
    super(PropTypes.INT, value, apiname, uiname, description, flag, icon);

    //remember to update NumberConstraintsBase et al when adding new number
    //constraints

    this.radix = 10;
  }

  setValue(val) {
    super.setValue(Math.floor(val));
    return this;
  }

  setRadix(radix) {
    this.radix = radix;
  }

  toJSON() {
    let json = super.toJSON();

    json.data = this.data;
    json.radix = this.radix;

    return json;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    this.data = obj.data || this.data;
    this.radix = obj.radix || this.radix;

    return this;
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
}

IntProperty.STRUCT = nstructjs.inherit(IntProperty, _NumberPropertyBase) + `
  data : int;
}`;
nstructjs.register(IntProperty);

ToolProperty$1.internalRegister(IntProperty);

class ReportProperty extends StringProperty {
  constructor(value, apiname, uiname, description, flag, icon) {
    super(value, apiname, uiname, description, flag, icon);

    this.type = PropTypes.REPORT;
  }
}

ReportProperty.STRUCT = nstructjs.inherit(ReportProperty, StringProperty) + `
}
`;
nstructjs.register(ReportProperty);
ToolProperty$1.internalRegister(ReportProperty);

class BoolProperty extends ToolProperty$1 {
  constructor(value, apiname,
              uiname, description, flag, icon) {
    super(PropTypes.BOOL, undefined, apiname, uiname, description, flag, icon);

    this.data = !!value;
  }

  equals(b) {
    return this.data == b.data;
  }

  copyTo(b) {
    super.copyTo(b);
    b.data = this.data;

    return this;
  }

  setValue(val) {
    this.data = !!val;
    super.setValue(val);

    return this;
  }

  getValue() {
    return this.data;
  }

  toJSON() {
    let ret = super.toJSON();

    return ret;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    return this;
  }
}

ToolProperty$1.internalRegister(BoolProperty);
BoolProperty.STRUCT = nstructjs.inherit(BoolProperty, ToolProperty$1) + `
  data : bool;
}
`;
nstructjs.register(BoolProperty);


class FloatProperty extends _NumberPropertyBase {
  constructor(value, apiname,
              uiname, description, flag, icon) {
    super(PropTypes.FLOAT, value, apiname, uiname, description, flag, icon);

    //remember to update NumberConstraintsBase et al when adding new number
    //constraints

    this.decimalPlaces = 4;
  }

  setDecimalPlaces(n) {
    this.decimalPlaces = n;
    return this;
  }

  copyTo(b) {
    super.copyTo(b);
    b.data = this.data;
    return this;
  }

  setValue(val) {
    this.data = val;

    //fire events
    super.setValue(val);

    return this;
  }

  toJSON() {
    let json = super.toJSON();

    json.data = this.data;
    json.decimalPlaces = this.decimalPlaces;

    return json;
  }

  loadJSON(obj) {
    super.loadJSON(obj);

    this.data = obj.data || this.data;
    this.decimalPlaces = obj.decimalPlaces || this.decimalPlaces;

    return this;
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
}

ToolProperty$1.internalRegister(FloatProperty);
FloatProperty.STRUCT = nstructjs.inherit(FloatProperty, _NumberPropertyBase) + `
  decimalPlaces : int;
  data          : float;
}
`;
nstructjs.register(FloatProperty);

class EnumKeyPair {
  constructor(key, val) {
    this.key = "" + key;
    this.val = "" + val;
    this.key_is_int = typeof key === "number" || typeof key === "boolean";
    this.val_is_int = typeof val === "number" || typeof val === "boolean";
  }

  loadSTRUCT(reader) {
    reader(this);

    if (this.val_is_int) {
      this.val = parseInt(this.val);
    }

    if (this.key_is_int) {
      this.key = parseInt(this.key);
    }
  }
}

EnumKeyPair.STRUCT = `
EnumKeyPair {
  key        : string;
  val        : string;
  key_is_int : bool;
  val_is_int : bool; 
}
`;
nstructjs.register(EnumKeyPair);

class EnumProperty extends ToolProperty$1 {
  constructor(string_or_int, valid_values, apiname,
              uiname, description, flag, icon) {
    super(PropTypes.ENUM, undefined, apiname, uiname, description, flag, icon);

    this.values = {};
    this.keys = {};
    this.ui_value_names = {};
    this.descriptions = {};

    if (valid_values === undefined) return this;

    if (valid_values instanceof Array || valid_values instanceof String) {
      for (var i = 0; i < valid_values.length; i++) {
        this.values[valid_values[i]] = valid_values[i];
        this.keys[valid_values[i]] = valid_values[i];
      }
    } else {
      for (var k in valid_values) {
        this.values[k] = valid_values[k];
        this.keys[valid_values[k]] = k;
      }
    }

    if (string_or_int === undefined) {
      this.data = first(valid_values);
    } else {
      this.setValue(string_or_int);
    }

    for (var k in this.values) {
      let uin = k.replace(/[_-]/g, " ").trim();
      uin = uin.split(" ");

      let uiname = ToolProperty$1.makeUIName(k);

      this.ui_value_names[k] = uiname;
      this.descriptions[k] = uiname;
    }

    this.iconmap = {};
    this.iconmap2 = {};

    this.wasSet = false;
  }

  calcHash(digest = new HashDigest()) {
    for (let key in this.keys) {
      digest.add(key);
      digest.add(this.keys[key]);
    }

    return digest.get();
  }

  updateDefinition(enumdef_or_prop) {
    let descriptions = this.descriptions;
    let ui_value_names = this.ui_value_names;

    this.values = {};
    this.keys = {};
    this.ui_value_names = {};
    this.descriptions = {};

    let enumdef;

    if (enumdef_or_prop instanceof EnumProperty) {
      enumdef = enumdef_or_prop.values;
    } else {
      enumdef = enumdef_or_prop;
    }

    for (let k in enumdef) {
      let v = enumdef[k];

      this.values[k] = v;
      this.keys[v] = k;
    }

    if (enumdef_or_prop instanceof EnumProperty) {
      let prop = enumdef_or_prop;
      this.iconmap = Object.assign({}, prop.iconmap);
      this.iconmap2 = Object.assign({}, prop.iconmap2);

      this.ui_value_names = Object.assign({}, prop.ui_value_names);
      this.descriptions = Object.assign({}, prop.descriptions);
    } else {
      for (let k in this.values) {
        if (k in ui_value_names) {
          this.ui_value_names[k] = ui_value_names[k];
        } else {
          this.ui_value_names[k] = ToolProperty$1.makeUIName(k);
        }

        if (k in descriptions) {
          this.descriptions[k] = descriptions[k];
        } else {
          this.descriptions[k] = ToolProperty$1.makeUIName(k);
        }
      }
    }

    this._fire('metaChange', this);

    return this;
  }

  calcMemSize() {
    let tot = super.calcMemSize();

    for (let k in this.values) {
      tot += (k.length*4 + 16)*4;
    }

    if (this.descriptions) {
      for (let k in this.descriptions) {
        tot += (k.length + this.descriptions[k].length)*4;
      }
    }

    return tot + 64;
  }

  equals(b) {
    return this.getValue() === b.getValue();
  }

  addUINames(map) {
    for (let k in map) {
      this.ui_value_names[k] = map[k];
    }

    return this;
  }

  addDescriptions(map) {
    for (let k in map) {
      this.descriptions[k] = map[k];
    }

    return this;
  }

  addIcons2(iconmap2) {
    if (this.iconmap2 === undefined) {
      this.iconmap2 = {};
    }

    for (let k in iconmap2) {
      this.iconmap2[k] = iconmap2[k];
    }

    return this;
  }

  addIcons(iconmap) {
    if (this.iconmap === undefined) {
      this.iconmap = {};
    }
    for (let k in iconmap) {
      this.iconmap[k] = iconmap[k];
    }

    return this;
  }

  copyTo(p) {
    super.copyTo(p);

    p.data = this.data;

    p.keys = Object.assign({}, this.keys);
    p.values = Object.assign({}, this.values);
    p.ui_value_names = this.ui_value_names;
    p.update = this.update;
    p.api_update = this.api_update;

    p.iconmap = this.iconmap;
    p.iconmap2 = this.iconmap2;
    p.descriptions = this.descriptions;

    return p;
  }

  copy() {
    var p = new this.constructor("dummy", {"dummy": 0}, this.apiname, this.uiname, this.description, this.flag);

    this.copyTo(p);
    return p;
  }

  getValue() {
    if (this.data in this.values)
      return this.values[this.data];
    else
      return this.data;
  }

  setValue(val) {
    if (!(val in this.values) && (val in this.keys))
      val = this.keys[val];

    if (!(val in this.values)) {
      this.report("Invalid value for enum!", val, this.values);
      return;
    }

    this.data = val;

    //fire events
    super.setValue(val);
    return this;
  }

  _loadMap(obj) {
    if (!obj) {
      return {};
    }

    let ret = {};
    for (let k of obj) {
      ret[k.key] = k.val;
    }

    return ret;
  }

  _saveMap(obj) {
    obj = obj === undefined ? {} : obj;
    let ret = [];

    for (let k in obj) {
      ret.push(new EnumKeyPair(k, obj[k]));
    }

    return ret;
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);

    this.keys = this._loadMap(this._keys);
    this.values = this._loadMap(this._values);
    this.ui_value_names = this._loadMap(this._ui_value_names);
    this.iconmap = this._loadMap(this._iconmap);
    this.iconmap2 = this._loadMap(this._iconmap2);
    this.descriptions = this._loadMap(this._descriptions);

    if (this.data_is_int) {
      this.data = parseInt(this.data);
      delete this.data_is_int;
    } else if (this.data in this.keys) {
      this.data = this.keys[this.data];
    }
  }

  _is_data_int() {
    return typeof this.data === "number";
  }
}

ToolProperty$1.internalRegister(EnumProperty);
EnumProperty.STRUCT = nstructjs.inherit(EnumProperty, ToolProperty$1) + `
  data            : string             | ""+this.data;
  data_is_int     : bool               | this._is_data_int();
  _keys           : array(EnumKeyPair) | this._saveMap(this.keys) ;
  _values         : array(EnumKeyPair) | this._saveMap(this.values) ;
  _ui_value_names : array(EnumKeyPair) | this._saveMap(this.ui_value_names) ;
  _iconmap        : array(EnumKeyPair) | this._saveMap(this.iconmap) ;
  _iconmap2       : array(EnumKeyPair) | this._saveMap(this.iconmap2) ;
  _descriptions   : array(EnumKeyPair) | this._saveMap(this.descriptions) ;  
}
`;
nstructjs.register(EnumProperty);

class FlagProperty extends EnumProperty {
  constructor(string, valid_values, apiname,
              uiname, description, flag, icon) {
    super(string, valid_values, apiname,
      uiname, description, flag, icon);

    this.type = PropTypes.FLAG;
    this.wasSet = false;
  }

  setValue(bitmask) {
    this.data = bitmask;

    //do not trigger EnumProperty's setValue
    ToolProperty$1.prototype.setValue.call(this, bitmask);
    return this;
  }
}

ToolProperty$1.internalRegister(FlagProperty);
FlagProperty.STRUCT = nstructjs.inherit(FlagProperty, EnumProperty) + `
}
`;
nstructjs.register(FlagProperty);


class VecPropertyBase extends FloatProperty {
  constructor(data, apiname, uiname, description) {
    super(undefined, apiname, uiname, description);

    this.hasUniformSlider = false;
  }

  calcMemSize() {
    return super.calcMemSize() + this.data.length*8;
  }

  equals(b) {
    return this.data.vectorDistance(b.data) < 0.00001;
  }

  uniformSlider(state = true) {
    this.hasUniformSlider = state;
    return this;
  }

  copyTo(b) {
    super.copyTo(b);
    b.hasUniformSlider = this.hasUniformSlider;
  }
}

VecPropertyBase.STRUCT = nstructjs.inherit(VecPropertyBase, FloatProperty) + `
  hasUniformSlider : bool;
}
`;


class Vec2Property extends FloatProperty {
  constructor(data, apiname, uiname, description) {
    super(undefined, apiname, uiname, description);

    this.type = PropTypes.VEC2;
    this.data = new Vector2(data);
  }

  setValue(v) {
    this.data.load(v);

    //do not trigger parent classes's setValue
    ToolProperty$1.prototype.setValue.call(this, v);
    return this;
  }

  getValue() {
    return this.data;
  }

  copyTo(b) {
    let data = b.data;
    super.copyTo(b);

    b.data = data;
    b.data.load(this.data);
  }
}

Vec2Property.STRUCT = nstructjs.inherit(Vec2Property, VecPropertyBase) + `
  data : vec2;
}
`;
nstructjs.register(Vec2Property);

ToolProperty$1.internalRegister(Vec2Property);

class Vec3Property extends VecPropertyBase {
  constructor(data, apiname, uiname, description) {
    super(undefined, apiname, uiname, description);

    this.type = PropTypes.VEC3;
    this.data = new Vector3(data);
  }

  isColor() {
    this.subtype = PropSubTypes$1.COLOR;
    return this;
  }

  setValue(v) {
    this.data.load(v);

    //do not trigger parent classes's setValue
    ToolProperty$1.prototype.setValue.call(this, v);
    return this;
  }

  getValue() {
    return this.data;
  }

  copyTo(b) {
    let data = b.data;
    super.copyTo(b);

    b.data = data;
    b.data.load(this.data);
  }
}

Vec3Property.STRUCT = nstructjs.inherit(Vec3Property, VecPropertyBase) + `
  data : vec3;
}
`;
nstructjs.register(Vec3Property);
ToolProperty$1.internalRegister(Vec3Property);

class Vec4Property extends FloatProperty {
  constructor(data, apiname, uiname, description) {
    super(undefined, apiname, uiname, description);

    this.type = PropTypes.VEC4;
    this.data = new Vector4(data);
  }

  setValue(v, w = 1.0) {
    this.data.load(v);

    //do not trigger parent classes's setValue
    ToolProperty$1.prototype.setValue.call(this, v);

    if (v.length < 3) {
      this.data[2] = 0.0;
    }
    if (v.length < 4) {
      this.data[3] = w;
    }

    return this;
  }

  isColor() {
    this.subtype = PropSubTypes$1.COLOR;
    return this;
  }

  getValue() {
    return this.data;
  }

  copyTo(b) {
    let data = b.data;
    super.copyTo(b);

    b.data = data;
    b.data.load(this.data);
  }
}

Vec4Property.STRUCT = nstructjs.inherit(Vec4Property, VecPropertyBase) + `
  data : vec4;
}
`;
nstructjs.register(Vec4Property);
ToolProperty$1.internalRegister(Vec4Property);

class QuatProperty extends ToolProperty$1 {
  constructor(data, apiname, uiname, description) {
    super(PropTypes.QUAT, undefined, apiname, uiname, description);
    this.data = new Quat(data);
  }

  equals(b) {
    return this.data.vectorDistance(b.data) < 0.00001;
  }

  setValue(v) {
    this.data.load(v);
    super.setValue(v);
    return this;
  }

  getValue() {
    return this.data;
  }

  copyTo(b) {
    let data = b.data;
    super.copyTo(b);

    b.data = data;
    b.data.load(this.data);
  }
}

QuatProperty.STRUCT = nstructjs.inherit(QuatProperty, VecPropertyBase) + `
  data : vec4;
}
`;
nstructjs.register(QuatProperty);

ToolProperty$1.internalRegister(QuatProperty);

class Mat4Property extends ToolProperty$1 {
  constructor(data, apiname, uiname, description) {
    super(PropTypes.MATRIX4, undefined, apiname, uiname, description);
    this.data = new Matrix4(data);
  }

  calcMemSize() {
    return super.calcMemSize() + 16*8 + 32;
  }

  equals(b) {
    let m1 = this.data.$matrix;
    let m2 = b.data.$matrix;

    for (let i = 1; i <= 4; i++) {
      for (let j = 1; j <= 4; j++) {
        let key = `m${i}${j}`;

        if (Math.abs(m1[key] - m2[key]) > 0.00001) {
          return false;
        }
      }
    }

    return true;
  }

  setValue(v) {
    this.data.load(v);
    super.setValue(v);
    return this;
  }

  getValue() {
    return this.data;
  }

  copyTo(b) {
    let data = b.data;
    super.copyTo(b);
    b.data = data;

    b.data.load(this.data);
  }

  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
}

Mat4Property.STRUCT = nstructjs.inherit(Mat4Property, FloatProperty) + `
  data           : mat4;
}
`;
nstructjs.register(Mat4Property);
ToolProperty$1.internalRegister(Mat4Property);

/**
 * List of other tool props (all of one type)
 */
class ListProperty extends ToolProperty$1 {
  /*
  * Prop must be a ToolProperty subclass instance
  * */
  constructor(prop, list = [], uiname = "") {
    super(PropTypes.PROPLIST);

    this.uiname = uiname;

    if (typeof prop == "number") {
      prop = PropClasses[prop];

      if (prop !== undefined) {
        prop = new prop();
      }
    } else if (prop !== undefined) {
      if (prop instanceof ToolProperty$1) {
        prop = prop.copy();
      } else {
        prop = new prop();
      }
    }


    this.prop = prop;
    this.value = [];

    if (list) {
      for (let val of list) {
        this.push(val);
      }
    }

    this.wasSet = false;
  }

  get length() {
    return this.value.length;
  }

  set length(val) {
    this.value.length = val;
  }

  calcMemSize() {
    let tot = super.calcMemSize();

    let psize = this.prop ? this.prop.calcMemSize() + 8 : 8;
    if (!this.prop && this.value.length > 0) {
      psize = this.value[0].calcMemSize();
    }

    tot += psize*this.value.length + 8;
    tot += 16;

    return tot;
  }

  equals(b) {
    let l1 = this.value ? this.value.length : 0;
    let l2 = b.value ? b.value.length : 0;

    if (l1 !== l2) {
      return false;
    }

    for (let i = 0; i < l1; i++) {
      let prop1 = this.value[i];
      let prop2 = b.value[i];

      let bad = prop1.constructor !== prop2.constructor;
      bad = bad || !prop1.equals(prop2);

      if (bad) {
        return false;
      }
    }

    return true;
  }

  copyTo(b) {
    super.copyTo(b);

    b.prop = this.prop.copy();

    for (let prop of this.value) {
      b.value.push(prop.copy());
    }

    return b;
  }

  copy() {
    return this.copyTo(new ListProperty(this.prop.copy()));
  }

  push(item = undefined) {
    if (item === undefined) {
      item = this.prop.copy();
    }

    if (!(item instanceof ToolProperty$1)) {
      let prop = this.prop.copy();
      prop.setValue(item);
      item = prop;
    }

    this.value.push(item);
    return item;
  }

  clear() {
    this.value.length = 0;
  }

  getListItem(i) {
    return this.value[i].getValue();
  }

  setListItem(i, val) {
    this.value[i].setValue(val);
  }

  setValue(value) {
    this.clear();

    for (let item of value) {
      let prop = this.push();

      if (typeof item !== "object") {
        prop.setValue(item);
      } else if (item instanceof prop.constructor) {
        item.copyTo(prop);
      } else {
        this.report(item);
        throw new Error("invalid value " + item);
      }
    }

    super.setValue(value);
    return this;
  }

  getValue() {
    return this.value;
  }

  [Symbol.iterator]() {
    let list = this.value;

    return (function* () {
      for (let item of list) {
        yield item.getValue();
      }
    })();
  }
}

ListProperty.STRUCT = nstructjs.inherit(ListProperty, ToolProperty$1) + `
  prop  : abstract(ToolProperty);
  value : array(abstract(ToolProperty));
}`;
nstructjs.register(ListProperty);

ToolProperty$1.internalRegister(ListProperty);


//like FlagsProperty but uses strings
class StringSetProperty extends ToolProperty$1 {
  constructor(value = undefined, definition = []) {
    super(PropTypes.STRSET);

    let values = [];

    this.value = new set$1();

    let def = definition;
    if (Array.isArray(def) || def instanceof set$1 || def instanceof Set) {
      for (let item of def) {
        values.push(item);
      }
    } else if (typeof def === "object") {
      for (let k in def) {
        values.push(k);
      }
    } else if (typeof def === "string") {
      values.push(def);
    }

    this.values = {};
    this.ui_value_names = {};
    this.descriptions = {};
    this.iconmap = {};
    this.iconmap2 = {};

    for (let v of values) {
      this.values[v] = v;

      let uiname = ToolProperty$1.makeUIName(v);
      this.ui_value_names[v] = uiname;
    }

    if (value !== undefined) {
      this.setValue(value);
    }

    this.wasSet = false;
  }

  calcMemSize() {
    let tot = super.calcMemSize();

    for (let k in this.values) {
      tot += (k.length + 16)*5;
    }

    if (this.descriptions) {
      for (let k in this.descriptions) {
        tot += (k.length + this.descriptions[k].length + 8)*4;
      }
    }

    return tot + 64;
  }

  equals(b) {
    return this.value.equals(b.value);
  }

  /*
  * Values can be a string, undefined/null, or a list/set/object-literal of strings.
  * If destructive is true, then existing set will be cleared.
  * */
  setValue(values, destructive = true, soft_fail = true) {
    let bad = typeof values !== "string";
    bad = bad && typeof values !== "object";
    bad = bad && values !== undefined && values !== null;

    if (bad) {
      if (soft_fail) {
        this.report("Invalid argument to StringSetProperty.prototype.setValue() " + values);
        return;
      } else {
        throw new Error("Invalid argument to StringSetProperty.prototype.setValue() " + values);
      }
    }

    //handle undefined/null
    if (!values) {
      this.value.clear();
    } else if (typeof values === "string") {
      if (destructive)
        this.value.clear();

      if (!(values in this.values)) {
        if (soft_fail) {
          this.report(`"${values}" is not in this StringSetProperty`);
          return;
        } else {
          throw new Error(`"${values}" is not in this StringSetProperty`);
        }
      }

      this.value.add(values);
    } else {
      let data = [];

      if (Array.isArray(values) || values instanceof set$1 || values instanceof Set) {
        for (let item of values) {
          data.push(item);
        }
      } else { //object literal?
        for (let k in values) {
          data.push(k);
        }
      }

      for (let item of data) {
        if (!(item in this.values)) {
          if (soft_fail) {
            this.report(`"${item}" is not in this StringSetProperty`);
            continue;
          } else {
            throw new Error(`"${item}" is not in this StringSetProperty`);
          }
        }

        this.value.add(item);
      }
    }

    super.setValue();
    return this;
  }

  getValue() {
    return this.value;
  }

  addIcons2(iconmap2) {
    if (iconmap2 === undefined)
      return;

    for (let k in iconmap2) {
      this.iconmap2[k] = iconmap2[k];
    }

    return this;
  }

  addIcons(iconmap) {
    if (iconmap === undefined)
      return;

    for (let k in iconmap) {
      this.iconmap[k] = iconmap[k];
    }

    return this;
  }

  addUINames(map) {
    for (let k in map) {
      this.ui_value_names[k] = map[k];
    }

    return this;
  }

  addDescriptions(map) {
    for (let k in map) {
      this.descriptions[k] = map[k];
    }

    return this;
  }

  copyTo(b) {
    super.copyTo(b);

    for (let val of this.value) {
      b.value.add(val);
    }

    b.values = {};
    for (let k in this.values) {
      b.values[k] = this.values[k];
    }

    b.ui_value_names = {};
    for (let k in this.ui_value_names) {
      b.ui_value_names[k] = this.ui_value_names[k];
    }

    b.iconmap = {};
    b.iconmap2 = {};

    for (let k in this.iconmap) {
      b.iconmap[k] = this.iconmap[k];
    }

    for (let k in this.iconmap2) {
      b.iconmap2[k] = this.iconmap2[k];
    }

    b.descriptions = {};
    for (let k in this.descriptions) {
      b.descriptions[k] = this.descriptions[k];
    }
  }

  loadSTRUCT(reader) {
    reader(this);

    let values = this.values;
    this.values = {};

    for (let s of values) {
      this.values[s] = s;
    }

    this.value = new set$1(this.value);
  }
}

StringSetProperty.STRUCT = nstructjs.inherit(StringSetProperty, ToolProperty$1) + `
  value  : iter(string);
  values : iterkeys(string);  
}`;
nstructjs.register(StringSetProperty);

ToolProperty$1.internalRegister(StringSetProperty);

class Curve1DProperty extends ToolProperty$1 {
  constructor(curve, apiname, uiname, description, flag, icon) {
    super(PropTypes.CURVE, undefined, apiname, uiname, description, flag, icon);

    this.data = new Curve1D();

    if (curve !== undefined) {
      this.setValue(curve);
    }

    this.wasSet = false;
  }

  calcMemSize() {
    //bleh, just return a largish block size
    return 1024;
  }

  equals(b) {

  }

  getValue() {
    return this.data;
  }

  evaluate(t) {
    return this.data.evaluate(t);
  }

  setValue(curve) {
    if (curve === undefined) {
      return;
    }

    this.data.load(curve);
    super.setValue(curve);
  }

  copyTo(b) {
    super.copyTo(b);

    b.setValue(this.data);
  }
}

Curve1DProperty.STRUCT = nstructjs.inherit(Curve1DProperty, ToolProperty$1) + `
  data : Curve1D;
}
`;

nstructjs.register(Curve1DProperty);
ToolProperty$1.internalRegister(Curve1DProperty);

//import * as nstructjs from './struct.js';

let ScreenClass = undefined;


function setScreenClass(cls) {
  ScreenClass = cls;
}

function getAreaIntName(name) {
  let hash = 0;

  for (let i = 0; i < name.length; i++) {
    let c = name.charCodeAt(i);

    if (i%2 === 0) {
      hash += c<<8;
      hash *= 13;
      hash = hash & ((1<<15) - 1);
    } else {
      hash += c;
    }
  }

  return hash;
}

//XXX get rid of me
window.getAreaIntName = getAreaIntName;

//XXX get rid of me
var AreaTypes = {
  TEST_CANVAS_EDITOR: 0
};

function setAreaTypes(def) {
  for (let k in AreaTypes) {
    delete AreaTypes[k];
  }

  for (let k in def) {
    AreaTypes[k] = def[k];
  }
}

let areaclasses = {};

/*hackish! store ref an active wrangler so simple_event's modal
* system can lock it!*/
let theWrangler = undefined;

class AreaWrangler {
  constructor() {
    this.stacks = new Map();
    this.lasts = new Map();
    this.lastArea = undefined;
    this.stack = [];
    this.idgen = 0;
    this.locked = 0;
    this._last_screen_id = undefined;

    theWrangler = this;
  }

  /*Yeek this is particularly evil, it creates a context
  * that can be used by popups with the original context
  * area stack intact of the elements that spawned them.*/
  makeSafeContext(ctx) {
    let wrangler = this.copy();
    let this2 = this;

    return new Proxy(ctx, {
      get(target, key, rec) {
        wrangler.copyTo(contextWrangler);
        return target[key];
      }
    });
  }

  copyTo(ret) {
    for (let [key, stack1] of this.stacks) {
      ret.stack.set(key, list(stack1));
    }

    for (let [key, val] of this.lasts) {
      ret.lasts.set(key, val);
    }

    ret.stack = list(this.stack);
    ret.lastArea = this.lastArea;
  }

  copy(b) {
    let ret = new AreaWrangler();
    this.copyTo(ret);
    return ret;
  }

  _checkWrangler(ctx) {
    if (ctx === undefined) {
      return true;
    }

    if (this._last_screen_id === undefined) {
      this._last_screen_id = ctx.screen._id;
      return true;
    }

    if (ctx.screen._id !== this._last_screen_id) {
      this.reset();

      this._last_screen_id = ctx.screen._id;
      console.warn("contextWrangler detected a new screen; new file?");
      return false;
    }

    return true;
  }

  reset() {
    theWrangler = this;
    this.stacks = new Map();
    this.lasts = new Map();
    this.lastArea = undefined;
    this.stack = [];
    this.locked = 0;
    this._last_screen_id = undefined;

    return this;
  }

  static findInstance() {
    return theWrangler;
  }

  static lock() {
    return this.findInstance().lock();
  }

  static unlock() {
    return this.findInstance().unlock();
  }

  lock() {
    this.locked++;
    return this;
  }

  unlock() {
    this.locked = Math.max(this.locked - 1, 0);
    return this;
  }

  push(type, area, pushLastRef = true) {
    theWrangler = this;

    if (haveModal() || this.locked) {
      pushLastRef = false;
    }

    if (pushLastRef || !this.lasts.has(type[ClassIdSymbol])) {
      this.lasts.set(type[ClassIdSymbol], area);
      this.lastArea = area;
    }

    let stack = this.stacks.get(type[ClassIdSymbol]);
    if (stack === undefined) {
      stack = [];
      this.stacks.set(type[ClassIdSymbol], stack);
    }

    let last = this.lasts.get(type[ClassIdSymbol]);

    stack.push(last);
    stack.push(area);

    this.stack.push(area);
  }

  updateLastRef(type, area) {
    theWrangler = this;

    if ((this.locked || haveModal()) && this.lasts.has(type[ClassIdSymbol])) {
      return;
    }

    this.lasts.set(type[ClassIdSymbol], area);
    this.lastArea = area;
  }

  pop(type, area) {
    let stack = this.stacks.get(type[ClassIdSymbol]);

    if (stack === undefined) {
      console.warn("pop_ctx_area called in error");
      //throw new Error("pop_ctx_area called in error");
      return;
    }

    if (stack.length > 0) {
      stack.pop();
      let last = stack.pop();

      /* paranoia isConnected check to ensure stale elements don't
       * pollute the lasts stack */
      if (!this.locked && last && last.isConnected) {
        this.lasts.set(type[ClassIdSymbol], last);
      }
    } else {
      console.error("pop_ctx_area called in error");
    }

    if (this.stack.length > 0) {
      this.stack.pop();
    }
  }

  getLastArea(type) {
    //if (Math.random() > 0.9995) {
      //console.warn("getLastArea!", type, this.lasts.get(type[ClassIdSymbol]));
    //}

    if (type === undefined) {
      if (this.stack.length > 0) {
        return this.stack[this.stack.length - 1];
      } else {
        return this.lastArea;
      }
    } else {
      if (this.stacks.has(type[ClassIdSymbol])) {
        let stack = this.stacks.get(type[ClassIdSymbol]);

        if (stack.length > 0) {
          return stack[stack.length-1];
        }
      }

      return this.lasts.get(type[ClassIdSymbol]);
    }
  }
}
_setModalAreaClass(AreaWrangler);

let contextWrangler = new AreaWrangler();

function css2matrix(s) {
  return new DOMMatrix(s);
}

function matrix2css(m) {
  if (m.$matrix) {
    m = m.$matrix;
  }

  return `matrix(${m.m11},${m.m12},${m.m21},${m.m22},${m.m41},${m.m42})`
}

"use strict";

let dtvtmps = cachering$1.fromConstructor(Vector3, 32);


let quad_co_rets2 = cachering$1.fromConstructor(Vector2, 512);

function quad_bilinear(v1, v2, v3, v4, u, v) {
  return -((v1 - v2)*u - v1 - (u*v1 - u*v2 + u*v3 - u*v4 - v1 + v4)*v);
}

/*

 on factor;
 off period;

 a1 := v1 + (v2 - v1) * u;
 a2 := v4 + (v3 - v4) * u;
 bilin := a1 + (a2 - a1) * v;

 v1x := 0;
 v1y := 0;

 bx := sub(v1=v1x, v2=v2x, v3=v3x, v4=v4x, bilin);
 by := sub(v1=v1y, v2=v2y, v3=v3y, v4=v4y, bilin);

 f1 := bx - x;
 f2 := by - y;

 ff := solve({f1, f2}, {u, v});

 */
function quad_uv_2d(p, v1, v2, v3, v4) {
  let u, v;

  let v2x = v2[0] - v1[0];
  let v2y = v2[1] - v1[1];
  let v3x = v3[0] - v1[0];
  let v3y = v3[1] - v1[1];
  let v4x = v4[0] - v1[0];
  let v4y = v4[1] - v1[1];

  let x = p[0] - v1[0];
  let y = p[1] - v1[1];
  let sqrt = Math.sqrt;

  let A = 2*(((v4y + y)*x - 2*v4x*y)*
      v3y + (v4x*y - v4y*x)*(v4y + y) - ((v4x - x)*v2y - v3x*y)*(v4y - y))*v2x - 2*(
      (v4x*y - v4y*x)*(v4x + x) - (v4x - x)*v3y*x + ((2*v4y - y)*x - v4x*y)*v3x)*
    v2y + (v4x*y - v4y*x + v3y*x - v3x*y)**2 + (v4x - x)**2*v2y**2 + (v4y - y)**2*
    v2x**2;

  let B = v4x*y - v4y*x + v3y*x - v3x*y;

  let C1 = (2*(v3x - v4x)*v2y - 2*(v3y - v4y)*v2x);
  let C2 = (2*(v3x*v4y - v3y*v4x + v2y*v4x) - 2*v2x*v4y);

  let u1, u2;

  if (A < 0.0) {
    console.log("A was < 0", A);
    A = -A;
    C1 = C2 = 0.0;
  }

  if (Math.abs(C1) < 0.00001) { //perfectly 90 degrees?
    let dx = v2x;
    let dy = v2y;

    console.log("C1 bad");

    let l = Math.sqrt(dx*dx + dy*dy);
    if (l > 0.000001) {
      dx /= l*l;
      dy /= l*l;
    }

    u1 = u2 = dx*x + dy*y;
  } else {
    u1 = (-(B + sqrt(A) - (v4y - y)*v2x) - (v4x - x)*v2y)/C1;
    u2 = (-(B - sqrt(A) - (v4y - y)*v2x) - (v4x - x)*v2y)/C1;
  }

  if (Math.abs(C2) < 0.00001) { //perfectly 90 degrees?
    let dx, dy;

    dx = v3x - v2x;
    dy = v3y - v2y;

    console.log("C2 bad");

    let l = Math.sqrt(dx**2 + dy**2);
    if (l > 0.00001) {
      dx /= l*l;
      dy /= l*l;
    }

    v1 = v2 = x*dx + y*dy;
  } else {
    v1 = (-(B - sqrt(A) + (v4y + y)*v2x) + (v4x + x)*v2y)/C2;
    v2 = (-(B + sqrt(A) + (v4y + y)*v2x) + (v4x + x)*v2y)/C2;
  }

  let ret = quad_co_rets2.next();

  let d1 = (u1 - 0.5)**2 + (v1 - 0.5)**2;
  let d2 = (u2 - 0.5)**2 + (v2 - 0.5)**2;

  if (d1 < d2) {
    ret[0] = u1;
    ret[1] = v1;
  } else {
    ret[0] = u2;
    ret[1] = v2;
  }

  return ret;
}


const ClosestModes = {
  CLOSEST  : 0,
  START    : 1,
  END      : 2,
  ENDPOINTS: 3,
  ALL      : 4
};

let advs = cachering$1.fromConstructor(Vector4, 128);

class AbstractCurve {
  evaluate(t) {
    throw new Error("implement me");
  }

  derivative(t) {
  }

  curvature(t) {

  }

  normal(t) {

  }

  width(t) {

  }
}

class ClosestCurveRets {
  constructor() {
    this.p = new Vector3();
    this.t = 0;
  }
}

let cvrets = cachering$1.fromConstructor(ClosestCurveRets, 2048);
let cvarrays = new ArrayPool();
let cvtmp = new Array(1024);

function closestPoint(p, curve, mode) {
  let steps = 5;
  let s = 0, ds = 1.0/steps;

  let ri = 0;

  for (let i = 0; i < steps; i++, s += ds) {
    let c1 = curve.evaluate(s);
    let c2 = curve.evaluate(s + ds);


  }
}

let poly_normal_tmps = cachering$1.fromConstructor(Vector3, 64);
let pncent = new Vector3();

function normal_poly(vs) {
  if (vs.length === 3) {
    return poly_normal_tmps.next().load(normal_tri(vs[0], vs[1], vs[2]));
  } else if (vs.length === 4) {
    return poly_normal_tmps.next().load(normal_quad(vs[0], vs[1], vs[2], vs[3]));
  }

  if (vs.length === 0) {
    return poly_normal_tmps.next().zero();
  }

  let cent = pncent.zero();
  let tot = 0;

  for (let v of vs) {
    cent.add(v);
    tot++;
  }

  cent.mulScalar(1.0/tot);
  let n = poly_normal_tmps.next().zero();

  for (let i = 0; i < vs.length; i++) {
    let a = vs[i];
    let b = vs[(i + 1)%vs.length];
    let c = cent;

    let n2 = normal_tri(a, b, c);
    n.add(n2);
  }

  n.normalize();
  return n;
}

/*
on factor;
off period;

f1 := u*v1x + v*v2x + (1.0-u-v)*v3x - px;
f2 := u*v1y + v*v2y + (1.0-u-v)*v3y - py;

ff := solve({f1, f2}, {u, v});

on fort;
part(ff, 1, 1);
part(ff, 1, 2);
off fort;

*/

let barycentric_v2_rets = cachering$1.fromConstructor(Vector2, 2048);
let calc_proj_refs = new cachering$1(() => [0, 0], 64);

/*
  a b c d
     b

  a------c

     d

  on factor;
  load_package avector;

  ax := 0;
  ay := 0;
  az := 0;

  a := avec(ax, ay, az);
  b := avec(bx, by, bz);
  c := avec(cx, cy, cz);
  d := avec(dx, dy, dz);

  n1 := d cross c;
  n2 := c cross b;

  n1 := n1 / (VMOD n1);
  n2 := n2 / (VMOD n2);

  d := n1 dot n2;
  on fort;

  d*d;

  off fort;


  */

/**

 v2

 v1------v3

 v4

 */
function dihedral_v3_sqr(v1, v2, v3, v4) {
  let bx = v2[0] - v1[0];
  let by = v2[1] - v1[1];
  let bz = v2[2] - v1[2];

  let cx = v3[0] - v1[0];
  let cy = v3[1] - v1[1];
  let cz = v3[2] - v1[2];

  let dx = v4[0] - v1[0];
  let dy = v4[1] - v1[1];
  let dz = v4[2] - v1[2];


  return ((bx*cz - bz*cx)*(cx*dz - cz*dx) + (by*cz - bz*cy)*(cy*dz - cz*dy) + (bx*cy - by*cx)*
    (cx*dy - cy*dx))**2/(((bx*cz - bz*cx)**2 + (by*cz - bz*cy)**2
    + (bx*cy - by*cx)**2)*((cx*dz - cz*dx)**2 + (cy*dz - cz*dy)**2 + (cx*dy - cy*dx)**2));
}

let tet_area_tmps = cachering$1.fromConstructor(Vector3, 64);

function tet_volume(a, b, c, d) {
  a = tet_area_tmps.next().load(a);
  b = tet_area_tmps.next().load(b);
  c = tet_area_tmps.next().load(c);
  d = tet_area_tmps.next().load(d);

  a.sub(d);
  b.sub(d);
  c.sub(d);

  b.cross(c);
  return a.dot(b)/6.0;
}

function calc_projection_axes(no) {
  let ax = Math.abs(no[0]), ay = Math.abs(no[1]), az = Math.abs(no[2]);

  let ret = calc_proj_refs.next();

  if (ax > ay && ax > az) {
    ret[0] = 1;
    ret[1] = 2;
  } else if (ay > az && ay > ax) {
    ret[0] = 0;
    ret[1] = 2;
  } else {
    ret[0] = 0;
    ret[1] = 1;
  }

  return ret;
}

let _avtmps = cachering$1.fromConstructor(Vector3, 128);

function inrect_3d(p, min, max) {
  let ok = p[0] >= min[0] && p[0] <= max[0];
  ok = ok && p[1] >= min[1] && p[1] <= max[1];
  ok = ok && p[2] >= min[2] && p[2] <= max[2];

  return ok;
}

function aabb_isect_line_3d(v1, v2, min, max) {
  let inside = inrect_3d(v1, min, max);
  inside = inside || inrect_3d(v2, min, max);

  if (inside) {
    return true;
  }

  let cent = _avtmps.next().load(min).interp(max, 0.5);

  let p = closest_point_on_line(cent, v1, v2, true);
  if (!p) {
    return false;
  }

  p = p[0];

  return inrect_3d(p, min, max);
}

function aabb_isect_cylinder_3d(v1, v2, radius, min, max) {
  let inside = inrect_3d(v1, min, max);
  inside = inside || inrect_3d(v2, min, max);

  if (inside) {
    return true;
  }

  let cent = _avtmps.next().load(min).interp(max, 0.5);

  let p = closest_point_on_line(cent, v1, v2, true);
  if (!p) {
    return false;
  }

  p = p[0];

  let size = _avtmps.next().load(max).sub(min);

  size.mulScalar(0.5);
  size.addScalar(radius); //*(3**0.5));

  p.sub(cent).abs();

  return p[0] <= size[0] && p[1] <= size[1] && p[2] <= size[2];
}

function barycentric_v2(p, v1, v2, v3, axis1 = 0, axis2 = 1, out = undefined) {
  let div = (v2[axis1]*v3[axis2] - v2[axis2]*v3[axis1] + (v2[axis2] - v3[axis2])*v1[axis1] - (v2[axis1] - v3[axis1])*v1[axis2]);

  if (Math.abs(div) < 0.000001) {
    div = 0.00001;
  }

  let u = (v2[axis1]*v3[axis2] - v2[axis2]*v3[axis1] + (v2[axis2] - v3[axis2])*p[axis1] - (v2[axis1] - v3[axis1])*p[axis2])/div;
  let v = (-(v1[axis1]*v3[axis2] - v1[axis2]*v3[axis1] + (v1[axis2] - v3[axis2])*p[axis1]) + (v1[axis1] - v3[axis1])*p[axis2])/div;

  if (!out) {
    out = barycentric_v2_rets.next();
  }

  out[0] = u;
  out[1] = v;

  return out;
}

/*

on factor;

load_package "avector";

px := 0;
py := 0;
pz := 0;

v1 := avec(v1x, v1y, v1z);
v2 := avec(v2x, v2y, v2z);
p := avec(px, py, pz);

t1 := p - v1;
t2 := v2 - v1;

l1 := t2 / VMOD t2;

t := dot(t1, t2);

p2 := v1 + t2*t;

on fort;
dot(p2, p2);
off fort;

**/

function _linedis2(co, v1, v2) {
  let v1x = v1[0] - co[0];
  let v1y = v1[1] - co[1];
  let v1z = v1[2] - co[2];

  let v2x = v2[0] - co[0];
  let v2y = v2[1] - co[1];
  let v2z = v2[2] - co[2];

  let dis = (((v1y - v2y)*v1y + (v1z - v2z)*v1z + (v1x - v2x)*v1x)*(v1y - v2y) - v1y)**2 +
    (((v1y - v2y)*v1y + (v1z - v2z)*v1z + (v1x - v2x)*v1x)*(v1z - v2z) - v1z)**2 +
    (((v1y - v2y)*v1y + (v1z - v2z)*v1z + (v1x - v2x)*v1x)*(v1x - v2x) - v1x)**2;

  return dis;
}

let closest_p_tri_rets = new cachering$1(() => {
  return {
    co  : new Vector3(),
    uv  : new Vector2(),
    dist: 0
  }
}, 512);

let cpt_v1 = new Vector3();
let cpt_v2 = new Vector3();
let cpt_v3 = new Vector3();
let cpt_v4 = new Vector3();
let cpt_v5 = new Vector3();
let cpt_v6 = new Vector3();
let cpt_p = new Vector3();
let cpt_n = new Vector3();
let cpt_mat = new Matrix4();
let cpt_mat2 = new Matrix4();
let cpt_b = new Vector3();

function closest_point_on_quad(p, v1, v2, v3, v4, n, uvw) {
  let a = closest_point_on_tri(p, v1, v2, v3, n, uvw);
  let b = closest_point_on_tri(p, v1, v3, v4, n, uvw);

  return a.dist <= b.dist ? a : b;
}

function closest_point_on_tri(p, v1, v2, v3, n, uvw) {
  let op = p;

  if (uvw) {
    uvw[0] = uvw[1] = 0.0;
    if (uvw.length > 2) {
      uvw[2] = 0.0;
    }
  }

  v1 = cpt_v1.load(v1);
  v2 = cpt_v2.load(v2);
  v3 = cpt_v3.load(v3);
  p = cpt_p.load(p);

  if (n === undefined) {
    n = cpt_n.load(normal_tri(v1, v2, v3));
  }

  v1.sub(p);
  v2.sub(p);
  v3.sub(p);
  p.zero();


  /*use least squares to solve for barycentric coordinates
    then clip to triangle

    we do this in 2d, as all solutions are coplanar anyway and that way we
    can have one of the equations be "u+v+w = 1".
    should investigate if this is really necassary.
   */

  let ax1, ax2;
  let ax = Math.abs(n[0]), ay = Math.abs(n[1]), az = Math.abs(n[2]);
  if (ax === 0.0 && ay === 0.0 && az === 0.0) {
    console.log("eek1", n, v1, v2, v3);
    let ret = closest_p_tri_rets.next();

    ret.dist = 1e17;
    ret.co.zero();
    ret.uv.zero();

    return ret;
  }

  let ax3;
  if (ax >= ay && ax >= az) {
    ax1 = 1;
    ax2 = 2;
    ax3 = 0;
  } else if (ay >= ax && ay >= az) {
    ax1 = 0;
    ax2 = 2;
    ax3 = 1;
  } else {
    ax1 = 0;
    ax2 = 1;
    ax3 = 2;
  }

  let mat = cpt_mat;
  let mat2 = cpt_mat2;
  mat.makeIdentity();

  let m = mat.$matrix;

  m.m11 = v1[ax1];
  m.m12 = v2[ax1];
  m.m13 = v3[ax1];
  m.m14 = 0.0;

  m.m21 = v1[ax2];
  m.m22 = v2[ax2];
  m.m23 = v3[ax2];
  m.m24 = 0.0;

  /*
  m.m31 = v1[ax3];
  m.m32 = v2[ax3];
  m.m33 = v3[ax3];
  m.m34 = 0.0;
  */

  m.m31 = 1;
  m.m32 = 1;
  m.m33 = 1;
  m.m34 = 0.0;

  mat.transpose();

  let b = cpt_b.zero();

  b[0] = p[ax1];
  b[1] = p[ax2];
  //b[2] = p[ax3];
  b[2] = 1.0;
  b[3] = 0.0;

  mat2.load(mat).transpose();

  mat.preMultiply(mat2);

  if (mat.invert() === null) {
    console.log("eek2", mat.determinant(), ax1, ax2, n);
    let ret = closest_p_tri_rets.next();

    ret.dist = 1e17;
    ret.co.zero();
    ret.uv.zero();

    return ret;
  }

  mat.multiply(mat2);


  b.multVecMatrix(mat);

  let u = b[0];
  let v = b[1];
  let w = b[2];

  for (let i = 0; i < 1; i++) {
    u = Math.min(Math.max(u, 0.0), 1.0);
    v = Math.min(Math.max(v, 0.0), 1.0);
    w = Math.min(Math.max(w, 0.0), 1.0);

    let tot = u + v + w;

    if (tot !== 0.0) {
      tot = 1.0/tot;
      u *= tot;
      v *= tot;
      w *= tot;
    }
  }

  if (uvw) {
    uvw[0] = u;
    uvw[1] = v;
    if (uvw.length > 2) {
      uvw[2] = w;
    }
  }

  let x = v1[0]*u + v2[0]*v + v3[0]*w;
  let y = v1[1]*u + v2[1]*v + v3[1]*w;
  let z = v1[2]*u + v2[2]*v + v3[2]*w;

  let ret = closest_p_tri_rets.next();

  ret.co.loadXYZ(x, y, z);
  ret.uv[0] = u;
  ret.uv[1] = v;

  ret.dist = ret.co.vectorLength();
  ret.co.add(op);

  return ret;
}

function dist_to_tri_v3_old(co, v1, v2, v3, no = undefined) {
  if (!no) {
    no = dtvtmps.next().load(normal_tri(v1, v2, v3));
  }

  let p = dtvtmps.next().load(co);
  p.sub(v1);

  let planedis = -p.dot(no);

  let [axis, axis2] = calc_projection_axes(no);

  let p1 = dtvtmps.next();
  let p2 = dtvtmps.next();
  let p3 = dtvtmps.next();

  p1[0] = v1[axis];
  p1[1] = v1[axis2];
  p1[2] = 0.0;

  p2[0] = v2[axis];
  p2[1] = v2[axis2];
  p2[2] = 0.0;

  p3[0] = v3[axis];
  p3[1] = v3[axis2];
  p3[2] = 0.0;

  let pp = dtvtmps.next();
  pp[0] = co[axis];
  pp[1] = co[axis2];
  pp[2] = 0.0;

  let dis = 1e17;

  function linedis2d(a, b, c) {
    let dx1 = a[0] - b[0];
    let dy1 = a[1] - b[1];
    let dx2 = c[0] - b[0];
    let dy2 = c[1] - b[1];

    let len = dx2*dx2 + dy2*dy2;
    len = len > 0.000001 ? 1.0 / len : 0.0;

    dx2 *= len;
    dy2 *= len;

    return Math.abs(dx1*dy2 - dx2*dy1);
  }

  let tmp = dtvtmps.next();
  let tmp2 = dtvtmps.next();

  function linedis3d(a, b, c) {
    tmp.load(a).sub(b);
    tmp2.load(c).sub(b).normalize();

    let t = tmp.dot(tmp2);
    t = Math.min(Math.max(t, 0.0), b.vectorDistance(c));

    tmp2.mulScalar(t).add(b);

    return tmp2.vectorDistance(a);
  }


  /* are we above the triangle? if so use plane distance */
  if (point_in_tri(pp, p1, p2, p3)) {
    return Math.abs(planedis);
  }

  /* get distance to the closest edge */
  dis = Math.min(dis, linedis3d(co, v1, v2));
  dis = Math.min(dis, linedis3d(co, v2, v3));
  dis = Math.min(dis, linedis3d(co, v3, v1));

  if (0) {
    let uv = barycentric_v2(pp, p1, p2, p3);

    let w = 1.0 - uv[0] - uv[1];
    uv[0] = Math.min(Math.max(uv[0], 0.0), 1.0);
    uv[1] = Math.min(Math.max(uv[1], 0.0), 1.0);
    w = Math.min(Math.max(w, 0.0), 1.0);

    let sum = (uv[0] + uv[1] + w);
    sum = sum !== 0.0 ? 1.0/sum : 0.0;

    w *= sum;
    uv[0] *= sum;
    uv[1] *= sum;

    pp.zero();

    pp.addFac(v1, uv[0]);
    pp.addFac(v2, uv[1]);
    pp.addFac(v3, 1.0 - uv[0] - uv[1]);

    dis = Math.min(dis, pp.vectorDistance(co));
  }

  return dis;
}


function dist_to_tri_v3(p, v1, v2, v3, n) {
  return dist_to_tri_v3_old(p, v1, v2, v3, n);
  //return Math.sqrt(Math.abs(dist_to_tri_v3_sqr(p, v1, v2, v3, n)));
}


/* reduce script

on factor;

ax := 0;
ay := 0;

e1x := bx - ax;
e1y := by - ay;
e2x := cx - bx;
e2y := cy - by;
e3x := ax - cx;
e3y := ay - cy;

l1 := (e1x**2 + e1y**2)**0.5;
l2 := (e2x**2 + e2y**2)**0.5;
l3 := (e3x**2 + e3y**2)**0.5;

load_package "avector";

e1 := avec(e1x / l1, e1y / l1, 0.0);
e2 := avec(e2x / l2, e2y / l2, 0.0);
e3 := avec(e3x / l3, e3y / l3, 0.0);

d1 := x1*e1[1] - y1*e1[0];
d2 := x1*e2[1] - y1*e2[0];
d3 := x1*e3[1] - y1*e3[0];

d1 := d1**2;
d2 := d2**2;
d3 := d3**2;

on fort;
d1;
d2;
d3;
off fort;

*/

let _dt3s_n = new Vector3();

function dist_to_tri_v3_sqr(p, v1, v2, v3, n) {
  if (n === undefined) {
    n = _dt3s_n;
    n.load(normal_tri(v1, v2, v3));
  }

  // find projection axis;
  let axis1, axis2, axis3;
  let nx = n[0] < 0.0 ? -n[0] : n[0];
  let ny = n[1] < 0.0 ? -n[1] : n[1];
  let nz = n[2] < 0.0 ? -n[2] : n[2];

  const feps = 0.0000001;

  if (nx > ny && nx > nz) {
    axis1 = 1;
    axis2 = 2;
    axis3 = 0;
  } else if (ny > nx && ny > nz) {
    axis1 = 0;
    axis2 = 2;
    axis3 = 1;
  } else {
    axis1 = 0;
    axis2 = 1;
    axis3 = 2;
  }

  //n.load(normal_tri(v1, v2, v3));

  let planedis = (p[0] - v1[0])*n[0] + (p[1] - v1[1])*n[1] + (p[2] - v1[2])*n[2];
  planedis = planedis < 0.0 ? -planedis : planedis;

  let ax = v1[axis1], ay = v1[axis2], az = v1[axis3];

  let bx = v2[axis1] - ax, by = v2[axis2] - ay, bz = v2[axis3] - az;
  let cx = v3[axis1] - ax, cy = v3[axis2] - ay, cz = v3[axis3] - az;

  let bx2 = bx*bx, by2 = by*by, bz2 = bz*bz, cx2 = cx*cx, cy2 = cy*cy, cz2 = cz*cz;

  let x1 = p[axis1] - ax;
  let y1 = p[axis2] - ay;
  let z1 = p[axis3] - az;

  const testf = 0.0;

  let l1 = Math.sqrt(bx**2 + by**2);
  let l2 = Math.sqrt((cx - bx)**2 + (cy - by)**2);
  let l3 = Math.sqrt(cx**2 + cy**2);

  let s1 = x1*by - y1*bx < testf;
  let s2 = (x1 - bx)*(cy - by) - (y1 - by)*(cx - bx) < testf;
  let s3 = (x1* -cy + y1*cx) < testf;

  /*
    (x1-cx)*-cy - (y1-cy)*-cx
   reduces to:
     x1*-cy + y1*cx;
   */

  //console.log(axis1, axis2, axis3, n);
  //console.log(s1, s2, s3);
  //console.log(bx, by, cx, cy);

  if (1 && n[axis3] < 0.0) {
    s1 = !s1;
    s2 = !s2;
    s3 = !s3;
    /*
        bx = v3[axis1];
        by = v3[axis2];
        bz = v3[axis3];

        cx = v2[axis1];
        cy = v2[axis2];
        cz = v2[axis3];

        bx2 = bx*bx;
        by2 = by*by;
        bz2 = bz*bz;

        cx2 = cx*cx;
        cy2 = cy*cy;
        cz2 = cz*cz;*/
  }

  let mask = (s1 & 1) | (s2<<1) | (s3<<2);
  if (mask === 0 || mask === 7) {
    return planedis*planedis;
  }

  let d1, d2, d3, div;


  /*
//\  3|
//  \ |
//    b
//    | \
//  1 |   \  2
//    |  0  \
// ___a_______c___
//  5 |   4      \ 6
*/

  let dis = 0.0;
  let lx, ly, lz;

  lx = bx;
  ly = by;
  lz = bz;

  nx = n[axis1];
  ny = n[axis2];
  nz = n[axis3];

  switch (mask) {
    case 1:
      div = (bx2 + by2);

      if (div > feps) {
        d1 = (bx*y1 - by*x1);
        d1 = (d1*d1)/div;

        lx = -by;
        ly = bx;
        lz = bz;
      } else {
        d1 = x1*x1 + y1*y1;

        lx = x1;
        ly = y1;
        lz = z1;
      }

      dis = d1;
      break;
    case 3:
      lx = x1 - bx;
      ly = y1 - by;
      lz = z1 - bz;

      dis = lx*lx + ly*ly;
      return lx*lx + ly*ly + lz*lz;
    case 2:
      div = (bx - cx)**2 + (by - cy)**2;

      if (div > feps) {
        d2 = ((bx - cx)*y1 - (by - cy)*x1);
        d2 = d2/div;

        lx = (by - cy);
        ly = (cx - bx);
        lz = cz - bz;
      } else {
        d2 = (x1 - bx)*(x1 - bx) + (y1 - by)*(y1 - by);

        lx = x1 - bx;
        ly = y1 - by;
        lz = z1 - bz;
      }

      dis = d2;
      break;
    case 6:
      lx = x1 - cx;
      ly = y1 - cy;
      lz = z1 - cz;

      return lx*lx + ly*ly + lz*lz;
    case 4:
      div = (cx2 + cy2);

      if (div > feps) {
        d3 = (cx*y1 - cy*x1);
        d3 = (d3*d3)/div;

        lx = cy;
        ly = -cx;
        lz = cz;
      } else {
        d3 = (x1 - cx)*(x1 - cx) + (y1 - cy)*(y1 - cy);

        lx = x1 - cx;
        ly = y1 - cy;
        lz = z1 - cz;
      }

      dis = d3;
      break;
    case 5:
      lx = x1;
      ly = y1;
      lz = z1;

      return lx*lx + ly*ly + lz*lz;
  }

  //lx = p[axis1] - v1[axis1];
  //ly = p[axis2] - v1[axis2];
  {
    let d = lx*nx + ly*ny + lz*nz;

    d = -d;

    lx += nx*d;
    ly += ny*d;
    lz += nz*d;

    //dis = lx*lx + ly*ly;

    if (0 && Math.random() > 0.999) {
      console.log("d", d.toFixed(6));
      console.log(lx*nx + ly*ny + lz*nz);
    }
  }

  let mul = ((lx**2 + ly**2)*nz**2 + (lx*nx + ly*ny)**2)/((lx**2 + ly**2)*nz**2);
  //let mul = ((lx**2+ly**2)*nz**2+(lx*nx+ly*ny)**2)/((ly**2+lz**2+lx**2)*nz**2);

  //mul = 1.0 / nz;
  //mul *= mul;

  if (Math.random() > 0.999) {
    console.log(mul.toFixed(4));
  }

  //mul = 1.0;

  if (0) {
    let odis = dis;

    dis = x1**2 + y1**2 + z1**2;

    if (Math.random() > 0.999) {
      console.log((dis/odis).toFixed(4), mul.toFixed(4));
    }
    mul = 1.0;
  }

  /*
  on factor;

  dx := sqrt(dis)*(lx / sqrt(lx**2 + ly**2));
  dy := sqrt(dis)*(ly / sqrt(lx**2 + ly**2));
  f2 := dx*nx + dy*ny + dz*nz;

  fz := solve(f2, dz);
  fz := part(fz, 1, 2);

  dis2 := dx*dx + dy*dy + fz*fz;
  fmul := dis2/dis;

  on fort;
  fmul;
  off fort;


  */

  return dis*mul + planedis*planedis;
}

let tri_area_temps = cachering$1.fromConstructor(Vector3, 64);

function tri_area(v1, v2, v3) {
  let l1 = v1.vectorDistance(v2);
  let l2 = v2.vectorDistance(v3);
  let l3 = v3.vectorDistance(v1);

  let s = (l1 + l2 + l3)/2.0;
  return Math.sqrt(s*(s - l1)*(s - l2)*(s - l3))
}

function aabb_overlap_area(pos1, size1, pos2, size2) {
  let r1 = 0.0, r2 = 0.0;

  for (let i = 0; i < 2; i++) {
    let a1 = pos1[i], a2 = pos2[i];
    let b1 = pos1[i] + size1[i];
    let b2 = pos2[i] + size2[i];

    if (b1 >= a2 && b2 >= a1) {
      let r = Math.abs(a2 - b1);
      r = Math.min(r, Math.abs(a1 - b2));

      if (i) {
        r2 = r;
      } else {
        r1 = r;
      }
    }
  }

  return r1*r2;
}

/**
 * Returns true if two aabbs intersect
 * @param {*} pos1
 * @param {*} size1
 * @param {*} pos2
 * @param {*} size2
 */

function aabb_isect_2d(pos1, size1, pos2, size2) {
  let ret = 0;
  for (let i = 0; i < 2; i++) {
    let a = pos1[i];
    let b = pos1[i] + size1[i];
    let c = pos2[i];
    let d = pos2[i] + size2[i];
    if (b >= c && a <= d)
      ret += 1;
  }
  return ret === 2;
};


function aabb_isect_3d(pos1, size1, pos2, size2) {
  let ret = 0;

  for (let i = 0; i < 3; i++) {
    let a = pos1[i];
    let b = pos1[i] + size1[i];

    let c = pos2[i];
    let d = pos2[i] + size2[i];

    if (b >= c && a <= d)
      ret += 1;
  }
  return ret === 3;
}


let aabb_intersect_vs = cachering$1.fromConstructor(Vector2, 32);
let aabb_intersect_rets = new cachering$1(() => {
  return {
    pos : new Vector2(),
    size: new Vector2()
  }
}, 512);

/**
 * Returns aabb that's the intersection of two aabbs
 * @param {*} pos1
 * @param {*} size1
 * @param {*} pos2
 * @param {*} size2
 */
function aabb_intersect_2d(pos1, size1, pos2, size2) {
  let v1 = aabb_intersect_vs.next().load(pos1);
  let v2 = aabb_intersect_vs.next().load(pos1).add(size1);
  let v3 = aabb_intersect_vs.next().load(pos2);
  let v4 = aabb_intersect_vs.next().load(pos2).add(size2);

  let min = aabb_intersect_vs.next().zero();
  let max = aabb_intersect_vs.next().zero();

  let tot = 0;

  for (let i = 0; i < 2; i++) {
    if (v2[i] >= v3[i] && v1[i] <= v4[i]) {
      tot++;

      min[i] = Math.max(v3[i], v1[i]);
      max[i] = Math.min(v2[i], v4[i]);
    }
  }

  if (tot !== 2) {
    return undefined;
  }

  let ret = aabb_intersect_rets.next();
  ret.pos.load(min);
  ret.size.load(max).sub(min);

  return ret;
}

window.test_aabb_intersect_2d = function () {
  let canvas = document.getElementById("test_canvas");

  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.setAttribute("id", "test_canvas");
    canvas.g = canvas.getContext("2d");

    document.body.appendChild(canvas);
  }

  canvas.width = ~~(window.innerWidth*devicePixelRatio);
  canvas.height = ~~(window.innerHeight*devicePixelRatio);
  canvas.style.width = (canvas.width/devicePixelRatio) + "px";
  canvas.style.height = (canvas.height/devicePixelRatio) + "px";
  canvas.style.position = "absolute";
  canvas.style["z-index"] = "1000";

  let g = canvas.g;
  g.clearRect(0, 0, canvas.width, canvas.height);

  let sz = 800;
  let a1 = new Vector2([Math.random()*sz, Math.random()*sz]).floor();
  let a2 = new Vector2([Math.random()*sz, Math.random()*sz]).floor();
  let b1 = new Vector2([Math.random()*sz, Math.random()*sz]).floor();
  let b2 = new Vector2([Math.random()*sz, Math.random()*sz]).floor();

  let p1 = new Vector2();
  let s1 = new Vector2();
  let p2 = new Vector2();
  let s2 = new Vector2();

  p1.load(a1).min(a2);
  s1.load(a1).max(a2);
  p2.load(b1).min(b2);
  s2.load(b1).max(b2);

  s1.sub(p1);
  s2.sub(p1);

  console.log(p1, s1);
  console.log(p2, s2);

  g.beginPath();
  g.rect(0, 0, canvas.width, canvas.height);
  g.fillStyle = "white";
  g.fill();

  g.beginPath();
  g.rect(p1[0], p1[1], s1[0], s1[1]);
  g.fillStyle = "rgba(255, 100, 75, 1.0)";
  g.fill();

  g.beginPath();
  g.rect(p2[0], p2[1], s2[0], s2[1]);
  g.fillStyle = "rgba(75, 100, 255, 1.0)";
  g.fill();

  let ret = aabb_intersect_2d(p1, s1, p2, s2);

  if (ret) {

    g.beginPath();
    g.rect(ret.pos[0], ret.pos[1], ret.size[0], ret.size[1]);
    g.fillStyle = "rgba(0, 0, 0, 1.0)";
    g.fill();
  }

  /*
  window.setTimeout(() => {
    canvas.remove();
  }, 2000);
  //*/

  return {
    end  : test_aabb_intersect_2d.end,
    timer: test_aabb_intersect_2d.timer
  };
};

test_aabb_intersect_2d.stop = function stop() {
  if (test_aabb_intersect_2d._timer) {
    console.log("stopping timer");

    window.clearInterval(test_aabb_intersect_2d._timer);
    test_aabb_intersect_2d._timer = undefined;
  }
};

test_aabb_intersect_2d.end = function end() {
  test_aabb_intersect_2d.stop();

  let canvas = document.getElementById("test_canvas");
  if (canvas) {
    canvas.remove();
  }
};
test_aabb_intersect_2d.timer = function timer(rate = 500) {
  if (test_aabb_intersect_2d._timer) {
    window.clearInterval(test_aabb_intersect_2d._timer);
    test_aabb_intersect_2d._timer = undefined;
    console.log("stopping timer");
    return;
  }

  console.log("starting timer");

  test_aabb_intersect_2d._timer = window.setInterval(() => {
    test_aabb_intersect_2d();
  }, rate);
};

let aabb_intersect_vs3 = cachering$1.fromConstructor(Vector3, 64);

function aabb_intersect_3d(min1, max1, min2, max2) {
  let tot = 0;

  for (let i = 0; i < 2; i++) {
    if (max1[i] >= min2[i] && min1[i] <= max2[i]) {
      tot++;
    }
  }

  if (tot !== 3) {
    return false;
  }

  return true;
}

/**
 * AABB union of a and b.
 * Result is in a.
 *
 * @param a List of two vectors
 * @param b List of two vectors
 * @returns a
 */
function aabb_union(a, b) {
  for (let i = 0; i < 2; i++) {
    for (let j = 0; j < a[i].length; j++) {
      a[i][j] = i ? Math.max(a[i][j], b[i][j]) : Math.min(a[i][j], b[i][j]);
    }
  }

  return a;
}

function aabb_union_2d(pos1, size1, pos2, size2) {
  let v1 = aabb_intersect_vs.next();
  let v2 = aabb_intersect_vs.next();
  let min = aabb_intersect_vs.next();
  let max = aabb_intersect_vs.next();
  v1.load(pos1).add(size1);
  v2.load(pos2).add(size2);

  min.load(v1).min(v2);
  max.load(v1).max(v2);

  max.sub(min);
  let ret = aabb_intersect_rets.next();

  ret.pos.load(min);
  ret.pos.load(max);

  return ret;
}

//XXX refactor to use es6 classes,
//    or at last the class system in typesystem.js
function init_prototype(cls, proto) {
  for (var k in proto) {
    cls.prototype[k] = proto[k];
  }

  return cls.prototype;
}

function inherit$1(cls, parent, proto) {
  cls.prototype = Object.create(parent.prototype);

  for (var k in proto) {
    cls.prototype[k] = proto[k];
  }

  return cls.prototype;
}

var set$2 = set$1;

//everything below here was compiled from es6 code  
//variables starting with $ are function static local vars,
//like in C.  don't use them outside their owning functions.
//
//except for $_mh and $_swapt.  they were used with a C macro
//preprocessor.
var $_mh, $_swapt;

//XXX destroy me
const feps = 2.22e-16;

const COLINEAR = 1;
const LINECROSS = 2;
const COLINEAR_ISECT = 3;

var _cross_vec1 = new Vector3();
var _cross_vec2 = new Vector3();

const SQRT2 = Math.sqrt(2.0);
const FEPS_DATA = {
  F16: 1.11e-16,
  F32: 5.96e-08,
  F64: 4.88e-04
};

/*use 32 bit epsilon by default, since we're often working from
  32-bit float data.  note that javascript uses 64-bit doubles 
  internally.*/
const FEPS = FEPS_DATA.F32;
const FLOAT_MIN = -1e+21;
const FLOAT_MAX = 1e+22;
const Matrix4UI = Matrix4;

/*
var Matrix4UI=exports.Matrix4UI = function(loc, rot, size) {
  if (rot==undefined) {
      rot = undefined;
  }
  
  if (size==undefined) {
      size = undefined;
  }
  
  Object.defineProperty(this, "loc", {get: function() {
    var t=new Vector3();
    this.decompose(t);
    return t;
  }, set: function(loc) {
    var l=new Vector3(), r=new Vector3(), s=new Vector3();
    this.decompose(l, r, s);
    this.calc(loc, r, s);
  }});
  
  Object.defineProperty(this, "size", {get: function() {
    var t=new Vector3();
    this.decompose(undefined, undefined, t);
    return t;
  }, set: function(size) {
    var l=new Vector3(), r=new Vector3(), s=new Vector3();
    this.decompose(l, r, s);
    this.calc(l, r, size);
  }});
  
  Object.defineProperty(this, "rot", {get: function() {
    var t=new Vector3();
    this.decompose(undefined, t);
    return t;
  }, set: function(rot) {
    var l=new Vector3(), r=new Vector3(), s=new Vector3();
    this.decompose(l, r, s);
    this.calc(l, rot, s);
  }});
  
  if (loc instanceof Matrix4) {
      this.load(loc);
      return ;
  }
  
  if (rot==undefined)
    rot = [0, 0, 0];
  if (size==undefined)
    size = [1.0, 1.0, 1.0];
  this.makeIdentity();
  this.calc(loc, rot, size);
};

Matrix4UI.prototype = inherit(Matrix4UI, Matrix4, {
  calc : function(loc, rot, size) {
    this.rotate(rot[0], rot[1], rot[2]);
    this.scale(size[0], size[1], size[2]);
    this.translate(loc[0], loc[1], loc[2]);
  }

});
*/

if (FLOAT_MIN != FLOAT_MIN || FLOAT_MAX != FLOAT_MAX) {
  FLOAT_MIN = 1e-05;
  FLOAT_MAX = 1000000.0;
  console.log("Floating-point 16-bit system detected!");
}

var _static_grp_points4 = new Array(4);
var _static_grp_points8 = new Array(8);

function get_rect_points(p, size) {
  var cs;
  if (p.length == 2) {
    cs = _static_grp_points4;
    cs[0] = p;
    cs[1] = [p[0] + size[0], p[1]];
    cs[2] = [p[0] + size[0], p[1] + size[1]];
    cs[3] = [p[0], p[1] + size[1]];
  } else if (p.length == 3) {
    cs = _static_grp_points8;
    cs[0] = p;
    cs[1] = [p[0] + size[0], p[1], p[2]];
    cs[2] = [p[0] + size[0], p[1] + size[1], p[2]];
    cs[3] = [p[0], p[1] + size[0], p[2]];
    cs[4] = [p[0], p[1], p[2] + size[2]];
    cs[5] = [p[0] + size[0], p[1], p[2] + size[2]];
    cs[6] = [p[0] + size[0], p[1] + size[1], p[2] + size[2]];
    cs[7] = [p[0], p[1] + size[0], p[2] + size[2]];
  } else {
    throw "get_rect_points has no implementation for " + p.length + "-dimensional data";
  }
  return cs;
};

function get_rect_lines(p, size) {
  var ps = get_rect_points(p, size);
  if (p.length == 2) {
    return [[ps[0], ps[1]], [ps[1], ps[2]], [ps[2], ps[3]], [ps[3], ps[0]]];
  } else if (p.length == 3) {
    var l1 = [[ps[0], ps[1]], [ps[1], ps[2]], [ps[2], ps[3]], [ps[3], ps[0]]];
    var l2 = [[ps[4], ps[5]], [ps[5], ps[6]], [ps[6], ps[7]], [ps[7], ps[4]]];
    l1.concat(l2);
    l1.push([ps[0], ps[4]]);
    l1.push([ps[1], ps[5]]);
    l1.push([ps[2], ps[6]]);
    l1.push([ps[3], ps[7]]);
    return l1;
  } else {
    throw "get_rect_points has no implementation for " + p.length + "-dimensional data";
  }
};

var $vs_simple_tri_aabb_isect = [0, 0, 0];

function simple_tri_aabb_isect(v1, v2, v3, min, max) {
  $vs_simple_tri_aabb_isect[0] = v1;
  $vs_simple_tri_aabb_isect[1] = v2;
  $vs_simple_tri_aabb_isect[2] = v3;
  for (var i = 0; i < 3; i++) {
    var isect = true;
    for (var j = 0; j < 3; j++) {
      if ($vs_simple_tri_aabb_isect[j][i] < min[i] || $vs_simple_tri_aabb_isect[j][i] >= max[i])
        isect = false;
    }
    if (isect)
      return true;
  }
  return false;
};

class MinMax {
  constructor(totaxis) {
    if (totaxis == undefined) {
      totaxis = 1;
    }
    this.totaxis = totaxis;
    if (totaxis != 1) {
      let cls;

      switch (totaxis) {
        case 2:
          cls = Vector2;
          break;
        case 3:
          cls = Vector3;
          break;
        case 4:
          cls = Vector4;
          break;
        default:
          cls = Array;
          break;
      }

      this._min = new cls(totaxis);
      this._max = new cls(totaxis);
      this.min = new cls(totaxis);
      this.max = new cls(totaxis);
    } else {
      this.min = this.max = 0;
      this._min = FLOAT_MAX;
      this._max = FLOAT_MIN;
    }
    this.reset();
    this._static_mr_co = new Array(this.totaxis);
    this._static_mr_cs = new Array(this.totaxis*this.totaxis);
  }

  static fromSTRUCT(reader) {
    var ret = new MinMax();
    reader(ret);
    return ret;
  }

  load(mm) {
    if (this.totaxis == 1) {
      this.min = mm.min;
      this.max = mm.max;
      this._min = mm.min;
      this._max = mm.max;
    } else {
      this.min = new Vector3(mm.min);
      this.max = new Vector3(mm.max);
      this._min = new Vector3(mm._min);
      this._max = new Vector3(mm._max);
    }
  }

  reset() {
    var totaxis = this.totaxis;
    if (totaxis == 1) {
      this.min = this.max = 0;
      this._min = FLOAT_MAX;
      this._max = FLOAT_MIN;
    } else {
      for (var i = 0; i < totaxis; i++) {
        this._min[i] = FLOAT_MAX;
        this._max[i] = FLOAT_MIN;
        this.min[i] = 0;
        this.max[i] = 0;
      }
    }
  }

  minmax_rect(p, size) {
    var totaxis = this.totaxis;
    var cs = this._static_mr_cs;
    if (totaxis == 2) {
      cs[0] = p;
      cs[1] = [p[0] + size[0], p[1]];
      cs[2] = [p[0] + size[0], p[1] + size[1]];
      cs[3] = [p[0], p[1] + size[1]];
    } else if (totaxis = 3) {
      cs[0] = p;
      cs[1] = [p[0] + size[0], p[1], p[2]];
      cs[2] = [p[0] + size[0], p[1] + size[1], p[2]];
      cs[3] = [p[0], p[1] + size[0], p[2]];
      cs[4] = [p[0], p[1], p[2] + size[2]];
      cs[5] = [p[0] + size[0], p[1], p[2] + size[2]];
      cs[6] = [p[0] + size[0], p[1] + size[1], p[2] + size[2]];
      cs[7] = [p[0], p[1] + size[0], p[2] + size[2]];
    } else {
      throw "Minmax.minmax_rect has no implementation for " + totaxis + "-dimensional data";
    }
    for (var i = 0; i < cs.length; i++) {
      this.minmax(cs[i]);
    }
  }

  minmax(p) {
    var totaxis = this.totaxis;

    if (totaxis == 1) {
      this._min = this.min = Math.min(this._min, p);
      this._max = this.max = Math.max(this._max, p);
    } else if (totaxis == 2) {
      this._min[0] = this.min[0] = Math.min(this._min[0], p[0]);
      this._min[1] = this.min[1] = Math.min(this._min[1], p[1]);
      this._max[0] = this.max[0] = Math.max(this._max[0], p[0]);
      this._max[1] = this.max[1] = Math.max(this._max[1], p[1]);
    } else if (totaxis == 3) {
      this._min[0] = this.min[0] = Math.min(this._min[0], p[0]);
      this._min[1] = this.min[1] = Math.min(this._min[1], p[1]);
      this._min[2] = this.min[2] = Math.min(this._min[2], p[2]);
      this._max[0] = this.max[0] = Math.max(this._max[0], p[0]);
      this._max[1] = this.max[1] = Math.max(this._max[1], p[1]);
      this._max[2] = this.max[2] = Math.max(this._max[2], p[2]);
    } else {
      for (var i = 0; i < totaxis; i++) {
        this._min[i] = this.min[i] = Math.min(this._min[i], p[i]);
        this._max[i] = this.max[i] = Math.max(this._max[i], p[i]);
      }
    }
  }
};
MinMax.STRUCT = "\n  math.MinMax {\n    min     : vec3;\n    max     : vec3;\n    _min    : vec3;\n    _max    : vec3;\n    totaxis : int;\n  }\n";

function winding_axis(a, b, c, up_axis) {
  let xaxis = (up_axis + 1)%3;
  let yaxis = (up_axis + 2)%3;

  let x1 = a[xaxis], y1 = a[yaxis];
  let x2 = b[xaxis], y2 = b[yaxis];
  let x3 = c[xaxis], y3 = c[yaxis];

  let dx1 = x1 - x2, dy1 = y1 - y2;
  let dx2 = x3 - x2, dy2 = y3 - y2;

  let f = dx1*dy2 - dy1*dx2;
  return f >= 0.0;
}

function winding(a, b, c, zero_z, tol = 0.0) {
  let t1 = _cross_vec1;
  let t2 = _cross_vec2;

  for (let i = 0; i < a.length; i++) {
    t1[i] = b[i] - a[i];
    t2[i] = c[i] - a[i];
  }

  return t1[0]*t2[1] - t1[1]*t2[0] > tol;
  /*
  t1.load(a).sub(b);
  t2.load(c).sub(b);
  return t[0]*
  
  for (var i=0; i<a.length; i++) {
      _cross_vec1[i] = b[i]-a[i];
      _cross_vec2[i] = c[i]-a[i];
  }
  if (a.length==2 || zero_z) {
      _cross_vec1[2] = 0.0;
      _cross_vec2[2] = 0.0;
  }
  _cross_vec1.cross(_cross_vec2);
  return _cross_vec1[2]>tol;
*/
}

function inrect_2d(p, pos, size) {
  if (p == undefined || pos == undefined || size == undefined) {
    console.trace();
    console.log("Bad paramters to inrect_2d()");
    console.log("p: ", p, ", pos: ", pos, ", size: ", size);
    return false;
  }
  return p[0] >= pos[0] && p[0] <= pos[0] + size[0] && p[1] >= pos[1] && p[1] <= pos[1] + size[1];
};
var $smin_aabb_isect_line_2d = new Vector2();
var $ssize_aabb_isect_line_2d = new Vector2();
var $sv1_aabb_isect_line_2d = new Vector2();
var $ps_aabb_isect_line_2d = [new Vector2(), new Vector2(), new Vector2()];
var $l1_aabb_isect_line_2d = [0, 0];
var $smax_aabb_isect_line_2d = new Vector2();
var $sv2_aabb_isect_line_2d = new Vector2();
var $l2_aabb_isect_line_2d = [0, 0];

function aabb_isect_line_2d(v1, v2, min, max) {
  for (var i = 0; i < 2; i++) {
    $smin_aabb_isect_line_2d[i] = Math.min(min[i], v1[i]);
    $smax_aabb_isect_line_2d[i] = Math.max(max[i], v2[i]);
  }
  $smax_aabb_isect_line_2d.sub($smin_aabb_isect_line_2d);
  $ssize_aabb_isect_line_2d.load(max).sub(min);
  if (!aabb_isect_2d($smin_aabb_isect_line_2d, $smax_aabb_isect_line_2d, min, $ssize_aabb_isect_line_2d))
    return false;
  for (var i = 0; i < 4; i++) {
    if (inrect_2d(v1, min, $ssize_aabb_isect_line_2d))
      return true;
    if (inrect_2d(v2, min, $ssize_aabb_isect_line_2d))
      return true;
  }
  $ps_aabb_isect_line_2d[0] = min;
  $ps_aabb_isect_line_2d[1][0] = min[0];
  $ps_aabb_isect_line_2d[1][1] = max[1];
  $ps_aabb_isect_line_2d[2] = max;
  $ps_aabb_isect_line_2d[3][0] = max[0];
  $ps_aabb_isect_line_2d[3][1] = min[1];
  $l1_aabb_isect_line_2d[0] = v1;
  $l1_aabb_isect_line_2d[1] = v2;
  for (var i = 0; i < 4; i++) {
    var a = $ps_aabb_isect_line_2d[i], b = $ps_aabb_isect_line_2d[(i + 1)%4];
    $l2_aabb_isect_line_2d[0] = a;
    $l2_aabb_isect_line_2d[1] = b;
    if (line_line_cross($l1_aabb_isect_line_2d, $l2_aabb_isect_line_2d))
      return true;
  }
  return false;
};


function expand_rect2d(pos, size, margin) {
  pos[0] -= Math.floor(margin[0]);
  pos[1] -= Math.floor(margin[1]);
  size[0] += Math.floor(margin[0]*2.0);
  size[1] += Math.floor(margin[1]*2.0);
};

function expand_line(l, margin) {
  var c = new Vector3();
  c.add(l[0]);
  c.add(l[1]);
  c.mulScalar(0.5);
  l[0].sub(c);
  l[1].sub(c);
  var l1 = l[0].vectorLength();
  var l2 = l[1].vectorLength();
  l[0].normalize();
  l[1].normalize();
  l[0].mulScalar(margin + l1);
  l[1].mulScalar(margin + l2);
  l[0].add(c);
  l[1].add(c);
  return l;
};

//stupidly ancient function, todo: rewrite
function colinear(a, b, c, limit = 2.2e-16) {
  for (var i = 0; i < 3; i++) {
    _cross_vec1[i] = b[i] - a[i];
    _cross_vec2[i] = c[i] - a[i];
  }

  if (a.vectorDistance(b) < feps*100 && a.vectorDistance(c) < feps*100) {
    return true;
  }
  if (_cross_vec1.dot(_cross_vec1) < limit || _cross_vec2.dot(_cross_vec2) < limit)
    return true;
  _cross_vec1.cross(_cross_vec2);
  return _cross_vec1.dot(_cross_vec1) < limit;
};

var _llc_l1 = [new Vector3(), new Vector3()];
var _llc_l2 = [new Vector3(), new Vector3()];
var _llc_l3 = [new Vector3(), new Vector3()];
var _llc_l4 = [new Vector3(), new Vector3()];

var lli_v1 = new Vector3(), lli_v2 = new Vector3(), lli_v3 = new Vector3(), lli_v4 = new Vector3();

var _zero_cn = new Vector3();
var _tmps_cn = cachering$1.fromConstructor(Vector3, 64);
var _rets_cn = cachering$1.fromConstructor(Vector3, 64);

//vec1, vec2 should both be normalized
function corner_normal(vec1, vec2, width) {
  var ret = _rets_cn.next().zero();

  var vec = _tmps_cn.next().zero();
  vec.load(vec1).add(vec2).normalize();

  /*
  ret.load(vec).mulScalar(width);
  return ret;
  */

  //handle colinear case
  if (Math.abs(vec1.normalizedDot(vec2)) > 0.9999) {
    if (vec1.dot(vec2) > 0.0001) {
      ret.load(vec1).add(vec2).normalize();
    } else {
      ret.load(vec1).normalize();
    }

    ret.mulScalar(width);

    return ret;
  } else { //XXX
    //ret.load(vec).mulScalar(width);
    //return ret;
  }

  vec1 = _tmps_cn.next().load(vec1).mulScalar(width);
  vec2 = _tmps_cn.next().load(vec2).mulScalar(width);

  var p1 = _tmps_cn.next().load(vec1);
  var p2 = _tmps_cn.next().load(vec2);

  vec1.addFac(vec1, 0.01);
  vec2.addFac(vec2, 0.01);

  var sc = 1.0;

  p1[0] += vec1[1]*sc;
  p1[1] += -vec1[0]*sc;

  p2[0] += -vec2[1]*sc;
  p2[1] += vec2[0]*sc;

  var p = line_line_isect(vec1, p1, vec2, p2, false);

  if (p == undefined || p === COLINEAR_ISECT || p.dot(p) < 0.000001) {
    ret.load(vec1).add(vec2).normalize().mulScalar(width);
  } else {
    ret.load(p);

    if (vec.dot(vec) > 0 && vec.dot(ret) < 0) {
      ret.load(vec).mulScalar(width);
    }
  }

  return ret;
}

//test_segment is optional, true
function line_line_isect(v1, v2, v3, v4, test_segment) {
  test_segment = test_segment === undefined ? true : test_segment;

  if (!line_line_cross(v1, v2, v3, v4)) {
    return undefined;
  }

  /*
  on factor;
  off period;
  
  xa := xa1 + (xa2 - xa1)*t1;
  xb := xb1 + (xb2 - xb1)*t2;
  ya := ya1 + (ya2 - ya1)*t1;
  yb := yb1 + (yb2 - yb1)*t2;
  
  f1 := xa - xb;
  f2 := ya - yb;
  
  f := solve({f1, f2}, {t1, t2});
  ft1 := part(f, 1, 1, 2);
  ft2 := part(f, 1, 2, 2);
  
  */

  var xa1 = v1[0], xa2 = v2[0], ya1 = v1[1], ya2 = v2[1];
  var xb1 = v3[0], xb2 = v4[0], yb1 = v3[1], yb2 = v4[1];

  var div = ((xa1 - xa2)*(yb1 - yb2) - (xb1 - xb2)*(ya1 - ya2));
  if (div < 0.00000001) { //parallel but intersecting lines.
    return COLINEAR_ISECT;
  } else { //intersection exists
    var t1 = (-((ya1 - yb2)*xb1 - (yb1 - yb2)*xa1 - (ya1 - yb1)*xb2))/div;

    return lli_v1.load(v1).interp(v2, t1);
  }
}

function line_line_cross(v1, v2, v3, v4) {
  var l1 = _llc_l3, l2 = _llc_l4;
  //l1[0].load(v1), l1[1].load(v2), l2[0].load(v3), l2[1].load(v4);

  {
    var a = l1[0], b = l1[1], c = l2[0], d = l2[1];

    a[0] = v1[0];
    a[1] = v1[1];
    a[2] = v1[2];

    b[0] = v2[0];
    b[1] = v2[1];
    b[2] = v2[2];

    c[0] = v3[0];
    c[1] = v3[1];
    c[2] = v3[2];

    d[0] = v4[0];
    d[1] = v4[1];
    d[2] = v4[2];
  }

  /*
  var limit=feps*1000;
  if (Math.abs(l1[0].vectorDistance(l2[0])+l1[1].vectorDistance(l2[0])-l1[0].vectorDistance(l1[1]))<limit) {
      return true;
  }
  if (Math.abs(l1[0].vectorDistance(l2[1])+l1[1].vectorDistance(l2[1])-l1[0].vectorDistance(l1[1]))<limit) {
      return true;
  }
  if (Math.abs(l2[0].vectorDistance(l1[0])+l2[1].vectorDistance(l1[0])-l2[0].vectorDistance(l2[1]))<limit) {
      return true;
  }
  if (Math.abs(l2[0].vectorDistance(l1[1])+l2[1].vectorDistance(l1[1])-l2[0].vectorDistance(l2[1]))<limit) {
      return true;
  }
  //*/

  var a = l1[0];
  var b = l1[1];
  var c = l2[0];
  var d = l2[1];
  var w1 = winding(a, b, c);
  var w2 = winding(c, a, d);
  var w3 = winding(a, b, d);
  var w4 = winding(c, b, d);
  return (w1 == w2) && (w3 == w4) && (w1 != w3);
};

var _asi_v1 = new Vector3();
var _asi_v2 = new Vector3();
var _asi_v3 = new Vector3();
var _asi_v4 = new Vector3();
var _asi_v5 = new Vector3();
var _asi_v6 = new Vector3();

function point_in_aabb_2d(p, min, max) {
  return p[0] >= min[0] && p[0] <= max[0] && p[1] >= min[1] && p[1] <= max[1];
}

var _asi2d_v1 = new Vector2();
var _asi2d_v2 = new Vector2();
var _asi2d_v3 = new Vector2();
var _asi2d_v4 = new Vector2();
var _asi2d_v5 = new Vector2();
var _asi2d_v6 = new Vector2();

function aabb_sphere_isect_2d(p, r, min, max) {
  var v1 = _asi2d_v1, v2 = _asi2d_v2, v3 = _asi2d_v3, mvec = _asi2d_v4;
  var v4 = _asi2d_v5;

  p = _asi2d_v6.load(p);
  v1.load(p);
  v2.load(p);

  min = _asi_v5.load(min);
  max = _asi_v6.load(max);

  mvec.load(max).sub(min).normalize().mulScalar(r + 0.0001);

  v1.sub(mvec);
  v2.add(mvec);
  v3.load(p);

  var ret = point_in_aabb_2d(v1, min, max) || point_in_aabb_2d(v2, min, max)
    || point_in_aabb_2d(v3, min, max);

  if (ret)
    return ret;

  /*
  v1.load(min).add(max).mulScalar(0.5);
  ret = ret || v1.vectorDistance(p) < r;
  
  v1.load(min);
  ret = ret || v1.vectorDistance(p) < r;
  
  v1.load(max);
  ret = ret || v1.vectorDistance(p) < r;
  
  v1[0] = min[0], v1[1] = max[1];
  ret = ret || v1.vectorDistance(p) < r;
  
  v1[0] = max[0], v1[1] = min[1];
  ret = ret || v1.vectorDistance(p) < r;
  */
  //*
  v1.load(min);
  v2[0] = min[0];
  v2[1] = max[1];
  ret = ret || dist_to_line_2d(p, v1, v2) < r;

  v1.load(max);
  v2[0] = max[0];
  v2[1] = max[1];
  ret = ret || dist_to_line_2d(p, v1, v2) < r;

  v1.load(max);
  v2[0] = max[0];
  v2[1] = min[1];
  ret = ret || dist_to_line_2d(p, v1, v2) < r;

  v1.load(max);
  v2[0] = min[0];
  v2[1] = min[1];
  ret = ret || dist_to_line_2d(p, v1, v2) < r;
  //*/
  return ret;
};

function point_in_aabb(p, min, max) {
  return p[0] >= min[0] && p[0] <= max[0] && p[1] >= min[1] && p[1] <= max[1]
    && p[2] >= min[2] && p[2] <= max[2];
}

let asi_rect = new Array(8);
for (let i = 0; i < 8; i++) {
  asi_rect[i] = new Vector3();
}

let aabb_sphere_isect_vs = cachering$1.fromConstructor(Vector3, 64);

function aabb_sphere_isect(p, r, min, max) {
  {
    let p1 = aabb_sphere_isect_vs.next().load(p);
    let min1 = aabb_sphere_isect_vs.next().load(min);
    let max1 = aabb_sphere_isect_vs.next().load(max);
    if (p.length === 2) {
      p1[2] = 0.0;
    }
    if (min1.length === 2) {
      min1[2] = 0.0;
    }
    if (max.length === 2) {
      max1[2] = 0.0;
    }

    p = p1;
    min = min1;
    max = max1;
  }

  let cent = aabb_sphere_isect_vs.next().load(min).interp(max, 0.5);
  p.sub(cent);
  min.sub(cent);
  max.sub(cent);

  r *= r;

  let isect = point_in_aabb(p, min, max);

  if (isect) {
    return true;
  }

  let rect = asi_rect;

  rect[0].loadXYZ(min[0], min[1], min[2]);
  rect[1].loadXYZ(min[0], max[1], min[2]);
  rect[2].loadXYZ(max[0], max[1], min[2]);
  rect[3].loadXYZ(max[0], min[1], min[2]);

  rect[4].loadXYZ(min[0], min[1], max[2]);
  rect[5].loadXYZ(min[0], max[1], max[2]);
  rect[6].loadXYZ(max[0], max[1], max[2]);
  rect[7].loadXYZ(max[0], min[1], max[2]);

  for (let i = 0; i < 8; i++) {
    if (p.vectorDistanceSqr(rect[i]) < r) {
      return true;
    }
  }

  let p2 = aabb_sphere_isect_vs.next().load(p);

  for (let i = 0; i < 3; i++) {
    p2.load(p);

    let i2 = (i + 1)%3;
    let i3 = (i + 2)%3;

    p2[i] = p2[i] < 0.0 ? min[i] : max[i];

    p2[i2] = Math.min(Math.max(p2[i2], min[i2]), max[i2]);
    p2[i3] = Math.min(Math.max(p2[i3], min[i3]), max[i3]);

    let isect = p2.vectorDistanceSqr(p) <= r;

    if (isect) {
      return true;
    }
  }

  return false;
};

function aabb_sphere_dist(p, min, max) {
  {
    let p1 = aabb_sphere_isect_vs.next().load(p);
    let min1 = aabb_sphere_isect_vs.next().load(min);
    let max1 = aabb_sphere_isect_vs.next().load(max);
    if (p.length === 2) {
      p1[2] = 0.0;
    }
    if (min1.length === 2) {
      min1[2] = 0.0;
    }
    if (max.length === 2) {
      max1[2] = 0.0;
    }

    p = p1;
    min = min1;
    max = max1;
  }

  let cent = aabb_sphere_isect_vs.next().load(min).interp(max, 0.5);
  p.sub(cent);
  min.sub(cent);
  max.sub(cent);

  let isect = point_in_aabb(p, min, max);

  if (isect) {
    return 0.0;
  }

  let rect = asi_rect;

  rect[0].loadXYZ(min[0], min[1], min[2]);
  rect[1].loadXYZ(min[0], max[1], min[2]);
  rect[2].loadXYZ(max[0], max[1], min[2]);
  rect[3].loadXYZ(max[0], min[1], min[2]);

  rect[4].loadXYZ(min[0], min[1], max[2]);
  rect[5].loadXYZ(min[0], max[1], max[2]);
  rect[6].loadXYZ(max[0], max[1], max[2]);
  rect[7].loadXYZ(max[0], min[1], max[2]);

  let mindis;

  for (let i = 0; i < 8; i++) {
    let dis = p.vectorDistanceSqr(rect[i]);

    if (mindis === undefined || dis < mindis) {
      mindis = dis;
    }
  }

  let p2 = aabb_sphere_isect_vs.next().load(p);

  for (let i = 0; i < 3; i++) {
    p2.load(p);

    let i2 = (i + 1)%3;
    let i3 = (i + 2)%3;

    p2[i] = p2[i] < 0.0 ? min[i] : max[i];

    p2[i2] = Math.min(Math.max(p2[i2], min[i2]), max[i2]);
    p2[i3] = Math.min(Math.max(p2[i3], min[i3]), max[i3]);

    let dis = p2.vectorDistanceSqr(p);
    if (mindis === undefined || dis < mindis) {
      mindis = dis;
    }
  }

  return mindis === undefined ? 1e17 : mindis;
};

function point_in_tri(p, v1, v2, v3) {
  var w1 = winding(p, v1, v2);
  var w2 = winding(p, v2, v3);
  var w3 = winding(p, v3, v1);
  return w1 == w2 && w2 == w3;
};

function convex_quad(v1, v2, v3, v4) {
  return line_line_cross([v1, v3], [v2, v4]);
};

var $e1_normal_tri = new Vector3();
var $e3_normal_tri = new Vector3();
var $e2_normal_tri = new Vector3();

function isNum(f) {
  let ok = typeof f === "number";

  ok = ok && !isNaN(f) && isFinite(f);

  return ok;
}

const _normal_tri_rets = cachering$1.fromConstructor(Vector3, 64);

function normal_tri(v1, v2, v3) {
  let x1 = v2[0] - v1[0];
  let y1 = v2[1] - v1[1];
  let z1 = v2[2] - v1[2];
  let x2 = v3[0] - v1[0];
  let y2 = v3[1] - v1[1];
  let z2 = v3[2] - v1[2];

  if (!isNum(x1 + y1 + z1 + z2 + y2 + z2)) {
    throw new Error("NaN in normal_tri");
  }

  let x3, y3, z3;

  x1 = v2[0] - v1[0];
  y1 = v2[1] - v1[1];
  z1 = v2[2] - v1[2];
  x2 = v3[0] - v1[0];
  y2 = v3[1] - v1[1];
  z2 = v3[2] - v1[2];
  x3 = y1*z2 - z1*y2;
  y3 = z1*x2 - x1*z2;
  z3 = x1*y2 - y1*x2;

  let len = Math.sqrt((x3*x3 + y3*y3 + z3*z3));

  if (len > 1e-05)
    len = 1.0/len;

  x3 *= len;
  y3 *= len;
  z3 *= len;

  let n = _normal_tri_rets.next();

  if (!isNum(x3 + y3 + z3)) {
    throw new Error("NaN!");
  }

  n[0] = x3;
  n[1] = y3;
  n[2] = z3;

  return n;
};

var $n2_normal_quad = new Vector3();

let _q1 = new Vector3(), _q2 = new Vector3(), _q3 = new Vector3();

function normal_quad(v1, v2, v3, v4) {
  _q1.load(normal_tri(v1, v2, v3));
  _q2.load(normal_tri(v2, v3, v4));

  _q1.add(_q2).normalize();
  return _q1;
}

function normal_quad_old(v1, v2, v3, v4) {
  var n = normal_tri(v1, v2, v3);
  $n2_normal_quad[0] = n[0];
  $n2_normal_quad[1] = n[1];
  $n2_normal_quad[2] = n[2];
  n = normal_tri(v1, v3, v4);
  $n2_normal_quad[0] = $n2_normal_quad[0] + n[0];
  $n2_normal_quad[1] = $n2_normal_quad[1] + n[1];
  $n2_normal_quad[2] = $n2_normal_quad[2] + n[2];
  var _len = Math.sqrt(($n2_normal_quad[0]*$n2_normal_quad[0] + $n2_normal_quad[1]*$n2_normal_quad[1] + $n2_normal_quad[2]*$n2_normal_quad[2]));
  if (_len > 1e-05)
    _len = 1.0/_len;
  $n2_normal_quad[0] *= _len;
  $n2_normal_quad[1] *= _len;
  $n2_normal_quad[2] *= _len;
  return $n2_normal_quad;
};

var _li_vi = new Vector3();

//calc_t is optional, false
function line_isect(v1, v2, v3, v4, calc_t) {
  if (calc_t == undefined) {
    calc_t = false;
  }
  var div = (v2[0] - v1[0])*(v4[1] - v3[1]) - (v2[1] - v1[1])*(v4[0] - v3[0]);
  if (div == 0.0)
    return [new Vector3(), COLINEAR, 0.0];
  var vi = _li_vi;
  vi[0] = 0;
  vi[1] = 0;
  vi[2] = 0;
  vi[0] = ((v3[0] - v4[0])*(v1[0]*v2[1] - v1[1]*v2[0]) - (v1[0] - v2[0])*(v3[0]*v4[1] - v3[1]*v4[0]))/div;
  vi[1] = ((v3[1] - v4[1])*(v1[0]*v2[1] - v1[1]*v2[0]) - (v1[1] - v2[1])*(v3[0]*v4[1] - v3[1]*v4[0]))/div;
  if (calc_t || v1.length == 3) {
    var n1 = new Vector2(v2).sub(v1);
    var n2 = new Vector2(vi).sub(v1);
    var t = n2.vectorLength()/n1.vectorLength();
    n1.normalize();
    n2.normalize();
    if (n1.dot(n2) < 0.0) {
      t = -t;
    }
    if (v1.length == 3) {
      vi[2] = v1[2] + (v2[2] - v1[2])*t;
    }
    return [vi, LINECROSS, t];
  }
  return [vi, LINECROSS];
};

var dt2l_v1 = new Vector2();
var dt2l_v2 = new Vector2();
var dt2l_v3 = new Vector2();
var dt2l_v4 = new Vector2();
var dt2l_v5 = new Vector2();

function dist_to_line_2d(p, v1, v2, clip, closest_co_out = undefined, t_out = undefined) {
  if (clip == undefined) {
    clip = true;
  }

  v1 = dt2l_v4.load(v1);
  v2 = dt2l_v5.load(v2);

  var n = dt2l_v1;
  var vec = dt2l_v3;

  n.load(v2).sub(v1).normalize();
  vec.load(p).sub(v1);

  var t = vec.dot(n);
  if (clip) {
    t = Math.min(Math.max(t, 0.0), v1.vectorDistance(v2));
  }

  n.mulScalar(t).add(v1);

  if (closest_co_out) {
    closest_co_out[0] = n[0];
    closest_co_out[1] = n[1];
  }

  if (t_out !== undefined) {
    t_out = t;
  }

  return n.vectorDistance(p);
}

var dt3l_v1 = new Vector3();
var dt3l_v2 = new Vector3();
var dt3l_v3 = new Vector3();
var dt3l_v4 = new Vector3();
var dt3l_v5 = new Vector3();

function dist_to_line_sqr(p, v1, v2, clip = true) {
  let px = p[0] - v1[0];
  let py = p[1] - v1[1];
  let pz = p.length < 3 ? 0.0 : p[2] - v1[2];

  pz = pz === undefined ? 0.0 : pz;

  let v2x = v2[0] - v1[0];
  let v2y = v2[1] - v1[1];
  let v2z = v2.length < 3 ? 0.0 : v2[2] - v1[2];

  let len = v2x*v2x + v2y*v2y + v2z*v2z;

  if (len === 0.0) {
    return Math.sqrt(px*px + py*py + pz*pz);
  }

  let len2 = 1.0/len;
  v2x *= len2;
  v2y *= len2;
  v2z *= len2;

  let t = px*v2x + py*v2y + pz*v2z;
  if (clip) {
    t = Math.min(Math.max(t, 0.0), len);
  }

  v2x *= t;
  v2y *= t;
  v2z *= t;

  return (v2x - px)*(v2x - px) + (v2y - py)*(v2y - py) + (v2z - pz)*(v2z - pz);
}

function dist_to_line(p, v1, v2, clip = true) {
  return Math.sqrt(dist_to_line_sqr(p, v1, v2, clip));
}

//p cam be 2d, 3d, or 4d point, v1/v2 however must be full homogenous coordinates
var _cplw_vs4 = cachering$1.fromConstructor(Vector4, 64);
var _cplw_vs3 = cachering$1.fromConstructor(Vector3, 64);
var _cplw_vs2 = cachering$1.fromConstructor(Vector2, 64);

function wclip(x1, x2, w1, w2, near) {
  var r1 = near*w1 - x1;
  var r2 = (w1 - w2)*near - (x1 - x2);

  if (r2 == 0.0) return 0.0;

  return r1/r2;
}

function clip(a, b, znear) {
  if (a - b == 0.0) return 0.0;

  return (a - znear)/(a - b);
}

/*clips v1 and v2 to lie within homogenous projection range
  v1 and v2 are assumed to be projected, pre-division Vector4's
  returns a positive number (how much the line was scaled) if either _v1 or _v2 are
  in front of the near clipping plane otherwise, returns 0
 */
function clip_line_w(_v1, _v2, znear, zfar) {
  var v1 = _cplw_vs4.next().load(_v1);
  var v2 = _cplw_vs4.next().load(_v2);

  //are we fully behind the view plane?
  if ((v1[2] < 1.0 && v2[2] < 1.0))
    return false;

  function doclip1(v1, v2, axis) {
    if (v1[axis]/v1[3] < -1) {
      var t = wclip(v1[axis], v2[axis], v1[3], v2[3], -1);
      v1.interp(v2, t);
    } else if (v1[axis]/v1[3] > 1) {
      var t = wclip(v1[axis], v2[axis], v1[3], v2[3], 1);
      v1.interp(v2, t);
    }
  }

  function doclip(v1, v2, axis) {
    doclip1(v1, v2, axis);
    doclip1(v2, v1, axis);
  }

  function dozclip(v1, v2) {
    if (v1[2] < 1) {
      var t = clip(v1[2], v2[2], 1);
      v1.interp(v2, t);
    } else if (v2[2] < 1) {
      var t = clip(v2[2], v1[2], 1);
      v2.interp(v1, t);
    }
  }

  dozclip(v1, v2, 1);
  doclip(v1, v2, 0);
  doclip(v1, v2, 1);

  for (var i = 0; i < 4; i++) {
    _v1[i] = v1[i];
    _v2[i] = v2[i];
  }

  return !(v1[0]/v1[3] == v2[0]/v2[3] || v1[1]/v2[3] == v2[1]/v2[3]);
};

//clip is optional, true.  clip point to lie within line segment v1->v2
var _closest_point_on_line_cache = cachering$1.fromConstructor(Vector3, 64);
var _closest_point_rets = new cachering$1(function () {
  return [0, 0];
}, 64);

var _closest_tmps = [new Vector3(), new Vector3(), new Vector3()];

function closest_point_on_line(p, v1, v2, clip = true) {
  var l1 = _closest_tmps[0], l2 = _closest_tmps[1];
  var len;


  l1.load(v2).sub(v1);

  if (clip) {
    len = l1.vectorLength();
  }

  l1.normalize();
  l2.load(p).sub(v1);

  var t = l2.dot(l1);
  if (clip) {
    //t = t*(t<0.0) + t*(t>1.0) + (t>1.0);
    t = t < 0.0 ? 0.0 : t;
    t = t > len ? len : t;
  }

  var p = _closest_point_on_line_cache.next();
  p.load(l1).mulScalar(t).add(v1);
  var ret = _closest_point_rets.next();

  ret[0] = p;
  ret[1] = t;

  return ret;
};

/*given input line (a,d) and tangent t,
  returns a circle that goes through both
  a and d, whose normalized tangent at a is the same
  as normalized t.
  
  note that t need not be normalized, this function
  does that itself*/
var _circ_from_line_tan_vs = cachering$1.fromConstructor(Vector3, 32);
var _circ_from_line_tan_ret = new cachering$1(function () {
  return [new Vector3(), 0];
}, 64);

function circ_from_line_tan(a, b, t) {
  let p1 = _circ_from_line_tan_vs.next();
  let t2 = _circ_from_line_tan_vs.next();
  let n1 = _circ_from_line_tan_vs.next();

  p1.load(a).sub(b);
  t2.load(t).normalize();
  n1.load(p1).normalize().cross(t2).cross(t2).normalize();

  let ax = p1[0], ay = p1[1], az = p1[2], nx = n1[0], ny = n1[1], nz = n1[2];
  let r = -(ax*ax + ay*ay + az*az);
  let div = (2*(ax*nx + ay*ny + az*nz));

  if (Math.abs(div) > 0.000001) {
    r /= div;
  } else {
    r = 1000000.0;
  }

  let ret = _circ_from_line_tan_ret.next();
  ret[0].load(n1).mulScalar(r).add(a);
  ret[1] = r;

  return ret;
}

/*given input line (a,d) and tangent t,
  returns a circle that goes through both
  a and d, whose normalized tangent at a is the same
  as normalized t.

  note that t need not be normalized, this function
  does that itself*/
var _circ_from_line_tan2d_vs = cachering$1.fromConstructor(Vector3, 32);
var _circ_from_line_tan2d_ret = new cachering$1(function () {
  return [new Vector2(), 0];
}, 64);

function circ_from_line_tan_2d(a, b, t) {
  a = _circ_from_line_tan2d_vs.next().load(a);
  b = _circ_from_line_tan2d_vs.next().load(b);
  t = _circ_from_line_tan2d_vs.next().load(t);

  a[2] = b[2] = t[2] = 0.0;

  let p1 = _circ_from_line_tan2d_vs.next();
  let t2 = _circ_from_line_tan2d_vs.next();
  let n1 = _circ_from_line_tan2d_vs.next();

  p1.load(a).sub(b);
  t2.load(t).normalize();
  n1.load(p1).normalize().cross(t2).cross(t2).normalize();

  if (1) {
    let cx, cy, r;
    let x1 = a[0], y1 = a[1];
    let x2 = b[0], y2 = b[1];
    let tanx1 = t[0], tany1 = t[1];

    let div = (4.0*((x1 - x2)*tany1 - (y1 - y2)*tanx1)**2);
    let div2 = (2.0*(x1 - x2)*tany1 - 2.0*(y1 - y2)*tanx1);

    if (Math.abs(div) < 0.0001 || Math.abs(div2) < 0.0001) {
      let ret = _circ_from_line_tan2d_ret.next();

      ret[0].load(a).interp(b, 0.5);
      let dx = a[1] - b[1];
      let dy = b[0] - a[0];

      r = 1000000.0;

      ret[0][0] += dx*r;
      ret[0][1] += dy*r;
      ret[1] = r;

      return ret;
    }
    cx = (((x1 + x2)*(x1 - x2) - (y1 - y2)**2)*tany1 - 2.0*(y1 - y2)*tanx1*x1
    )/div2;

    cy = (-((y1 + y2)*(y1 - y2) - x2**2 - (x1 - 2.0*x2)*x1)*tanx1 + 2.0*(x1 -
      x2)*tany1*y1)/div2;

    r = (((y1 - y2)**2 + x2**2 + (x1 - 2.0*x2)*x1)**2*(tanx1**2 + tany1**2)
    )/div;

    let midx = a[0]*0.5 + b[0]*0.5;
    let midy = a[1]*0.5 + b[1]*0.5;

    //mirror
    cx = 2.0*midx - cx;
    cy = 2.0*midy - cy;

    let ret = _circ_from_line_tan2d_ret.next();
    ret[0].loadXY(cx, cy);
    ret[1] = Math.sqrt(r);

    return ret;
  } else {
    let ax = p1[0], ay = p1[1], az = p1[2], nx = n1[0], ny = n1[1], nz = n1[2];
    let r = -(ax*ax + ay*ay + az*az);
    let div = (2*(ax*nx + ay*ny + az*nz));

    if (Math.abs(div) > 0.000001) {
      r /= div;
    } else {
      r = 1000000.0;
    }

    let ret = _circ_from_line_tan2d_ret.next();
    ret[0].load(n1).mulScalar(r).add(a);
    ret[1] = r;

    return ret;
  }

  return ret;
}

var _gtc_e1 = new Vector3();
var _gtc_e2 = new Vector3();
var _gtc_e3 = new Vector3();
var _gtc_p1 = new Vector3();
var _gtc_p2 = new Vector3();
var _gtc_v1 = new Vector3();
var _gtc_v2 = new Vector3();
var _gtc_p12 = new Vector3();
var _gtc_p22 = new Vector3();
var _get_tri_circ_ret = new cachering$1(function () {
  return [0, 0]
});

function get_tri_circ(a, b, c) {
  var v1 = _gtc_v1;
  var v2 = _gtc_v2;
  var e1 = _gtc_e1;
  var e2 = _gtc_e2;
  var e3 = _gtc_e3;
  var p1 = _gtc_p1;
  var p2 = _gtc_p2;

  for (var i = 0; i < 3; i++) {
    e1[i] = b[i] - a[i];
    e2[i] = c[i] - b[i];
    e3[i] = a[i] - c[i];
  }

  for (var i = 0; i < 3; i++) {
    p1[i] = (a[i] + b[i])*0.5;
    p2[i] = (c[i] + b[i])*0.5;
  }

  e1.normalize();

  v1[0] = -e1[1];
  v1[1] = e1[0];
  v1[2] = e1[2];

  v2[0] = -e2[1];
  v2[1] = e2[0];
  v2[2] = e2[2];

  v1.normalize();
  v2.normalize();

  var cent;
  var type;
  for (var i = 0; i < 3; i++) {
    _gtc_p12[i] = p1[i] + v1[i];
    _gtc_p22[i] = p2[i] + v2[i];
  }

  var ret = line_isect(p1, _gtc_p12, p2, _gtc_p22);
  cent = ret[0];
  type = ret[1];

  e1.load(a);
  e2.load(b);
  e3.load(c);

  var r = e1.sub(cent).vectorLength();
  if (r < feps)
    r = e2.sub(cent).vectorLength();
  if (r < feps)
    r = e3.sub(cent).vectorLength();

  var ret = _get_tri_circ_ret.next();
  ret[0] = cent;
  ret[1] = r;

  return ret;
};

function gen_circle(m, origin, r, stfeps) {
  var pi = Math.PI;
  var f = -pi/2;
  var df = (pi*2)/stfeps;
  var verts = new Array();
  for (var i = 0; i < stfeps; i++) {
    var x = origin[0] + r*Math.sin(f);
    var y = origin[1] + r*Math.cos(f);
    var v = m.make_vert(new Vector3([x, y, origin[2]]));
    verts.push(v);
    f += df;
  }
  for (var i = 0; i < verts.length; i++) {
    var v1 = verts[i];
    var v2 = verts[(i + 1)%verts.length];
    m.make_edge(v1, v2);
  }
  return verts;
};

var cos$1 = Math.cos;
var sin$1 = Math.sin;

//axis is optional, 0
function rot2d(v1, A, axis) {
  var x = v1[0];
  var y = v1[1];

  if (axis == 1) {
    v1[0] = x*cos$1(A) + y*sin$1(A);
    v1[2] = y*cos$1(A) - x*sin$1(A);
  } else {
    v1[0] = x*cos$1(A) - y*sin$1(A);
    v1[1] = y*cos$1(A) + x*sin$1(A);
  }
}

function makeCircleMesh(gl, radius, stfeps) {
  var mesh = new Mesh();
  var verts1 = gen_circle(mesh, new Vector3(), radius, stfeps);
  var verts2 = gen_circle(mesh, new Vector3(), radius/1.75, stfeps);
  mesh.make_face_complex([verts1, verts2]);
  return mesh;
};

function minmax_verts(verts) {
  var min = new Vector3([1000000000000.0, 1000000000000.0, 1000000000000.0]);
  var max = new Vector3([-1000000000000.0, -1000000000000.0, -1000000000000.0]);
  var __iter_v = __get_iter(verts);
  var v;
  while (1) {
    var __ival_v = __iter_v.next();
    if (__ival_v.done) {
      break;
    }
    v = __ival_v.value;
    for (var i = 0; i < 3; i++) {
      min[i] = Math.min(min[i], v.co[i]);
      max[i] = Math.max(max[i], v.co[i]);
    }
  }
  return [min, max];
};

function unproject(vec, ipers, iview) {
  var newvec = new Vector3(vec);
  newvec.multVecMatrix(ipers);
  newvec.multVecMatrix(iview);
  return newvec;
};

function project(vec, pers, view) {
  var newvec = new Vector3(vec);
  newvec.multVecMatrix(pers);
  newvec.multVecMatrix(view);
  return newvec;
};

var _sh_minv = new Vector3();
var _sh_maxv = new Vector3();
var _sh_start = [];
var _sh_end = [];

var static_cent_gbw = new Vector3();

function get_boundary_winding(points) {
  var cent = static_cent_gbw.zero();
  if (points.length == 0)
    return false;
  for (var i = 0; i < points.length; i++) {
    cent.add(points[i]);
  }
  cent.divideScalar(points.length);
  var w = 0, totw = 0;
  for (var i = 0; i < points.length; i++) {
    var v1 = points[i];
    var v2 = points[(i + 1)%points.length];
    if (!colinear(v1, v2, cent)) {
      w += winding(v1, v2, cent);
      totw += 1;
    }
  }
  if (totw > 0)
    w /= totw;
  return Math.round(w) == 1;
};

class PlaneOps {
  constructor(normal) {
    var no = normal;
    this.axis = [0, 0, 0];
    this.reset_axis(normal);
  }

  reset_axis(no) {
    var ax, ay, az;
    var nx = Math.abs(no[0]), ny = Math.abs(no[1]), nz = Math.abs(no[2]);
    if (nz > nx && nz > ny) {
      ax = 0;
      ay = 1;
      az = 2;
    } else if (nx > ny && nx > nz) {
      ax = 2;
      ay = 1;
      az = 0;
    } else {
      ax = 0;
      ay = 2;
      az = 1;
    }
    this.axis = [ax, ay, az];
  }

  convex_quad(v1, v2, v3, v4) {
    var ax = this.axis;
    v1 = new Vector3([v1[ax[0]], v1[ax[1]], v1[ax[2]]]);
    v2 = new Vector3([v2[ax[0]], v2[ax[1]], v2[ax[2]]]);
    v3 = new Vector3([v3[ax[0]], v3[ax[1]], v3[ax[2]]]);
    v4 = new Vector3([v4[ax[0]], v4[ax[1]], v4[ax[2]]]);
    return convex_quad(v1, v2, v3, v4);
  }

  line_isect(v1, v2, v3, v4) {
    var ax = this.axis;
    var orig1 = v1, orig2 = v2;
    v1 = new Vector3([v1[ax[0]], v1[ax[1]], v1[ax[2]]]);
    v2 = new Vector3([v2[ax[0]], v2[ax[1]], v2[ax[2]]]);
    v3 = new Vector3([v3[ax[0]], v3[ax[1]], v3[ax[2]]]);
    v4 = new Vector3([v4[ax[0]], v4[ax[1]], v4[ax[2]]]);
    var ret = line_isect(v1, v2, v3, v4, true);
    var vi = ret[0];
    if (ret[1] == LINECROSS) {
      ret[0].load(orig2).sub(orig1).mulScalar(ret[2]).add(orig1);
    }
    return ret;
  }

  line_line_cross(l1, l2) {
    var ax = this.axis;
    var v1 = l1[0], v2 = l1[1], v3 = l2[0], v4 = l2[1];
    v1 = new Vector3([v1[ax[0]], v1[ax[1]], 0.0]);
    v2 = new Vector3([v2[ax[0]], v2[ax[1]], 0.0]);
    v3 = new Vector3([v3[ax[0]], v3[ax[1]], 0.0]);
    v4 = new Vector3([v4[ax[0]], v4[ax[1]], 0.0]);
    return line_line_cross([v1, v2], [v3, v4]);
  }

  winding(v1, v2, v3) {
    var ax = this.axis;
    if (v1 == undefined)
      console.trace();
    v1 = new Vector3([v1[ax[0]], v1[ax[1]], 0.0]);
    v2 = new Vector3([v2[ax[0]], v2[ax[1]], 0.0]);
    v3 = new Vector3([v3[ax[0]], v3[ax[1]], 0.0]);
    return winding(v1, v2, v3);
  }

  colinear(v1, v2, v3) {
    var ax = this.axis;
    v1 = new Vector3([v1[ax[0]], v1[ax[1]], 0.0]);
    v2 = new Vector3([v2[ax[0]], v2[ax[1]], 0.0]);
    v3 = new Vector3([v3[ax[0]], v3[ax[1]], 0.0]);
    return colinear(v1, v2, v3);
  }

  get_boundary_winding(points) {
    var ax = this.axis;
    var cent = new Vector3();
    if (points.length == 0)
      return false;
    for (var i = 0; i < points.length; i++) {
      cent.add(points[i]);
    }
    cent.divideScalar(points.length);
    var w = 0, totw = 0;
    for (var i = 0; i < points.length; i++) {
      var v1 = points[i];
      var v2 = points[(i + 1)%points.length];
      if (!this.colinear(v1, v2, cent)) {
        w += this.winding(v1, v2, cent);
        totw += 1;
      }
    }
    if (totw > 0)
      w /= totw;
    return Math.round(w) == 1;
  }
}

/*
on factor;

px := rox + rnx*t;
py := roy + rny*t;
pz := roz + rnz*t;

f1 := (px-pox)*pnx + (py-poy)*pny + (pz-poz)*pnz;
ff := solve(f1, t);
on fort;
part(ff, 1, 2);
off fort;

* */
var _isrp_ret = new Vector3();
let isect_ray_plane_rets = cachering$1.fromConstructor(Vector3, 256);

function isect_ray_plane(planeorigin, planenormal, rayorigin, raynormal) {
  let po = planeorigin, pn = planenormal, ro = rayorigin, rn = raynormal;

  let div = (pn[1]*rn[1] + pn[2]*rn[2] + pn[0]*rn[0]);

  if (Math.abs(div) < 0.000001) {
    return undefined;
  }

  let t = ((po[1] - ro[1])*pn[1] + (po[2] - ro[2])*pn[2] + (po[0] - ro[0])*pn[0])/div;
  _isrp_ret.load(ro).addFac(rn, t);

  return isect_ray_plane_rets.next().load(_isrp_ret);
}

function _old_isect_ray_plane(planeorigin, planenormal, rayorigin, raynormal) {
  var p = planeorigin, n = planenormal;
  var r = rayorigin, v = raynormal;

  var d = p.vectorLength();
  var t = -(r.dot(n) - p.dot(n))/v.dot(n);
  _isrp_ret.load(v);
  _isrp_ret.mulScalar(t);
  _isrp_ret.add(r);
  return _isrp_ret;
};

function mesh_find_tangent(mesh, viewvec, offvec, projmat, verts) {
  if (verts == undefined)
    verts = mesh.verts.selected;
  var vset = new set$2();
  var eset = new set$2();
  var __iter_v = __get_iter(verts);
  var v;
  while (1) {
    var __ival_v = __iter_v.next();
    if (__ival_v.done) {
      break;
    }
    v = __ival_v.value;
    vset.add(v);
  }
  var __iter_v = __get_iter(vset);
  var v;
  while (1) {
    var __ival_v = __iter_v.next();
    if (__ival_v.done) {
      break;
    }
    v = __ival_v.value;
    var __iter_e = __get_iter(v.edges);
    var e;
    while (1) {
      var __ival_e = __iter_e.next();
      if (__ival_e.done) {
        break;
      }
      e = __ival_e.value;
      if (vset.has(e.other_vert(v))) {
        eset.add(e);
      }
    }
  }
  if (eset.length == 0) {
    return new Vector3(offvec);
  }
  var tanav = new Vector3();
  var evec = new Vector3();
  var tan = new Vector3();
  var co2 = new Vector3();
  var __iter_e = __get_iter(eset);
  var e;
  while (1) {
    var __ival_e = __iter_e.next();
    if (__ival_e.done) {
      break;
    }
    e = __ival_e.value;
    evec.load(e.v1.co).multVecMatrix(projmat);
    co2.load(e.v2.co).multVecMatrix(projmat);
    evec.sub(co2);
    evec.normalize();
    tan[0] = evec[1];
    tan[1] = -evec[0];
    tan[2] = 0.0;
    if (tan.dot(offvec) < 0.0)
      tan.mulScalar(-1.0);
    tanav.add(tan);
  }
  tanav.normalize();
  return tanav;
};

class Mat4Stack {
  constructor() {
    this.stack = [];
    this.matrix = new Matrix4();
    this.matrix.makeIdentity();
    this.update_func = undefined;
  }

  set_internal_matrix(mat, update_func) {
    this.update_func = update_func;
    this.matrix = mat;
  }

  reset(mat) {
    this.matrix.load(mat);
    this.stack = [];
    if (this.update_func != undefined)
      this.update_func();
  }

  load(mat) {
    this.matrix.load(mat);
    if (this.update_func != undefined)
      this.update_func();
  }

  multiply(mat) {
    this.matrix.multiply(mat);
    if (this.update_func != undefined)
      this.update_func();
  }

  identity() {
    this.matrix.loadIdentity();
    if (this.update_func != undefined)
      this.update_func();
  }

  push(mat2) {
    this.stack.push(new Matrix4(this.matrix));
    if (mat2 != undefined) {
      this.matrix.load(mat2);
      if (this.update_func != undefined)
        this.update_func();
    }
  }

  pop() {
    var mat = this.stack.pop(this.stack.length - 1);
    this.matrix.load(mat);
    if (this.update_func != undefined)
      this.update_func();
    return mat;
  }
}


/*

on factor;
off period;

load_package "avector";


a1 := avec(a1x, a1y, a1z);
b1 := avec(b1x, b1y, b1z);
c1 := avec(c1x, c1y, c1z);
d1 := avec(d1x, d1y, d1z);

a1x := 0;
a1y := 0;
a1z := 0;

a2 := avec(a2x, a2y, a2z);
b2 := avec(b2x, b2y, b2z);
c2 := avec(c2x, c2y, c2z);
d2 := avec(d2x, d2y, d2z);

p1 := a1 + (b1 - a1) * v;
p2 := d1 + (c1 - d1) * v;
p3 := p1 + (p2 - p1) * u;

p4 := a2 + (b2 - a2) * v;
p5 := d2 + (c2 - d2) * v;
p6 := p4 + (p5 - p4) * u;

p7 := p3 + (p6 - p3) * w;

f1 := p7[0] - goalx;
f2 := p7[1] - goaly;
f3 := p7[2] - goalz;

comment: solve({f1, f2, f3}, {u, v, w});

on fort;
p7;
off fort;

sub(u=0, v=1, w=0, p7[0]);

*/

const tril_rets = cachering$1.fromConstructor(Vector3, 128);

function lreport() {
  //console.log(...arguments);
}

function trilinear_v3(uvw, boxverts) {
  let [u, v, w] = uvw;

  const a1x = boxverts[0][0], a1y = boxverts[0][1], a1z = boxverts[0][2];

  const b1x = boxverts[1][0] - a1x, b1y = boxverts[1][1] - a1y, b1z = boxverts[1][2] - a1z;
  const c1x = boxverts[2][0] - a1x, c1y = boxverts[2][1] - a1y, c1z = boxverts[2][2] - a1z;
  const d1x = boxverts[3][0] - a1x, d1y = boxverts[3][1] - a1y, d1z = boxverts[3][2] - a1z;

  const a2x = boxverts[4][0] - a1x, a2y = boxverts[4][1] - a1y, a2z = boxverts[4][2] - a1z;
  const b2x = boxverts[5][0] - a1x, b2y = boxverts[5][1] - a1y, b2z = boxverts[5][2] - a1z;
  const c2x = boxverts[6][0] - a1x, c2y = boxverts[6][1] - a1y, c2z = boxverts[6][2] - a1z;
  const d2x = boxverts[7][0] - a1x, d2y = boxverts[7][1] - a1y, d2z = boxverts[7][2] - a1z;

  const x = (((a2x - b2x)*v - a2x + (c2x - d2x)*v + d2x)*u - ((a2x - b2x)*v - a2x) - (
      ((c1x - d1x)*v + d1x - b1x*v)*u + b1x*v))*w + ((c1x - d1x)*v + d1x - b1x*v)*u +
    b1x*v;
  const y = (((a2y - b2y)*v - a2y + (c2y - d2y)*v + d2y)*u - ((a2y - b2y)*v - a2y) - (
      ((c1y - d1y)*v + d1y - b1y*v)*u + b1y*v))*w + ((c1y - d1y)*v + d1y - b1y*v)*u +
    b1y*v;
  const z = (((a2z - b2z)*v - a2z + (c2z - d2z)*v + d2z)*u - ((a2z - b2z)*v - a2z) - (
      ((c1z - d1z)*v + d1z - b1z*v)*u + b1z*v))*w + ((c1z - d1z)*v + d1z - b1z*v)*u +
    b1z*v;

  let p = tril_rets.next();

  p[0] = x + a1x;
  p[1] = y + a1y;
  p[2] = z + a1z;

  return p;
}

let tril_co_rets = cachering$1.fromConstructor(Vector3, 128);
let tril_co_tmps = cachering$1.fromConstructor(Vector3, 16);
let tril_mat_1 = new Matrix4();
let tril_mat_2 = new Matrix4();

let wtable = [
  [
    [0.5, 0.5, 0], //u triplet
    [0.5, 0.5, 0], //v triplet
    [0.5, 0.5, 0]  //w triplet
  ],
  [
    [0.5, 0.5, 0],
    [0.0, 0.5, 0.5],
    [0.5, 0.5, 0]
  ],
  [
    [0.0, 0.5, 0.5],
    [0.0, 0.5, 0.5],
    [0.5, 0.5, 0]
  ],
  [
    [0.0, 0.5, 0.5],
    [0.5, 0.5, 0],
    [0.5, 0.5, 0]
  ],
];

for (let i = 0; i < 4; i++) {
  let w = wtable[i];
  w = [w[0], w[1], [0.0, 0.5, 0.5]];
  wtable.push(w);
}

const pih_tmps = cachering$1.fromConstructor(Vector3, 16);
const boxfaces_table = [
  [0, 1, 2, 3],
  [7, 6, 5, 4],
  [0, 4, 5, 1],
  [1, 5, 6, 2],
  [2, 6, 7, 3],
  [3, 7, 4, 0]
];

let boxfaces_tmp = new Array(6);
for (let i = 0; i < 6; i++) {
  boxfaces_tmp[i] = new Vector3();
}

let boxfacenormals_tmp = new Array(6);
for (let i = 0; i < 6; i++) {
  boxfacenormals_tmp[i] = new Vector3();
}

function point_in_hex(p, boxverts, boxfacecents = undefined, boxfacenormals = undefined) {
  if (!boxfacecents) {
    boxfacecents = boxfaces_tmp;

    for (let i = 0; i < 6; i++) {
      let [v1, v2, v3, v4] = boxfaces_table[i];
      v1 = boxverts[v1];
      v2 = boxverts[v2];
      v3 = boxverts[v3];
      v4 = boxverts[v4];

      boxfacecents[i].load(v1).add(v2).add(v3).add(v4).mulScalar(0.25);
    }
  }

  if (!boxfacenormals) {
    boxfacenormals = boxfacenormals_tmp;
    for (let i = 0; i < 6; i++) {
      let [v1, v2, v3, v4] = boxfaces_table[i];
      v1 = boxverts[v1];
      v2 = boxverts[v2];
      v3 = boxverts[v3];
      v4 = boxverts[v4];

      let n = normal_quad(v1, v2, v3, v4);
      boxfacenormals[i].load(n).negate();
    }
  }

  let t1 = pih_tmps.next();
  let t2 = pih_tmps.next();

  let cent = pih_tmps.next().zero();
  for (let i = 0; i < 6; i++) {
    cent.add(boxfacecents[i]);
  }
  cent.mulScalar(1.0/6.0);

  let ret = true;

  for (let i = 0; i < 6; i++) {
    t1.load(p).sub(boxfacecents[i]);
    t2.load(cent).sub(boxfacecents[i]);
    let n = boxfacenormals[i];

    if (1) {
      t1.normalize();
      t2.normalize();

      //console.log(i, "DOT", n.dot(t1).toFixed(5), n, t1);
    }

    if (t1.dot(t2) < 0) {
      //console.log("\n");
      ret = false;
      return false;
    }
  }

  //console.log("\n");
  return ret;
  //return true;
}

const boxverts_tmp = new Array(8);
for (let i = 0; i < 8; i++) {
  boxverts_tmp[i] = new Vector3();
}

function trilinear_co(p, boxverts) {
  let uvw = tril_co_rets.next();

  uvw.zero();

  let u = tril_co_tmps.next();
  let v = tril_co_tmps.next();
  let w = tril_co_tmps.next();

  u.loadXYZ(0.0, 0.5, 1.0);
  v.loadXYZ(0.0, 0.5, 1.0);
  w.loadXYZ(0.0, 0.5, 1.0);

  let uvw2 = tril_co_tmps.next();

  for (let step = 0; step < 4; step++) {
    uvw.loadXYZ(u[1], v[1], w[1]);

    let mini = undefined;
    let mindis = trilinear_v3(uvw, boxverts).vectorDistanceSqr(p);

    for (let i = 0; i < 8; i++) {
      let [t1, t2, t3] = wtable[i];

      let u2 = t1[0]*u[0] + t1[1]*u[1] + t1[2]*u[2];
      let v2 = t2[0]*v[0] + t2[1]*v[1] + t2[2]*v[2];
      let w2 = t3[0]*w[0] + t3[1]*w[1] + t3[2]*w[2];

      let du = Math.abs(u2 - u[1]);
      let dv = Math.abs(v2 - v[1]);
      let dw = Math.abs(w2 - w[1]);

      uvw.loadXYZ(u2, v2, w2);
      let dis = trilinear_v3(uvw, boxverts).vectorDistanceSqr(p);

      if (mindis === undefined || dis < mindis) {
        //mindis = dis;
        //mini = i;
      }

      if (1) {
        let bv = boxverts_tmp;

        /*
        let dd = 1.0 - 0.001;

        du *= dd;
        dv *= dd;
        dw *= dd;
        //*/

        bv[0].loadXYZ(u2 - du, v2 - dv, w2 - dw);
        bv[1].loadXYZ(u2 - du, v2 + dv, w2 - dw);
        bv[2].loadXYZ(u2 + du, v2 + dv, w2 - dw);
        bv[3].loadXYZ(u2 + du, v2 - dv, w2 - dw);

        bv[4].loadXYZ(u2 - du, v2 - dv, w2 + dw);
        bv[5].loadXYZ(u2 - du, v2 + dv, w2 + dw);
        bv[6].loadXYZ(u2 + du, v2 + dv, w2 + dw);
        bv[7].loadXYZ(u2 + du, v2 - dv, w2 + dw);

        for (let j = 0; j < 8; j++) {
          bv[j].load(trilinear_v3(bv[j], boxverts));
        }

        if (point_in_hex(p, bv)) {
          mini = i;
          mindis = dis;
          //console.log("DIS", (dis**0.5).toFixed(3));
          break;
        }

        //console.log("\n");
      }
    }

    if (mini === undefined) {
      lreport("mindis:", (mindis**0.5).toFixed(3));
      break;
    }

    let [t1, t2, t3] = wtable[mini];

    let u2 = t1[0]*u[0] + t1[1]*u[1] + t1[2]*u[2];
    let v2 = t2[0]*v[0] + t2[1]*v[1] + t2[2]*v[2];
    let w2 = t3[0]*w[0] + t3[1]*w[1] + t3[2]*w[2];

    let du = Math.abs(u2 - u[1]);
    let dv = Math.abs(v2 - v[1]);
    let dw = Math.abs(w2 - w[1]);

    u[0] = u2 - du;
    v[0] = v2 - dv;
    w[0] = w2 - dw;

    u[1] = u2;
    v[1] = v2;
    w[1] = w2;

    u[2] = u2 + du;
    v[2] = v2 + dv;
    w[2] = w2 + dw;

    lreport("mindis:", (mindis**0.5).toFixed(3), u2, v2, w2);
  }

  uvw.loadXYZ(u[1], v[1], w[1]);

  //console.log("uvw", uvw);

  //return uvw;

  return trilinear_co2(p, boxverts, uvw);
}

//newton-raphson
function trilinear_co2(p, boxverts, uvw) {
  //let uvw = tril_co_rets.next();
  let grad = tril_co_tmps.next();

  //uvw[0] = uvw[1] = uvw[2] = 0.5;

  let df = 0.00001;

  let mat = tril_mat_1;
  let m = mat.$matrix;
  let mat2 = tril_mat_2;

  let r1 = tril_co_tmps.next();

  for (let step = 0; step < 55; step++) {
    //let r1 = trilinear_v3(uvw, boxverts).vectorDistance(p);
    let totg = 0;

    for (let i = 0; i < 3; i++) {
      let axis_error = 0.0;

      if (uvw[i] < 0) {
        axis_error = -uvw[i];
      } else if (uvw[i] > 1.0) {
        axis_error = uvw[i] - 1.0;
      }
      //r1[i] = trilinear_v3(uvw, boxverts)[i] - p[i];
      r1[i] = trilinear_v3(uvw, boxverts).vectorDistance(p) + 10.0*axis_error;

      let orig = uvw[i];

      uvw[i] += df;
      //let r2 = trilinear_v3(uvw, boxverts)[i] - p[i];

      if (uvw[i] < 0) {
        axis_error = -uvw[i];
      } else if (uvw[i] > 1.0) {
        axis_error = uvw[i] - 1.0;
      } else {
        axis_error = 0.0;
      }
      let r2 = trilinear_v3(uvw, boxverts).vectorDistance(p) + 10.0*axis_error;
      uvw[i] = orig;

      grad[i] = (r2 - r1[i])/df;
      totg += grad[i]**2;
    }

    if (totg === 0.0) {
      break;
    }

    let err = trilinear_v3(uvw, boxverts).vectorDistance(p);

    if (1) {
      //grad.normalize();
      uvw.addFac(grad, -err/totg*0.85);
    } else {
      mat.makeIdentity();
      m.m11 = grad[0];
      m.m12 = grad[1];
      m.m13 = grad[2];
      m.m22 = m.m33 = m.m44 = 0.0;

      mat.transpose();
      mat2.load(mat).transpose();

      //right-indepdenent pseudo inverse
      //mat.multiply(mat2).invert();
      //mat.preMultiply(mat2);

      //left-independent
      mat.preMultiply(mat2).invert();
      mat.multiply(mat2);

      grad.load(r1);
      grad.multVecMatrix(mat);
      uvw.addFac(grad, -1.0);
    }

    lreport("error:", err.toFixed(3), uvw);

    if (r1.dot(r1)**0.5 < 0.0001) {
      break;
    }
  }

  lreport("\n");

  return uvw;
}

let angle_tri_v3_rets = cachering$1.fromConstructor(Vector3, 32);
let angle_tri_v3_vs = cachering$1.fromConstructor(Vector3, 32);

function tri_angles(v1, v2, v3) {
  let t1 = angle_tri_v3_vs.next().load(v1).sub(v2);
  let t2 = angle_tri_v3_vs.next().load(v3).sub(v2);
  let t3 = angle_tri_v3_vs.next().load(v2).sub(v3);

  t1.normalize();
  t2.normalize();
  t3.normalize();

  let th1 = Math.acos(t1.dot(t2)*0.99999);
  t2.negate();

  let th2 = Math.acos(t2.dot(t3)*0.99999);
  let th3 = Math.PI - (th1 + th2);

  let ret = angle_tri_v3_rets.next();

  ret[0] = th1;
  ret[1] = th2;
  ret[2] = th3;

  return ret;
}

var math1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  quad_bilinear: quad_bilinear,
  ClosestModes: ClosestModes,
  AbstractCurve: AbstractCurve,
  ClosestCurveRets: ClosestCurveRets,
  closestPoint: closestPoint,
  normal_poly: normal_poly,
  dihedral_v3_sqr: dihedral_v3_sqr,
  tet_volume: tet_volume,
  calc_projection_axes: calc_projection_axes,
  aabb_isect_line_3d: aabb_isect_line_3d,
  aabb_isect_cylinder_3d: aabb_isect_cylinder_3d,
  barycentric_v2: barycentric_v2,
  closest_point_on_quad: closest_point_on_quad,
  closest_point_on_tri: closest_point_on_tri,
  dist_to_tri_v3_old: dist_to_tri_v3_old,
  dist_to_tri_v3: dist_to_tri_v3,
  dist_to_tri_v3_sqr: dist_to_tri_v3_sqr,
  tri_area: tri_area,
  aabb_overlap_area: aabb_overlap_area,
  aabb_isect_2d: aabb_isect_2d,
  aabb_isect_3d: aabb_isect_3d,
  aabb_intersect_2d: aabb_intersect_2d,
  aabb_intersect_3d: aabb_intersect_3d,
  aabb_union: aabb_union,
  aabb_union_2d: aabb_union_2d,
  feps: feps,
  COLINEAR: COLINEAR,
  LINECROSS: LINECROSS,
  COLINEAR_ISECT: COLINEAR_ISECT,
  SQRT2: SQRT2,
  FEPS_DATA: FEPS_DATA,
  FEPS: FEPS,
  get FLOAT_MIN () { return FLOAT_MIN; },
  get FLOAT_MAX () { return FLOAT_MAX; },
  Matrix4UI: Matrix4UI,
  get_rect_points: get_rect_points,
  get_rect_lines: get_rect_lines,
  simple_tri_aabb_isect: simple_tri_aabb_isect,
  MinMax: MinMax,
  winding_axis: winding_axis,
  winding: winding,
  inrect_2d: inrect_2d,
  aabb_isect_line_2d: aabb_isect_line_2d,
  expand_rect2d: expand_rect2d,
  expand_line: expand_line,
  colinear: colinear,
  corner_normal: corner_normal,
  line_line_isect: line_line_isect,
  line_line_cross: line_line_cross,
  point_in_aabb_2d: point_in_aabb_2d,
  aabb_sphere_isect_2d: aabb_sphere_isect_2d,
  point_in_aabb: point_in_aabb,
  aabb_sphere_isect: aabb_sphere_isect,
  aabb_sphere_dist: aabb_sphere_dist,
  point_in_tri: point_in_tri,
  convex_quad: convex_quad,
  isNum: isNum,
  normal_tri: normal_tri,
  normal_quad: normal_quad,
  normal_quad_old: normal_quad_old,
  line_isect: line_isect,
  dist_to_line_2d: dist_to_line_2d,
  dist_to_line_sqr: dist_to_line_sqr,
  dist_to_line: dist_to_line,
  clip_line_w: clip_line_w,
  closest_point_on_line: closest_point_on_line,
  circ_from_line_tan: circ_from_line_tan,
  circ_from_line_tan_2d: circ_from_line_tan_2d,
  get_tri_circ: get_tri_circ,
  gen_circle: gen_circle,
  rot2d: rot2d,
  makeCircleMesh: makeCircleMesh,
  minmax_verts: minmax_verts,
  unproject: unproject,
  project: project,
  get_boundary_winding: get_boundary_winding,
  PlaneOps: PlaneOps,
  isect_ray_plane: isect_ray_plane,
  _old_isect_ray_plane: _old_isect_ray_plane,
  mesh_find_tangent: mesh_find_tangent,
  Mat4Stack: Mat4Stack,
  trilinear_v3: trilinear_v3,
  point_in_hex: point_in_hex,
  trilinear_co: trilinear_co,
  trilinear_co2: trilinear_co2,
  tri_angles: tri_angles
});

let _clipdata = {
  name : "nothing",
  mime : "nothing",
  data : undefined
};

let _clipboards = {};

window.setInterval(() => {
  let cb = navigator.clipboard;

  if (!cb || !cb.read) {
    return;
  }

  cb.read().then((data) => {
    for (let item of data) {
      for (let i=0; i<item.types.length; i++) {
        let type = item.types[i];

        if (!(type in _clipboards)) {
          _clipboards[type] = {
            name : type,
            mime : type,
            data : undefined
          };
        };

        item.getType(type).then((blob) => new Response(blob).text()).then((text) => {
          _clipboards[type].data = text;
        });
      }

      //item.getType("text/css").then((blob) => blob.text()).then((text) => {
      //  console.log("text", text);
      //});
    }
    //_clipdata.mime =
  }).catch(function() {});
}, 200);

let exports = {
  /*client code can override this using .loadConstants, here is a simple implementation
    that just handles color data

    desiredMimes is either a string, or an array of strings
   */
  getClipboardData(desiredMimes="text/plain") {
    if (typeof desiredMimes === "string") {
      desiredMimes = [desiredMimes];
    }

    for (let m of desiredMimes) {
      let cb = _clipboards[m];

      if (cb && cb.data) {
        return cb;
      }
    }
  },
  /*client code can override this, here is a simple implementation
    that just handles color data
   */
  setClipboardData(name, mime, data) {
    _clipboards[mime] = {
      name : name,
      mime : mime,
      data : data
    };

    let clipboard = navigator.clipboard;
    if (!clipboard) {
      return;
    }

    try {
      clipboard.write([new ClipboardItem({
        [mime] : new Blob([data], {type : mime})
      })]).catch((error) => {
        //try pushing through text/plain
        if (mime.startsWith("text") && mime !== "text/plain") {
          this.setClipboardData(name, "text/plain", data);
        } else {
          console.error(error);
        }
      });
    } catch (error) {
      console.log(error.stack);
      console.log("failed to write to system clipboard");
    }
  },
  colorSchemeType : "light",
  docManualPath : "../simple_docsys/doc_build/",
  
  //add textboxes to rollar sliders,
  //note that  users can also double click them to
  //enter text as well
  useNumSliderTextboxes : true,

  numSliderArrowLimit : 3, //threshold to check if numslider arrow was clicked
  simpleNumSliders : false,

  menu_close_time : 500,
  doubleClickTime : 500,

  //timeout for press-and-hold (touch) version of double clicking
  doubleClickHoldTime : 750,
  DEBUG : {
    paranoidEvents: false,
    screenborders: false,
    areaContextPushes: false,
    allBordersMovable: false,
    doOnce: false,
    modalEvents : false,
    areaConstraintSolver : false,
    datapaths : false,

    domEvents : false,
    domEventAddRemove : false,

    debugUIUpdatePerf : false, //turns async FrameManager.update_intern loop into sync

    screenAreaPosSizeAccesses : false,
    buttonEvents : false,

    /*
    customWindowSize: {
      width: 2048, height: 2048
    },
    //*/
  },

  //auto load 1d bspline templates, can hurt startup time
  autoLoadSplineTemplates : true,

  addHelpPickers : true,

  useAreaTabSwitcher: false,
  autoSizeUpdate : true,
  showPathsInToolTips: true,

  enableThemeAutoUpdate : true,

  loadConstants : function(args) {
    for (let k in args) {
      if (k === "loadConstants")
        continue;

      this[k] = args[k];
    }

    setConfig(this);
  }
};
window.DEBUG = exports.DEBUG;

let cfg = document.getElementById("pathux-config");
if (cfg) {
  console.error("CONFIG CONFIG", cfg.innerText);
  exports.loadConstants(JSON.parse(cfg.innerText));
}

/*
THEME REFACTOR:

* Use CSS as much as possible
* Create a compatibility layer

*/

let compatMap = {
  BoxMargin : "padding",
  BoxBG : "background",
  BoxRadius : "border-radius",
  background : "background-color",
  defaultWidth : "width",
  defaultHeight : "height",
  DefaultWidth : "width",
  DefaultHeight : "height",
  BoxBorder : "border-color",
  BoxLineWidth : "border-width",
  BoxSubBG : "background-color",
  BoxSub2BG : "background-color",
  DefaultPanelBG : "background-color",
  InnerPanelBG : "background-color",
  Background : "background-color",
  numslider_width : "width",
  numslider_height : "height",
};

let ColorSchemeTypes = {
  LIGHT : "light",
  DARK  : "dark"
};

function parsepx$1(css) {
  return parseFloat(css.trim().replace("px", ""))
}

function color2css$2(c, alpha_override) {
  let r = ~~(c[0]*255);
  let g = ~~(c[1]*255);
  let b = ~~(c[2]*255);
  let a = c.length < 4 ? 1.0 : c[3];

  a = alpha_override !== undefined ? alpha_override : a;

  if (c.length === 3 && alpha_override === undefined) {
    return `rgb(${r},${g},${b})`;
  } else {
    return `rgba(${r},${g},${b}, ${a})`;
  }
}
window.color2css = color2css$2;

let css2color_rets = cachering$1.fromConstructor(Vector4, 64);
let basic_colors = {
  'white' : [1,1,1],
  'grey' : [0.5, 0.5, 0.5],
  'gray' : [0.5, 0.5, 0.5],
  'black' : [0, 0, 0],
  'red' : [1, 0, 0],
  'yellow' : [1, 1, 0],
  'green' : [0, 1, 0],
  'teal' : [0, 1, 1],
  'cyan' : [0, 1, 1],
  'blue' : [0, 0, 1],
  'orange' : [1, 0.5, 0.25],
  'brown' : [0.5, 0.4, 0.3],
  'purple' : [1, 0, 1],
  'pink' : [1, 0.5, 0.5]
};

function color2web(color) {
  function tostr(n) {
    n = ~~(n*255);
    let s = n.toString(16);

    if (s.length > 2) {
      s = s.slice(0, 2);
    }

    while (s.length < 2) {
      s = "0" + s;
    }

    return s;
  }

  if (color.length === 3 || color[3] === 1.0) {
    let r = tostr(color[0]);
    let g = tostr(color[1]);
    let b = tostr(color[2]);

    return "#" + r + g + b;
  } else {
    let r = tostr(color[0]);
    let g = tostr(color[1]);
    let b = tostr(color[2]);
    let a = tostr(color[3]);

    return "#" + r + g + b + a;
  }
}

window.color2web = color2web;

function css2color$1(color) {
  if (!color) {
    return new Vector4([0,0,0,1]);
  }

  color = (""+color).trim();

  let ret = css2color_rets.next();

  if (color[0] === "#") {
    color = color.slice(1, color.length);
    let parts = [];

    for (let i=0; i<color.length>>1; i++) {
      let part = "0x" + color.slice(i*2, i*2+2);
      parts.push(parseInt(part));
    }

    ret.zero();
    let i;
    for (i=0; i<Math.min(parts.length, ret.length); i++) {
      ret[i] = parts[i] / 255.0;
    }

    if (i < 4) {
      ret[3] = 1.0;
    }

    return ret;
  }

  if (color in basic_colors) {
    ret.load(basic_colors[color]);
    ret[3] = 1.0;
    return ret;
  }

  color = color.replace("rgba", "").replace("rgb", "").replace(/[\(\)]/g, "").trim().split(",");

  for (let i=0; i<color.length; i++) {
    ret[i] = parseFloat(color[i]);
    if (i < 3) {
      ret[i] /= 255;
    }
  }

  if (color.length === 3) {
    color.push(1.0);
  }

  return ret;
}

window.css2color = css2color$1;

function web2color(str) {
  if (typeof str === "string" && str.trim()[0] !== "#") {
    str = "#" + str.trim();
  }

  return css2color$1(str);
}
window.web2color = web2color;

let validate_pat = /\#?[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$/;

function validateWebColor(str) {
  if (typeof str !== "string" && !(str instanceof String))
    return false;

  return str.trim().search(validate_pat) === 0;
}

let num = "(([0-9]+\.[0-9]+)|[0-9a-f]+)";

let validate_rgba = new RegExp(`rgba\\(${num},${num},${num},${num}\\)$`);
let validate_rgb = new RegExp(`rgb\\(${num},${num},${num}\\)$`);

function validateCSSColor$1(color) {
  if (color.toLowerCase() in basic_colors) {
    return true;
  }

  let rgba = color.toLowerCase().replace(/[ \t]/g, "");
  rgba = rgba.trim();

  if (validate_rgba.test(rgba) || validate_rgb.exec(rgba)) {
    return true;
  }

  return validateWebColor(color);
}

window.validateCSSColor = validateCSSColor$1;

let theme = {};

function invertTheme() {
  exports.colorSchemeType = exports.colorSchemeType === ColorSchemeTypes.LIGHT ? ColorSchemeTypes.DARK : ColorSchemeTypes.LIGHT;

  function inverted(color) {
    if (Array.isArray(color)) {
      for (let i = 0; i < 3; i++) {
        color[i] = 1.0 - color[i];
      }

      return color;
    }

    color = css2color$1(color);
    return color2css$2(inverted(color));
  }

  let bg = document.body.style["background-color"];
  //if (!bg) {
  bg = exports.colorSchemeType === ColorSchemeTypes.LIGHT ? "rgb(200,200,200)" : "rgb(55, 55, 55)";
  //} else {
  //  bg = inverted(bg);
  //}

  document.body.style["background-color"] = bg;

  for (let style in theme) {
    style = theme[style];

    for (let k in style) {
      let v = style[k];

      if (v instanceof CSSFont) {
        v.color = inverted(v.color);
      } else if (typeof v === "string") {
        v = v.trim().toLowerCase();

        let iscolor = v.search("rgb") >= 0;
        iscolor = iscolor || v in basic_colors;
        iscolor = iscolor || validateWebColor(v);

        if (iscolor) {
          style[k] = inverted(v);
        }
      }
    }
  }
}

window.invertTheme = invertTheme;

function setColorSchemeType(mode) {
  if (!!mode !== exports.colorSchemeType) {
    invertTheme();
    exports.colorSchemeType = mode;
  }

}
window.validateWebColor = validateWebColor;

let _digest = new HashDigest();

class CSSFont {
  constructor(args={}) {
    this._size = args.size ? args.size : 12;
    this.font = args.font;
    this.style = args.style !== undefined ? args.style : "normal";
    this.weight = args.weight !== undefined ? args.weight : "normal";
    this.variant = args.variant !== undefined ? args.variant : "normal";
    this.color = args.color;
  }

  calcHashUpdate(digest=_digest.reset()) {
    digest.add(this._size || 0);
    digest.add(this.font);
    digest.add(this.style);
    digest.add(this.weight);
    digest.add(this.variant);
    digest.add(this.color);

    return digest.get();
  }

  set size(val) {
    this._size = val;
  }

  get size() {
    if (isMobile()) {
      let mul = theme.base.mobileTextSizeMultiplier / visualViewport.scale;
      if (mul) {
        return this._size * mul;;
      }
    }

    return this._size;
  }

  copyTo(b) {
    b._size = this._size;
    b.font = this.font;
    b.style = this.style;
    b.color = this.color;
    b.variant = this.variant;
    b.weight = this.weight;
  }

  copy() {
    let ret = new CSSFont();
    this.copyTo(ret);
    return ret;
  }

  genCSS(size=this.size) {
    return `${this.style} ${this.variant} ${this.weight} ${size}px ${this.font}`;
  }

  //deprecated, use genKey()
  hash() {
    return this.genKey();
  }

  genKey() {
    let color = this.color;

    if (typeof this.color === "object" || typeof this.color === "function") {
      color = JSON.stringify(color);
    }

    return this.genCSS() + ":" + this.size + ":" + color;
  }
}
CSSFont.STRUCT = `
CSSFont {
  size     : float | obj._size;
  font     : string | obj.font || "";
  style    : string | obj.font || "";
  color    : string | ""+obj.color;
  variant  : string | obj.variant || "";
  weight   : string | ""+obj.weight;
}
`;
nstructjs.register(CSSFont);

function exportTheme(theme1=theme, addVarDecl=true) {
  let sortkeys = (obj) => {
    let keys = [];
    for (let k in obj) {
      keys.push(k);
    }
    keys.sort();

    return keys;
  };

  let s = addVarDecl ? "var theme = {\n" : "{\n";

  function writekey(v, indent="") {
    if (typeof v === "string") {
      if (v.search("\n") >= 0) {
        v = "`" + v + "`";
      } else {
        v = "'" + v + "'";
      }

      return v;
    } else if (typeof v === "object") {
      if (v instanceof CSSFont) {
        return `new CSSFont({
${indent}  font    : ${writekey(v.font)},
${indent}  weight  : ${writekey(v.weight)},
${indent}  variant : ${writekey(v.variant)},
${indent}  style   : ${writekey(v.style)},
${indent}  size    : ${writekey(v._size)},
${indent}  color   : ${writekey(v.color)}
${indent}})`;
      } else {
        let s = "{\n";

        for (let k of sortkeys(v)) {
          let v2 = v[k];

          if (k.search(" ") >= 0 || k.search("-") >= 0) {
            k = "'" + k + "'";
          }

          s += indent + "  " + k + " : " + writekey(v2, indent + "  ") + ",\n";
        }

        s += indent + "}";
        return s;
      }
    } else {
      return ""+v;
    }

    return "error";
  }

  for (let k of sortkeys(theme1)) {
    let k2 = k;

    if (k.search("-") >= 0 || k.search(" ") >= 0) {
      k2 = "'" + k + "'";
    }
    s += "  " + k2 + ": ";

    let v = theme1[k];
    if (typeof v !== "object" || v instanceof CSSFont) {
      s += writekey(v, "  ") + ",\n";
    } else {
      s += " {\n";
      let s2 = "";

      let maxwid = 0;

      for (let k2 of sortkeys(v)) {
        if (k2.search("-") >= 0 || k2.search(" ") >= 0) {
          k2 = "'" + k2 + "'";
        }

        maxwid = Math.max(maxwid, k2.length);
      }

      for (let k2 of sortkeys(v)) {
        let v2 = v[k2];

        if (k2.search("-") >= 0 || k2.search(" ") >= 0) {
          k2 = "'" + k2 + "'";
        }

        let pad = "";

        for (let i=0; i<maxwid-k2.length; i++) {
          pad += " ";
        }

        s2 += "    " + k2 + pad + ": " + writekey(v2, "    ") + ",\n";
      }

      s += s2;
      s += "  },\n\n";
    }
  }
  s += "};\n";

  return s;
}
window._exportTheme = exportTheme;

class Task {
  constructor(taskcb) {
    this.task = taskcb;
    this.start = time_ms();
    this.done = false;
  }
}

class AnimManager {
  constructor() {
    this.tasks = [];
    this.timer = undefined;

    //all animation tasks that last longer then 10 seconds are terminated
    this.timeOut = 10*1000.0;
  }

  stop() {
    if (this.timer !== undefined) {
      window.clearInterval(this.timer);
      this.timer = undefined;
    }
  }

  add(task) {
    this.tasks.push(new Task(task));
  }

  remove(task) {
    for (let t of this.tasks) {
      if (t.task === task) {
        t.dead = true;
        this.tasks.remove(t);
        return;
      }
    }
  }

  start() {
    this.timer = window.setInterval(() => {
      for (let t of this.tasks) {
        try {
          t.task();
        } catch (error) {
          t.done = true;
          print_stack$1(error);
        }

        if (time_ms() - t.start > this.timeOut) {
          t.dead = true;
        }
      }

      for (let i=0; i<this.tasks.length; i++) {
        if (this.tasks[i].done) {
          let t = this.tasks[i];
          this.tasks.remove(t);
          i--;

          try {
            if (t.task.onend) {
              t.task.onend();
            }
          } catch (error) {
            print_stack$1(error);
          }
        }
      }
    }, 1000/40.0);
  }
}


const manager$1 = new AnimManager();
manager$1.start();

class AbstractCommand {
  constructor() {
    this.cbs = [];
    this.end_cbs = [];
  }

  start(animator, done) {

  }

  exec(animator, done) {

  }
}

class WaitCommand extends AbstractCommand {
  constructor(ms) {
    super();
    this.ms = ms;
  }

  start(animator, done) {
    this.time = animator.time;
  }

  exec(animator, done) {
    if (animator.time - this.time > this.ms) {
      done();
    }
  }
}

class GoToCommand extends AbstractCommand {
  constructor(obj, key, value, time, curve="ease") {
    super();

    this.object = obj;
    this.key = key;
    this.value = value;
    this.ms = time;

    if (typeof curve === "string") {
      this.curve = new (getCurve(curve))();
    } else {
      this.curve = curve;
    }
  }

  start(animator, done) {
    this.time = animator.time;

    let value = this.object[this.key];

    if (Array.isArray(value)) {
      this.startValue = list(value);
    } else {
      this.startValue = value;
    }
  }

  exec(animator, done) {
    let t = animator.time - this.time;
    let ms = this.ms;

    if (t > ms) {
      done();
      t = ms;
    }

    t /= ms;

    t = this.curve.evaluate(t);

    if (Array.isArray(this.startValue)) {
      let value = this.object[this.key];

      for (let i=0; i<this.startValue.length; i++) {
        if (value[i] === undefined || this.value[i] === undefined) {
          continue;
        }

        value[i] = this.startValue[i] + (this.value[i] - this.startValue[i]) * t;
      }
    } else {
      this.object[this.key] = this.startValue + (this.value - this.startValue) * t;

    }
  }
}

class SetCommand extends AbstractCommand {
  constructor(obj, key, val) {
    super();

    this.object = obj;
    this.key = key;
    this.value = val;
  }

  start(animator, done) {
    this.object[key] = val;
    done();
  }
}

class Command {
  constructor(type, args) {
    this.args = args;
    this.cbs = [];
  }
}

class Animator {
  constructor(owner, method = "update") {
    this.on_tick = this.on_tick.bind(this);
    this.on_tick.onend = () => {
      if (this.onend) {
        this.onend();
      }
    };

    this.commands = [];
    this.owner = owner;
    this._done = false;
    this.method = method;
    this.onend = null;
    this.first = true;

    this.time = 0.0;
    this.last = time_ms();

    this.bind(owner);
  }

  bind(owner) {
    this._done = false;
    this.owner = owner;
    //this.owner[this.method].after(this.on_tick);
    manager$1.add(this.on_tick);
  }

  wait(ms) {
    this.commands.push(new WaitCommand(ms));
    return this;
  }

  goto(key, val, timeMs, curve = "ease") {
    let cmd = new GoToCommand(this.owner, key, val, timeMs, curve);
    this.commands.push(cmd);
    return this;
  }

  set(key, val, time) {
    let cmd = new SetCommand(this.owner, key, val);
    this.commands.push(cmd);
    return this;
  }

  while(cb) {
    this.commands[this.commands.length - 1].cbs.push(cb);
    return this;
  }

  then(cb) {
    this.commands[this.commands.length-1].end_cbs.push(cb);
    return this;
  }

  end() {
    if (this._done) {
      return;
    }

    this._done = true;
    manager$1.remove(this.on_tick);
    //this.owner.update.remove(this.on_tick);

    if (this.onend) {
      this.onend();
    }
  }

  on_tick() {
    if (this._done) {
      throw new Error("animation wasn't properly cleaned up");
    }

    let dt = time_ms() - this.last;
    this.time += dt;
    this.last = time_ms();

    if (this.commands.length === 0) {
      this.end();
      return
    }

    let cmd = this.commands[0];
    let done = false;

    function donecb() {
      done = true;
    }

    if (this.first) {
      this.first = false;
      //console.log(cmd, cmd.start)
      cmd.start(this, donecb);
    }

    try {
      cmd.exec(this, donecb);
    } catch (error) {
      done = true;
      print_stack$1(error);
    }

    for (let cb of this.commands[0].cbs) {
      try {
        cb();
      } catch (error) {
        print_stack$1(error);
      }
    }

    if (done) {
      for (let cb of this.commands[0].end_cbs) {
        try {
          cb();
        } catch (error) {
          print_stack$1(error);
        }
      }
      while (this.commands.length > 0) {
        this.commands.shift();

        done = false;

        if (this.commands.length > 0) {
          this.commands[0].start(this, donecb);
        }

        if (!done) {
          break;
        }
      }
    }
  }
}

class token$1 {
  constructor(type, val, lexpos, lexlen, lineno, lexer, parser) {
    this.type = type;
    this.value = val;
    this.lexpos = lexpos;
    this.lexlen = lexlen;
    this.lineno = lineno;
    this.lexer = lexer;
    this.parser = parser;
  }

  setValue(val) {
    this.value = val;
    return this;
  }

  toString() {
    if (this.value !== undefined)
      return "token(type=" + this.type + ", value='" + this.value + "')"
    else
      return "token(type=" + this.type + ")"
  }
}

//func is optional. it takes a function
//with one parameter, token, and either
//a) returns the token, or b) returns
//undefined, in which case the token
//should be ignored by the lexer
class tokdef$1 {
  constructor(name, regexpr, func) {
    this.name = name;
    this.re = regexpr;
    this.func = func;
  }
}

class PUTLParseError extends Error {
}

//errfunc is optional.  it requires
//a function that takes one param, lexer,
//and returns true if the lexer
//should propegate an error when an error
//has happened
class lexer$1 {
  constructor(tokdef, errfunc) {
    this.tokdef = tokdef;
    this.tokens = new Array();
    this.lexpos = 0;
    this.lexdata = "";
    this.lineno = 0;
    this.errfunc = errfunc;
    this.tokints = {};

    for (var i=0; i<tokdef.length; i++) {
      this.tokints[tokdef[i].name] = i;
    }

    this.statestack = [["__main__", 0]];
    this.states = {"__main__" : [tokdef, errfunc]};
    this.statedata = 0; //public variable
  }

  copy() {
    let ret = new lexer$1(this.tokdef, this.errfunc);

    for (let k in this.states) {
      let state = this.states[k];

      state = [state[0], state[1]];
      ret.states[k] = state;
    }

    ret.statedata = this.statedata;

    return ret;
  }

//errfunc is optional, defines state-specific error function
  add_state(name, tokdef, errfunc) {
    if (errfunc === undefined) {
      errfunc = function(lexer) { return true; };
    }

    this.states[name] = [tokdef, errfunc];
  }

  tok_int(name) {

  }

  //statedata is optional.
  //it stores state-specific data in lexer.statedata.
  push_state(state, statedata) {
    this.statestack.push([state, statedata]);

    state = this.states[state];
    this.statedata = statedata;

    this.tokdef = state[0];
    this.errfunc = state[1];
  }

  pop_state() {
    var item = this.statestack[this.statestack.length-1];
    var state = this.states[item[0]];

    this.tokdef = state[0];
    this.errfunc = state[1];
    this.statedata = item[1];
  }

  input(str) {
    //go back to main state
    while (this.statestack.length > 1) {
      this.pop_state();
    }

    this.lexdata = str;
    this.lexpos = 0;
    this.lineno = 0;
    this.tokens = new Array();

    this.peeked_tokens = [];
  }

  error() {
    if (this.errfunc !== undefined && !this.errfunc(this))
      return;

    console.log("Syntax error near line " + this.lineno);
    var next = Math.min(this.lexpos+8, this.lexdata.length);
    console.log("  " + this.lexdata.slice(this.lexpos, next));

    throw new PUTLParseError("Parse error");
  }

  peek() {
    var tok = this.next(true);

    if (tok === undefined)
      return undefined;

    this.peeked_tokens.push(tok);
    return tok;
  }


  peek_i(i) {
    while (this.peeked_tokens.length <= i) {
      var t = this.peek();
      if (t === undefined)
        return undefined;
    }

    return this.peeked_tokens[i];
  }

  at_end() {
    return this.lexpos >= this.lexdata.length && this.peeked_tokens.length == 0;
  }

  next(ignore_peek) {
    if (ignore_peek !== true && this.peeked_tokens.length > 0) {
      var tok = this.peeked_tokens[0];
      this.peeked_tokens.shift();

      return tok;
    }

    if (this.lexpos >= this.lexdata.length)
      return undefined;

    var ts = this.tokdef;
    var tlen = ts.length;

    var lexdata = this.lexdata.slice(this.lexpos, this.lexdata.length);

    var results = [];

    for (var i=0; i<tlen; i++) {
      var t = ts[i];

      if (t.re === undefined)
        continue;

      var res = t.re.exec(lexdata);

      if (res !== null && res !== undefined && res.index === 0) {
        results.push([t, res]);
      }
    }

    var max_res = 0;
    var theres = undefined;
    for (var i=0; i<results.length; i++) {
      var res = results[i];

      if (res[1][0].length > max_res) {
        theres = res;
        max_res = res[1][0].length;
      }
    }

    if (theres === undefined) {
      this.error();
      return;
    }

    var def = theres[0];

    var lexlen = max_res;
    var tok = new token$1(def.name, theres[1][0], this.lexpos, lexlen, this.lineno, this, undefined);
    this.lexpos += max_res;

    if (def.func) {
      tok = def.func(tok);
      if (tok === undefined) {
        return this.next();
      }
    }

    return tok;
  }
}

class parser$1 {
  constructor(lexer, errfunc) {
    this.lexer = lexer;
    this.errfunc = errfunc;
    this.start = undefined;
    this.userdata = undefined;
  }

  copy() {
    let ret = new parser$1(this.lexer.copy(), this.errfunc);
    ret.start = this.start;

    return ret;
  }


  parse(data, err_on_unconsumed) {
    if (err_on_unconsumed === undefined)
      err_on_unconsumed = true;

    if (data !== undefined)
      this.lexer.input(data);

    var ret = this.start(this);

    if (err_on_unconsumed && !this.lexer.at_end() && this.lexer.next() !== undefined) {
      //console.log(this.lexer.lexdata.slice(this.lexer.lexpos-1, this.lexer.lexdata.length));
      this.error(undefined, "parser did not consume entire input");
    }

    return ret;
  }

  input(data) {
    this.lexer.input(data);
  }

  error(tok, msg) {
    if (msg == undefined)
      msg = "";

    if (tok == undefined)
      var estr = "Parse error at end of input: " + msg;
    else
      estr = "Parse error at line " + (tok.lineno+1) + ": " + msg;

    var buf = "1| ";
    var ld = this.lexer.lexdata;
    var l = 1;
    for (var i=0; i<ld.length; i++) {
      var c = ld[i];
      if (c == '\n') {
        l++;
        buf += "\n" + l + "| ";
      } else {
        buf += c;
      }
    }

    console.log("------------------");
    console.log(buf);
    console.log("==================");
    console.log(estr);

    if (this.errfunc && !this.errfunc(tok)) {
      return;
    }

    throw new PUTLParseError(estr);
  }

  peek() {
    var tok = this.lexer.peek();
    if (tok != undefined)
      tok.parser = this;

    return tok;
  }

  peek_i(i) {
    var tok = this.lexer.peek_i(i);
    if (tok !== undefined)
      tok.parser = this;

    return tok;
  }

  peeknext() {
    return this.peek_i(0);
  }

  next() {
    var tok = this.lexer.next();
    if (tok !== undefined)
      tok.parser = this;

    return tok;
  }

  optional(type) {
    var tok = this.peek_i(0);

    if (tok && tok.type === type) {
      this.next();

      return true;
    }

    return false;
  }

  at_end() {
    return this.lexer.at_end();
  }

  expect(type, msg) {
    var tok = this.next();

    if (msg == undefined)
      msg = type;

    if (tok == undefined || tok.type != type) {
      this.error(tok, "Expected " + msg + ", not " + tok.type);
    }

    return tok.value;
  }
}

function test_parser$1() {
  var basic_types = new set([
    "int",
    "float",
    "double",
    "vec2",
    "vec3",
    "vec4",
    "mat4",
    "string"]);

  var reserved_tokens = new set([
    "int",
    "float",
    "double",
    "vec2",
    "vec3",
    "vec4",
    "mat4",
    "string",
    "static_string",
    "array"]);

  function tk(name, re, func) {
    return new tokdef$1(name, re, func);
  }
  var tokens = [
    tk("ID", /[a-zA-Z]+[a-zA-Z0-9_]*/, function(t) {
      if (reserved_tokens.has(t.value)) {
        t.type = t.value.toUpperCase();
      }

      return t;
    }),
    tk("OPEN", /\{/),
    tk("CLOSE", /}/),
    tk("COLON", /:/),
    tk("JSCRIPT", /\|/, function(t) {
      var js = "";
      var lexer = t.lexer;
      while (lexer.lexpos < lexer.lexdata.length) {
        var c = lexer.lexdata[lexer.lexpos];
        if (c == "\n")
          break;

        js += c;
        lexer.lexpos++;
      }

      if (js.endsWith(";")) {
        js = js.slice(0, js.length-1);
        lexer.lexpos--;
      }

      t.value = js;
      return t;
    }),

    tk("LPARAM", /\(/),
    tk("RPARAM", /\)/),
    tk("COMMA", /,/),
    tk("NUM", /[0-9]/),
    tk("SEMI", /;/),
    tk("NEWLINE", /\n/, function(t) {
      t.lexer.lineno += 1;
    }),
    tk("SPACE", / |\t/, function(t) {
      //throw out non-newline whitespace tokens
    })
  ];

  for (var rt in reserved_tokens) {
    tokens.push(tk(rt.toUpperCase()));
  }

  /*var a =
  Loop {
    eid : int;
    flag : int;
    index : int;
    type : int;

    co : vec3;
    no : vec3;
    loop : int | eid(loop);
    edges : array(e, int) | e.eid;

    loops : array(Loop);
  }
  `;
  */

  function errfunc(lexer) {
    return true; //throw error
  }

  var lex = new lexer$1(tokens, errfunc);
  console.log("Testing lexical scanner...");

  lex.input(a);

  var tok;
  while (tok = lex.next()) {
    console.log(tok.toString());
  }

  var parser = new parser(lex);
  parser.input(a);

  function p_Array(p) {
    p.expect("ARRAY");
    p.expect("LPARAM");

    var arraytype = p_Type(p);
    var itername = "";

    if (p.optional("COMMA")) {
      itername = arraytype;
      arraytype = p_Type(p);
    }


    p.expect("RPARAM");

    return {type : "array", data : {type : arraytype, iname : itername}};
  }

  function p_Type(p) {
    var tok = p.peek();

    if (tok.type == "ID") {
      p.next();
      return {type : "struct", data : "\"" + tok.value + "\""};
    } else if (basic_types.has(tok.type.toLowerCase())) {
      p.next();
      return {type : tok.type.toLowerCase()};
    } else if (tok.type == "ARRAY") {
      return p_Array(p);
    } else {
      p.error(tok, "invalid type " + tok.type); //(tok.value == "" ? tok.type : tok.value));
    }
  }

  function p_Field(p) {
    var field = {};

    console.log("-----", p.peek().type);

    field.name = p.expect("ID", "struct field name");
    p.expect("COLON");

    field.type = p_Type(p);
    field.set = undefined;
    field.get = undefined;

    var tok = p.peek();
    if (tok.type == "JSCRIPT") {
      field.get =  tok.value;
      p.next();
    }

    tok = p.peek();
    if (tok.type == "JSCRIPT") {
      field.set = tok.value;
      p.next();
    }

    p.expect("SEMI");

    return field;
  }

  function p_Struct(p) {
    var st = {};
    st.name = p.expect("ID", "struct name");
    st.fields = [];

    p.expect("OPEN");

    while (1) {
      if (p.at_end()) {
        p.error(undefined);
      } else if (p.optional("CLOSE")) {
        break;
      } else {
        st.fields.push(p_Field(p));
      }
    }

    return st;
  }

  var ret = p_Struct(parser);

  console.log(JSON.stringify(ret));
}

var parseutil1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  token: token$1,
  tokdef: tokdef$1,
  PUTLParseError: PUTLParseError,
  lexer: lexer$1,
  parser: parser$1
});

const DataFlags = {
  READ_ONLY             : 1,
  USE_CUSTOM_GETSET     : 2,
  USE_FULL_UNDO         : 4, //DataPathSetOp in controller_ops.js saves/loads entire file for undo/redo
  USE_CUSTOM_PROP_GETTER: 8,
};


const DataTypes = {
  STRUCT        : 0,
  DYNAMIC_STRUCT: 1,
  PROP          : 2,
  ARRAY         : 3
};

let propCacheRings = {};

function getTempProp(type) {
  if (!(type in propCacheRings)) {
    propCacheRings[type] = cachering$1.fromConstructor(ToolProperty.getClass(type), 32);
  }

  return propCacheRings[type].next();
}

class DataPathError extends Error {
};


function getVecClass(proptype) {
  switch (proptype) {
    case PropTypes.VEC2:
      return Vector2;
    case PropTypes.VEC3:
      return Vector3;
    case PropTypes.VEC4:
      return Vector4;
    case PropTypes.QUAT:
      return Quat;
    default:
      throw new Error("bad prop type " + proptype);
  }
}

function isVecProperty(prop) {
  if (!prop || typeof prop !== "object" || prop === null)
    return false;

  let ok = false;

  ok = ok || prop instanceof Vec2PropertyIF;
  ok = ok || prop instanceof Vec3PropertyIF;
  ok = ok || prop instanceof Vec4PropertyIF;
  ok = ok || prop instanceof Vec2Property;
  ok = ok || prop instanceof Vec3Property;
  ok = ok || prop instanceof Vec4Property;

  ok = ok || prop.type === PropTypes.VEC2;
  ok = ok || prop.type === PropTypes.VEC3;
  ok = ok || prop.type === PropTypes.VEC4;
  ok = ok || prop.type === PropTypes.QUAT;

  return ok;
}

class DataPath {
  constructor(path, apiname, prop, type = DataTypes.PROP) {
    this.type = type;
    this.data = prop;
    this.apiname = apiname;
    this.path = path;
    this.flag = 0;
    this.struct = undefined;
  }

  copy() {
    let ret = new DataPath();

    ret.flag = this.flag;
    ret.type = this.type;
    ret.data = this.data;
    ret.apiname = this.apiname;
    ret.path = this.path;
    ret.struct = this.struct;

    return ret;
  }

  /** this property should not be treated as something
   *  that should be kept track off in the undo stack*/
  noUndo() {
    this.data.flag |= PropFlags.NO_UNDO;
    return this;
  }

  setProp(prop) {
    this.data = prop;
  }

  readOnly() {
    this.flag |= DataFlags.READ_ONLY;

    if (this.type === DataTypes.PROP) {
      this.data.flag |= PropFlags.READ_ONLY;
    }

    return this;
  }

  read_only() {
    console.warn("DataPath.read_only is deprecated; use readOnly");
    return this.readOnly();
  }

  /** used to override tool property settings,
   *  e.g. ranges, units, etc; returns a
   *  base class instance of ToolProperty.
   *
   *  The this context points to the original ToolProperty and contains
   *  a few useful references:
   *
   *  this.dataref - an object instance of this struct type
   *  this.ctx - a context
   *
   *  callback takes one argument, a new (freshly copied of original)
   *  tool property to modify
   *
   * */
  customPropCallback(callback) {
    this.flag |= DataFlags.USE_CUSTOM_PROP_GETTER;
    this.data.flag |= PropFlags.USE_CUSTOM_PROP_GETTER;
    this.propGetter = callback;

    return this;
  }

  /**
   *
   * For the callbacks 'this' points to an internal ToolProperty;
   * Referencing object lives in 'this.dataref'; calling context in 'this.ctx';
   * and the datapath is 'this.datapath'
   **/
  customGetSet(get, set) {
    this.flag |= DataFlags.USE_CUSTOM_GETSET;

    if (this.type !== DataTypes.DYNAMIC_STRUCT && this.type !== DataTypes.STRUCT) {
      this.data.flag |= PropFlags.USE_CUSTOM_GETSET;
      this.data._getValue = this.data.getValue;
      this.data._setValue = this.data.setValue;

      if (get)
        this.data.getValue = get;

      if (set)
        this.data.setValue = set;
    } else {
      this.getSet = {
        get, set
      };

      this.getSet.dataref = undefined;
      this.getSet.datapath = undefined;
      this.getSet.ctx = undefined;
    }

    return this;
  }

  customSet(set) {
    this.customGetSet(undefined, set);
    return this;
  }

  customGet(get) {
    this.customGetSet(get, undefined);
    return this;
  }

  /**db will be executed with underlying data object
   that contains this path in 'this.dataref'

   main event is 'change'
   */
  on(type, cb) {
    if (this.type == DataTypes.PROP) {
      this.data.on(type, cb);
    } else {
      throw new Error("invalid call to DataPath.on");
    }

    return this;
  }

  off(type, cb) {
    if (this.type === DataTypes.PROP) {
      this.data.off(type, cb);
    }
  }

  simpleSlider() {
    this.data.flag |= PropFlags.SIMPLE_SLIDER;
    this.data.flag &= ~PropFlags.FORCE_ROLLER_SLIDER;
    return this;
  }

  rollerSlider() {
    this.data.flag &= ~PropFlags.SIMPLE_SLIDER;
    this.data.flag |= PropFlags.FORCE_ROLLER_SLIDER;

    return this;
  }

  noUnits() {
    this.baseUnit("none");
    this.displayUnit("none");
    return this;
  }

  baseUnit(unit) {
    this.data.setBaseUnit(unit);
    return this;
  }

  displayUnit(unit) {
    this.data.setDisplayUnit(unit);
    return this;
  }

  unit(unit) {
    return this.baseUnit(unit).displayUnit(unit);
  }

  editAsBaseUnit() {
    this.data.flag |= PropFlags.EDIT_AS_BASE_UNIT;
    return this;
  }

  range(min, max) {
    this.data.setRange(min, max);
    return this;
  }

  uiRange(min, max) {
    this.data.setUIRange(min, max);
    return this;
  }

  decimalPlaces(n) {
    this.data.setDecimalPlaces(n);
    return this;
  }

  /**
   * like other callbacks (until I refactor it),
   * func will be called with a mysterious object that stores
   * the following properties:
   *
   * this.dataref  : owning object reference
   * this.datactx  : ctx
   * this.datapath : datapath
   * */
  uiNameGetter(func) {
    this.ui_name_get = func;
    return this;
  }

  expRate(exp) {
    this.data.setExpRate(exp);
    return this;
  }

  slideSpeed(speed) {
    this.data.setSlideSpeed(speed);
    return this;
  }

  /**adds a slider for moving vector component sliders simultaneously*/
  uniformSlider(state = true) {
    this.data.uniformSlider(state);

    return this;
  }

  radix(r) {
    this.data.setRadix(r);
    return this;
  }

  relativeStep(s) {
    this.data.setRelativeStep(s);
    return this;
  }

  step(s) {
    this.data.setStep(s);
    return this;
  }

  /**
   *
   * Tell DataPathSetOp to save/load entire app state for undo/redo
   *
   * */
  fullSaveUndo() {
    this.flag |= DataFlags.USE_FULL_UNDO;
    this.data.flag |= PropFlags.USE_BASE_UNDO;

    return this;
  }

  icon(i) {
    this.data.setIcon(i);
    return this;
  }

  icon2(i) {
    this.data.setIcon2(i);
    return this;
  }

  icons(icons) { //for enum/flag properties
    this.data.addIcons(icons);
    return this;
  }

  /** secondary icons (e.g. disabled states) */
  icons2(icons) {
    this.data.addIcons2(icons);
    return this;
  }

  descriptions(description_map) { //for enum/flag properties
    this.data.addDescriptions(description_map);
    return this;
  }

  uiNames(uinames) {
    this.data.addUINames(uinames);
    return this;
  }

  description(d) {
    this.data.description = d;
    return this;
  }
}

const StructFlags = {
  NO_UNDO: 1 //struct and its child structs can't participate in undo
             //via the DataPathToolOp
};

class ListIface {
  getStruct(api, list, key) {

  }

  get(api, list, key) {

  }

  getKey(api, list, obj) {

  }

  getActive(api, list) {

  }

  setActive(api, list, val) {

  }

  set(api, list, key, val) {
    list[key] = val;
  }

  getIter() {

  }

  filter(api, list, filter) {

  }
}

class ToolOpIface {
  constructor() {
  }

  static tooldef() {
    return {
      uiname     : "!untitled tool",
      icon       : -1,
      toolpath   : "logical_module.tool", //logical_module need not match up to real module name
      description: undefined,
      is_modal   : false,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }
};


let DataAPIClass = undefined;

function setImplementationClass(cls) {
  DataAPIClass = cls;
}

function registerTool(cls) {
  if (DataAPIClass === undefined) {
    throw new Error("data api not initialized properly; call setImplementationClass");
  }

  return DataAPIClass.registerTool(cls);
}

"use strict";

let ToolClasses = [];
window._ToolClasses = ToolClasses;

function setContextClass(cls) {
  console.warn("setContextClass is deprecated");
}

const ToolFlags = {
  PRIVATE: 1

};


const UndoFlags = {
  NO_UNDO      : 2,
  IS_UNDO_ROOT : 4,
  UNDO_BARRIER : 8,
  HAS_UNDO_DATA: 16
};

class InheritFlag {
  constructor(slots = {}) {
    this.slots = slots;
  }
}

let modalstack$1 = [];

let defaultUndoHandlers = {
  undoPre(ctx) {
    throw new Error("implement me");
  },
  undo(ctx) {
    throw new Error("implement me");
  }
};

function setDefaultUndoHandlers(undoPre, undo) {
  if (!undoPre || !undo) {
    throw new Error("invalid parameters to setDefaultUndoHandlers");
  }

  defaultUndoHandlers.undoPre = undoPre;
  defaultUndoHandlers.undo = undo;
}

class ToolPropertyCache {
  constructor() {
    this.map = new Map();
    this.pathmap = new Map();
    this.accessors = {};

    this.userSetMap = new Set();

    this.api = undefined;
    this.dstruct = undefined;
  }

  static getPropKey(cls, key, prop) {
    return prop.apiname && prop.apiname.length > 0 ? prop.apiname : key;
  }

  _buildAccessors(cls, key, prop, dstruct, api) {
    let tdef = cls._getFinalToolDef();

    this.api = api;
    this.dstruct = dstruct;

    if (!tdef.toolpath) {
      console.warn("Bad tool property", cls, "it's tooldef was missing a toolpath field");
      return;
    }

    let path = tdef.toolpath.trim().split(".").filter(f => f.trim().length > 0);
    let obj = this.accessors;

    let st = dstruct;
    let partial = "";

    for (let i = 0; i < path.length; i++) {
      let k = path[i];
      let pathk = k;

      if (i === 0) {
        pathk = "accessors." + k;
      }

      if (i > 0) {
        partial += ".";
      }
      partial += k;

      if (!(k in obj)) {
        obj[k] = {};
      }

      let st2 = api.mapStruct(obj[k], true, k);
      if (!(k in st.pathmap)) {
        st.struct(pathk, k, k, st2);
      }
      st = st2;

      this.pathmap.set(partial, obj[k]);

      obj = obj[k];
    }

    let name = prop.apiname !== undefined && prop.apiname.length > 0 ? prop.apiname : key;
    let prop2 = prop.copy();

    let dpath = new DataPath(name, name, prop2);
    let uiname = prop.uiname;

    if (!uiname || uiname.trim().length === 0) {
      uiname = prop.apiname;
    }
    if (!uiname || uiname.trim().length === 0) {
      uiname = key;
    }

    uiname = ToolProperty.makeUIName(uiname);

    prop2.uiname = uiname;
    prop2.description = prop2.description || prop2.uiname;

    st.add(dpath);

    obj[name] = prop2.getValue();
  }

  _getAccessor(cls) {
    let toolpath = cls.tooldef().toolpath.trim();
    return this.pathmap.get(toolpath);
  }

  useDefault(cls, key, prop) {
    key = this.userSetMap.has(cls.tooldef().trim() + "." + this.constructor.getPropKey(key));
    key = key.trim();

    return key;
  }

  has(cls, key, prop) {
    let obj = this._getAccessor(cls);

    key = this.constructor.getPropKey(cls, key, prop);
    return obj && key in obj;
  }

  get(cls, key, prop) {
    if (cls === ToolMacro) {
      return;
    }

    let obj = this._getAccessor(cls);
    key = this.constructor.getPropKey(cls, key, prop);

    if (obj) {
      return obj[key];
    }

    return undefined;
  }

  set(cls, key, prop) {
    if (cls === ToolMacro) {
      return;
    }

    let toolpath = cls.tooldef().toolpath.trim();
    let obj = this._getAccessor(cls);

    if (!obj) {
      console.warn("Warning, toolop " + cls.name + " was not in the default map; unregistered?");
      this._buildAccessors(cls, key, prop, this.dstruct, this.api);

      obj = this.pathmap.get(toolpath);
    }

    if (!obj) {
      console.error("Malformed toolpath in toolop definition: " + toolpath);
      return;
    }

    key = this.constructor.getPropKey(cls, key, prop);

    //copy prop first in case we're a non-primitive-value type, e.g. vector properties
    obj[key] = prop.copy().getValue();

    let path = toolpath + "." + key;
    this.userSetMap.add(path);

    return this;
  }
}

const SavedToolDefaults = new ToolPropertyCache();

class ToolOp extends EventHandler {
  /**
   Main ToolOp constructor.  It reads the inputs/outputs properteis from
   this.constructor.tooldef() and copies them to build this.inputs and this.outputs.
   If inputs or outputs are wrapped in ToolOp.inherit(), it will walk up the class
   chain to fetch parent class properties.


   Default input values are loaded from SavedToolDefaults.  If initialized (buildToolSysAPI
   has been called) SavedToolDefaults will have a copy of all the default
   property values of all registered ToolOps.
   **/

  constructor() {
    super();

    this._overdraw = undefined;
    this.__memsize = undefined;

    var def = this.constructor.tooldef();

    if (def.undoflag !== undefined) {
      this.undoflag = def.undoflag;
    }

    if (def.flag !== undefined) {
      this.flag = def.flag;
    }

    this._accept = this._reject = undefined;
    this._promise = undefined;

    for (var k in def) {
      this[k] = def[k];
    }

    let getSlots = (slots, key) => {
      if (slots === undefined)
        return {};

      if (!(slots instanceof InheritFlag)) {
        return slots;
      }

      slots = {};
      let p = this.constructor;
      let lastp = undefined;

      while (p !== undefined && p !== Object && p !== ToolOp && p !== lastp) {
        if (p.tooldef) {
          let def = p.tooldef();

          if (def[key] !== undefined) {
            let slots2 = def[key];
            let stop = !(slots2 instanceof InheritFlag);

            if (slots2 instanceof InheritFlag) {
              slots2 = slots2.slots;
            }

            for (let k in slots2) {
              if (!(k in slots)) {
                slots[k] = slots2[k];
              }
            }

            if (stop) {
              break;
            }
          }
        }

        lastp = p;
        p = p.prototype.__proto__.constructor;
      }

      return slots;
    };

    let dinputs = getSlots(def.inputs, "inputs");
    let doutputs = getSlots(def.outputs, "outputs");

    this.inputs = {};
    this.outputs = {};

    if (dinputs) {
      for (let k in dinputs) {
        let prop = dinputs[k].copy();
        prop.apiname = prop.apiname && prop.apiname.length > 0 ? prop.apiname : k;

        if (!this.hasDefault(prop, k)) {
          this.inputs[k] = prop;
          continue;
        }

        try {
          prop.setValue(this.getDefault(prop, k));
        } catch (error) {
          console.log(error.stack);
          console.log(error.message);
        }

        prop.wasSet = false;
        this.inputs[k] = prop;
      }
    }

    if (doutputs) {
      for (let k in doutputs) {
        let prop = doutputs[k].copy();
        prop.apiname = prop.apiname && prop.apiname.length > 0 ? prop.apiname : k;

        this.outputs[k] = prop;
      }
    }

    this.drawlines = [];
  }

  /**
   ToolOp definition.

   An example:
   <pre>
   static tooldef() {
    return {
      uiname   : "Tool Name",
      toolpath : "logical_module.tool", //logical_module need not match up to a real module
      icon     : -1, //tool's icon, or -1 if there is none
      description : "tooltip",
      is_modal : false, //tool is interactive and takes control of events
      hotkey   : undefined,
      undoflag : 0, //see UndoFlags
      flag     : 0,
      inputs   : ToolOp.inherit({
        f32val : new Float32Property(1.0),
        path   : new StringProperty("./path");
      }),
      outputs  : {}
      }
    }
   </pre>
   */
  static tooldef() {
    if (this === ToolOp) {
      throw new Error("Tools must implemented static tooldef() methods!");
    }

    return {};
  }

  static Equals(a, b) {
    if (!a || !b) return false;
    if (a.constructor !== b.constructor) return false;

    let bad = false;

    for (let k in a.inputs) {
      bad = bad || !(k in b.inputs);
      bad = bad || a.inputs[k].constructor !== b.inputs[k];
      bad = bad || !a.inputs[k].equals(b.inputs[k]);

      if (bad) {
        break;
      }
    }

    return !bad;
  }

  static inherit(slots = {}) {
    return new InheritFlag(slots);
  }

  /**

   Creates a new instance of this toolop from args and a context.
   This is often use to fill properties with default arguments
   stored somewhere in the context.

   */
  static invoke(ctx, args) {
    let tool = new this();

    for (let k in args) {
      if (!(k in tool.inputs)) {
        console.warn("Unknown tool argument " + k);
        continue;
      }

      let prop = tool.inputs[k];
      let val = args[k];

      if ((typeof val === "string") && prop.type & (PropTypes.ENUM | PropTypes.FLAG)) {
        if (val in prop.values) {
          val = prop.values[val];
        } else {
          console.warn("Possible invalid enum/flag:", val);
          continue;
        }
      }

      tool.inputs[k].setValue(val);
    }

    return tool;
  }

  static register(cls) {
    if (ToolClasses.indexOf(cls) >= 0) {
      console.warn("Tried to register same ToolOp class twice:", cls.name, cls);
      return;
    }

    ToolClasses.push(cls);
  }

  static _regWithNstructjs(cls, structName = cls.name) {
    if (nstructjs.isRegistered(cls)) {
      return;
    }

    let parent = cls.prototype.__proto__.constructor;

    if (!cls.hasOwnProperty("STRUCT")) {
      if (parent !== ToolOp && parent !== ToolMacro && parent !== Object) {
        this._regWithNstructjs(parent);
      }

      cls.STRUCT = nstructjs.inherit(cls, parent) + '}\n';
    }

    nstructjs.register(cls);
  }

  static isRegistered(cls) {
    return ToolClasses.indexOf(cls) >= 0;
  }

  static unregister(cls) {
    if (ToolClasses.indexOf(cls) >= 0) {
      ToolClasses.remove(cls);
    }
  }

  static _getFinalToolDef() {
    let def = this.tooldef();

    let getSlots = (slots, key) => {
      if (slots === undefined)
        return {};

      if (!(slots instanceof InheritFlag)) {
        return slots;
      }

      slots = {};
      let p = this;

      while (p !== undefined && p !== Object && p !== ToolOp) {
        if (p.tooldef) {
          let def = p.tooldef();

          if (def[key] !== undefined) {
            let slots2 = def[key];
            let stop = !(slots2 instanceof InheritFlag);

            if (slots2 instanceof InheritFlag) {
              slots2 = slots2.slots;
            }

            for (let k in slots2) {
              if (!(k in slots)) {
                slots[k] = slots2[k];
              }
            }

            if (stop) {
              break;
            }
          }

        }
        p = p.prototype.__proto__.constructor;
      }

      return slots;
    };

    let dinputs = getSlots(def.inputs, "inputs");
    let doutputs = getSlots(def.outputs, "outputs");

    def.inputs = dinputs;
    def.outputs = doutputs;

    return def;
  }

  static onTick() {
    for (let toolop of modalstack$1) {
      toolop.on_tick();
    }
  }

  static searchBoxOk(ctx) {
    let flag = this.tooldef().flag;
    let ret = !(flag && (flag & ToolFlags.PRIVATE));
    ret = ret && this.canRun(ctx);

    return ret;
  }

  //toolop is an optional instance of this class, may be undefined
  static canRun(ctx, toolop = undefined) {
    return true;
  }

  /** Called when the undo system needs to destroy
   *  this toolop to save memory*/
  onUndoDestroy() {

  }

  /** Used by undo system to limit memory */
  calcMemSize(ctx) {
    if (this.__memsize !== undefined) {
      return this.__memsize;
    }

    let tot = 0;

    for (let step = 0; step < 2; step++) {
      let props = step ? this.outputs : this.inputs;

      for (let k in props) {
        let prop = props[k];

        let size = prop.calcMemSize();

        if (isNaN(size) || !isFinite(size)) {
          console.warn("Got NaN when calculating mem size for property", prop);
          continue;
        }

        tot += size;
      }
    }

    let size = this.calcUndoMem(ctx);

    if (isNaN(size) || !isFinite(size)) {
      console.warn("Got NaN in calcMemSize", this);
    } else {
      tot += size;
    }

    this.__memsize = tot;

    return tot;
  }

  loadDefaults(force = true) {
    for (let k in this.inputs) {
      let prop = this.inputs[k];

      if (!force && prop.wasSet) {
        continue;
      }

      if (this.hasDefault(prop, k)) {
        prop.setValue(this.getDefault(prop, k));
        prop.wasSet = false;
      }
    }

    return this;
  }

  hasDefault(toolprop, key = toolprop.apiname) {
    return SavedToolDefaults.has(this.constructor, key, toolprop);
  }

  getDefault(toolprop, key = toolprop.apiname) {
    let cls = this.constructor;

    if (SavedToolDefaults.has(cls, key, toolprop)) {
      return SavedToolDefaults.get(cls, key, toolprop);
    } else {
      return toolprop.getValue();
    }
  }

  saveDefaultInputs() {
    for (let k in this.inputs) {
      let prop = this.inputs[k];

      if (prop.flag & PropFlags.SAVE_LAST_VALUE) {
        SavedToolDefaults.set(this.constructor, k, prop);
      }
    }

    return this;
  }

  genToolString() {
    let def = this.constructor.tooldef();
    let path = def.toolpath + "(";

    for (let k in this.inputs) {
      let prop = this.inputs[k];

      path += k + "=";
      if (prop.type === PropTypes.STRING)
        path += "'";

      if (prop.type === PropTypes.FLOAT) {
        path += prop.getValue().toFixed(3);
      } else {
        path += prop.getValue();
      }

      if (prop.type === PropTypes.STRING)
        path += "'";
      path += " ";
    }
    path += ")";
    return path;
  }

  on_tick() {

  }

  /**default on_keydown implementation for modal tools,
   no need to call super() to execute this if you don't want to*/
  on_keydown(e) {
    switch (e.keyCode) {
      case keymap["Enter"]:
      case keymap["Space"]:
        this.modalEnd(false);
        break;
      case keymap["Escape"]:
        this.modalEnd(true);
        break;
    }
  }

  //called after undoPre
  calcUndoMem(ctx) {
    console.warn("ToolOp.prototype.calcUndoMem: implement me!");
    return 0;
  }

  undoPre(ctx) {
    throw new Error("implement me!");
  }

  undo(ctx) {
    throw new Error("implement me!");
    //_appstate.loadUndoFile(this._undo);
  }

  redo(ctx) {
    this._was_redo = true; //also set by toolstack.redo

    this.undoPre(ctx);
    this.execPre(ctx);
    this.exec(ctx);
    this.execPost(ctx);
  }

  //for compatibility with fairmotion
  exec_pre(ctx) {
    this.execPre(ctx);
  }

  execPre(ctx) {
  }

  exec(ctx) {
  }

  execPost(ctx) {

  }

  /**for use in modal mode only*/
  resetTempGeom() {
    var ctx = this.modal_ctx;

    for (var dl of this.drawlines) {
      dl.remove();
    }

    this.drawlines.length = 0;
  }

  error(msg) {
    console.warn(msg);
  }

  getOverdraw() {
    if (this._overdraw === undefined) {
      this._overdraw = document.createElement("overdraw-x");
      this._overdraw.start(this.modal_ctx.screen);
    }

    return this._overdraw;
  }

  /**for use in modal mode only*/
  makeTempLine(v1, v2, style) {
    let line = this.getOverdraw().line(v1, v2, style);
    this.drawlines.push(line);
    return line;
  }

  pushModal(node) {
    throw new Error("cannot call this; use modalStart")
  }

  popModal() {
    throw new Error("cannot call this; use modalEnd");
  }

  /**returns promise to be executed on modalEnd*/
  modalStart(ctx) {
    if (this.modalRunning) {
      console.warn("Warning, tool is already in modal mode consuming events");
      return this._promise;
    }

    this.modal_ctx = ctx;
    this.modalRunning = true;

    this._promise = new Promise((accept, reject) => {
      this._accept = accept;
      this._reject = reject;

      modalstack$1.push(this);
      super.pushModal(ctx.screen);
    });

    return this._promise;
  }

  /*eek, I've not been using this.
    guess it's a non-enforced contract, I've been naming
    cancel methods 'cancel' all this time.

    XXX fix
  */
  toolCancel() {
  }

  modalEnd(was_cancelled) {
    if (this._modalstate) {
      modalstack$1.pop();
    }

    if (this._overdraw !== undefined) {
      this._overdraw.end();
      this._overdraw = undefined;
    }

    if (was_cancelled && this._on_cancel !== undefined) {
      if (this._accept) {
        this._accept(this.modal_ctx, true);
      }
      this._on_cancel(this);
    }

    this.resetTempGeom();

    var ctx = this.modal_ctx;

    this.modal_ctx = undefined;
    this.modalRunning = false;
    this.is_modal = false;

    super.popModal();

    this._promise = undefined;

    if (this._accept) {
      this._accept(ctx, false);//Context, was_cancelled
      this._accept = this._reject = undefined;
    }

    this.saveDefaultInputs();
  }

  loadSTRUCT(reader) {
    reader(this);

    let outs = this.outputs;
    let ins = this.inputs;

    this.inputs = {};
    this.outputs = {};

    for (let pair of ins) {
      this.inputs[pair.key] = pair.val;
    }

    for (let pair of outs) {
      this.outputs[pair.key] = pair.val;
    }
  }

  _save_inputs() {
    let ret = [];
    for (let k in this.inputs) {
      ret.push(new PropKey(k, this.inputs[k]));
    }

    return ret;
  }

  _save_outputs() {
    let ret = [];
    for (let k in this.outputs) {
      ret.push(new PropKey(k, this.outputs[k]));
    }

    return ret;
  }
}

ToolOp.STRUCT = `
toolsys.ToolOp {
  inputs  : array(toolsys.PropKey) | this._save_inputs();
  outputs : array(toolsys.PropKey) | this._save_outputs();
}
`;
nstructjs.register(ToolOp);

class PropKey {
  constructor(key, val) {
    this.key = key;
    this.val = val;
  }
}

PropKey.STRUCT = `
toolsys.PropKey {
  key : string;
  val : abstract(ToolProperty);
}
`;
nstructjs.register(PropKey);

class MacroLink {
  constructor(sourcetool_idx, srckey, srcprops = "outputs", desttool_idx, dstkey, dstprops = "inputs") {
    this.source = sourcetool_idx;
    this.dest = desttool_idx;

    this.sourceProps = srcprops;
    this.destProps = dstprops;

    this.sourcePropKey = srckey;
    this.destPropKey = dstkey;
  }
}

MacroLink.STRUCT = `
toolsys.MacroLink {
  source         : int;
  dest           : int;
  sourcePropKey  : string;
  destPropKey    : string;
  sourceProps    : string;
  destProps      : string; 
}
`;
nstructjs.register(MacroLink);

const MacroClasses = {};
window._MacroClasses = MacroClasses;

let macroidgen = 0;


class ToolMacro extends ToolOp {
  constructor() {
    super();

    this.tools = [];
    this.curtool = 0;
    this.has_modal = false;
    this.connects = [];
    this.connectLinks = [];

    this._macro_class = undefined;
  }

  static tooldef() {
    return {
      uiname: "Tool Macro"
    }
  }

  //toolop is an optional instance of this class, may be undefined
  static canRun(ctx, toolop = undefined) {
    return true;
  }

  _getTypeClass() {
    if (this._macro_class && this._macro_class.ready) {
      return this._macro_class;
    }

    if (!this._macro_class) {
      this._macro_class = class MacroTypeClass extends ToolOp {
        static tooldef() {
          return this.__tooldef;
        }
      };

      this._macro_class.__tooldef = {
        toolpath: this.constructor.tooldef().toolpath || ''
      };
      this._macro_class.ready = false;
    }

    if (!this.tools || this.tools.length === 0) {
      /* We've been invoked by ToolOp constructor,
      *  for now just return an empty class  */
      return this._macro_class;
    }

    let key = "";
    for (let tool of this.tools) {
      key = tool.constructor.name + ":";
    }

    /* Handle child classes of ToolMacro */
    if (this.constructor !== ToolMacro) {
      key += ":" + this.constructor.tooldef().toolpath;
    }

    for (let k in this.inputs) {
      key += k + ":";
    }

    if (key in MacroClasses) {
      this._macro_class = MacroClasses[key];
      return this._macro_class;
    }

    let name = "Macro(";
    let i = 0;
    let is_modal;

    for (let tool of this.tools) {
      let def = tool.constructor.tooldef();

      if (i > 0) {
        name += ", ";
      } else {
        is_modal = def.is_modal;
      }

      if (def.uiname) {
        name += def.uiname;
      } else if (def.toolpath) {
        name += def.toolpath;
      } else {
        name += tool.constructor.name;
      }

      i++;
    }

    let inputs = {};

    for (let k in this.inputs) {
      inputs[k] = this.inputs[k].copy().clearEventCallbacks();
      inputs[k].wasSet = false;
    }

    let tdef = {
      uiname  : name,
      toolpath: key,
      inputs,
      outputs : {},
      is_modal
    };

    let cls = this._macro_class;
    cls.__tooldef = tdef;
    cls._macroTypeId = macroidgen++;
    cls.ready = true;

    /*
    let cls = {
      name : key,
      tooldef() {
        return tdef
      },
      _getFinalToolDef() {
        return this.tooldef();
      }
    };//*/

    MacroClasses[key] = cls;

    return cls;
  }

  saveDefaultInputs() {
    for (let k in this.inputs) {
      let prop = this.inputs[k];

      if (prop.flag & PropFlags.SAVE_LAST_VALUE) {
        SavedToolDefaults.set(this._getTypeClass(), k, prop);
      }
    }

    return this;
  }

  hasDefault(toolprop, key = toolprop.apiname) {
    return SavedToolDefaults.has(this._getTypeClass(), key, toolprop);
  }

  getDefault(toolprop, key = toolprop.apiname) {
    let cls = this._getTypeClass();

    if (SavedToolDefaults.has(cls, key, toolprop)) {
      return SavedToolDefaults.get(cls, key, toolprop);
    } else {
      return toolprop.getValue();
    }
  }

  connect(srctool, srcoutput, dsttool, dstinput, srcprops = "outputs", dstprops = "inputs") {
    if (typeof dsttool === "function") {
      return this.connectCB(...arguments);
    }

    let i1 = this.tools.indexOf(srctool);
    let i2 = this.tools.indexOf(dsttool);

    if (i1 < 0 || i2 < 0) {
      throw new Error("tool not in macro");
    }

    //remove linked properties from this.inputs
    if (srcprops === "inputs") {
      let tool = this.tools[i1];

      let prop = tool.inputs[srcoutput];
      if (prop === this.inputs[srcoutput]) {
        delete this.inputs[srcoutput];
      }
    }

    if (dstprops === "inputs") {
      let tool = this.tools[i2];
      let prop = tool.inputs[dstinput];

      if (this.inputs[dstinput] === prop) {
        delete this.inputs[dstinput];
      }
    }

    this.connectLinks.push(new MacroLink(i1, srcoutput, srcprops, i2, dstinput, dstprops));
    return this;
  }

  connectCB(srctool, dsttool, callback, thisvar) {
    this.connects.push({
      srctool : srctool,
      dsttool : dsttool,
      callback: callback,
      thisvar : thisvar
    });

    return this;
  }

  add(tool) {
    if (tool.is_modal) {
      this.is_modal = true;
    }

    for (let k in tool.inputs) {
      let prop = tool.inputs[k];

      if (!(prop.flag & PropFlags.PRIVATE)) {
        this.inputs[k] = prop;
      }
    }

    this.tools.push(tool);

    return this;
  }

  _do_connections(tool) {
    let i = this.tools.indexOf(tool);

    for (let c of this.connectLinks) {
      if (c.source === i) {
        let tool2 = this.tools[c.dest];

        tool2[c.destProps][c.destPropKey].setValue(tool[c.sourceProps][c.sourcePropKey].getValue());
      }
    }

    for (var c of this.connects) {
      if (c.srctool === tool) {
        c.callback.call(c.thisvar, c.srctool, c.dsttool);
      }
    }
  }

  /*
  canRun(ctx) {
    if (this.tools.length == 0)
      return false;

    //poll first tool only in list
    return this.tools[0].constructor.canRun(ctx);
  }//*/

  modalStart(ctx) {
    //macros obviously can't call loadDefaults in the constructor
    //like normal tool ops can.
    this.loadDefaults(false);

    this._promise = new Promise((function (accept, reject) {
      this._accept = accept;
      this._reject = reject;
    }).bind(this));

    this.curtool = 0;

    let i;

    for (i = 0; i < this.tools.length; i++) {
      if (this.tools[i].is_modal)
        break;

      this.tools[i].undoPre(ctx);
      this.tools[i].execPre(ctx);
      this.tools[i].exec(ctx);
      this.tools[i].execPost(ctx);
      this._do_connections(this.tools[i]);
    }

    var on_modal_end = (function on_modal_end() {
      this._do_connections(this.tools[this.curtool]);
      this.curtool++;

      while (this.curtool < this.tools.length &&
      !this.tools[this.curtool].is_modal) {
        this.tools[this.curtool].undoPre(ctx);
        this.tools[this.curtool].execPre(ctx);
        this.tools[this.curtool].exec(ctx);
        this.tools[this.curtool].execPost(ctx);
        this._do_connections(this.tools[this.curtool]);

        this.curtool++;
      }

      if (this.curtool < this.tools.length) {
        this.tools[this.curtool].undoPre(ctx);
        this.tools[this.curtool].modalStart(ctx).then(on_modal_end);
      } else {
        this._accept(this, false);
      }
    }).bind(this);

    if (i < this.tools.length) {
      this.curtool = i;
      this.tools[this.curtool].undoPre(ctx);
      this.tools[this.curtool].modalStart(ctx).then(on_modal_end);
    }

    return this._promise;
  }

  loadDefaults(force = true) {
    return super.loadDefaults(force);
  }

  exec(ctx) {
    //macros obviously can't call loadDefaults in the constructor
    //like normal tool ops can.
    //note that this will detect if the user changes property values

    this.loadDefaults(false);

    for (var i = 0; i < this.tools.length; i++) {
      this.tools[i].undoPre(ctx);
      this.tools[i].execPre(ctx);
      this.tools[i].exec(ctx);
      this.tools[i].execPost(ctx);
      this._do_connections(this.tools[i]);
    }
  }

  calcUndoMem(ctx) {
    let tot = 0;

    for (let tool of this.tools) {
      tot += tool.calcUndoMem(ctx);
    }

    return tot;
  }

  calcMemSize(ctx) {
    let tot = 0;

    for (let tool of this.tools) {
      tot += tool.calcMemSize(ctx);
    }

    return tot;
  }

  undoPre() {
    return; //undoPre is handled in exec() or modalStart()
  }

  undo(ctx) {
    for (var i = this.tools.length - 1; i >= 0; i--) {
      this.tools[i].undo(ctx);
    }
  }
}

ToolMacro.STRUCT = nstructjs.inherit(ToolMacro, ToolOp, "toolsys.ToolMacro") + `
  tools        : array(abstract(toolsys.ToolOp));
  connectLinks : array(toolsys.MacroLink);
}
`;
nstructjs.register(ToolMacro);

class ToolStack extends Array {
  constructor(ctx) {
    super();

    this.memLimit = 512*1024*1024;
    this.enforceMemLimit = false;

    this.cur = -1;
    this.ctx = ctx;

    this.modalRunning = 0;

    this._undo_branch = undefined; //used to save undo branch in case of tool cancel
  }

  get head() {
    return this[this.cur];
  }

  limitMemory(maxmem = this.memLimit, ctx = this.ctx) {
    if (maxmem === undefined) {
      throw new Error("maxmem cannot be undefined");
    }

    let size = this.calcMemSize();

    let start = 0;

    while (start < this.cur - 2 && size > maxmem) {
      size -= this[start].calcMemSize(ctx);
      start++;
    }

    if (start === 0) {
      return size;
    }

    for (let i = 0; i < start; i++) {
      this[i].onUndoDestroy();
    }

    this.cur -= start;

    for (let i = 0; i < this.length - start; i++) {
      this[i] = this[i + start];
    }
    this.length -= start;

    return this.calcMemSize(ctx);
  }

  calcMemSize(ctx = this.ctx) {
    let tot = 0;

    for (let tool of this) {
      try {
        tot += tool.calcMemSize();
      } catch (error) {
        print_stack$1(error);
        console.error("Failed to execute a calcMemSize method");
      }
    }

    return tot;
  }

  setRestrictedToolContext(ctx) {
    this.toolctx = ctx;
  }

  reset(ctx) {
    if (ctx !== undefined) {
      this.ctx = ctx;
    }

    this.modalRunning = 0;
    this.cur = -1;
    this.length = 0;
  }

  /**
   * runs .undo,.redo if toolstack head is same as tool
   *
   * otherwise, .execTool(ctx, tool) is called.
   *
   * @param compareInputs : check if toolstack head has identical input values, defaults to false
   * */
  execOrRedo(ctx, tool, compareInputs = false) {
    let head = this.head;

    let ok = compareInputs ? ToolOp.Equals(head, tool) : head && head.constructor === tool.constructor;

    tool.__memsize = undefined; //reset cache memsize

    if (ok) {
      //console.warn("Same tool detected");

      this.undo();

      //can inputs differ? in that case, execute new tool
      if (!compareInputs) {
        this.execTool(ctx, tool);
      } else {
        this.rerun();
      }

      return false;
    } else {
      this.execTool(ctx, tool);
      return true;
    }
  }

  execTool(ctx, toolop) {
    if (this.enforceMemLimit) {
      this.limitMemory(this.memLimit, ctx);
    }

    if (!toolop.constructor.canRun(ctx, toolop)) {
      console.log("toolop.constructor.canRun returned false");
      return;
    }

    let tctx = ctx.toLocked();

    let undoflag = toolop.constructor.tooldef().undoflag;
    if (toolop.undoflag !== undefined) {
      undoflag = toolop.undoflag;
    }
    undoflag = undoflag === undefined ? 0 : undoflag;

    //if (!(undoflag & UndoFlags.IS_UNDO_ROOT) && !(undoflag & UndoFlags.NO_UNDO)) {
    //tctx = new SavedContext(ctx, ctx.datalib);
    //}

    toolop.execCtx = tctx;

    if (!(undoflag & UndoFlags.NO_UNDO)) {
      this.cur++;

      //save branch for if tool cancel
      this._undo_branch = this.slice(this.cur + 1, this.length);

      //truncate
      this.length = this.cur + 1;

      this[this.cur] = toolop;
      toolop.undoPre(tctx);
    }

    if (toolop.is_modal) {
      ctx = toolop.modal_ctx = ctx;

      this.modal_running = true;

      toolop._on_cancel = (function (toolop) {
        if (!(toolop.undoflag & UndoFlags.NO_UNDO)) {
          this.pop_i(this.cur);
          this.cur--;
        }
      }).bind(this);

      //will handle calling .exec itself
      toolop.modalStart(ctx);
    } else {
      toolop.execPre(tctx);
      toolop.exec(tctx);
      toolop.execPost(tctx);
      toolop.saveDefaultInputs();
    }
  }

  toolCancel(ctx, tool) {
    if (tool._was_redo) { //also set by toolstack.redo
      //ignore tool cancel requests on redo
      return;
    }

    if (tool !== this[this.cur]) {
      console.warn("toolCancel called in error", this, tool);
      return;
    }

    this.undo();
    this.length = this.cur + 1;

    if (this._undo_branch !== undefined) {
      for (let item of this._undo_branch) {
        this.push(item);
      }
    }
  }

  undo() {
    if (this.enforceMemLimit) {
      this.limitMemory(this.memLimit);
    }

    if (this.cur >= 0 && !(this[this.cur].undoflag & UndoFlags.IS_UNDO_ROOT)) {
      let tool = this[this.cur];

      tool.undo(tool.execCtx);

      this.cur--;
    }
  }

  //reruns a tool if it's at the head of the stack
  rerun(tool) {
    if (this.enforceMemLimit) {
      this.limitMemory(this.memLimit);
    }

    if (tool === this[this.cur]) {
      tool._was_redo = false;

      if (!tool.execCtx) {
        tool.execCtx = this.ctx;
      }

      tool.undo(tool.execCtx);

      tool._was_redo = true; //also set by toolstack.redo

      tool.undoPre(tool.execCtx);
      tool.execPre(tool.execCtx);
      tool.exec(tool.execCtx);
      tool.execPost(tool.execCtx);
    } else {
      console.warn("Tool wasn't at head of stack", tool);
    }
  }

  redo() {
    if (this.enforceMemLimit) {
      this.limitMemory(this.memLimit);
    }

    if (this.cur >= -1 && this.cur + 1 < this.length) {
      //console.log("redo!", this.cur, this.length);

      this.cur++;
      let tool = this[this.cur];


      if (!tool.execCtx) {
        tool.execCtx = this.ctx;
      }

      tool._was_redo = true;
      tool.redo(tool.execCtx);

      tool.saveDefaultInputs();
    }
  }

  save() {
    let data = [];
    nstructjs.writeObject(data, this);
    return data;
  }

  rewind() {
    while (this.cur >= 0) {
      let last = this.cur;
      this.undo();

      //prevent infinite loops
      if (last === this.cur) {
        break;
      }
    }

    return this;
  }

  /**cb is a function(ctx), if it returns the value false then playback stops
   promise will still be fulfilled.

   onstep is a callback, if it returns a promise that promise will be
   waited on, otherwise execution is queue with window.setTimeout().
   */
  replay(cb, onStep) {
    let cur = this.cur;

    this.rewind();

    let last = this.cur;

    let start = time_ms();

    return new Promise((accept, reject) => {
      let next = () => {
        last = this.cur;

        if (cb && cb(ctx) === false) {
          accept();
          return;
        }

        if (this.cur < this.length) {
          this.cur++;
          this.rerun();
        }

        if (last === this.cur) {
          console.warn("time:", (time_ms() - start)/1000.0);
          accept(this);
        } else {
          if (onStep) {
            let ret = onStep();

            if (ret && ret instanceof Promise) {
              ret.then(() => {
                next();
              });
            } else {
              window.setTimeout(() => {
                next();
              });
            }
          }
        }
      };

      next();
    });
  }

  loadSTRUCT(reader) {
    reader(this);

    for (let item of this._stack) {
      this.push(item);
    }

    delete this._stack;
  }

  //note that this makes sure tool classes are registered with nstructjs
  //during save
  _save() {
    for (let tool of this) {
      let cls = tool.constructor;

      if (!nstructjs.isRegistered(cls)) {
        cls._regWithNstructjs(cls);
      }
    }

    return this;
  }
}

ToolStack.STRUCT = `
toolsys.ToolStack {
  cur    : int;
  _stack : array(abstract(toolsys.ToolOp)) | this._save();
}
`;
nstructjs.register(ToolStack);

window._testToolStackIO = function () {
  let data = [];
  let cls = _appstate.toolstack.constructor;

  nstructjs.writeObject(data, _appstate.toolstack);
  data = new DataView(new Uint8Array(data).buffer);

  let toolstack = nstructjs.readObject(data, cls);

  _appstate.toolstack.rewind();

  toolstack.cur = -1;
  toolstack.ctx = _appstate.toolstack.ctx;
  _appstate.toolstack = toolstack;

  return toolstack;
};

function buildToolSysAPI(api, registerWithNStructjs = true, rootCtxStruct = undefined) {
  let datastruct = api.mapStruct(ToolPropertyCache, true);

  for (let cls of ToolClasses) {
    let def = cls._getFinalToolDef();

    for (let k in def.inputs) {
      let prop = def.inputs[k];

      if (!(prop.flag & (PropFlags.PRIVATE | PropFlags.READ_ONLY))) {
        SavedToolDefaults._buildAccessors(cls, k, prop, datastruct, api);
      }
    }
  }

  if (rootCtxStruct) {
    rootCtxStruct.struct("toolDefaults", "toolDefaults", "Tool Defaults", api.mapStruct(ToolPropertyCache));
  }

  if (!registerWithNStructjs) {
    return;
  }

  //register tools with nstructjs
  for (let cls of ToolClasses) {
    try {
      if (!nstructjs.isRegistered(cls)) {
        ToolOp._regWithNstructjs(cls);
      }
    } catch (error) {
      console.log(error.stack);
      console.error("Failed to register a tool with nstructjs");
    }
  }
}

let ToolPaths = {};

var initToolPaths_run = false;

function buildParser() {
  let t = (name, re, func) => new tokdef$1(name, re, func);

  let tokens = [
    t('ID', /[a-zA-Z_$]+[a-zA-Z0-9_$]*/, (t) => {
      if (t.value == "true" || t.value == "false") {
        t.type = "BOOL";
        t.value = t.value == "true";
      }

      return t;
    }),
    t('LPAREN', /\(/),
    t('RPAREN', /\)/),
    t('LSBRACKET', /\[/),
    t('RSBRACKET', /\]/),
    t('DOT', /\./),
    t('COMMA', /\,/),
    t('EQUALS', /\=/),
    t('STRLIT', /"[^"]*"/, (t) => {
      t.value = t.value.slice(1, t.value.length-1);
      return t;
    }),
    t('STRLIT', /'[^']*'/, (t) => {
      t.value = t.value.slice(1, t.value.length-1);
      return t;
    }),
    t('NUMBER', /-?[0-9]+/, (t) => {
      t.value = parseInt(t.value);
      return t;
    }),
    t('NUMBER', /-?[0-9]+\.[0-9]*/, (t) => {
      t.value = parseFloat(t.value);
      return t;
    }),
    t('WS', /[ \n\r\t]/, (t) => undefined) //ignore whitespace
  ];

  let lexerror = (t) => {
    console.warn("Parse error");
    return true;
  };

  let valid_datatypes = {
    "STRLIT" : 1, "NUMBER" : 1, "BOOL" : 1
  };

  function p_Start(p) {
    let args = {};

    while (!p.at_end()) {
      let keyword = p.expect("ID");

      p.expect("EQUALS");

      let t = p.next();
      if (!(t.type in valid_datatypes)) {
        throw new PUTLParseError("parse error: unexpected " + t.type);
      }

      args[keyword] = t.value;
    }

    return args;
  }

  let lex = new lexer$1(tokens, lexerror);
  let p = new parser$1(lex);
  p.start = p_Start;

  return p;
}

let Parser = buildParser();
/*
let parse_rets = new cachering(() => return {
  toolclass : undefined,
  args : {}
}, 64);
//*/

function parseToolPath(str, check_tool_exists=true) {
  if (!initToolPaths_run) {
    initToolPaths_run = true;
    initToolPaths();
  }

  let startstr = str;

  let i1 = str.search(/\(/);
  let i2 = str.search(/\)/);
  let args = "";

  if (i1 >= 0 && i2 >= 0) {
    args = str.slice(i1+1, i2).trim();
    str = str.slice(0, i1).trim();
  }

  if (!(str in ToolPaths) && check_tool_exists) {
    throw new DataPathError("unknown tool " + str);
  }

  let ret;

  try {
    ret = Parser.parse(args);
  } catch (error) {
    console.log(error);
    throw new DataPathError(`"${startstr}"\n  ${error.message}`);
  }

  return {
    toolclass : ToolPaths[str],
    args      : ret
  };
}

function testToolParser() {
  let ret = parseToolPath("view3d.sometool(selectmode=1 str='str' bool=true)", false);

  return ret;
}

window.parseToolPath = parseToolPath;
//window._ToolPaths = ToolPaths;

//tool path parser for simple_toolsys.js
function initToolPaths() {
  for (let cls of ToolClasses) {
    if (!cls.hasOwnProperty("tooldef")) { //ignore abstract classes
      continue;
    }

    let def = cls.tooldef();
    let path = def.toolpath;

    ToolPaths[path] = cls;
  }
}

class ModelInterface {
  constructor() {
    this.prefix = "";
  }

  getToolDef(path) {
    throw new Error("implement me");
  }

  getToolPathHotkey(ctx, path) {
    return undefined;
  }

  get list() {
    throw new Error("implement me");
    return ListIface;
  }

  createTool(path, inputs={}, constructor_argument=undefined) {
    throw new Error("implement me");
  }

  //returns tool class, or undefined if one cannot be found for path
  parseToolPath(path) {
    throw new Error("implement me");
  }

  /**
   * runs .undo,.redo if toolstack head is same as tool
   *
   * otherwise, .execTool(ctx, tool) is called.
   *
   * @param compareInputs : check if toolstack head has identical input values, defaults to false
   * */
  execOrRedo(ctx, toolop, compareInputs=false) {
    return ctx.toolstack.execOrRedo(ctx, toolop, compareInputs);
  }

  execTool(ctx, path, inputs={}, constructor_argument=undefined) {
    return new Promise((accept, reject) => {
      let tool = path;

      try {
        if (typeof tool == "string" || !(tool instanceof ToolOp)) {
          tool = this.createTool(ctx, path, inputs, constructor_argument);
        }
      } catch (error) {
        print_stack$1(error);
        reject(error);
        return;
      }

      //give client a chance to change tool instance directly
      accept(tool);

      //execute
      try {
        ctx.toolstack.execTool(ctx, tool);
      } catch (error) { //for some reason chrome is suppressing errors
        print_stack$1(error);
        throw error;
      }
    });
  }

  //used by simple_controller.js for tagging error messages
  pushReportContext(name) {

  }

  //used by simple_controller.js for tagging error messages
  popReportContext() {

  }

  static toolRegistered(tool) {
    throw new Error("implement me");
  }

  static registerTool(tool) {
    throw new Error("implement me");
  }

  //not yet supported by path.ux's controller implementation
  massSetProp(ctx, mass_set_path, value) {
    throw new Error("implement me");
  }

  /** takes a mass_set_path and returns an array of individual paths */
  resolveMassSetPaths(ctx, mass_set_path) {
    throw new Error("implement me");
  }

  /**
   * @example
   *
   * return {
   *   obj      : [object owning property key]
   *   parent   : [parent of obj]
   *   key      : [property key]
   *   subkey   : used by flag properties, represents a key within the property
   *   value    : [value of property]
   *   prop     : [optional toolprop.ToolProperty representing the property definition]
   *   struct   : [optional datastruct representing the type, if value is an object]
   *   mass_set : mass setter string, if controller implementation supports it
   * }
   */
  resolvePath(ctx, path, ignoreExistence, rootStruct) {
  }

  setValue(ctx, path, val, rootStruct) {
    let res = this.resolvePath(ctx, path, undefined,  rootStruct);
    let prop = res.prop;

    if (prop !== undefined && (prop.flag & PropFlags.READ_ONLY)) {
      throw new DataPathError("Tried to set read only property");
    }

    if (prop !== undefined && (prop.flag & PropFlags.USE_CUSTOM_GETSET)) {
      prop.dataref = res.obj;
      prop.ctx = ctx;
      prop.datapath = path;

      if (res.subkey !== undefined) {
        let val2 = prop.getValue();
        if (typeof val2 === "object") {
          val2 = val2.copy();
        }

        if (prop.type === PropTypes.FLAG) {
          if (val) {
            val2 |= prop.values[res.subkey];
          } else {
            val2 &= ~prop.values[res.subkey];
          }

          val = val2;
        } else if (prop.type === PropTypes.ENUM) {
          val = prop.values[res.subkey];
        } else {
          val2[res.subkey] = val;
          val = val2;
        }
      }

      prop.setValue(val);
      return;
    }

    if (prop !== undefined) {
      if (prop.type === PropTypes.CURVE && !val) {
        throw new DataPathError("can't set curve data to nothing");
      }

      let use_range = (prop.type & (PropTypes.INT | PropTypes.FLOAT));

      use_range = use_range || (res.subkey && (prop.type & (PropTypes.VEC2 | PropTypes.VEC3 | PropTypes.VEC4)));
      use_range = use_range && prop.range;
      use_range = use_range && !(prop.range[0] === 0.0 && prop.range[1] === 0.0);
      use_range = use_range && typeof val === "number";

      if (use_range) {
        val = Math.min(Math.max(val, prop.range[0]), prop.range[1]);
      }
    }

    let old = res.obj[res.key];

    if (res.subkey !== undefined && res.prop !== undefined && res.prop.type === PropTypes.ENUM) {
      let ival = res.prop.values[res.subkey];

      if (val) {
        res.obj[res.key] = ival;
      }
    } else if (res.prop !== undefined && res.prop.type === PropTypes.FLAG) {
      if (res.subkey !== undefined) {
        let ival = res.prop.values[res.subkey];

        if (val) {
          res.obj[res.key] |= ival;
        } else {
          res.obj[res.key] &= ~ival;
        }
      } else if (typeof val === "number" || typeof val === "boolean") {
        val = typeof val === "boolean" ? (val & 1) : val;

        res.obj[res.key] = val;
      } else {
        throw new DataPathError("Expected a number for a bitmask property");
      }
    } else if (res.subkey !== undefined && isVecProperty(res.prop)) {
      if (res.key !== "") {
        res.obj[res.key][res.subkey] = val;
      } else {
        res.obj[res.subkey] = val;
      }
    } else if (res.key === "" && isVecProperty(res.prop)) {
      for (let i=0; i<res.obj.length; i++) {
        res.obj[i] = val[i];
      }
    } else if (!(prop !== undefined && prop instanceof ListIface)) {
      res.obj[res.key] = val;
    }

    if (prop !== undefined && prop instanceof ListIface) {
      prop.set(this, res.obj, res.key, val);
    } else if (prop !== undefined) {
      prop.dataref = res.obj;
      prop.datapath = path;
      prop.ctx = ctx;

      prop._fire("change", res.obj[res.key], old);
    }
  }

  getDescription(ctx, path) {
    let rdef = this.resolvePath(ctx, path);
    if (rdef === undefined) {
      throw new DataPathError("invalid path " + path);
    }

    if (!rdef.prop || !(rdef.prop instanceof ToolProperty$1)) {
      return "";
    }

    let type = rdef.prop.type;
    let prop = rdef.prop;

    if (rdef.subkey !== undefined) {
      let subkey = rdef.subkey;

      if (type & (PropTypes.VEC2|PropTypes.VEC3|PropTypes.VEC4)) {
        if (prop.descriptions && subkey in prop.descriptions) {
          return prop.descriptions[subkey];
        }
      } else if (type & (PropTypes.ENUM|PropTypes.FLAG)) {
        if (!(subkey in prop.values) && subkey in prop.keys) {
          subkey = prop.keys[subkey];
        };

        if (prop.descriptions && subkey in prop.descriptions) {
          return prop.descriptions[subkey];
        }
      } else if (type === PropTypes.PROPLIST) {
        let val = tdef.value;
        if (typeof val === "object" && val instanceof ToolProperty$1) {
          return val.description;
        }
      }
    }

    return rdef.prop.description ? rdef.prop.description : rdef.prop.uiname;
  }

  validPath(ctx, path, rootStruct) {
    try {
      this.getValue(ctx, path, rootStruct);
      return true;
    } catch (error) {
      if (!(error instanceof DataPathError)) {
        throw error;
      }
    }

    return false;
  }

  getPropName(ctx, path) {
    let i = path.length-1;
    while (i >= 0 && path[i] !== ".") {
      i--;
    }

    path = path.slice(i+1, path.length).trim();

    if (path.endsWith("]")) {
      i = path.length - 1;
      while (i >= 0 && path[i] !== "[") {
        i--;
      }

      path = path.slice(0, i).trim();

      return this.getPropName(ctx, path);
    }

    return path;
  }

  getValue(ctx, path, rootStruct=undefined) {
    if (typeof ctx == "string") {
      throw new Error("You forgot to pass context to getValue");
    }

    let ret = this.resolvePath(ctx, path, undefined, rootStruct);

    if (ret === undefined) {
      throw new DataPathError("invalid path " + path);
    }

    let exec = ret.prop !== undefined && (ret.prop.flag & PropFlags.USE_CUSTOM_GETSET);

    //resolvePath handles the case of vector properties with custom callbacks for us
    //(and possibly all the other cases too, need to check)
    exec = exec && !(ret.prop !== undefined && (ret.prop.type & (PropTypes.VEC2|PropTypes.VEC3|PropTypes.VEC4|PropTypes.QUAT)));

    if (exec) {
      ret.prop.dataref = ret.obj;
      ret.prop.datapath = path;
      ret.prop.ctx = ctx;

      let val = ret.prop.getValue();

      if (typeof val === "string" && (ret.prop.type & (PropTypes.FLAG|PropTypes.ENUM))) {
        val = ret.prop.values[val];
      }

      if (ret.subkey && ret.prop.type === PropTypes.ENUM) {
        val = val === ret.prop.values[ret.subkey];
      } else if (ret.subkey && ret.prop.type === PropTypes.FLAG) {
        val = val & ret.prop.values[ret.subkey];
      }

      return val;

    }

    return ret.value;
  }
}

class DataPathSetOp extends ToolOp {
  constructor() {
    super();

    this.propType = -1;
    this._undo = undefined;
  }

  setValue(ctx, val, object) {
    let prop = this.inputs.prop;
    let path = this.inputs.dataPath.getValue();

    if (prop.type & (PropTypes.ENUM | PropTypes.FLAG)) {
      let rdef = ctx.api.resolvePath(ctx, path);
      if (rdef.subkey !== undefined) {
        let subkey = rdef.subkey;
        if (typeof subkey === "string") {
          subkey = rdef.prop.values[subkey];
        }

        this.inputs.flagBit.setValue(subkey);
        this.inputs.useFlagBit.setValue(true);
      }

      //if (rdef.subkey !== undefined) {
      //  val = rdef.value;
      //val = !!val;
      //}
    }

    prop.dataref = object;
    prop.ctx = ctx;
    prop.datapath = path;

    try {
      prop.setValue(val);
      this.hadError = false;
    } catch (error) {
      console.error("Error setting datapath", path);
      this.hadError = true;
    }
  }

  static create(ctx, datapath, value, id, massSetPath) {
    let rdef = ctx.api.resolvePath(ctx, datapath);

    if (rdef === undefined || rdef.prop === undefined) {
      console.warn("DataPathSetOp failed", rdef, rdef.prop);
      return;
    }

    let prop = rdef.prop;
    let tool = new DataPathSetOp();

    tool.propType = prop.type;
    tool.inputs.destType.setValue(prop.type);

    if (prop && (prop.flag & PropFlags.USE_BASE_UNDO)) {
      tool.inputs.fullSaveUndo.setValue(true);
    }

    let mask = PropTypes.FLAG | PropTypes.ENUM;
    mask |= PropTypes.VEC2 | PropTypes.VEC3 | PropTypes.VEC4 | PropTypes.QUAT;

    if (rdef.subkey !== undefined && (prop.type & mask)) {
      if (prop.type & (PropTypes.ENUM | PropTypes.FLAG)) {
        let i = datapath.length - 1;

        //chope off enum selector
        while (i >= 0 && datapath[i] !== '[') {
          i--;
        }

        if (i >= 0) {
          datapath = datapath.slice(0, i);
        }

        tool.inputs.prop = new IntProperty();
      } else {
        tool.inputs.prop = new FloatProperty();
      }

      let subkey = rdef.subkey;
      if (typeof subkey !== "number") {
        subkey = rdef.prop.values[subkey];
      }

      if (prop.type === PropTypes.FLAG) {
        tool.inputs.flagBit.setValue(subkey);
        tool.inputs.useFlagBit.setValue(true);
      }

      if (prop.type === PropTypes.ENUM) {
        value = subkey;
      } else if (prop.type === PropTypes.FLAG) {
        let value2 = ctx.api.getValue(ctx, datapath);

        if (typeof value2 !== "number") {
          value2 = typeof value2 === "boolean" ? (value & 1) : 0;
        }

        if (value) {
          value2 |= subkey;
        } else {
          value2 &= ~subkey;
        }

        value = value2;
      }
      //value = rdef.obj[rdef.key];
      //console.log("rdef.value", value);
    } else {
      tool.inputs.prop = prop.copy();
    }

    tool.inputs.dataPath.setValue(datapath);

    if (massSetPath) {
      tool.inputs.massSetPath.setValue(massSetPath);
    } else {
      tool.inputs.massSetPath.setValue("");
    }

    tool.id = id;

    tool.setValue(ctx, value, rdef.obj);

    return tool;
  }

  hash(massSetPath, dataPath, prop, id) {
    massSetPath = massSetPath === undefined ? "" : massSetPath;
    massSetPath = massSetPath === null ? "" : massSetPath;

    let ret = "" + massSetPath + ":" + dataPath + ":" + prop + ":" + id;

    return ret;
  }

  hashThis() {
    return this.hash(this.inputs.massSetPath.getValue(),
      this.inputs.dataPath.getValue(),
      this.propType,
      this.id);
  }

  undoPre(ctx) {
    if (this.inputs.fullSaveUndo.getValue()) {
      return super.undoPre(ctx);
    }

    if (this.__ctx)
      ctx = this.__ctx;

    this._undo = {};

    let paths = new Set();

    if (this.inputs.massSetPath.getValue().trim()) {
      let massSetPath = this.inputs.massSetPath.getValue().trim();

      paths = new Set(ctx.api.resolveMassSetPaths(ctx, massSetPath));

    }

    paths.add(this.inputs.dataPath.getValue());

    for (let path of paths) {
      let val = ctx.api.getValue(ctx, path);

      if (typeof val === "object") {
        val = val.copy();
      }

      this._undo[path] = val;
    }

    /*
    for (let path of paths) {
      let rdef = ctx.api.resolvePath(ctx, path);

      if (rdef === undefined) {
        console.warn("Failed to lookup path in DataPathSetOp.undoPre", path);
        continue;
      }

      let prop = rdef.prop;
      let value = rdef.value;

      if (prop.type & (PropTypes.ENUM|PropTypes.FLAG)) {
        this._undo[path] = rdef.obj[rdef.key];
      } else if (isVecProperty(prop)) {
        if (rdef.subkey) {
          this._undo[path] = rdef.value;
        } else {
          let cls = getVecClass(prop.type);
          this._undo[path] = new cls(rdef.value);
        }
      } else {
        let prop2 = prop.copy();

        prop2.dataref = rdef.obj;
        prop2.datapath = path;
        prop2.ctx = ctx;

        prop2.setValue(value);

        this._undo[path] = prop2.getValue();
      }
    }*/
  }

  undo(ctx) {
    if (this.__ctx)
      ctx = this.__ctx;

    if (this.inputs.fullSaveUndo.getValue()) {
      return super.undo(ctx);
    }

    for (let path in this._undo) {
      let rdef = ctx.api.resolvePath(ctx, path);

      if (rdef.prop !== undefined && (rdef.prop.type & (PropTypes.ENUM | PropTypes.FLAG))) {
        let old = rdef.obj[rdef.key];

        if (rdef.subkey) {
          let key = rdef.subkey;

          if (typeof key !== "number") {
            key = rdef.prop.values[key];
          }

          if (rdef.prop.type === PropTypes.FLAG) {
            if (this._undo[path]) {
              rdef.obj[rdef.key] |= key;
            } else {
              rdef.obj[rdef.key] &= ~key;
            }
          } else {
            rdef.obj[rdef.key] = key;
          }
        } else {
          rdef.obj[rdef.key] = this._undo[path];
        }

        rdef.prop.dataref = rdef.obj;
        rdef.prop.datapath = path;
        rdef.prop.ctx = ctx;

        rdef.prop._fire("change", rdef.obj[rdef.key], old);
      } else {
        try {
          ctx.api.setValue(ctx, path, this._undo[path]);
        } catch (error) {
          print_stack$1(error);
          console.warn("Failed to set property in undo for DataPathSetOp");
        }
      }
    }
  }

  exec(ctx) {
    //use saved ctx we got from modal start
    if (this.__ctx) {
      ctx = this.__ctx;
    }

    let path = this.inputs.dataPath.getValue();
    let massSetPath = this.inputs.massSetPath.getValue().trim();

    try {
      ctx.api.setValue(ctx, path, this.inputs.prop.getValue());
      this.hadError = false;
    } catch (error) {
      console.log(error.stack);
      console.log(error.message);
      console.log("error setting " + path);

      this.hadError = true;
    }

    if (massSetPath) {
      let value = this.inputs.prop.getValue();
      let useFlagBit = this.inputs.useFlagBit.getValue();

      if (useFlagBit && this.inputs.destType.getValue() === PropTypes.FLAG) {
        let bit = this.inputs.flagBit.getValue();

        value = !!(value & bit);
      }
      try {
        ctx.api.massSetProp(ctx, massSetPath, value);
      } catch (error) {
        console.log(error.stack);
        console.log(error.message);
        console.log("error setting " + path);

        this.hadError = true;
      }
    }
  }

  modalStart(ctx) {
    this.__ctx = ctx.toLocked();

    //save full, modal ctx
    super.modalStart(this.__ctx);

    this.exec(this.__ctx);
    this.modalEnd(false);
  }

  static tooldef() {
    return {
      uiname  : "Property Set",
      toolpath: "app.prop_set",
      icon    : -1,
      flag    : ToolFlags.PRIVATE,
      is_modal: true,
      inputs  : {
        dataPath    : new StringProperty(),
        massSetPath : new StringProperty(),
        fullSaveUndo: new BoolProperty(false),
        flagBit     : new IntProperty(),
        useFlagBit  : new BoolProperty(),
        destType    : new EnumProperty(PropTypes.INT, PropTypes),
      }
    }
  }
}

ToolOp.register(DataPathSetOp);

/**

 This is the main datapath controller module, inspired by Blender's RNA system.

 Datapaths are special bindings for objects; they store types (e.g. float, int, enumeration, string),
 as well as lots of UI-specific metadata (like human-readable names, tooltips, icons, numeric ranges, etc).

 Controller bindings are intended to present a more unified and coherent model of the
 application model than may actually exists.  This is inspired by Blender's RNA system, which
 hides almost all of Blender's core data structure complexity (Blender is written in C) from
 users who e.g. write python scripts, extend the UI, use advanced animation features, or anything else
 that uses RNA paths.

 ## Contexts

 The datapath system works in tandem with the context module.  Contexts are client-provided classes
 that the datapath API and ToolOps use to communicate with the application state.

 ## Example

 <pre>

 function initMyDataAPI() {
  let api = new DataAPI();

  //map MyContextClass to a struct, true tells mapStruct to auto-create
  //the struct if it doesn't already exist
  let st = api.mapStruct(MyContextClass, true);

  //set fields of struct, e.g. st.int, st.float, st.enum, st.struct, etc

  //build toolsys api
  buildToolSysAPI(api);

  //create bindings for default tool operator settings
  cstruct.struct("propCache", "toolDefaults", "Tool Defaults", api.mapStruct(ToolPropertyCache));

  return api;
}
 </pre>
 */

let PUTLParseError$1 = PUTLParseError;

let tk = (name, re, func) => new tokdef$1(name, re, func);
let tokens = [
  tk("ID", /[a-zA-Z_$]+[a-zA-Z_$0-9]*/),
  tk("NUM", /-?[0-9]+/, (t) => {
    t.value = parseInt(t.value);
    return t;
  }),
  tk('NUMBER', /-?[0-9]+\.[0-9]*/, (t) => {
    t.value = parseFloat(t.value);
    return t;
  }),
  tk("STRLIT", /'.*?'/, (t) => {
    t.value = t.value.slice(1, t.value.length - 1);
    return t;
  }),
  tk("STRLIT", /".*?"/, (t) => {
    t.value = t.value.slice(1, t.value.length - 1);
    return t;
  }),
  tk("DOT", /\./),
  tk("EQUALS", /(\=)|(\=\=)/),
  tk("LSBRACKET", /\[/),
  tk("RSBRACKET", /\]/),
  tk("AND", /\&/),
  tk("WS", /[ \t\n\r]+/, (t) => undefined) //drok token
];

let lexer$2 = new lexer$1(tokens, (t) => {
  console.warn("Parse error", t);
  throw new DataPathError();
});

let pathParser = new parser$1(lexer$2);

let parserStack = new Array(32);
for (let i = 0; i < parserStack.length; i++) {
  parserStack[i] = pathParser.copy();
}
parserStack.cur = 0;

let tool_classes = ToolClasses;

let tool_idgen = 1;
Symbol.ToolID = Symbol("toolid");

function toolkey(cls) {
  if (!(Symbol.ToolID in cls)) {
    cls[Symbol.ToolID] = tool_idgen++;
  }

  return cls[Symbol.ToolID];
}

let lt = time_ms();
let lastmsg = undefined;
let lcount = 0;

let reportstack = ["api"];

function pushReportName(name) {
  if (reportstack.length > 1024) {
    console.trace("eerk, reportstack overflowed");
    reportstack.length = 0;
    reportstack.push("api");
  }

  reportstack.push(name);
}

function report(msg) {
  let name = reportstack.length === 0 ? "api" : reportstack[reportstack.length - 1];

  console$1.context(name).warn(msg);
}

function popReportName() {
  reportstack.pop();
}


class DataList extends ListIface {
  constructor(callbacks) {
    super();

    if (callbacks === undefined) {
      throw new DataPathError("missing callbacks argument to DataList");
    }

    this.cb = {};

    if (typeof callbacks === "object" && !Array.isArray(callbacks)) {
      for (let k in callbacks) {
        this.cb[k] = callbacks[k];
      }
    } else {
      for (let cb of callbacks) {
        this.cb[cb.name] = cb;
      }
    }

    let check = (key) => {
      if (!(key in this.cbs)) {
        throw new DataPathError(`Missing ${key} callback in DataList`);
      }
    };
  }

  /**
   Generic list API.

   * Callbacks is an array of name functions, like so:
   - function getStruct(api, list, key) //return DataStruct type of object in key, key is optional if omitted return base type of all objects?
   - function get(api, list, key)
   - function set(api, list, key, val) //this one has default behavior: list[key] = val
   - function getLength(api, list)
   - function getActive(api, list)
   - function setActive(api, list, key)
   - function getIter(api, list)
   - function getKey(api, list, object) returns object's key in this list, either a string or a number
   * */

  copy() {
    let ret = new DataList([this.cb.get]);

    for (let k in this.cb) {
      ret.cb[k] = this.cb[k];
    }

    return ret;
  }

  get(api, list, key) {
    return this.cb.get(api, list, key);
  }

  getLength(api, list) {
    this._check("getLength");
    return this.cb.getLength(api, list);
  }

  _check(cb) {
    if (!(cb in this.cb)) {
      throw new DataPathError(cb + " not supported by this list");
    }
  }

  set(api, list, key, val) {
    if (this.cb.set === undefined) {
      list[key] = val;
    } else {
      this.cb.set(api, list, key, val);
    }
  }

  getIter(api, list) {
    this._check("getIter");
    return this.cb.getIter(api, list);
  }

  filter(api, list, bitmask) {
    this._check("filter");
    return this.cb.filter(api, list, bitmask);
  }

  getActive(api, list) {
    this._check("getActive");
    return this.cb.getActive(api, list);
  }

  setActive(api, list, key) {
    this._check("setActive");
    this.cb.setActive(api, list, key);
  }

  getKey(api, list, obj) {
    this._check("getKey");
    return this.cb.getKey(api, list, obj);
  }

  getStruct(api, list, key) {
    if (this.cb.getStruct !== undefined) {
      return this.cb.getStruct(api, list, key);
    }

    let obj = this.get(api, list, key);

    if (obj === undefined)
      return undefined;

    return api.getStruct(obj.constructor);
  }
}

class DataStruct {
  constructor(members = [], name = "unnamed") {
    this.members = [];
    this.name = name;
    this.pathmap = {};
    this.flag = 0;
    this.dpath = undefined; //owning DataPath

    this.inheritFlag = 0;

    for (let m of members) {
      this.add(m);
    }
  }

  copy() {
    let ret = new DataStruct();

    ret.name = this.name;
    ret.flag = this.flag;
    ret.inheritFlag = this.inheritFlag;

    for (let m of this.members) {
      let m2 = m.copy();

      //don't copy struct or list references, just
      //direct properties

      if (m2.type === DataTypes.PROP) {
        m2.data = m2.data.copy();
      }

      ret.add(m2);
    }

    return ret;
  }

  /**
   * Like .struct, but the type of struct is looked up
   * for objects at runtime.  Note that to work correctly each object
   * must create its own struct definition via api.mapStruct
   *
   * @param path
   * @param apiname
   * @param uiname
   * @param default_struct : default struct if one can't be looked up
   * @returns {*}
   */
  dynamicStruct(path, apiname, uiname, default_struct = undefined) {
    let ret = default_struct ? default_struct : new DataStruct();

    let dpath = new DataPath(path, apiname, ret, DataTypes.DYNAMIC_STRUCT);
    ret.inheritFlag |= this.inheritFlag;

    ret.dpath = dpath;

    this.add(dpath);
    return ret;
  }

  struct(path, apiname, uiname, existing_struct = undefined) {
    let ret = existing_struct ? existing_struct : new DataStruct();

    let dpath = new DataPath(path, apiname, ret, DataTypes.STRUCT);
    ret.inheritFlag |= this.inheritFlag;

    ret.dpath = dpath;

    this.add(dpath);
    return ret;
  }

  customGet(getter) {
    this.dpath.customGet(getter);

    return this;
  }

  customGetSet(getter, setter) {
    this.dpath.customGetSet(getter, setter);

    return this;
  }

  color3(path, apiname, uiname, description) {
    let ret = this.vec3(path, apiname, uiname, description);

    ret.data.subtype = PropSubTypes$1.COLOR;
    ret.range(0, 1);
    ret.simpleSlider();

    ret.noUnits();

    return ret;
  }

  color4(path, apiname, uiname, description = uiname) {
    let ret = this.vec4(path, apiname, uiname, description);

    ret.data.subtype = PropSubTypes$1.COLOR;
    ret.range(0, 1);
    ret.simpleSlider();

    ret.noUnits();

    return ret;
  }

  arrayList(path, apiname, structdef, uiname, description) {
    let ret = this.list(path, apiname, [
      function getIter(api, list) {
        return list[Symbol.iterator]();
      },
      function getLength(api, list) {
        return list.length;
      },
      function get(api, list, key) {
        return list[key];
      },
      function set(api, list, key, val) {
        if (typeof key === "string") {
          key = parseInt(key);
        }

        if (key < 0 || key >= list.length) {
          throw new DataPathError("Invalid index " + key);
        }

        list[key] = val;
        window.redraw_viewport();
      },
      function getKey(api, list, obj) {
        return list.indexOf(obj);
      },
      function getStruct(api, list, key) {
        return structdef;
      }]);

    return ret;
  }

  color3List(path, apiname, uiname, description) {
    return this.vectorList(3, path, apiname, uiname, description, PropSubTypes$1.COLOR);
  }

  color4List(path, apiname, uiname, description) {
    return this.vectorList(4, path, apiname, uiname, description, PropSubTypes$1.COLOR);
  }

  vectorList(size, path, apiname, uiname, description, subtype) {
    let type;

    switch (size) {
      case 2:
        type = Vec2Property;
        break;
      case 3:
        type = Vec3Property;
      case 4:
        type = Vec4Property;
    }

    if (type === undefined) {
      throw new DataPathError("Invalid size for vectorList; expected 2 3 or 4");
    }

    let prop = new type(undefined, apiname, uiname, description);

    let pstruct = new DataStruct(undefined, "Vector");
    pstruct.vec3("", "co", "Coords", "Coordinates");

    let ret = this.list(path, apiname, [
      function getIter(api, list) {
        return list[Symbol.iterator]();
      },
      function getLength(api, list) {
        return list.length;
      },
      function get(api, list, key) {
        return list[key];
      },
      function set(api, list, key, val) {
        if (typeof key == "string") {
          key = parseInt(key);
        }

        if (key < 0 || key >= list.length) {
          throw new DataPathError("Invalid index " + key);
        }

        list[key] = val;
        window.redraw_viewport();
      },
      function getKey(api, list, obj) {
        return list.indexOf(obj);
      },
      function getStruct(api, list, key) {
        return pstruct;
      }]);

    return ret;
  }

  bool(path, apiname, uiname, description) {
    let prop = new BoolProperty(undefined, apiname, uiname, description);

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  vec2(path, apiname, uiname, description) {
    let prop = new Vec2Property(undefined, apiname, uiname, description);

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  vec3(path, apiname, uiname, description) {
    let prop = new Vec3Property(undefined, apiname, uiname, description);
    //prop.uiname = uiname;

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  vec4(path, apiname, uiname, description) {
    let prop = new Vec4Property(undefined, apiname, uiname, description);
    //prop.uiname = uiname;

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  float(path, apiname, uiname, description) {
    let prop = new FloatProperty(0, apiname, uiname, description);

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  textblock(path, apiname, uiname, description) {
    let prop = new StringProperty(undefined, apiname, uiname, description);
    prop.multiLine = true;

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  report(path, apiname, uiname, description) {
    let prop = new ReportProperty(undefined, apiname, uiname, description);

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  string(path, apiname, uiname, description) {
    let prop = new StringProperty(undefined, apiname, uiname, description);

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  int(path, apiname, uiname, description, prop = undefined) {
    if (!prop) {
      prop = new IntProperty(0, apiname, uiname, description);
    }

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  curve1d(path, apiname, uiname, description) {
    let prop = new Curve1DProperty(undefined);

    prop.apiname = apiname;
    prop.uiname = uiname;
    prop.description = description;

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  enum(path, apiname, enumdef, uiname, description) {
    let prop;

    if (enumdef instanceof EnumProperty) {
      prop = enumdef;
    } else {
      prop = new EnumProperty(undefined, enumdef, apiname, uiname, description);
    }

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  list(path, apiname, funcs) {
    let array = new DataList(funcs);

    let dpath = new DataPath(path, apiname, array);
    dpath.type = DataTypes.ARRAY;

    this.add(dpath);
    return dpath;
  }

  flags(path, apiname, enumdef, uiname, description) {
    let prop;

    if (enumdef === undefined || !(enumdef instanceof ToolProperty$1)) {
      prop = new FlagProperty(undefined, enumdef, apiname, uiname, description);
    } else {
      prop = enumdef;
    }

    let dpath = new DataPath(path, apiname, prop);
    this.add(dpath);
    return dpath;
  }

  remove(m) {
    if (typeof m === "string") {
      m = this.pathmap[m];
    }

    if (!(m.apiname in this.pathmap)) {
      throw new Error("Member not in struct " + m.apiname);
    }

    delete this.pathmap[m.apiname];
    this.members.remove(m);
  }

  fromToolProp(path, prop, apiname) {
    if (apiname === undefined) {
      apiname = prop.apiname !== undefined && prop.apiname.length > 0 ? prop.apiname : k;
    }

    let dpath = new DataPath(path, apiname, prop);

    this.add(dpath);

    return dpath;
  }

  add(m) {
    if (m.apiname in this.pathmap) {
      if (window.DEBUG.datapaths) {
        console.warn("Overriding existing member '" + m.apiname + "' in datapath struct", this.name);
      }

      this.remove(this.pathmap[m.apiname]);
    }

    m.flag |= this.inheritFlag;

    this.members.push(m);
    m.parent = this;

    this.pathmap[m.apiname] = m;

    return this;
  }
}

let _map_struct_idgen = 1;
let _map_structs = {};

window._debug__map_structs = _map_structs; //global for debugging purposes only

let _dummypath = new DataPath();

let DummyIntProperty = new IntProperty();
const CLS_API_KEY = Symbol("__dp_map_id");

class DataAPI extends ModelInterface {
  constructor() {
    super();

    this.rootContextStruct = undefined;
    this.structs = [];
  }

  get list() {
    return undefined;
  }

  static toolRegistered(cls) {
    return ToolOp.isRegistered(cls);
    //let key = toolkey(cls);
    //return key in tool_classes;
  }

  static registerTool(cls) {
    console.warn("Outdated function simple_controller.DataAPI.registerTool called");

    return ToolOp.register(cls);

    //let key = toolkey(cls);
    //
    //if (!(key in tool_classes)) {
    //  tool_classes[key] = cls;
    //}
  }

  getStructs() {
    return this.structs;
  }

  setRoot(sdef) {
    this.rootContextStruct = sdef;
  }

  hasStruct(cls) {
    return cls.hasOwnProperty(CLS_API_KEY);
  }

  getStruct(cls) {
    return this.mapStruct(cls, false);
  }

  mergeStructs(dest, src) {
    for (let m of src.members) {
      dest.add(m.copy());
    }
  }

  inheritStruct(cls, parent, auto_create_parent = false) {
    let st = this.mapStruct(parent, auto_create_parent);

    if (st === undefined) {
      throw new Error("parent has no struct definition");
    }

    st = st.copy();
    st.name = cls.name;

    this._addClass(cls, st);
    return st;
  }

  /**
   * Look up struct definition for a class.
   *
   * @param cls: the class
   * @param auto_create: If true, automatically create definition if not already existing.
   * @returns {IterableIterator<*>}
   */

  _addClass(cls, dstruct) {
    let key = _map_struct_idgen++;
    cls[CLS_API_KEY] = key;

    this.structs.push(dstruct);

    _map_structs[key] = dstruct;
  }

  mapStruct(cls, auto_create = true, name = cls.name) {
    let key;

    if (!cls.hasOwnProperty(CLS_API_KEY)) {
      key = undefined;
    } else {
      key = cls[CLS_API_KEY];
    }

    if (key === undefined && auto_create) {
      let dstruct = new DataStruct(undefined, name);
      this._addClass(cls, dstruct);
      return dstruct;
    } else if (key === undefined) {
      throw new Error("class does not have a struct definition: " + name);
    }

    return _map_structs[key];
  }

  //used for tagging error messages
  pushReportContext(name) {
    pushReportName(name);
  }

  //used for tagging error messages
  popReportContext() {
    popReportName();
  }

  /*
  massSetProp operate on lists.  The idea is to
  write a filter str inside a data path, e.g.

  ctx.api.massSetProp(ctx, "obj.list[{$.select}].value", 1);


  * */
  massSetProp(ctx, massSetPath, value) {
    for (let path of this.resolveMassSetPaths(ctx, massSetPath)) {
      this.setValue(ctx, path, value);
    }
  }

  resolveMassSetPaths(ctx, massSetPath) {
    if (massSetPath.startsWith("/")) {
      massSetPath = massSetPath.slice(1, massSetPath.length);
    }

    let start = massSetPath.search("{");
    let end = massSetPath.search("}");

    if (start < 0 || end < 0) {
      throw new DataPathError("Invalid mass set datapath: " + massSetPath);
      return;
    }

    let prefix = massSetPath.slice(0, start - 1);
    let filter = massSetPath.slice(start + 1, end);
    let suffix = massSetPath.slice(end + 2, massSetPath.length);

    let rdef = this.resolvePath(ctx, prefix);

    if (!(rdef.prop instanceof DataList)) {
      throw new DataPathError("massSetPath expected a path resolving to a DataList: " + massSetPath);
    }

    let paths = [];

    let list = rdef.prop;
    let api = ctx.api;

    function applyFilter(obj) {
      //console.log(filter, obj, obj.constructor.name);

      if (obj === undefined) {
        return undefined;
      } else if (typeof obj === "object" || typeof obj === "function") {
        let st = api.mapStruct(obj.constructor, false);

        let path = filter;
        if (path.startsWith("$")) {
          path = path.slice(1, filter.length).trim();
        }
        if (path.startsWith(".")) {
          path = path.slice(1, filter.length).trim();
        }

        try {
          return api.getValue(obj, path, st);
        } catch (error) {
          if (!(error instanceof DataPathError)) {
            print_stack$1(error);
            console.error("Error in datapath callback");
          }

          return false;
        }
      } else {
        let $ = obj;
        return eval(filter);
      }
    }

    for (let obj of list.getIter(this, rdef.value)) {
      if (!applyFilter(obj)) {
        continue;
      }

      let key = "" + list.getKey(this, rdef.value, obj);
      let path = `${prefix}[${key}]${suffix}`;

      /* validate the final path */
      try {
        this.getValue(ctx, path);
      } catch (error) {
        if (!(error instanceof DataPathError)) {
          print_stack$1(error);
          console.error(path + ": Error in datapath API");
        }

        continue;
      }

      paths.push(path);
    }

    return paths;
  }

  resolvePath(ctx, inpath, ignoreExistence = false, dstruct = undefined) {
    let parser = parserStack[parserStack.cur++];
    let ret = undefined;

    if (inpath[0] === "/") {
      inpath = inpath.slice(1, inpath.length).trim();
    }

    try {
      ret = this.resolvePath_intern(ctx, inpath, ignoreExistence, parser, dstruct);
    } catch (error) {
      //throw new DataPathError("bad path " + path);
      if (!(error instanceof DataPathError)) {
        print_stack$1(error);
        report("error while evaluating path " + inpath);
      }

      if (window.DEBUG && window.DEBUG.datapaths) {
        print_stack$1(error);
      }

      ret = undefined;
    }

    parserStack.cur--;

    if (ret !== undefined && ret.prop && ret.dpath && (ret.dpath.flag & DataFlags.USE_CUSTOM_PROP_GETTER)) {
      let prop = ret.prop;

      prop.ctx = ctx;
      prop.datapath = inpath;
      prop.dataref = ret.obj;

      let newprop = getTempProp(prop.type);
      prop.copyTo(newprop);

      ret.dpath.propGetter.call(prop, newprop);
      ret.prop = newprop;

      prop.ctx = prop.datapath = prop.dataref = undefined;
    }

    if (ret !== undefined && ret.prop && ret.dpath && ret.dpath.ui_name_get) {
      let dummy = {
        datactx : ctx,
        datapath: inpath,
        dataref : ret.obj
      };

      let name = ret.dpath.ui_name_get.call(dummy);

      ret.prop.uiname = "" + name;
    }

    return ret;
  }

  /**
   get meta information for a datapath.

   @param ignoreExistence: don't try to get actual data associated with path,
   just want meta information
   */
  resolvePath_intern(ctx, inpath, ignoreExistence = false, p = pathParser, dstruct = undefined) {
    inpath = inpath.replace("==", "=");

    p.input(inpath);

    dstruct = dstruct || this.rootContextStruct;

    let obj = ctx;
    let lastobj = ctx;
    let subkey;
    let lastobj2 = undefined;
    let lastkey = undefined;
    let prop = undefined;
    let lastdpath = undefined;

    function p_key() {
      let t = p.peeknext();
      if (t.type === "NUM" || t.type === "STRLIT") {
        p.next();
        return t.value;
      } else {
        throw new PUTLParseError$1("Expected list key");
      }
    }

    let _i = 0;
    while (!p.at_end()) {
      let key = p.expect("ID");
      let dpath = dstruct.pathmap[key];

      lastdpath = dpath;

      if (dpath === undefined) {
        if (key === "length" && prop !== undefined && prop instanceof DataList) {
          prop.getLength(this, obj);
          key = "length";

          prop = DummyIntProperty;

          prop.name = "length";
          prop.flag = PropFlags.READ_ONLY;

          dpath = _dummypath;
          dpath.type = DataTypes.PROP;
          dpath.data = prop;
          dpath.struct = dpath.parent = dstruct;
          dpath.flag = DataFlags.READ_ONLY;
          dpath.path = "length";

          /*
          parent: lastobj2,
            obj: lastobj,
            value: obj,
            key: lastkey,
            //*/
        } else if (key === "active" && prop !== undefined && prop instanceof DataList) {
          let act = prop.getActive(this, obj);

          if (act === undefined && !ignoreExistence) {
            throw new DataPathError("no active elem ent for list");
          }

          let actkey = obj !== undefined && act !== undefined ? prop.getKey(this, obj, act) : undefined;

          dstruct = prop.getStruct(this, obj, actkey);
          if (dstruct === undefined) {
            throw new DataPathError("couldn't get data type for " + inpath + "'s element '" + key + "'");
          }

          _dummypath.parent = dpath;
          dpath = _dummypath;

          lastobj = obj;
          obj = act;

          dpath.type = DataTypes.STRUCT;
          dpath.data = dstruct;
          dpath.path = key;

          p.optional("DOT");

          continue;
        } else {
          throw new DataPathError(inpath + ": unknown property " + key);
        }
      }

      let dynstructobj = undefined;

      if (dpath.type === DataTypes.STRUCT) {
        dstruct = dpath.data;
      } else if (dpath.type === DataTypes.DYNAMIC_STRUCT) {
        let ok = false;

        if (obj !== undefined) {
          let obj2;

          if (dpath.flag & DataFlags.USE_CUSTOM_GETSET) {
            let fakeprop = dpath.getSet;
            fakeprop.ctx = ctx;
            fakeprop.dataref = obj;
            fakeprop.datapath = inpath;

            obj2 = fakeprop.get();

            fakeprop.ctx = fakeprop.datapath = fakeprop.dataref = undefined;
          } else {
            obj2 = obj[dpath.path];
          }

          dynstructobj = obj2;

          if (obj2 !== undefined) {
            dstruct = this.mapStruct(obj2.constructor, false);
          } else {
            dstruct = dpath.data;
          }

          if (dstruct === undefined) {
            dstruct = dpath.data;
          }

          ok = dstruct !== undefined;
        }

        if (!ok) {
          throw new DataPathError("dynamic struct error for path: " + inpath);
        }
      } else {
        prop = dpath.data;
      }

      if (dpath.path.search(/\./) >= 0) {
        let keys = dpath.path.split(/\./);

        for (let key of keys) {
          lastobj2 = lastobj;
          lastobj = obj;
          lastkey = key;

          if (obj === undefined && !ignoreExistence) {
            throw new DataPathError("no data for " + inpath);
          } else if (obj !== undefined) {
            obj = obj[key.trim()];
          }
        }
      } else {
        lastobj2 = lastobj;
        lastobj = obj;

        lastkey = dpath.path;

        if (dpath.flag & DataFlags.USE_CUSTOM_GETSET) {
          let fakeprop = dpath.getSet;

          if (!fakeprop && dpath.type === DataTypes.PROP) {
            let prop = dpath.data;

            prop.ctx = ctx;
            prop.dataref = obj;
            prop.datapath = inpath;

            try {
              obj = prop.getValue();
            } catch (error) {
              print_stack$1(error);
              obj = undefined;
            }

            if (typeof obj === "string" && (prop.type & (PropTypes.ENUM | PropTypes.FLAG))) {
              obj = prop.values[obj];
            }

            prop.ctx = prop.dataref = prop.datapath = undefined;
          } else {
            fakeprop.ctx = ctx;
            fakeprop.dataref = obj;
            fakeprop.datapath = inpath;

            obj = fakeprop.get();
            fakeprop.ctx = fakeprop.datapath = fakeprop.dataref = undefined;
          }
        } else if (obj === undefined && !ignoreExistence) {
          throw new DataPathError("no data for " + inpath);
        } else if (dpath.type === DataTypes.DYNAMIC_STRUCT) {
          obj = dynstructobj;
        } else if (obj !== undefined && dpath.path !== "") {
          obj = obj[dpath.path];
        }
      }

      let t = p.peeknext();
      if (t === undefined) {
        break;
      }

      if (t.type === "DOT") {
        p.next();
      } else if (t.type === "EQUALS" && prop !== undefined && (prop.type & (PropTypes.ENUM | PropTypes.FLAG))) {
        p.expect("EQUALS");

        let t2 = p.peeknext();
        let type = t2 && t2.type === "ID" ? "ID" : "NUM";

        let val = p.expect(type);

        let val1 = val;

        if (typeof val == "string") {
          val = prop.values[val];
        }

        if (val === undefined) {
          throw new DataPathError("unknown value " + val1);
        }

        if (val in prop.keys) {
          subkey = prop.keys[val];
        }

        key = dpath.path;
        obj = !!(lastobj[key] == val);
      } else if (t.type === "AND" && prop !== undefined && (prop.type & (PropTypes.ENUM | PropTypes.FLAG))) {
        p.expect("AND");

        let t2 = p.peeknext();
        let type = t2 && t2.type === "ID" ? "ID" : "NUM";

        let val = p.expect(type);

        let val1 = val;

        if (typeof val == "string") {
          val = prop.values[val];
        }

        if (val === undefined) {
          throw new DataPathError("unknown value " + val1);
        }

        if (val in prop.keys) {
          subkey = prop.keys[val];
        }

        key = dpath.path;
        obj = !!(lastobj[key] & val);
      } else if (t.type === "LSBRACKET" && prop !== undefined && (prop.type & (PropTypes.ENUM | PropTypes.FLAG))) {
        p.expect("LSBRACKET");

        let t2 = p.peeknext();
        let type = t2 && t2.type === "ID" ? "ID" : "NUM";

        let val = p.expect(type);

        let val1 = val;

        if (typeof val == "string") {
          val = prop.values[val];
        }

        if (val === undefined) {
          console.warn(inpath, prop.values, val1, prop);
          throw new DataPathError("unknown value " + val1);
        }

        if (val in prop.keys) {
          subkey = prop.keys[val];
        }

        let bitfield;
        key = dpath.path;

        if (!(prop.flag & PropFlags.USE_CUSTOM_GETSET)) {
          bitfield = lastobj ? lastobj[key] : 0;
        } else {
          prop.dataref = lastobj;
          prop.datapath = inpath;
          prop.ctx = ctx;

          try {
            bitfield = prop.getValue();
          } catch (error) {
            print_stack$1(error);

            bitfield = NaN;
          }
        }

        if (lastobj === undefined && !ignoreExistence) {
          throw new DataPathError("no data for path " + inpath);
        } else if (lastobj !== undefined) {
          if (prop.type === PropTypes.ENUM) {
            obj = !!(bitfield === val);
          } else {
            obj = !!(bitfield & val);
          }
        }

        p.expect("RSBRACKET");
      } else if (t.type === "LSBRACKET" && prop !== undefined && isVecProperty(prop)) {
        p.expect("LSBRACKET");
        let num = p.expect("NUM");
        p.expect("RSBRACKET");

        subkey = num;

        if (prop !== undefined && !(prop.type & (PropTypes.VEC2 | PropTypes.VEC3 | PropTypes.VEC4 | PropTypes.QUAT))) {
          lastobj = obj;
        }

        obj = obj[num];
      } else if (t.type === "LSBRACKET") {
        p.expect("LSBRACKET");

        if (lastobj && lastkey && typeof lastkey === "string" && lastkey.length > 0) {
          lastobj = lastobj[lastkey];
        }

        lastkey = p_key();
        p.expect("RSBRACKET");

        if (!(prop instanceof DataList)) {
          throw new DataPathError("bad property, not a list");
        }

        obj = prop.get(this, lastobj, lastkey);
        dstruct = prop.getStruct(this, lastobj, lastkey);

        if (!dstruct) {
          throw new DataPathError(inpath + ": list has no entry " + lastkey);
        }

        if (p.peeknext() !== undefined && p.peeknext().type === "DOT") {
          p.next();
        }
      }

      if (_i++ > 1000) {
        console.warn("infinite loop in resolvePath parser");
        break;
      }
    }

    return {
      dpath  : lastdpath,
      parent : lastobj2,
      obj    : lastobj,
      value  : obj,
      key    : lastkey,
      dstruct: dstruct,
      prop   : prop,
      subkey : subkey
    };
  }

  resolvePathOld2(ctx, path) {
    let splitchars = new Set([".", "[", "]", "=", "&"]);
    let subkey = undefined;

    path = path.replace(/\=\=/g, "=");

    path = "." + this.prefix + path;

    let p = [""];
    for (let i = 0; i < path.length; i++) {
      let s = path[i];

      if (splitchars.has(s)) {
        if (s !== "]") {
          p.push(s);
        }

        p.push("");
        continue;
      }

      p[p.length - 1] += s;
    }

    for (let i = 0; i < p.length; i++) {
      p[i] = p[i].trim();

      if (p[i].length === 0) {
        p.remove(p[i]);
        i--;
      }

      let c = parseInt(p[i]);
      if (!isNaN(c)) {
        p[i] = c;
      }
    }

    let i = 0;

    let parent1, obj = ctx, parent2;
    let key = undefined;
    let dstruct = undefined;
    let arg = undefined;
    let type = "normal";
    let retpath = p;
    let prop;
    let lastkey = key, a;
    let apiname = key;

    while (i < p.length - 1) {
      lastkey = key;
      apiname = key;

      if (dstruct !== undefined && dstruct.pathmap[lastkey]) {
        let dpath = dstruct.pathmap[lastkey];

        apiname = dpath.apiname;
      }

      let a = p[i];
      let b = p[i + 1];

      //check for enum/flag propertys with [] form
      if (a === "[") {
        let ok = false;

        key = b;
        prop = undefined;

        if (dstruct !== undefined && dstruct.pathmap[lastkey]) {
          let dpath = dstruct.pathmap[lastkey];

          if (dpath.type === DataTypes.PROP) {
            prop = dpath.data;
          }
        }

        if (prop !== undefined && (prop.type === PropTypes.ENUM || prop.type === PropTypes.FLAG)) {
          console$1.context("api").log("found flag/enum property");
          ok = true;
        }

        if (ok) {
          if (isNaN(parseInt(key))) {
            key = prop.values[key];
          } else if (typeof key == "int") {
            key = parseInt(key);
          }

          let value = obj;
          if (typeof value == "string") {
            value = prop.values[key];
          }

          if (prop.type === PropTypes.ENUM) {
            value = !!(value == key);
          } else { //flag
            value = !!(value & key);
          }

          if (key in prop.keys) {
            subkey = prop.keys[key];
          }

          obj = value;
          i++;
          continue;
        }
      }

      if (dstruct !== undefined && dstruct.pathmap[lastkey]) {
        let dpath = dstruct.pathmap[lastkey];

        if (dpath.type == DataTypes.PROP) {
          prop = dpath.data;
        }
      }

      if (a === "." || a === "[") {
        key = b;

        parent2 = parent1;
        parent1 = obj;
        obj = obj[b];

        if (obj === undefined || obj === null) {
          break;
        }

        if (typeof obj == "object") {
          dstruct = this.mapStruct(obj.constructor, false);
        }

        i += 2;
        continue;
      } else if (a === "&") {
        obj &= b;
        arg = b;

        if (b in prop.keys) {
          subkey = prop.keys[b];
        }

        i += 2;
        type = "flag";
        continue;
      } else if (a === "=") {
        obj = obj == b;
        arg = b;

        if (b in prop.keys) {
          subkey = prop.keys[b];
        }

        i += 2;
        type = "enum";
        continue;
      } else {
        throw new DataPathError("bad path " + path);
      }

      i++;
    }

    if (lastkey !== undefined && dstruct !== undefined && dstruct.pathmap[lastkey]) {
      let dpath = dstruct.pathmap[key];

      apiname = dpath.apiname;
    }


    if (dstruct !== undefined && dstruct.pathmap[key]) {
      let dpath = dstruct.pathmap[key];

      if (dpath.type == DataTypes.PROP) {
        prop = dpath.data;
      }
    }

    return {
      parent : parent2,
      obj    : parent1,
      value  : obj,
      key    : key,
      dstruct: dstruct,
      subkey : subkey,
      prop   : prop,
      arg    : arg,
      type   : type,
      _path  : retpath
    };
  }

  /*returns {
    obj : [object owning property key]
    parent : [parent of obj]
    key : [property key]
    value : [value of property]
    prop : [optional toolprop.ToolProperty representing the property definition]
    struct : [optional datastruct representing the type, if value is an object]
  }
  */
  resolvePathold(ctx, path) {
    path = this.prefix + path;
    path = path.replace(/\[/g, ".").replace(/\]/g, "").trim().split(".");

    let parent1, obj = ctx, parent2;
    let key = undefined;
    let dstruct = undefined;

    for (let c of path) {
      let c2 = parseInt(c);
      if (!isNaN(c2)) {
        c = c2;
      }

      parent2 = parent1;
      parent1 = obj;
      key = c;

      if (typeof obj == "number") {
        //bitmask test
        obj = obj & c;
        break;
      }

      obj = obj[c];

      if (typeof obj == "object") {
        dstruct = this.mapStruct(obj.constructor, false);
      }
    }

    let prop;

    if (dstruct !== undefined && dstruct.pathmap[key]) {
      let dpath = dstruct.pathmap[key];

      if (dpath.type == DataTypes.PROP) {
        prop = dpath.data;
      }
    }

    return {
      parent : parent2,
      obj    : parent1,
      value  : obj,
      key    : key,
      dstruct: dstruct,
      prop   : prop
    };
  }

  _stripToolUIName(path, uiNameOut = undefined) {
    if (path.search(/\|/) >= 0) {
      if (uiNameOut) {
        uiNameOut[0] = path.slice(path.search(/\|/) + 1, path.length).trim();
      }
      path = path.slice(0, path.search(/\|/)).trim();
    }

    return path.trim();
  }

  getToolDef(path) {
    let uiname = [undefined];

    path = this._stripToolUIName(path, uiname);
    uiname = uiname[0];

    let cls = this.parseToolPath(path);
    if (cls === undefined) {
      throw new DataPathError("unknown path \"" + path + "\"");
    }

    let def = cls.tooldef();
    if (uiname) {
      def.uiname = uiname;
    }

    return def;
  }

  getToolPathHotkey(ctx, path) {
    path = this._stripToolUIName(path);

    try {
      return this.getToolPathHotkey_intern(ctx, path);
    } catch (error) {
      print_stack$1(error);
      console$1.context("api").log("failed to fetch tool path: " + path);

      return undefined;
    }
  }

  getToolPathHotkey_intern(ctx, path) {
    let screen = ctx.screen;
    let this2 = this;

    function searchKeymap(keymap) {
      if (keymap === undefined) {
        return undefined;
      }

      for (let hk of keymap) {
        if (typeof hk.action !== "string") {
          continue;
        }

        let tool = this2._stripToolUIName(hk.action);
        if (tool === path) {
          return hk.buildString();
        }
      }
    }

    if (screen.sareas.length === 0) {
      return searchKeymap(screen.keymap);
    }

    //client might have its own area subclass with
    //getActiveArea defined (that's encouraged),
    //which is why we don't just call Area.getActiveArea
    let areacls = screen.sareas[0].area.constructor;
    let area = areacls.getActiveArea();

    if (area) {
      for (let keymap of area.getKeyMaps()) {
        let ret = searchKeymap(keymap);

        if (ret !== undefined) {
          return ret;
        }
      }
    }

    //search all other areas
    for (let sarea of screen.sareas) {
      if (!sarea.area) continue;

      for (let keymap of sarea.area.getKeyMaps()) {
        let ret = searchKeymap(keymap);

        if (ret) {
          return ret;
        }
      }
    }

    return this.keymap ? searchKeymap(this.keymap) : false;
  }

  parseToolPath(path) {
    try {
      return parseToolPath(path).toolclass;
    } catch (error) {
      if (error instanceof DataPathError) {
        console.warn("warning, bad tool path " + path);
        return undefined;
      } else {
        throw error;
      }
    }
  }

  parseToolArgs(path) {
    return parseToolPath(path).args;
  }

  createTool(ctx, path, inputs = {}) {
    let cls;
    let args;

    if (typeof path == "string" || path instanceof String) {
      //parseToolPath will raise DataPathError if path is malformed
      let tpath = parseToolPath(path);

      cls = tpath.toolclass;
      args = tpath.args;
    } else {
      cls = path;
      args = {};
    }

    if (!cls) {
      debugger;
      console.error("Unknown tool " + path);
    }

    let tool = cls.invoke(ctx, args);

    if (inputs !== undefined) {
      for (let k in inputs) {
        if (!(k in tool.inputs)) {
          console.warn(cls.tooldef().uiname + ": Unknown tool property \"" + k + "\"");
          continue;
        }

        tool.inputs[k].setValue(inputs[k]);
      }
    }

    return tool;
  }
}

function initSimpleController() {
  initToolPaths();
}

let dpt = DataPathSetOp;

function getDataPathToolOp() {
  return dpt;
}

function setDataPathToolOp(cls) {
  ToolOp.unregister(DataPathSetOp);

  if (!ToolOp.isRegistered(cls)) {
    ToolOp.register(cls);
  }

  dpt = cls;
}

setImplementationClass(DataAPI);

let rgb_to_hsv_rets = new cachering$1(() => [0, 0, 0], 64);

function rgb_to_hsv(r, g, b) {
  let computedH = 0;
  let computedS = 0;
  let computedV = 0;

  if (r == null || g == null || b == null ||
    isNaN(r) || isNaN(g) || isNaN(b)) {
    throw new Error(`Please enter numeric RGB values! r: ${r} g: ${g} b: ${b}`);
  }
  /*
  if (r<0 || g<0 || b<0 || r>1.0 || g>1.0 || b>1.0) {
   throw new Error('RGB values must be in the range 0 to 1.0');
   return;
  }//*/

  let minRGB = Math.min(r, Math.min(g, b));
  let maxRGB = Math.max(r, Math.max(g, b));

  // Black-gray-white
  if (minRGB === maxRGB) {
    computedV = minRGB;

    let ret = rgb_to_hsv_rets.next();
    ret[0] = 0, ret[1] = 0, ret[2] = computedV;
    return ret;
  }

  // Colors other than black-gray-white:
  let d = (r === minRGB) ? g - b : ((b === minRGB) ? r - g : b - r);
  let h = (r === minRGB) ? 3 : ((b === minRGB) ? 1 : 5);

  computedH = (60*(h - d/(maxRGB - minRGB)))/360.0;
  computedS = (maxRGB - minRGB)/maxRGB;
  computedV = maxRGB;

  let ret = rgb_to_hsv_rets.next();
  ret[0] = computedH, ret[1] = computedS, ret[2] = computedV;
  return ret;
}

let hsv_to_rgb_rets = new cachering$1(() => [0, 0, 0], 64);

function hsv_to_rgb(h, s, v) {
  let c = 0, m = 0, x = 0;
  let ret = hsv_to_rgb_rets.next();

  ret[0] = ret[1] = ret[2] = 0.0;
  h *= 360.0;

  c = v*s;
  x = c*(1.0 - Math.abs(((h/60.0)%2) - 1.0));
  m = v - c;
  let color;

  function RgbF_Create(r, g, b) {
    ret[0] = r;
    ret[1] = g;
    ret[2] = b;

    return ret;
  }

  if (h >= 0.0 && h < 60.0) {
    color = RgbF_Create(c + m, x + m, m);
  } else if (h >= 60.0 && h < 120.0) {
    color = RgbF_Create(x + m, c + m, m);
  } else if (h >= 120.0 && h < 180.0) {
    color = RgbF_Create(m, c + m, x + m);
  } else if (h >= 180.0 && h < 240.0) {
    color = RgbF_Create(m, x + m, c + m);
  } else if (h >= 240.0 && h < 300.0) {
    color = RgbF_Create(x + m, m, c + m);
  } else if (h >= 300.0) {
    color = RgbF_Create(c + m, m, x + m);
  } else {
    color = RgbF_Create(m, m, m);
  }

  return color;
}

let rgb_to_cmyk_rets = cachering$1.fromConstructor(Vector4, 512);
let cmyk_to_rgb_rets = cachering$1.fromConstructor(Vector3, 512);

function cmyk_to_rgb(c, m, y, k) {
  let ret = cmyk_to_rgb_rets.next();

  if (k === 1.0) {
    ret.zero();
    return ret;
  }

  c = c - c*k + k;
  m = m - m*k + k;
  y = y - y*k + k;

  ret[0] = 1.0 - c;
  ret[1] = 1.0 - m;
  ret[2] = 1.0 - y;

  return ret;
}

function rgb_to_cmyk(r, g, b) {
  //CMYK and CMY values from 0 to 1
  let ret = rgb_to_cmyk_rets.next();

  let C = 1.0 - r;
  let M = 1.0 - g;
  let Y = 1.0 - b;

  let var_K = 1;

  if (C < var_K) var_K = C;
  if (M < var_K) var_K = M;
  if (Y < var_K) var_K = Y;
  if (var_K === 1) { //Black
    C = 0;
    M = 0;
    Y = 0;
  } else {
    C = (C - var_K)/(1 - var_K);
    M = (M - var_K)/(1 - var_K);
    Y = (Y - var_K)/(1 - var_K);
  }

  let K = var_K;

  ret[0] = C;
  ret[1] = M;
  ret[2] = Y;
  ret[3] = K;

  return ret;
}

const DefaultTheme = {
  base: {
    AreaHeaderBG        : 'rgba(200, 200, 200, 0.95)',
    BasePackFlag        : 0,
    BoxDepressed        : 'rgba(130,130,130, 1)',
    BoxHighlight        : 'rgba(151,208,239, 1)',
    "flex-grow"         : "unset",
    DefaultText         : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 14,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
    LabelText           : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 14,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
    TitleText           : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 12,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
    'background-color'  : 'rgba(207,207,207, 0.5)',
    'border-color'      : 'rgba(34,34,34, 1)',
    'border-radius'     : 12.010619764585666,
    'focus-border-width': 2,
    oneAxisPadding      : 2,
    padding             : 1,
  },

  button: {
    DefaultText        : new CSSFont({
      font   : 'poppins',
      weight : 'bold',
      variant: 'normal',
      style  : 'normal',
      size   : 12,
      color  : 'rgba(35,35,35, 1)'
    }),
    'background-color' : 'rgba(238,238,238, 0.8672412740773168)',
    'border-color'     : 'rgba(255,255,255, 1)',
    'border-radius'    : 4,
    'border-style'     : 'solid',
    'border-width'     : 2,
    disabled           : {
      DefaultText       : new CSSFont({
        font   : 'poppins',
        weight : 'bold',
        variant: 'normal',
        style  : 'normal',
        size   : 12,
        color  : 'rgb(109,109,109)'
      }),
      'background-color': 'rgb(19,19,19)',
      'border-color'    : '#f58f8f',
      'border-style'    : 'solid',
      'border-width'    : 1,
    },
    height             : 25,
    highlight          : {
      DefaultText       : new CSSFont({
        font   : 'poppins',
        weight : 'bold',
        variant: 'normal',
        style  : 'normal',
        size   : 12,
        color  : 'rgba(255,255,255, 1)'
      }),
      'background-color': 'rgba(138,222,255, 1)',
      'border-color'    : 'rgba(255,255,255, 1)',
      'border-radius'   : 4,
      'border-style'    : 'solid',
      'border-width'    : 2,
    },
    'highlight-pressed': {
      DefaultText       : new CSSFont({
        font   : 'poppins',
        weight : 'bold',
        variant: 'normal',
        style  : 'normal',
        size   : 12,
        color  : 'rgba(35,35,35, 1)'
      }),
      'background-color': 'rgba(113,113,113, 1)',
      'border-color'    : '#DADCE0',
      'border-style'    : 'solid',
      'border-width'    : 1,
    },
    margin             : 4,
    'margin-left'      : 4,
    'margin-right'     : 4,
    padding            : 1,
    pressed            : {
      DefaultText       : new CSSFont({
        font   : 'poppins',
        weight : 'bold',
        variant: 'normal',
        style  : 'normal',
        size   : 12,
        color  : 'rgba(35,35,35, 1)'
      }),
      'background-color': 'rgba(113,113,113, 1)',
      'border-color'    : '#DADCE0',
      'border-style'    : 'solid',
      'border-width'    : 1,
    },
    width              : 25,
  },

  checkbox: {
    CheckSide: 'left',
    height   : 32,
    width    : 32,
  },

  colorfield: {
    circleSize    : 11,
    colorBoxHeight: 24,
    fieldSize     : 400,
    height        : 256,
    hueHeight     : 32,
    width         : 256,
  },

  colorpickerbutton: {
    height: 32,
    width : 95,
  },

  curvewidget: {
    CanvasBG    : 'rgb(44,44,44)',
    CanvasHeight: 256,
    CanvasWidth : 256,
  },

  dropbox: {
    dropTextBG: 'rgba(233,233,233, 1)',
    height    : 25,
    width     : 32,
  },

  iconbutton: {
    highlight: {
      'background-color': 'rgba(133,182,255,0.8)',
      'border-color'    : 'black',
      'border-radius'   : 5,
      'border-width'    : 1,
      height            : 32,
      'margin-bottom'   : 1,
      'margin-left'     : 2,
      'margin-right'    : 2,
      'margin-top'      : 1,
      padding           : 2,
      width             : 32,
    },
    depressed: {
      'background-color': 'rgba(42,61,77,0.8)',
      'border-color'    : 'black',
      'border-radius'   : 5,
      'border-width'    : 1,
      height            : 32,
      'margin-bottom'   : 1,
      'margin-left'     : 2,
      'margin-right'    : 2,
      'margin-top'      : 1,
      padding           : 2,
      width             : 32,
    },

    'background-color': 'rgba(15,15,15, 0)',
    'border-color'    : 'black',
    'border-radius'   : 5,
    'border-width'    : 1,
    height            : 32,
    'margin-bottom'   : 1,
    'margin-left'     : 2,
    'margin-right'    : 2,
    'margin-top'      : 1,
    padding           : 2,
    width             : 32,
  },

  iconcheck: {
    highlight         : {
      'background-color': 'rgba(133,182,255,0.8)',
      'border-color'    : 'black',
      'border-radius'   : 5,
      'border-width'    : 1,
      height            : 32,
      'margin-bottom'   : 1,
      'margin-left'     : 2,
      'margin-right'    : 2,
      'margin-top'      : 1,
      padding           : 2,
      width             : 32,
    },
    depressed         : {
      'background-color': 'rgba(42,61,77,0.8)',
      'border-color'    : 'black',
      'border-radius'   : 5,
      'border-width'    : 1,
      height            : 32,
      'margin-bottom'   : 1,
      'margin-left'     : 2,
      'margin-right'    : 2,
      'margin-top'      : 1,
      padding           : 2,
      width             : 32,
    },
    'background-color': 'rgba(15,15,15, 0)',
    'border-color'    : 'rgba(237,209,209, 1)',
    'border-radius'   : 5,
    'border-width'    : 0,
    drawCheck         : true,
    height            : 32,
    'margin-bottom'   : 1,
    'margin-left'     : 2,
    'margin-right'    : 2,
    'margin-top'      : 1,
    padding           : 2,
    width             : 32,
  },

  label: {
    LabelText: new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 14,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
  },

  listbox: {
    ListActive   : 'rgba(200, 205, 215, 1.0)',
    ListHighlight: 'rgba(155, 220, 255, 0.5)',
    height       : 200,
    width        : 110,
  },

  menu: {
    MenuBG          : 'rgba(250, 250, 250, 1.0)',
    "item-radius"   : 0,
    MenuBorder      : '1px solid grey',
    MenuHighlight   : 'rgba(155, 220, 255, 1.0)',
    MenuSeparator   : {
      width             : "100%",
      height            : 2,
      padding           : 0,
      margin            : 0,
      border            : "none",
      "background-color": "grey"
    },
    'box-shadow'    : '5px 5px 25px rgba(0,0,0,0.75)',
    MenuSpacing     : 5,
    MenuText        : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 12,
      color  : 'rgba(25, 25, 25, 1.0)'
    }),
    "padding-top"   : 0,
    "padding-left"  : 0,
    "padding-right" : 0,
    "padding-bottom": 0,
    'border-color'  : 'grey',
    'border-radius' : 5,
    'border-style'  : 'solid',
    'border-width'  : 1,
  },

  notification: {
    DefaultText       : new CSSFont({
      font   : 'poppins',
      weight : 'bold',
      variant: 'normal',
      style  : 'normal',
      size   : 12,
      color  : 'rgb(55,55,55)'
    }),
    "background-color": "rgba(72,72,72,0)",
    "border-radius"   : 5,
    "border-color"    : "grey",
    "border-width"    : 1,
    "border-style"    : "solid",
    ProgressBarBG     : "rgb(74,148,183)",
    ProgressBar       : "rgb(250,132,58)",
  },

  numslider: {
    'background-color': 'rgba(219,219,219, 1)',
    'border-color'    : 'black',
    'border-radius'   : 1,
    height            : 18,
    width             : 90,
  },

  numslider_simple: {
    SlideHeight       : 10,
    TextBoxWidth      : 45,
    'background-color': 'rgba(219,219,219, 1)',
    height            : 18,
    labelOnTop        : true,
    width             : 135,
  },

  numslider_textbox: {
    TextBoxHeight     : 25,
    TextBoxWidth      : 50,
    'background-color': 'rgba(219,219,219, 1)',
    height            : 25,
    labelOnTop        : true,
    width             : 120,
  },

  panel: {
    HeaderBorderRadius    : 5.329650280441558,
    HeaderRadius          : 4,
    TitleBackground       : 'rgba(177,219,255, 1)',
    TitleBorder           : 'rgba(104,104,104, 1)',
    TitleText             : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 14,
      color  : 'rgba(0,0,0, 1)'
    }),
    'background-color'    : 'rgba(184,184,184, 0.7594818376068376)',
    'border-color'        : 'rgba(0,0,0, 0.5598061397157866)',
    'border-radius'       : 4,
    'border-style'        : 'groove',
    'border-width'        : 1.141,
    'margin-bottom'       : 0,
    'margin-bottom-closed': 0,
    'margin-left'         : 5.6584810220495445,
    'margin-right'        : 0,
    'margin-top'          : 0,
    'margin-top-closed'   : 0,
    'padding-bottom'      : 0,
    'padding-left'        : 0,
    'padding-right'       : 0,
    'padding-top'         : 0,
  },

  richtext: {
    DefaultText       : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 16,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
    'background-color': 'rgb(245, 245, 245)',
  },

  screenborder: {
    'border-inner'   : 'grey',
    'border-outer'   : 'rgba(228,228,228, 1)',
    'border-width'   : 2,
    'mouse-threshold': 8,
  },

  scrollbars: {
    border  : undefined,
    color   : undefined,
    color2  : undefined,
    contrast: undefined,
    width   : undefined,
  },

  sidebar: {
    'background-color': 'rgba(55, 55, 55, 0.5)',
  },

  strip: {
    'background-color': 'rgba(75,75,75, 0.33213141025641024)',
    'border-color'    : 'rgba(0,0,0, 0.31325409987877156)',
    'border-radius'   : 8.76503417507447,
    'border-style'    : 'solid',
    'border-width'    : 1,
    margin            : 2,
    oneAxisPadding    : 2,
    padding           : 1,
    "flex-grow"       : "unset",
  },

  tabs: {
    "movable-tabs"    : "true",
    TabActive         : 'rgba(212,212,212, 1)',
    TabBarRadius      : 6,
    TabHighlight      : 'rgba(50, 50, 50, 0.2)',
    TabInactive       : 'rgba(183,183,183, 1)',
    TabStrokeStyle1   : 'rgba(0,0,0, 1)',
    TabStrokeStyle2   : 'rgba(0,0,0, 1)',
    TabText           : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'bold',
      style  : 'normal',
      size   : 15,
      color  : 'rgba(0,0,0, 1)'
    }),
    'background-color': 'rgba(222,222,222, 1)',
  },

  textbox: {
    DefaultText       : new CSSFont({
      font   : 'sans-serif',
      weight : 'normal',
      variant: 'normal',
      style  : 'normal',
      size   : 14,
      color  : 'rgba(3,3,3, 1)'
    }),
    'background-color': 'rgba(245,245,245, 1)',
  },

  tooltip: {
    ToolTipText       : new CSSFont({
      font   : 'sans-serif',
      weight : 'bold',
      variant: 'normal',
      style  : 'normal',
      size   : 12,
      color  : 'rgba(35, 35, 35, 1.0)'
    }),
    'background-color': 'rgba(255,255,255, 1)',
    'border-color'    : 'rgba(139,139,139, 1)',
    'border-radius'   : 3,
    'border-style'    : 'solid',
    'border-width'    : 1,
    padding           : 5,
  },

  treeview: {
    itemIndent: 10,
    rowHeight : 18,
  },

  vecPopupButton: {
    height : 18,
    padding: 3,
    width  : 100,
  },

};

"use strict";

/*
Icons are defined in spritesheets that live in
the iconsheet16/32 dom nodes.  Icons are numbered start from
the upper left sprite tile.

This function sets the mapping between icon numbers and names.

The following icons should be in the icon sheet and in this map:

RESIZE      :
SMALL_PLUS  :
TRANSLATE   : for moving things
UI_EXPAND   : panel open icon
UI_COLLAPSE : panel close icon
NOTE_EXCL   : exclamation mark for notifications
HELP        : help symbol
*/
function setIconMap(icons) {
  for (let k in icons) {
    Icons[k] = icons[k];
  }
}

let a$1 = 0;
let Icons = {
  FOLDER: a$1++,
  FILE  : a$1++,
  TINY_X: a$1++,

  SMALL_PLUS : a$1++,
  SMALL_MINUS: a$1++,
  UNDO       : a$1++,

  REDO: a$1++,
  HELP: a$1++,

  UNCHECKED   : a$1++,
  CHECKED     : a$1++,
  LARGE_CHECK : a$1++,
  CURSOR_ARROW: a$1++,
  NOTE_EXCL   : a$1++,
  SCROLL_DOWN : a$1++,
  SCROLL_UP   : a$1++,
  BACKSPACE   : a$1++,
  LEFT_ARROW  : a$1++,
  RIGHT_ARROW : a$1++,
  UI_EXPAND   : a$1++, //triangle
  UI_COLLAPSE : a$1++, //triangle


  BOLD         : a$1++,
  ITALIC       : a$1++,
  UNDERLINE    : a$1++,
  STRIKETHRU   : a$1++,
  TREE_EXPAND  : a$1++,
  TREE_COLLAPSE: a$1++,
  ZOOM_OUT     : a$1++,
  ZOOM_IN      : a$1++
};
/* used for icon checkboxes with overlayed check marks */
Icons.ENUM_CHECKED = Icons.CHECKED;
Icons.ENUM_UNCHECKED = Icons.UNCHECKED;

let exclude = new Set([
  "toString", "constructor", "prototype", "__proto__", "toLocaleString",
  "hasOwnProperty", "shadow"
]);

let UIBase$1 = undefined;

//deal with circular module refrence
function _setUIBase(uibase) {
  UIBase$1 = uibase;
}

let AspectKeys = Symbol("aspect-keys");

function initAspectClass(object, blacklist = new Set()) {
  let cls = object.constructor;

  if (!cls[AspectKeys]) {
    cls[AspectKeys] = [];
    let keys = [];

    let p = object.__proto__;
    while (p) {
      keys = keys.concat(Reflect.ownKeys(p));
      p = p.__proto__;
    }
    keys = new Set(keys);

    function validProperty(obj, key) {
      let descr = Object.getOwnPropertyDescriptor(obj, key);

      if (descr && (descr.get || descr.set)) {
        return false;
      }

      let p = obj.constructor;
      do {
        if (p.prototype) {
          let descr = Object.getOwnPropertyDescriptor(p.prototype, key);

          if (descr && (descr.set || descr.get)) {
            return false;
          }
        }

        p = p.__proto__;
      } while (p && p !== p.__proto__);

      return true;
    }

    for (let k of keys) {
      let v;

      if (typeof k === "string" && k.startsWith("_")) {
        continue;
      }

      if (k === "constructor") {
        continue;
      }

      if (blacklist.has(k) || exclude.has(k)) {
        continue;
      }

      if (!validProperty(object, k)) {
        continue;
      }

      try {
        v = object[k];
      } catch (error) {
        continue;
      }

      if (typeof v !== "function") {
        continue;
      }

      cls[AspectKeys].push(k);
    }
  }

  object.__aspect_methods = new Set();

  for (let k of cls[AspectKeys]) {
    AfterAspect.bind(object, k);
  }
}

function clearAspectCallbacks(obj) {
  for (let key of obj.__aspect_methods) {
    obj[key].clear();
  }
}

/**
 *
 * example:
 *
 * someobject.update.after(() => {
 *   do_something();
 *   return someobject.update.value;
 * }
 *
 * */
class AfterAspect {
  constructor(owner, key) {
    this.owner = owner;
    this.key = key;

    this.chain = [[owner[key], false]];
    this.chain2 = [[owner[key], false]];

    this.root = [[owner[key], false]];

    let this2 = this;

    let method = this._method = function () {
      let chain = this2.chain;
      let chain2 = this2.chain2;

      chain2.length = chain.length;

      for (let i = 0; i < chain.length; i++) {
        chain2[i] = chain[i];
      }

      for (let i = 0; i < chain2.length; i++) {
        let [cb, node, once] = chain2[i];

        if (node) {
          let isDead = !node.isConnected;

          if (node instanceof UIBase$1) {
            isDead = isDead || node.isDead();
          }

          if (isDead) {
            console.warn("pruning dead AfterAspect callback", node);
            chain.remove(chain2[i]);
            continue;
          }
        }


        if (once && chain.indexOf(chain2[i]) >= 0) {
          chain.remove(chain2[i]);
        }

        if (cb && cb.apply) {
          method.value = cb.apply(this, arguments);
          //method.value = Reflect.apply(cb, this, arguments);
          //cb.apply(this, args);
        }
      }

      let ret = method.value;
      method.value = undefined;

      return ret;
    };

    this._method_bound = false;

    method.after = this.after.bind(this);
    method.once = this.once.bind(this);
    method.remove = this.remove.bind(this);

    owner[key].after = this.after.bind(this);
    owner[key].once = this.once.bind(this);
    owner[key].remove = this.remove.bind(this);
  }

  static bind(owner, key) {
    owner.__aspect_methods.add(key);

    return new AfterAspect(owner, key);
  }

  remove(cb) {
    for (let item of this.chain) {
      if (item[0] === cb) {
        this.chain.remove(item);
        return true;
      }
    }

    return false;
  }

  once(cb, node) {
    return this.after(cb, node, true);
  }

  _checkbind() {
    if (!this._method_bound) {
      this.owner[this.key] = this._method;
    }
  }

  clear() {
    this._checkbind();
    this.chain = [[this.root[0][0], this.root[0][1]]];
    this.chain2 = [[this.root[0][0], this.root[0][1]]];

    return this;
  }

  before(cb, node, once) {
    this._checkbind();

    if (cb === undefined) {
      console.warn("invalid call to .after(); cb was undefined");
      return;
    }
    this.chain = [[cb, node, once]].concat(this.chain);
  }

  after(cb, node, once) {
    this._checkbind();

    if (cb === undefined) {
      console.warn("invalid call to .after(); cb was undefined");
      return;
    }
    this.chain.push([cb, node, once]);
  }
}

let _ui_base = undefined;

//avoid circular module references
let TextBox = undefined;

function _setTextboxClass(cls) {
  TextBox = cls;
}

//global list of elements to, hopefully, prevent minification tree shaking
//of live elements
let ElementClasses = [];

window.__cconst = exports;

let Vector4$1 = Vector4;

const EnumProperty$1 = EnumProperty;

let Area;
let _setAreaClass = (cls) => {
  Area = cls;
};

const ErrorColors = {
  WARNING: "yellow",
  ERROR  : "red",
  OK     : "green"
};

window.__theme = theme;

let registered_has_happened = false;
let tagPrefix = "";

/**
 * Sets tag prefix for pathux html elements.
 * Must be called prior to loading other modules.
 * Since this is tricky, you can alternatively
 * add a script tag with the prefix with the id "pathux-tag-prefix",
 * e.g.<pre> <script type="text/plain" id="pathux-tag-prefix">prefix</script> </pre>
 * */
function setTagPrefix(prefix) {
  if (registered_has_happened) {
    throw new Error("have to call ui_base.setTagPrefix before loading any other path.ux modules");
  }

  tagPrefix = "" + prefix;
}

function getTagPrefix(prefix) {
  return tagPrefix;
}

let prefix = document.getElementById("pathux-tag-prefix");
if (prefix) {
  console.log("Found pathux-tag-prefix element");
  prefix = prefix.innerText.trim();
  setTagPrefix(prefix);
}

const ClassIdSymbol = Symbol("pathux-class-id");
let class_idgen = 1;

function setTheme(theme2) {
  //merge theme
  for (let k in theme2) {
    let v = theme2[k];

    if (typeof v !== "object") {
      theme[k] = v;
      continue;
    }

    let v0 = theme[k];

    if (!(k in theme)) {
      theme[k] = {};
    }

    for (let k2 in v) {
      //if (v0 && !(k2 in v0)) {
      //  continue;
      //}

      if (k2 in compatMap) {
        let k3 = compatMap[k2];

        if (v[k3] === undefined) {
          v[k3] = v[k2];
        }

        delete v[k2];
        k2 = k3;
      }

      theme[k][k2] = v[k2];
    }
  }
}

setTheme(DefaultTheme);

let _last_report = time_ms();

function report$1() {
  if (time_ms() - _last_report > 350) {
    console.warn(...arguments);
    _last_report = time_ms();
  }
}

//this function is deprecated
function getDefault(key, elem) {
  console.warn("Deprecated call to ui_base.js:getDefault");

  if (key in theme.base) {
    return theme.base[key];
  } else {
    throw new Error("Unknown default " + key);
  }
}

//XXX implement me!
function IsMobile() {
  console.warn("ui_base.IsMobile is deprecated; use util.isMobile instead");
  return isMobile();
};

let keys = ["margin", "padding", "margin-block-start", "margin-block-end"];
keys = keys.concat(["padding-block-start", "padding-block-end"]);

keys = keys.concat(["margin-left", "margin-top", "margin-bottom", "margin-right"]);
keys = keys.concat(["padding-left", "padding-top", "padding-bottom", "padding-right"]);
const marginPaddingCSSKeys = keys;


class _IconManager {
  constructor(image, tilesize, number_of_horizontal_tiles, drawsize) {
    this.tilex = number_of_horizontal_tiles;
    this.tilesize = tilesize;
    this.drawsize = drawsize;

    this.customIcons = new Map();

    this.image = image;
  }

  canvasDraw(elem, canvas, g, icon, x = 0, y = 0) {
    let customIcon = this.customIcons.get(icon);

    if (customIcon) {
      g.drawImage(customIcon.canvas, x, y);
      return;
    }

    let tx = icon%this.tilex;
    let ty = ~~(icon/this.tilex);

    let dpi = elem.getDPI();
    let ts = this.tilesize;
    let ds = this.drawsize;

    if (!this.image) {
      //console.warn("Failed to render an iconsheet");
      return;
    }

    try {
      g.drawImage(this.image, tx*ts, ty*ts, ts, ts, x, y, ds*dpi, ds*dpi);
    } catch (error) {
      console.log("failed to draw an icon");
    }
  }

  setCSS(icon, dom, fitsize = undefined) {
    if (!fitsize) {
      fitsize = this.drawsize;
    }

    if (typeof fitsize === "object") {
      fitsize = Math.max(fitsize[0], fitsize[1]);
    }

    dom.style["background"] = this.getCSS(icon, fitsize);
    if (this.customIcons.has(icon)) {
      dom.style["background-size"] = (fitsize) + "px";
    } else {
      dom.style["background-size"] = (fitsize*this.tilex) + "px";
    }

    dom.style["background-clip"] = "content-box";

    if (!dom.style["width"]) {
      dom.style["width"] = this.drawsize + "px";
    }
    if (!dom.style["height"]) {
      dom.style["height"] = this.drawsize + "px";
    }
  }

  //icon is an integer
  getCSS(icon, fitsize = this.drawsize) {
    if (icon === -1) { //-1 means no icon
      return '';
    }

    if (typeof fitsize === "object") {
      fitsize = Math.max(fitsize[0], fitsize[1]);
    }

    let ratio = fitsize/this.tilesize;

    let customIcon = this.customIcons.get(icon);
    if (customIcon !== undefined) {
      //ratio = fitsize / this.drawsize;
      //let d = this.drawsize*0.25;
      let d = 0.0;

      let css = `url("${customIcon.blobUrl}")`;

      return css;
    }

    let x = (-(icon%this.tilex)*this.tilesize)*ratio;
    let y = (-(~~(icon/this.tilex))*this.tilesize)*ratio;

    //x = ~~x;
    //y = ~~y;

    //console.log(this.tilesize, this.drawsize, x, y);
    //let ts = this.tilesize;
    //return `image('${this.image.src}#xywh=${x},${y},${ts},${ts}')`;
    return `url("${this.image.src}") ${x}px ${y}px`;
  }
}

class CustomIcon {
  constructor(manager, key, id, baseImage) {
    this.key = key;
    this.baseImage = baseImage;
    this.images = [];
    this.id = id;
    this.manager = manager;
  }

  regenIcons() {
    let manager = this.manager;

    let doSheet = (sheet) => {
      let size = sheet.drawsize;
      let canvas = document.createElement("canvas");
      let g = canvas.getContext("2d");

      canvas.width = canvas.height = size;
      g.drawImage(this.baseImage, 0, 0, size, size);

      canvas.toBlob((blob) => {
        let blobUrl = URL.createObjectURL(blob);

        sheet.customIcons.set(this.id, {
          blobUrl,
          canvas
        });
      });
    };

    for (let sheet of manager.iconsheets) {
      doSheet(sheet);
    }
  }
}

class IconManager {
  /**
   images is a list of dom ids of img tags

   sizes is a list of tile sizes, one per image.
   you can control the final *draw* size by passing an array
   of [tilesize, drawsize] instead of just a number.
   */
  constructor(images, sizes, horizontal_tile_count) {
    this.iconsheets = [];
    this.tilex = horizontal_tile_count;

    this.customIcons = new Map();
    this.customIconIDMap = new Map();

    for (let i = 0; i < images.length; i++) {
      let size, drawsize;

      if (typeof sizes[i] == "object") {
        size = sizes[i][0], drawsize = sizes[i][1];
      } else {
        size = drawsize = sizes[i];
      }

      if (isMobile()) {
        drawsize = ~~(drawsize*theme.base.mobileSizeMultiplier);
      }

      this.iconsheets.push(new _IconManager(images[i], size, horizontal_tile_count, drawsize));
    }
  }

  addCustomIcon(key, image) {
    let icon = this.customIcons.get(key);

    if (!icon) {
      let maxid = 0;

      for (let k in Icons) {
        maxid = Math.max(maxid, Icons[k] + 1);
      }
      for (let icon of this.customIcons.values()) {
        maxid = Math.max(maxid, icon.id + 1);
      }

      maxid = Math.max(maxid, 1000); //just to be on the safe side

      let id = maxid;
      icon = new CustomIcon(this, key, id, image);

      this.customIcons.set(key, icon);
      this.customIconIDMap.set(id, icon);
    }

    icon.baseImage = image;
    icon.regenIcons();

    return icon.id;
  }

  load(manager2) {
    this.iconsheets = manager2.iconsheets;
    this.tilex = manager2.tilex;

    return this;
  }

  reset(horizontal_tile_count) {
    this.iconsheets.length = 0;
    this.tilex = horizontal_tile_count;
  }

  add(image, size, drawsize = size) {
    this.iconsheets.push(new _IconManager(image, size, this.tilex, drawsize));
    return this;
  }

  canvasDraw(elem, canvas, g, icon, x = 0, y = 0, sheet = 0) {
    let base = this.iconsheets[sheet];

    sheet = this.findSheet(sheet);
    let ds = sheet.drawsize;

    sheet.drawsize = base.drawsize;
    sheet.canvasDraw(elem, canvas, g, icon, x, y);
    sheet.drawsize = ds;
  }

  findClosestSheet(size) {
    let sheets = this.iconsheets.concat([]);

    sheets.sort((a, b) => a.drawsize - b.drawsize);
    let sheet;

    for (let i = 0; i < sheets.length; i++) {
      if (sheets[i].drawsize <= size) {
        sheet = sheets[i];
        break;
      }
    }

    if (!sheet)
      sheet = sheets[sheets.length - 1];

    return this.iconsheets.indexOf(sheet);
  }

  findSheet(sheet) {
    if (sheet === undefined) {
      console.warn("sheet was undefined");
      sheet = 0;
    }

    let base = this.iconsheets[sheet];

    /**sigh**/
    let dpi = UIBase$2.getDPI();
    let minsheet = undefined;
    let goal = dpi*base.drawsize;

    for (let sheet of this.iconsheets) {
      minsheet = sheet;

      if (sheet.drawsize >= goal) {
        break;
      }
    }

    return minsheet === undefined ? base : minsheet;
  }

  getTileSize(sheet = 0) {
    return this.iconsheets[sheet].drawsize;
    return this.findSheet(sheet).drawsize;
  }

  getRealSize(sheet = 0) {
    return this.iconsheets[sheet].tilesize;
    return this.findSheet(sheet).tilesize;
    //return this.iconsheets[sheet].tilesize;
  }

  //icon is an integer
  getCSS(icon, sheet = 0) {
    //return this.iconsheets[sheet].getCSS(icon);
    //return this.findSheet(sheet).getCSS(icon);

    let base = this.iconsheets[sheet];
    sheet = this.findSheet(sheet);
    let ds = sheet.drawsize;

    sheet.drawsize = base.drawsize;
    let ret = sheet.getCSS(icon);
    sheet.drawsize = ds;

    return ret;
  }

  setCSS(icon, dom, sheet = 0, fitsize = undefined) {
    //return this.iconsheets[sheet].setCSS(icon, dom);

    let base = this.iconsheets[sheet];
    sheet = this.findSheet(sheet);
    let ds = sheet.drawsize;

    sheet.drawsize = base.drawsize;
    let ret = sheet.setCSS(icon, dom, fitsize);
    sheet.drawsize = ds;

    return ret;
  }
}

let iconmanager = new IconManager([
  document.getElementById("iconsheet16"),
  document.getElementById("iconsheet32"),
  document.getElementById("iconsheet48")
], [16, 32, 64], 16);

window._iconmanager = iconmanager; //debug global

//if client code overrides iconsheets, they must follow logical convention
//that the first one is "small" and the second is "large"
let IconSheets = {
  SMALL : 0,
  LARGE : 1,
  XLARGE: 2
};

function iconSheetFromPackFlag(flag) {
  if (flag & PackFlags.CUSTOM_ICON_SHEET) {
    //console.log("Custom Icon Sheet:", flag>>PackFlags.CUSTOM_ICON_SHEET_START);
    return flag>>PackFlags.CUSTOM_ICON_SHEET_START;
  }

  if ((flag & PackFlags.SMALL_ICON) && !(PackFlags.LARGE_ICON)) {
    return 0//IconSheets.SMALL; //0
  } else {
    return 1//IconSheets.LARGE; //1
  }
}

function getIconManager() {
  return iconmanager;
}

function setIconManager(manager, IconSheetsOverride) {
  iconmanager.load(manager);

  if (IconSheetsOverride !== undefined) {
    for (let k in IconSheetsOverride) {
      IconSheets[k] = IconSheetsOverride[k];
    }
  }
}

function makeIconDiv(icon, sheet = 0) {
  let size = iconmanager.getRealSize(sheet);

  let drawsize = iconmanager.getTileSize(sheet);

  let icontest = document.createElement("div");

  icontest.style["width"] = icontest.style["min-width"] = drawsize + "px";
  icontest.style["height"] = icontest.style["min-height"] = drawsize + "px";

  //icontest.style["background-color"] = "orange";

  icontest.style["margin"] = "0px";
  icontest.style["padding"] = "0px";

  iconmanager.setCSS(icon, icontest, sheet);

  return icontest;
}

let Vector2$3 = Vector2;
let Matrix4$1 = Matrix4;

let dpistack = [];

const UIFlags = {};

const internalElementNames = {};
const externalElementNames = {};

const PackFlags = {
  INHERIT_WIDTH : 1,
  INHERIT_HEIGHT: 2,
  VERTICAL      : 4,
  USE_ICONS     : 8,
  SMALL_ICON    : 16,
  LARGE_ICON    : 32,

  FORCE_PROP_LABELS         : 64, //force propeties (Container.prototype.prop()) to always have labels
  PUT_FLAG_CHECKS_IN_COLUMNS: 128, //group flag property checkmarks in columns (doesn't apply to icons)

  WRAP_CHECKBOXES: 256,

  //internal flags
  STRIP_HORIZ            : 512,
  STRIP_VERT             : 1024,
  STRIP                  : 512 | 1024,
  SIMPLE_NUMSLIDERS      : 2048,
  FORCE_ROLLER_SLIDER    : 4096,
  HIDE_CHECK_MARKS       : (1<<13),
  NO_NUMSLIDER_TEXTBOX   : (1<<14),
  CUSTOM_ICON_SHEET      : 1<<15,
  CUSTOM_ICON_SHEET_START: 20, //custom icon sheet bits are shifted to here
  NO_UPDATE              : 1<<16
};

let first$1 = (iter) => {
  if (iter === undefined) {
    return undefined;
  }

  if (!(Symbol.iterator in iter)) {
    for (let item in iter) {
      return item;
    }

    return undefined;
  }

  for (let item of iter) {
    return item;
  }
};

let _mobile_theme_patterns = [
  /.*width.*/,
  /.*height.*/,
  /.*size.*/,
  /.*margin.*/,
  /.*pad/,
  /.*radius.*/
];


let _idgen = 0;

window._testSetScrollbars = function (color = "grey", contrast = 0.5, width = 15, border = "solid") {
  let buf = styleScrollBars(color, undefined, contrast, width, border, "*");
  CTX.screen.mergeGlobalCSS(buf);

  //document.body.style["overflow"] = "scroll";

  /*
  if (!window._tsttag) {
    window._tsttag = document.createElement("style");
    document.body.prepend(_tsttag);
  }

  _tsttag.textContent = buf;
  //*/

  return buf;
};

function styleScrollBars(color = "grey", color2 = undefined, contrast = 0.5, width = 15,
                                border                                                    = "1px groove black", selector = "*") {

  if (!color2) {
    let c = css2color(color);
    let a = c.length > 3 ? c[3] : 1.0;

    c = rgb_to_hsv(c[0], c[1], c[2]);
    let inv = c.slice(0, c.length);

    inv[2] = 1.0 - inv[2];
    inv[2] += (c[2] - inv[2])*(1.0 - contrast);

    inv = hsv_to_rgb(inv[0], inv[1], inv[2]);

    inv.length = 4;
    inv[3] = a;

    inv = color2css(inv);
    color2 = inv;
  }

  let buf = `

${selector} {
  scrollbar-width : ${width <= 16 ? 'thin' : 'auto'};
  scrollbar-color : ${color2} ${color};
}

${selector}::-webkit-scrollbar {
  width : ${width}px;
  background-color : ${color};
}

${selector}::-webkit-scrollbar-track {
  background-color : ${color};
  border : ${border};
}

${selector}::-webkit-scrollbar-thumb {
  background-color : ${color2};
  border : ${border};
}
    `;

  //console.log(buf);
  return buf;
}

window.styleScrollBars = styleScrollBars;

let _digest$1 = new HashDigest();

function calcThemeKey(digest = _digest$1.reset()) {
  for (let k in theme) {
    let obj = theme[k];

    if (typeof obj !== "object") {
      continue;
    }

    for (let k2 in obj) {
      let v2 = obj[k2];

      if (typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "string") {
        digest.add(v2);
      } else if (typeof v2 === "object" && v2 instanceof CSSFont) {
        v2.calcHashUpdate(digest);
      }
    }
  }

  return digest.get();
}

var _themeUpdateKey = calcThemeKey();

function flagThemeUpdate() {
  _themeUpdateKey = calcThemeKey();
}

class UIBase$2 extends HTMLElement {
  constructor() {
    super();

    this._modalstack = [];

    this._tool_tip_abort_delay = undefined;
    this._tooltip_ref = undefined;

    this._textBoxEvents = false;

    this._themeOverride = undefined;

    this._checkTheme = true;
    this._last_theme_update_key = _themeUpdateKey;

    this._client_disabled_set = undefined;
    //this._parent_disabled_set = 0;

    this._useNativeToolTips = exports.useNativeToolTips;
    this._useNativeToolTips_set = false;
    this._has_own_tooltips = undefined;
    this._tooltip_timer = time_ms();

    this.pathUndoGen = 0;
    this._lastPathUndoGen = 0;
    this._useDataPathUndo = undefined;

    this._active_animations = [];

    //ref to Link element referencing Screen style node
    //Screen.update_intern sets the contents of this
    this._screenStyleTag = document.createElement("style");
    this._screenStyleUpdateHash = 0;

    initAspectClass(this, new Set(["appendChild", "animate", "shadow", "removeNode", "prepend", "add", "init"]));

    this.shadow = this.attachShadow({mode: 'open'});

    if (exports.DEBUG.paranoidEvents) {
      this.__cbs = [];
    }

    this.shadow.appendChild(this._screenStyleTag);
    this.shadow._appendChild = this.shadow.appendChild;

    ///*
    let appendChild = this.shadow.appendChild;
    this.shadow.appendChild = (child) => {
      if (child && typeof child === "object" && child instanceof UIBase$2) {
        child.parentWidget = this;
      }

      return this.shadow._appendChild(child, ...arguments);
    };
    //*/

    this._wasAddedToNodeAtSomeTime = false;

    this.visibleToPick = true;

    this._override_class = undefined;
    this.parentWidget = undefined;

    /*
    this.shadow._appendChild = this.shadow.appendChild;
    this.shadow.appendChild = (child) => {
      if (child instanceof UIBase) {
        child.ctx = this.ctx;
        child.parentWidget = this;

        if (child._useDataPathUndo === undefined) {
          child.useDataPathUndo = this.useDataPathUndo;
        }
      }

      return this.shadow._appendChild(child);
    };
    //*/

    let tagname = this.constructor.define().tagname;
    this._id = tagname.replace(/\-/g, "_") + (_idgen++);

    this.default_overrides = {}; //inherited by child widgets
    this.my_default_overrides = {}; //not inherited to child widgets
    this.class_default_overrides = {};

    this._last_description = undefined;
    this._description_final = undefined;

    //getting css to flow down properly can be a pain, so
    //some packing settings are set as bitflags here,
    //see PackFlags

    /*
    setInterval(() => {
      this.update();
    }, 200);
    //*/

    this._modaldata = undefined;
    this.packflag = this.getDefault("BasePackFlag");
    this._internalDisabled = false;
    this.__disabledState = false;
    this._disdata = undefined;
    this._ctx = undefined;

    this._description = undefined;

    let style = document.createElement("style");
    style.textContent = `
    .DefaultText {
      font: ` + _getFont(this) + `;
    }
    `;
    this.shadow.appendChild(style);
    this._init_done = false;

    //make default touch handlers that send mouse events
    let do_touch = (e, type, button) => {
      if (haveModal()) {
        return;
      }

      button = button === undefined ? 0 : button;
      let e2 = copyEvent(e);

      if (e.touches.length === 0) {
        //hrm, what to do, what to do. . .
      } else {
        let t = e.touches[0];

        e2.pageX = t.pageX;
        e2.pageY = t.pageY;
        e2.screenX = t.screenX;
        e2.screenY = t.screenY;
        e2.clientX = t.clientX;
        e2.clientY = t.clientY;
        e2.x = t.x;
        e2.y = t.y;
      }

      e2.button = button;

      e2 = new MouseEvent(type, e2);

      e2.was_touch = true;
      e2.stopPropagation = e.stopPropagation.bind(e);
      e2.preventDefault = e.preventDefault.bind(e);
      e2.touches = e.touches;

      this.dispatchEvent(e2);
    };

    this.addEventListener("touchstart", (e) => {
      do_touch(e, "mousedown", 0);
    }, {passive: false});
    this.addEventListener("touchmove", (e) => {
      do_touch(e, "mousemove");
    }, {passive: false});
    this.addEventListener("touchcancel", (e) => {
      do_touch(e, "mouseup", 2);
    }, {passive: false});
    this.addEventListener("touchend", (e) => {
      do_touch(e, "mouseup", 0);
    }, {passive: false});
  }

  /*
  set default_overrides(v) {
    console.error("default_overrides was set", v);
    this._default_overrides = v;
  }

  get default_overrides() {
    return this._default_overrides;
  }//*/

  get useNativeToolTips() {
    return this._useNativeToolTips;
  }

  set useNativeToolTips(val) {
    this._useNativeToolTips = val;
    this._useNativeToolTips_set = true;
  }

  get parentWidget() {
    return this._parentWidget;
  }

  set parentWidget(val) {
    if (val) {
      this._wasAddedToNodeAtSomeTime = true;
    }

    this._parentWidget = val;
  }

  get useDataPathUndo() {
    let p = this;

    while (p) {
      if (p._useDataPathUndo !== undefined) {
        return p._useDataPathUndo;
      }

      p = p.parentWidget;
    }

    return false;
  }

  /**
   causes calls to setPathValue to go through
   toolpath app.datapath_set(path="" newValueJSON="")

   every child will inherit
   */
  set useDataPathUndo(val) {
    this._useDataPathUndo = val;
  }

  get description() {

    return this._description;
  }

  set description(val) {
    if (val === null) {
      this._description = undefined;
      return;
    }

    this._description = val;

    if (val === undefined || val === null) {
      return;
    }

    if (exports.showPathsInToolTips && this.hasAttribute("datapath")) {
      let s = "" + this._description;

      let path = this.getAttribute("datapath");
      s += "\n    path: " + path;

      if (this.hasAttribute("mass_set_path")) {
        let m = this.getAttribute("mass_set_path");
        s += "\n    massSetPath: " + m;
      }

      this._description_final = s;
    }

    if (exports.useNativeToolTips) {
      this.title = "" + this._description_final;
    }
  }

  get background() {
    return this.__background;
  }

  set background(bg) {
    this.__background = bg;

    this.overrideDefault("background-color", bg, true);
    this.style["background-color"] = bg;
  }

  get disabled() {
    //hrm, I could just propegate checks upward. . .

    if (this.parentWidget && this.parentWidget.disabled) {
      return true;
    }

    return !!this._client_disabled_set || !!this._internalDisabled;// || !!this._parent_disabled_set;
  }

  set disabled(v) {
    this._client_disabled_set = v;
    this.__updateDisable(this.disabled);
  }

  get internalDisabled() {
    return this._internalDisabled;
  }

  set internalDisabled(val) {
    this._internalDisabled = !!val;

    this.__updateDisable(this.disabled);
  }

  get ctx() {
    return this._ctx;
  }

  set ctx(c) {
    this._ctx = c;

    this._forEachChildWidget((n) => {
      n.ctx = c;
    });
  }

  get _reportCtxName() {
    return "" + this._id;
  }

  get modalRunning() {
    return this._modaldata !== undefined;
  }

  static getIconEnum() {
    return Icons;
  }

  static setDefault(element) {
    return element;
  }

  /**DEPRECATED

   scaling ratio (e.g. for high-resolution displays)
   */
  static getDPI() {
    //if (dpistack.length > 0) {
    //  return dpistack[this.dpistack.length-1];
    //} else {
    //if (util.isMobile()) {
    return window.devicePixelRatio; // * visualViewport.scale;
    //}

    return window.devicePixelRatio;
    //}
  }

  static prefix(name) {
    return tagPrefix + name;
  }

  static internalRegister(cls) {
    cls[ClassIdSymbol] = class_idgen++;

    registered_has_happened = true;

    internalElementNames[cls.define().tagname] = this.prefix(cls.define().tagname);
    customElements.define(this.prefix(cls.define().tagname), cls);
  }

  static getInternalName(name) {
    return internalElementNames[name];
  }

  static createElement(name, internal = false) {
    if (!internal && name in externalElementNames) {
      return document.createElement(name);
    } else if (name in internalElementNames) {
      return document.createElement(internalElementNames[name]);
    } else {
      return document.createElement(name)
    }
  }

  static register(cls) {
    registered_has_happened = true;

    cls[ClassIdSymbol] = class_idgen++;

    ElementClasses.push(cls);

    externalElementNames[cls.define().tagname] = cls.define().tagname;
    customElements.define(cls.define().tagname, cls);
  }

  /**
   * Defines core attributes of the class
   *
   * @example
   *
   * static define() {return {
   *   tagname             : "custom-element-x",
   *   style               : "[style class in theme]"
   *   subclassChecksTheme : boolean //set to true to disable base class invokation of checkTheme()
   *   havePickClipboard   : boolean //whether element supports mouse hover copy/paste
   *   pasteForAllChildren : boolean //mouse hover paste happens even over child widgets
   *   copyForAllChildren  : boolean //mouse hover copy happens even over child widgets
   * }}
   */
  static define() {
    throw new Error("Missing define() for ux element");
  }

  setUndo(val) {
    this.useDataPathUndo = val;
    return this;
  }

  hide(sethide = true) {
    this.hidden = sethide;

    for (let n of this.shadow.childNodes) {
      n.hidden = sethide;
    }

    this._forEachChildWidget((n) => {
      n.hide(sethide);
    });
  }

  getElementById(id) {
    let ret;

    let rec = (n) => {
      if (ret) {
        return;
      }

      if (n.getAttribute("id") === id || n.id === id) {
        ret = n;
      }

      if (n instanceof UIBase$2 && n.constructor.define().tagname === "panelframe-x") {
        rec(n.contents);
      } else if (n instanceof UIBase$2 && n.constructor.define().tagname === "tabcontainer-x") {
        for (let k in n.tabs) {
          let tab = n.tabs[k];

          if (tab) {
            rec(tab);
          }
        }
      }

      for (let n2 of n.childNodes) {
        if (n2 instanceof HTMLElement) {
          rec(n2);

          if (ret) {
            break;
          }
        }
      }

      if (n.shadow) {
        for (let n2 of n.shadow.childNodes) {
          if (n2 instanceof HTMLElement) {
            rec(n2);

            if (ret) {
              break;
            }
          }
        }
      }
    };

    rec(this);

    return ret;
  }

  unhide() {
    this.hide(false);
  }

  findArea() {
    let p = this;

    while (p) {
      if (p instanceof Area) {
        return p;
      }

      p = p.parentWidget;
    }
  }

  addEventListener(type, cb, options) {
    if (exports.DEBUG.domEventAddRemove) {
      console.log("addEventListener", type, this._id, options);
    }

    let cb2 = (e) => {
      if (exports.DEBUG.paranoidEvents) {
        if (this.isDead()) {
          this.removeEventListener(type, cb, options);
          return;
        }
      }

      if (exports.DEBUG.domEvents) {
        pathDebugEvent(e);
      }

      let area = this.findArea();

      if (area) {
        area.push_ctx_active();
        try {
          let ret = cb(e);
          area.pop_ctx_active();
          return ret;
        } catch (error) {
          area.pop_ctx_active();
          throw error;
        }
      } else {
        if (exports.DEBUG.areaContextPushes) {
          console.warn("Element is not part of an area?", element);
        }

        return cb(e);
      }
    };

    cb._cb = cb2;

    if (exports.DEBUG.paranoidEvents) {
      this.__cbs.push([type, cb2, options]);
    }


    return super.addEventListener(type, cb, options);
  }

  removeEventListener(type, cb, options) {
    if (exports.DEBUG.paranoidEvents) {
      for (let item of this.__cbs) {
        if (item[0] == type && item[1] === cb._cb2 && ("" + item[2]) === ("" + options)) {
          this.__cbs.remove(item);
          break;
        }
      }
    }

    if (exports.DEBUG.domEventAddRemove) {
      console.log("removeEventListener", type, this._id, options);
    }

    if (!cb._cb) {
      return super.removeEventListener(type, cb, options);
    } else {
      return super.removeEventListener(type, cb._cb, options);
    }
  }

  connectedCallback() {

  }

  noMarginsOrPadding() {
    return;
    let keys = ["margin", "padding", "margin-block-start", "margin-block-end"];
    keys = keys.concat(["padding-block-start", "padding-block-end"]);

    keys = keys.concat(["margin-left", "margin-top", "margin-bottom", "margin-right"]);
    keys = keys.concat(["padding-left", "padding-top", "padding-bottom", "padding-right"]);

    for (let k of keys) {
      this.style[k] = "0px";
    }

    return this;
  }

  /**
   * find owning screen and tell it to update
   * the global tab order
   * */
  regenTabOrder() {
    let screen = this.getScreen();
    if (screen !== undefined) {
      screen.needsTabRecalc = true;
    }

    return this;
  }

  noMargins() {
    this.style["margin"] = this.style["margin-left"] = this.style["margin-right"] = "0px";
    this.style["margin-top"] = this.style["margin-bottom"] = "0px";
    return this;
  }

  noPadding() {
    this.style["padding"] = this.style["padding-left"] = this.style["padding-right"] = "0px";
    this.style["padding-top"] = this.style["padding-bottom"] = "0px";
    return this;
  }

  getTotalRect() {
    let found = false;

    let min = new Vector2$3([1e17, 1e17]);
    let max = new Vector2$3([-1e17, -1e17]);

    let doaabb = (n) => {
      let rs = n.getClientRects();

      for (let r of rs) {
        min[0] = Math.min(min[0], r.x);
        min[1] = Math.min(min[1], r.y);
        max[0] = Math.max(max[0], r.x + r.width);
        max[1] = Math.max(max[1], r.y + r.height);

        found = true;
      }
    };

    doaabb(this);

    this._forEachChildWidget((n) => {
      doaabb(n);
    });

    if (found) {
      return {
        width : max[0] - min[0],
        height: max[1] - min[1],
        x     : min[0],
        y     : min[1],
        left  : min[0],
        top   : min[1],
        right : max[0],
        bottom: max[1]
      };
    } else {
      return undefined;
    }
  }

  parseNumber(value, args = {}) {
    value = ("" + value).trim().toLowerCase();

    let baseUnit = args.baseUnit || this.baseUnit;
    let isInt = args.isInt || this.isInt;

    let sign = 1.0;

    if (value.startsWith("-")) {
      value = value.slice(1, value.length).trim();
      sign = -1;
    }

    let hexre = /-?[0-9a-f]+h$/;

    if (value.startsWith("0b")) {
      value = value.slice(2, value.length).trim();
      value = parseInt(value, 2);
    } else if (value.startsWith("0x")) {
      value = value.slice(2, value.length).trim();
      value = parseInt(value, 16);
    } else if (value.search(hexre) === 0) {
      value = value.slice(0, value.length - 1).trim();
      value = parseInt(value, 16);
    } else {
      value = parseValue(value, baseUnit);
    }

    if (isInt) {
      value = ~~value;
    }

    return value*sign;
  }

  formatNumber(value, args = {}) {
    let baseUnit = args.baseUnit || this.baseUnit;
    let displayUnit = args.displayUnit || this.displayUnit;
    let isInt = args.isInt || this.isInt;
    let radix = args.radix || this.radix || 10;
    let decimalPlaces = args.decimalPlaces || this.decimalPlaces;

    //console.log(this.baseUnit, this.displayUnit);

    if (isInt && radix !== 10) {
      let ret = Math.floor(value).toString(radix);

      if (radix === 2)
        return "0b" + ret;
      else if (radix === 16)
        return ret + "h";
    }

    return buildString(value, baseUnit, decimalPlaces, displayUnit);
  }

  setBoxCSS(subkey) {
    let boxcode = '';

    //debugger;

    let keys = ["left", "right", "top", "bottom"];

    let sub;
    if (subkey) {
      sub = this.getAttribute(subkey) || {};
    }

    let def = (key) => {
      if (sub) {
        return this.getSubDefault(subkey, key);
      }

      return this.getDefault(key);
    };

    for (let i = 0; i < 2; i++) {
      let key = i ? "padding" : "margin";

      this.style[key] = "unset";

      let val = def(key);
      if (val !== undefined) { //handle default first
        for (let j = 0; j < 4; j++) {
          this.style[key + "-" + keys[j]] = val + "px";
        }
      }

      for (let j = 0; j < 4; j++) { //now do box sides
        let key2 = `${key}-${keys[j]}`;
        let val2 = def(key2);

        if (val2 !== undefined) {
          this.style[key2] = val2 + "px";
        }
      }

    }

    this.style["border-radius"] = def("border-radius") + "px";
    this.style["border"] = `${def("border-width")}px ${def("border-style")} ${def("border-color")}`;
  }

  genBoxCSS(subkey) {
    let boxcode = '';

    let keys = ["left", "right", "top", "bottom"];

    let sub;
    if (subkey) {
      sub = this.getAttribute(subkey) || {};
    }

    let def = (key) => {
      if (sub) {
        return this.getSubDefault(subkey, key);
      }

      return this.getDefault(key);
    };

    for (let i = 0; i < 2; i++) {
      let key = i ? "padding" : "margin";

      let val = def(key);
      if (val !== undefined) {
        boxcode += `${key}: ${val} px;\n`;
      }

      for (let j = 0; j < 4; j++) {
        let key2 = `${key}-${keys[j]}`;
        let val2 = def(key2);

        if (val2 !== undefined) {
          boxcode += `${key2}: ${val}px;\n`;
        }
      }
    }

    boxcode += `border-radius: ${def("border-radius")}px;\n`;
    boxcode += `border: ${def("border-width")}px ${def("border-style")} ${def("border-color")};\n`;

    return boxcode;
  }

  setCSS(setBG = true) {
    if (setBG) {
      let bg = this.getDefault("background-color");
      if (bg) {
        this.style["background-color"] = bg;
      }
    }

    let zoom = this.getZoom();
    if (zoom === 1.0) {
      return;
    }

    let transform = "" + this.style["transform"];

    //try to preserve user set transform by selectively deleting scale
    //kind of hackish. . .

    //normalize whitespace
    transform = transform.replace(/[ \t\n\r]+/g, ' ');
    transform = transform.replace(/, /g, ',');

    //cut out scale
    let transform2 = transform.replace(/scale\([^)]+\)/, '').trim();
    this.style["transform"] = transform2 + ` scale(${zoom},${zoom})`;
  }

  flushSetCSS() {
    //check init
    this._init();

    this.setCSS();

    this._forEachChildWidget((c) => {
      if (!(c.packflag & PackFlags.NO_UPDATE)) {
        c.flushSetCSS();
      }
    });
  }

  /* Why is the DOM API argument order swapped here?*/
  replaceChild(newnode, node) {
    for (let i = 0; i < this.childNodes.length; i++) {
      if (this.childNodes[i] === node) {
        super.replaceChild(newnode, node);
        return true;
      }
    }

    for (let i = 0; i < this.shadow.childNodes.length; i++) {
      if (this.shadow.childNodes[i] === node) {
        this.shadow.replaceChild(newnode, node);
        return true;
      }
    }

    console.error("Unknown child node", node);
    return false;
  }

  swapWith(b) {
    let p1 = this.parentNode;
    let p2 = b.parentNode;

    if (this.parentWidget && (p1 === this.parentWidget.shadow) || p1 === null) {
      p1 = this.parentWidget;
    }

    if (b.parentWidget && (p2 === b.parentWidget.shadow) || p2 === null) {
      p2 = b.parentWidget;
    }

    if (!p1 || !p2) {
      console.error("Invalid call to UIBase.prototype.swapWith", this, b, p1, p2);
      return false;
    }

    let getPos = (n, p) => {
      let i = Array.prototype.indexOf.call(p.childNodes, n);

      if (i < 0 && p.shadow) {
        p = p.shadow;
        i = Array.prototype.indexOf.call(p.childNodes, n);
      }

      return [i, p];
    };

    let [i1, n1] = getPos(this, p1);
    let [i2, n2] = getPos(b, p2);

    console.log("i1, i2, n1, n2", i1, i2, n1, n2);

    let tmp1 = document.createElement("div");
    let tmp2 = document.createElement("div");

    n1.insertBefore(tmp1, this);
    n2.insertBefore(tmp2, b);

    //HTMLElement.prototype.remove.call(this);
    //HTMLElement.prototype.remove.call(b);

    n1.replaceChild(b, tmp1);
    n2.replaceChild(this, tmp2);

    let ptmp = this.parentWidget;
    this.parentWidget = b.parentWidget;
    b.parentWidget = ptmp;

    tmp1.remove();
    tmp2.remove();

    return true;
  }

  traverse(type_or_set) {
    let this2 = this;

    let classes = type_or_set;

    let is_set = type_or_set instanceof Set;
    is_set = is_set || type_or_set instanceof set$1;
    is_set = is_set || Array.isArray(type_or_set);

    if (!is_set) {
      classes = [type_or_set];
    }

    let visit = new Set();

    return (function* () {
      let stack = [this2];

      while (stack.length > 0) {
        let n = stack.pop();

        visit.add(n);

        if (!n || !n.childNodes) {
          continue;
        }

        for (let cls of classes) {
          if (n instanceof cls) {
            yield n;
          }
        }

        for (let c of n.childNodes) {
          if (!visit.has(c)) {
            stack.push(c);
          }
        }

        if (n.shadow) {
          for (let c of n.shadow.childNodes) {
            if (!visit.has(c)) {
              stack.push(c);
            }
          }
        }
      }
    })();
  }

  appendChild(child) {
    if (child instanceof UIBase$2) {
      child.ctx = this.ctx;
      child.parentWidget = this;

      child.useDataPathUndo = this.useDataPathUndo;
    }

    return super.appendChild(child);
  }

  _clipboardHotkeyInit() {
    this._clipboard_over = false;
    this._last_clipboard_keyevt = undefined;

    this._clipboard_keystart = () => {
      if (this._clipboard_events) {
        return;
      }

      this._clipboard_events = true;
      window.addEventListener("keydown", this._clipboard_keydown, {capture: true, passive: false});
    };

    this._clipboard_keyend = () => {
      if (!this._clipboard_events) {
        return;
      }

      this._clipboard_events = false;
      window.removeEventListener("keydown", this._clipboard_keydown, {capture: true, passive: false});
    };

    this._clipboard_keydown = (e, internal_mode) => {
      if (!this.isConnected || !exports.getClipboardData) {
        this._clipboard_keyend();
        return;
      }

      if (e === this._last_clipboard_keyevt || !this._clipboard_over) {
        return;
      }

      /* the user's mouse cursor might not be over the element
      *  if they've tabbed to it */

      let is_copy = e.keyCode === keymap["C"] && (e.ctrlKey || e.commandKey) && !e.shiftKey && !e.altKey;
      let is_paste = e.keyCode === keymap["V"] && (e.ctrlKey || e.commandKey) && !e.shiftKey && !e.altKey;

      if (!is_copy && !is_paste) {
        //early out, remember that pickElement is highly expensive to run
        return;
      }

      //pasteForAllChildren
      if (!internal_mode) {
        let screen = this.ctx.screen;
        let elem = screen.pickElement(screen.mpos[0], screen.mpos[1]);

        let checkTree = is_paste && this.constructor.define().pasteForAllChildren;
        checkTree = checkTree || (is_copy && this.constructor.define().copyForAllChildren);

        while (checkTree && !(elem instanceof TextBox) && elem !== this && elem.parentWidget) {
          console.log("  " + elem._id);

          elem = elem.parentWidget;
        }

        console.warn("COLOR", this._id, elem._id);

        if (elem !== this) {
          //remove global keyhandler
          this._clipboard_keyend();
          return;
        }
      } else {
        console.warn("COLOR", this._id);
      }

      this._last_clipboard_keyevt = e;

      if (is_copy) {
        this.clipboardCopy();
        e.preventDefault();
        e.stopPropagation();
      }

      if (is_paste) {
        this.clipboardPaste();
        e.preventDefault();
        e.stopPropagation();
      }
    };

    let start = (e) => {
      this._clipboard_over = true;
      this._clipboard_keystart();
    };

    let stop = (e) => {
      this._clipboard_over = false;
      this._clipboard_keyend();
    };

    this.tabIndex = 0; //enable self key events when element has focus

    this.addEventListener("keydown", (e) => {
      return this._clipboard_keydown(e, true);
    });

    this.addEventListener("pointerover", start, {capture: true, passive: true});
    this.addEventListener("pointerout", stop, {capture: true, passive: true});
    this.addEventListener("focus", stop, {capture: true, passive: true});
  }

  /** set havePickClipboard to true in define() to
   *  enable mouseover pick clipboarding */
  clipboardCopy() {
    throw new Error("implement me!");
  }

  clipboardPaste() {
    throw new Error("implement me!");
  }

  //delayed init
  init() {
    this._init_done = true;

    if (!this.hasAttribute("id") && this._id) {
      this.setAttribute("id", this._id);
    }

    if (this.constructor.define().havePickClipboard) {
      this._clipboardHotkeyInit();
    }
  }

  _ondestroy() {
    if (this.tabIndex >= 0) {
      this.regenTabOrder();
    }

    if (exports.DEBUG.paranoidEvents) {
      for (let item of this.__cbs) {
        this.removeEventListener(item[0], item[1], item[2]);
      }

      this.__cbs = [];
    }


    if (this.ondestroy !== undefined) {
      this.ondestroy();
    }
  }

  remove(trigger_on_destroy = true) {
    if (this.tabIndex >= 0) {
      this.regenTabOrder();
    }

    super.remove();

    if (trigger_on_destroy) {
      this._ondestroy();
    }

    if (this.on_remove) {
      this.on_remove();
    }

    this.parentWidget = undefined;
  }

  /*
  *
  * called when elements are removed.
  * you should assume the element will be reused later;
  * on_destroy is the callback for when elements are permanently destroyed
  * */
  on_remove() {

  }

  removeChild(child, trigger_on_destroy = true) {
    super.removeChild(child);

    if (trigger_on_destroy) {
      child._ondestroy();
    }
  }

  flushUpdate(force = false) {
    //check init
    this._init();

    this.update();

    this._forEachChildWidget((c) => {
      if (force || !(c.packflag & PackFlags.NO_UPDATE)) {
        c.flushUpdate(force);
      }
    });
  }

  //used by container nodes
  /**
   * Iterates over all child widgets,
   * including ones that might be inside
   * of normal DOM nodes.
   *
   * This is done by recursing into the dom
   * tree and stopping at any node that's
   * descended from ui_base.UIBase
   **/
  _forEachChildWidget(cb, thisvar) {
    let rec = (n) => {
      if (n instanceof UIBase$2) {
        if (thisvar !== undefined) {
          cb.call(thisvar, n);
        } else {
          cb(n);
        }
      } else {
        for (let n2 of n.childNodes) {
          rec(n2);
        }

        if (n.shadow !== undefined) {
          for (let n2 of n.shadow.childNodes) {
            rec(n2);
          }
        }
      }
    };

    for (let n of this.childNodes) {
      rec(n);
    }

    if (this.shadow) {
      for (let n of this.shadow.childNodes) {
        rec(n);
      }
    }
  }

  checkInit() {
    return this._init();
  }

  _init() {
    if (this._init_done) {
      return false;
    }

    this._init_done = true;
    this.init();

    return true;
  }

  getWinWidth() {
    return window.innerWidth;
  }

  getWinHeight() {
    return window.innerHeight;
  }

  calcZ() {
    let p = this;
    let n = this;

    while (n) {
      if (n.style && n.style["z-index"]) {
        let z = parseFloat(n.style["z-index"]);
        return z;
      }

      n = n.parentNode;

      if (!n) {
        n = p = p.parentWidget;
      }
    }

    return 0;
  }

  pickElement(x, y, args = {}, marginy = 0, nodeclass = UIBase$2, excluded_classes = undefined) {
    let marginx;
    let clip;
    let mouseEvent;
    let isMouseMove, isMouseDown;

    if (typeof args === "object") {
      marginx = args.sx || 0;
      marginy = args.sy || 0;
      nodeclass = args.nodeclass || UIBase$2;
      excluded_classes = args.excluded_classes;
      clip = args.clip;
      mouseEvent = args.mouseEvent;
    } else {
      marginx = args;

      args = {
        marginx         : marginx || 0,
        marginy         : marginy || 0,
        nodeclass       : nodeclass || UIBase$2,
        excluded_classes: excluded_classes,
        clip            : clip
      };
    }

    if (mouseEvent) {
      isMouseMove = mouseEvent.type === "mousemove" || mouseEvent.type === "touchmove" || mouseEvent.type === "pointermove";
      isMouseDown = mouseEvent.buttons || (mouseEvent.touches && mouseEvent.touches.length > 0);
    }

    x -= window.scrollX;
    y -= window.scrollY;

    let elem = document.elementFromPoint(x, y);

    if (!elem) {
      return;
    }

    let path = [elem];
    let lastelem = elem;
    let i = 0;

    while (elem.shadow) {
      if (i++ > 1000) {
        console.error("Infinite loop error");
        break;
      }

      elem = elem.shadow.elementFromPoint(x, y);

      if (elem === lastelem) {
        break;
      }

      if (elem) {
        path.push(elem);
      }

      lastelem = elem;
    }

    path.reverse();

    //console.warn(path);

    for (let i = 0; i < path.length; i++) {
      let node = path[i];
      let ok = node instanceof nodeclass;

      if (excluded_classes) {
        for (let cls of excluded_classes) {
          ok = ok && !(node instanceof cls);
        }
      }

      if (clip) {
        let rect = node.getBoundingClientRect();
        let clip2 = aabb_intersect_2d(clip.pos, clip.size, [rect.x, rect.y], [rect.width, rect.height]);

        ok = ok && clip2;
      }

      if (ok) {
        window.elem = node;
        //console.log(node._id);
        return node;
      }
    }
  }

  __updateDisable(val) {
    if (!!val === !!this.__disabledState) {
      return;
    }

    this.__disabledState = !!val;

    if (val && !this._disdata) {
      let style = this.getDefault("disabled") || this.getDefault("internalDisabled") || {
        "background-color": this.getDefault("DisabledBG")
      };

      this._disdata = {
        style   : {},
        defaults: {}
      };

      for (let k in style) {
        //save old style information
        this._disdata.style[k] = this.style[k];
        this._disdata.defaults[k] = this.default_overrides[k];

        let v = style[k];

        if (typeof v === "object" && v instanceof CSSFont) {
          this.style[k] = style[k].genCSS();
        } else {
          this.style[k] = style[k];
        }

        this.default_overrides[k] = style[k];
      }

      this.__disabledState = !!val;
      this.on_disabled();
    } else if (!val && this._disdata) {

      //load old style information
      for (let k in this._disdata.style) {
        this.style[k] = this._disdata.style[k];
      }

      for (let k in this._disdata.defaults) {
        let v = this._disdata.defaults[k];

        if (v === undefined) {
          delete this.default_overrides[k];
        } else {
          this.default_overrides[k] = v;
        }
      }

      //this.background = this.style["background-color"];
      this._disdata = undefined;

      this.__disabledState = !!val;
      this.on_enabled();
    }

    this.__disabledState = !!val;

    let visit = (n) => {
      if (n instanceof UIBase$2) {
        let changed = !!n.__disabledState;

        /*
        if (val) {
          n._parent_disabled_set = Math.max(n._parent_disabled_set + 1, 0);
        } else {
          n._parent_disabled_set = Math.max(n._parent_disabled_set - 1, 0);
        }//*/

        n.__updateDisable(n.disabled);

        changed = changed !== !!n.__disabledState;
        if (changed) {
          n.update();
          n.setCSS();
        }
      }
    };

    this._forEachChildWidget(visit);
  }

  on_disabled() {

  }

  on_enabled() {

  }

  pushModal(handlers = this, autoStopPropagation = true, pointerId = undefined, pointerElem = this) {
    if (this._modaldata !== undefined) {
      console.warn("UIBase.prototype.pushModal called when already in modal mode");
      this.popModal();
    }

    let _areaWrangler = contextWrangler.copy();

    contextWrangler.copy(this.ctx);

    function bindFunc(func) {
      return function () {
        _areaWrangler.copyTo(contextWrangler);

        return func.apply(handlers, arguments);
      }
    }

    let handlers2 = {};
    for (let k in handlers) {
      let func = handlers[k];

      if (typeof func !== "function") {
        continue;
      }

      handlers2[k] = bindFunc(func);
    }
    //this._modalstack.push(this.ctx);
    //this.ctx = this.ctx.toLocked();

    if (pointerId !== undefined && pointerElem) {
      this._modaldata = pushPointerModal(handlers2, autoStopPropagation);
    } else {
      this._modaldata = pushModalLight(handlers2, autoStopPropagation);
    }

    return this._modaldata;
  }

  popModal() {
    if (this._modaldata === undefined) {
      console.warn("Invalid call to UIBase.prototype.popModal");
      return;
    }

    this.ctx = this._modalstack.pop();
    popModalLight(this._modaldata);
    this._modaldata = undefined;
  }

  /** child classes can override this to prevent focus on flash*/
  _flash_focus() {
    this.focus();
  }

  flash(color, rect_element = this, timems = 355, autoFocus = true) {
    if (typeof color != "object") {
      color = css2color(color);
    }
    color = new Vector4$1(color);
    let csscolor = color2css(color);

    if (this._flashtimer !== undefined && this._flashcolor !== csscolor) {
      window.setTimeout(() => {
        this.flash(color, rect_element, timems, autoFocus);
      }, 100);

      return;
    } else if (this._flashtimer !== undefined) {
      return;
    }

    //let rect = rect_element.getClientRects()[0];
    let rect = rect_element.getBoundingClientRect();

    if (rect === undefined) {
      return;
    }

    //okay, dom apparently calls onchange() on .remove, so we have
    //to put the timer code first to avoid loops
    let timer;
    let tick = 0;
    let max = ~~(timems/20);

    let x = rect.x, y = rect.y;

    let cb = (e) => {
      if (timer === undefined) {
        return
      }

      let a = 1.0 - tick/max;
      div.style["background-color"] = color2css(color, a*a*0.5);

      if (tick > max) {
        window.clearInterval(timer);

        this._flashtimer = undefined;
        this._flashcolor = undefined;
        timer = undefined;

        div.remove();

        if (autoFocus) {
          this._flash_focus();
        }
      }

      tick++;
    };

    setTimeout(cb, 5);
    this._flashtimer = timer = window.setInterval(cb, 20);

    let div = document.createElement("div");

    div.style["pointer-events"] = "none";
    div.tabIndex = undefined;
    div.style["z-index"] = "900";
    div.style["display"] = "float";
    div.style["position"] = UIBase$2.PositionKey;
    div.style["margin"] = "0px";
    div.style["left"] = x + "px";
    div.style["top"] = y + "px";

    div.style["background-color"] = color2css(color, 0.5);
    div.style["width"] = rect.width + "px";
    div.style["height"] = rect.height + "px";
    div.setAttribute("class", "UIBaseFlash");

    let screen = this.getScreen();
    if (screen !== undefined) {
      screen._enterPopupSafe();
    }

    document.body.appendChild(div);
    if (autoFocus) {
      this._flash_focus();
    }

    this._flashcolor = csscolor;

    if (screen !== undefined) {
      screen._exitPopupSafe();
    }
  }

  destroy() {
  }

  on_resize(newsize) {
  }

  toJSON() {
    let ret = {};

    if (this.hasAttribute("datapath")) {
      ret.datapath = this.getAttribute("datapath");
    }

    return ret;
  }

  loadJSON(obj) {
    if (!this._init_done) {
      this._init();
    }
  }

  getPathValue(ctx, path) {
    try {
      return ctx.api.getValue(ctx, path);
    } catch (error) {
      //report("data path error in ui for" + path);
      return undefined;
    }
  }

  undoBreakPoint() {
    this.pathUndoGen++;
  }

  setPathValueUndo(ctx, path, val) {
    let mass_set_path = this.getAttribute("mass_set_path");
    let rdef = ctx.api.resolvePath(ctx, path);
    let prop = rdef.prop;

    if (ctx.api.getValue(ctx, path) === val) {
      return;
    }

    let toolstack = this.ctx.toolstack;
    let head = toolstack.head;

    let bad = head === undefined || !(head instanceof getDataPathToolOp());
    bad = bad || head.hashThis() !== head.hash(mass_set_path, path, prop.type, this._id);
    bad = bad || this.pathUndoGen !== this._lastPathUndoGen;

    //if (head !== undefined && head instanceof getDataPathToolOp()) {
    //console.log("===>", bad, head.hashThis());
    //console.log("    ->", head.hash(mass_set_path, path, prop.type, this._id));
    //}

    if (!bad) {
      toolstack.undo();
      head.setValue(ctx, val, rdef.obj);
      toolstack.redo();
    } else {
      this._lastPathUndoGen = this.pathUndoGen;

      let toolop = getDataPathToolOp().create(ctx, path, val, this._id, mass_set_path);
      ctx.toolstack.execTool(this.ctx, toolop);
      head = toolstack.head;
    }

    if (!head || head.hadError === true) {
      throw new Error("toolpath error");
    }
  }

  /*
    adds a method call to the event queue,
    but only if that method (for this instance, as differentiated
    by ._id) isn't there already.

    also, method won't be ran until this.ctx exists
  */

  pushReportContext(key) {
    if (this.ctx.api.pushReportContext) {
      this.ctx.api.pushReportContext(key);
    }
  }

  popReportContext() {
    if (this.ctx.api.popReportContext)
      this.ctx.api.popReportContext();
  }

  setPathValue(ctx, path, val) {
    if (this.useDataPathUndo) {
      this.pushReportContext(this._reportCtxName);

      try {
        this.setPathValueUndo(ctx, path, val);
      } catch (error) {
        this.popReportContext();

        if (!(error instanceof DataPathError)) {
          throw error;
        } else {
          return;
        }
      }

      this.popReportContext();
      return;
    }

    this.pushReportContext(this._reportCtxName);

    try {
      if (this.hasAttribute("mass_set_path")) {
        ctx.api.massSetProp(ctx, this.getAttribute("mass_set_path"), val);
        ctx.api.setValue(ctx, path, val);
      } else {
        ctx.api.setValue(ctx, path, val);
      }
    } catch (error) {
      this.popReportContext();

      if (!(error instanceof DataPathError)) {
        throw error;
      }

      return;
    }

    this.popReportContext();
  }

  getPathMeta(ctx, path) {
    this.pushReportContext(this._reportCtxName);
    let ret = ctx.api.resolvePath(ctx, path);
    this.popReportContext();

    return ret !== undefined ? ret.prop : undefined;
  }

  getPathDescription(ctx, path) {
    let ret;
    this.pushReportContext(this._reportCtxName);

    try {
      ret = ctx.api.getDescription(ctx, path);
    } catch (error) {
      this.popReportContext();

      if (error instanceof DataPathError) {
        //console.warn("Invalid data path '" + path + "'");
        return undefined;
      } else {
        throw error;
      }
    }

    this.popReportContext();
    return ret;
  }

  getScreen() {
    if (this.ctx !== undefined)
      return this.ctx.screen;
  }

  isDead() {
    return !this.isConnected;
    let p = this, lastp = this;

    function find(c, n) {
      for (let n2 of c) {
        if (n2 === n) {
          return true;
        }
      }
    }

    while (p) {
      lastp = p;

      let parent = p.parentWidget;
      if (!parent) {
        parent = p.parentElement ? p.parentElement : p.parentNode;
      }

      if (parent && p && !find(parent.childNodes, p)) {
        if (parent.shadow !== undefined && !find(parent.shadow.childNodes)) {
          return true;
        }
      }
      p = parent;

      if (p === document.body) {
        return false;
      }
    }

    return true;
  }

  doOnce(func, timeout = undefined) {
    if (func._doOnce === undefined) {
      func._doOnce_reqs = new Set();

      func._doOnce = function (thisvar, trace) {
        if (func._doOnce_reqs.has(thisvar._id)) {
          return;
        }

        func._doOnce_reqs.add(thisvar._id);

        function f() {
          if (thisvar.isDead()) {
            func._doOnce_reqs.delete(thisvar._id);

            if (func === thisvar._init || !exports.DEBUG.doOnce) {
              return;
            }

            console.warn("Ignoring doOnce call for dead element", thisvar._id, func, trace);
            return;
          }

          if (!thisvar.ctx) {
            if (exports.DEBUG.doOnce) {
              console.warn("doOnce call is waiting for context...", thisvar._id, func);
            }

            window.setTimeout(f, 0);
            return;
          }

          func._doOnce_reqs.delete(thisvar._id);
          func.call(thisvar);
        };

        window.setTimeout(f, timeout);
      };
    }

    let trace = new Error().stack;
    func._doOnce(this, trace);
  }

  float(x = 0, y = 0, zindex = undefined, positionKey = UIBase$2.PositionKey) {
    this.style.position = positionKey;

    this.style.left = x + "px";
    this.style.top = y + "px";

    if (zindex !== undefined) {
      this.style["z-index"] = zindex;
    }

    return this;
  }

  _ensureChildrenCtx() {
    let ctx = this.ctx;
    if (ctx === undefined) {
      return;
    }

    this._forEachChildWidget((n) => {
      n.parentWidget = this;

      if (n.ctx === undefined) {
        n.ctx = ctx;
      }

      n._ensureChildrenCtx(ctx);
    });
  }

  checkThemeUpdate() {
    if (!exports.enableThemeAutoUpdate) {
      return false;
    }

    if (_themeUpdateKey !== this._last_theme_update_key) {
      this._last_theme_update_key = _themeUpdateKey;
      return true;
    }

    return false;
  }

  abortToolTips(delayMs = 500) {
    if (this._has_own_tooltips) {
      this._has_own_tooltips.stop_timer();
    }

    if (this._tooltip_ref) {
      this._tooltip_ref.remove();
      this._tooltip_ref = undefined;
    }

    this._tool_tip_abort_delay = time_ms() + delayMs;

    return this;
  }

  updateToolTipHandlers() {
    if (!this._useNativeToolTips_set && !exports.useNativeToolTips !== !this._useNativeToolTips) {
      this._useNativeToolTips = exports.useNativeToolTips;
    }

    if (!!this.useNativeToolTips === !this._has_own_tooltips) {
      return;
    }

    if (!this.useNativeToolTips) {
      let state = this._has_own_tooltips = {
        start_timer : (e) => {
          this._tooltip_timer = time_ms();
          //console.warn(this._id, "tooltip timer start", e.type);
        },
        stop_timer  : (e) => {
          //console.warn(this._id, "tooltip timer end", util.time_ms()-this._tooltip_timer, e.type);
          this._tooltip_timer = undefined;
        },
        reset_timer : (e) => {
          //console.warn(this._id, "tooltip timer reset", util.time_ms()-this._tooltip_timer, e.type);
          if (this._tooltip_timer !== undefined) {
            this._tooltip_timer = time_ms();
          }
        },
        start_events: [
          "mouseover"
        ],
        reset_events: [
          "mousemove", "mousedown", "mouseup",
          "touchstart", "touchend", "keydown", "focus"
        ],
        stop_events : [
          "mouseleave", "blur", "mouseout"
        ],
        handlers    : {}
      };

      let bind_handler = (type, etype) => {
        let handler = (e) => {
          if (this._tool_tip_abort_delay !== undefined && time_ms() < this._tool_tip_abort_delay) {
            this._tooltip_timer = undefined;
            return;
          }

          state[type](e);
        };

        if (etype in state.handlers) {
          console.error(type, "is in handlers already");
          return;
        }

        state.handlers[etype] = handler;
        return handler;
      };

      let i = 0;
      let lists = [state.start_events, state.stop_events, state.reset_events];

      for (let type of ["start_timer", "stop_timer", "reset_timer"]) {
        for (let etype of lists[i]) {
          this.addEventListener(etype, bind_handler(type, etype), {passive: true});
        }

        i++;
      }
    } else {
      console.warn(this.id, "removing tooltip handlers");
      let state = this._has_own_tooltips;

      for (let k in this.state.handlers) {
        let handler = this.state.handlers[k];
        this.removeEventListener(k, handler);
      }

      this._has_own_tooltips = undefined;
      this._tooltip_timer = undefined;
    }
  }

  updateToolTips() {
    if (this._description_final === undefined || this._description_final === null ||
      this._description_final.trim().length === 0) {
      return;
    }

    if (!this.ctx || !this.ctx.screen) {
      return;
    }

    this.updateToolTipHandlers();

    if (this.useNativeToolTips || this._tooltip_timer === undefined) {
      return;
    }

    if (this._tool_tip_abort_delay !== undefined && time_ms() < this._tool_tip_abort_delay) {
      return;
    }

    this._tool_tip_abort_delay = undefined;

    let screen = this.ctx.screen;

    const timelimit = 500;
    let ok = time_ms() - this._tooltip_timer > timelimit;

    let x = screen.mpos[0], y = screen.mpos[1];

    let r = this.getClientRects();
    r = r ? r[0] : r;

    if (!r) {
      ok = false;
    } else {
      ok = ok && x >= r.x && x < r.x + r.width;
      ok = ok && y >= r.y && y < r.y + r.height;
    }


    //console.log(r);
    if (r) {
      //console.warn(this._id, "possible tooltip", x, y, r.x-3, r.y-3, r.width, r.height);
    }

    ok = ok && !haveModal();
    ok = ok && screen.pickElement(x, y) === this;
    ok = ok && this._description_final;

    if (ok) {
      //console.warn("Showing tooltop", this.id);
      this._tooltip_ref = _ToolTip.show(this._description_final, this.ctx.screen, x, y);
    } else {
      if (this._tooltip_ref) {
        this._tooltip_ref.remove();
      }

      this._tooltip_ref = undefined;
    }

    //console.warn(this._id, "tooltip timer end");
    if (time_ms() - this._tooltip_timer > timelimit) {
      this._tooltip_timer = undefined;
    }
  }

  //called regularly
  update() {
    this.updateToolTips();

    if (this.ctx && this._description === undefined && this.getAttribute("datapath")) {
      let d = this.getPathDescription(this.ctx, this.getAttribute("datapath"));

      this.description = d;
    }

    if (!this._init_done) {
      this._init();
    }

    if (this._init_done && !this.constructor.define().subclassChecksTheme) {
      if (this.checkThemeUpdate()) {
        console.log("theme update!");

        this.setCSS();
      }
    }
  }

  onadd() {
    //if (this.parentWidget !== undefined) {
    //  this._useDataPathUndo = this.parentWidget._useDataPathUndo;
    //}

    if (!this._init_done) {
      this.doOnce(this._init);
    }

    if (this.tabIndex >= 0) {
      this.regenTabOrder();
    }
  }

  getZoom() {
    if (this.parentWidget !== undefined) {
      return this.parentWidget.getZoom();
    }

    return 1.0;
  }

  /**try to use this method

   scaling ratio (e.g. for high-resolution displays)
   for zoom ratio use getZoom()
   */
  getDPI() {
    if (this.parentWidget !== undefined) {
      return this.parentWidget.getDPI();
    }

    return UIBase$2.getDPI();
  }

  /**
   * for saving ui state.
   * see saveUIData() export
   *
   * should fail gracefully.
   */
  saveData() {
    return {};
  }

  /**
   * for saving ui state.
   * see saveUIData() export
   *
   * should fail gracefully.
   *
   * also, it doesn't rebuild the object graph,
   * it patches it; for true serialization use
   * the toJSON/loadJSON or STRUCT interfaces.
   */
  loadData(obj) {
    return this;
  }

  overrideDefault(key, val, localOnly = false) {
    this.my_default_overrides[key] = val;

    if (!localOnly) {
      this.default_overrides[key] = val;
    }

    return this;
  }

  overrideClass(style) {
    this._override_class = style;
  }

  overrideClassDefault(style, key, val) {
    if (!(style in this.class_default_overrides)) {
      this.class_default_overrides[style] = {};
    }

    this.class_default_overrides[style][key] = val;
  }

  _doMobileDefault(key, val) {
    if (!isMobile())
      return val;

    key = key.toLowerCase();
    let ok = false;

    for (let re of _mobile_theme_patterns) {
      if (key.search(re) >= 0) {
        ok = true;
        break;
      }
    }

    if (ok) {
      val *= theme.base.mobileSizeMultiplier;
    }

    return val;
  }

  hasDefault(key) {
    let p = this;

    while (p) {
      if (key in p.default_overrides) {
        return true;
      }

      p = p.parentWidget;
    }

    return this.hasClassDefault(key);
  }

  /** get a sub style from a theme style class.
   *  note that if key is falsy then it just forwards to this.getDefault directly*/
  getSubDefault(key, subkey, backupkey = subkey, defaultval = undefined) {
    if (!key) {
      return this.getDefault(subkey, undefined, defaultval);
    }

    let style = this.getDefault(key);

    if (!style || typeof style !== "object" || !(subkey in style)) {
      if (defaultval !== undefined) {
        return defaultval;
      } else if (backupkey !== undefined) {
        return this.getDefault(backupkey);
      }
    } else {
      return style[subkey];
    }
  }

  getDefault(key, checkForMobile = true, defaultval = undefined) {
    let ret = this.getDefault_intern(key, checkForMobile, defaultval);

    //convert pixel units straight to numbers
    if (typeof ret === "string" && ret.trim().toLowerCase().endsWith("px")) {
      let s = ret.trim().toLowerCase();
      s = s.slice(0, s.length - 2).trim();

      let f = parseFloat(s);
      if (!isNaN(f) && isFinite(f)) {
        return f;
      }
    }

    return ret;
  }

  getDefault_intern(key, checkForMobile = true, defaultval = undefined) {
    if (this.my_default_overrides[key] !== undefined) {
      let v = this.my_default_overrides[key];
      return checkForMobile ? this._doMobileDefault(key, v) : v;
    }

    let p = this;
    while (p) {
      if (p.default_overrides[key] !== undefined) {
        let v = p.default_overrides[key];
        checkForMobile ? this._doMobileDefault(key, v) : v;
      }

      p = p.parentWidget;
    }

    return this.getClassDefault(key, checkForMobile, defaultval);
  }

  getStyleClass() {
    if (this._override_class !== undefined) {
      return this._override_class;
    }

    let p = this.constructor, lastp = undefined;

    while (p && p !== lastp && p !== UIBase$2 && p !== Object) {
      let def = p.define();

      if (def.style) {
        return def.style;
      }

      if (!p.prototype || !p.prototype.__proto__)
        break;

      p = p.prototype.__proto__.constructor;
    }

    return "base";
  }

  hasClassDefault(key) {
    let style = this.getStyleClass();

    let p = this;
    while (p) {
      let def = p.class_default_overrides[style];

      if (def && (key in def)) {
        return true;
      }

      p = p.parentWidget;
    }

    let th = this._themeOverride;

    if (th && style in th && key in th[style]) {
      return true;
    }

    if (style in theme && key in theme[style]) {
      return true;
    }

    return key in theme.base;
  }

  getClassDefault(key, checkForMobile = true, defaultval = undefined) {
    let style = this.getStyleClass();

    if (style === "none") {
      return undefined;
    }

    let val = undefined;
    let p = this;
    while (p) {
      let def = p.class_default_overrides[style];

      if (def && (key in def)) {
        val = def[key];
        break;
      }

      p = p.parentWidget;
    }

    if (val === undefined && style in theme && !(key in theme[style]) && !(key in theme.base)) {
      if (window.DEBUG.theme) {
        report$1("Missing theme key ", key, "for", style);
      }
    }

    for (let i = 0; i < 2; i++) {
      let th = !i ? this._themeOverride : theme;

      if (!th) {
        continue;
      }

      if (val === undefined && style in th && key in th[style]) {
        val = th[style][key];
      } else if (defaultval !== undefined) {
        val = defaultval;
      } else if (val === undefined) {
        let def = this.constructor.define();

        if (def.parentStyle && key in th[def.parentStyle]) {
          val = th[def.parentStyle][key];
        } else {
          val = th.base[key];
        }
      }
    }

    return checkForMobile ? this._doMobileDefault(key, val) : val;
  }

  overrideTheme(theme) {
    this._themeOverride = theme;

    this._forEachChildWidget((child) => {
      child.overrideTheme(theme);
    });

    if (this.ctx) {
      this.flushSetCSS();
      this.flushUpdate();
    }

    return this;
  }

  getStyle() {
    console.warn("deprecated call to UIBase.getStyle");
    return this.getStyleClass();
  }

  /** returns a new Animator instance
   *
   * example:
   *
   * container.animate().goto("style.width", 500, 100, "ease");
   * */
  animate(_extra_handlers = {}) {
    let transform = new DOMMatrix(this.style["transform"]);

    let update_trans = () => {
      let t = transform;
      let css = "matrix(" + t.a + "," + t.b + "," + t.c + "," + t.d + "," + t.e + "," + t.f + ")";
      this.style["transform"] = css;
    };

    let handlers = {
      background_get() {
        return css2color(this.background);
      },

      background_set(c) {
        if (typeof c !== "string") {
          c = color2css(c);
        }
        this.background = c;
      },

      dx_get() {
        return transform.m41;
      },
      dx_set(x) {
        transform.m41 = x;
        update_trans();
      },

      dy_get() {
        return transform.m42;
      },
      dy_set(x) {
        transform.m42 = x;
        update_trans();
      }
    };

    let pixkeys = ["width", "height", "left", "top", "right", "bottom", "border-radius",
                   "border-width", "margin", "padding", "margin-left", "margin-right",
                   "margin-top", "margin-bottom", "padding-left", "padding-right", "padding-bottom",
                   "padding-top"];
    handlers = Object.assign(handlers, _extra_handlers);

    let makePixHandler = (k, k2) => {
      handlers[k2 + "_get"] = () => {
        let s = this.style[k];

        if (s.endsWith("px")) {
          return parsepx$1(s);
        } else {
          return 0.0;
        }
      };

      handlers[k2 + "_set"] = (val) => {
        this.style[k] = val + "px";
      };
    };

    for (let k of pixkeys) {
      if (!(k in handlers)) {
        makePixHandler(k, `style.${k}`);
        makePixHandler(k, `style["${k}"]`);
        makePixHandler(k, `style['${k}']`);
      }
    }

    let handler = {
      get: (target, key, receiver) => {
        console.log(key, handlers[key + "_get"], handlers);

        if ((key + "_get") in handlers) {
          return handlers[key + "_get"].call(target);
        } else {
          return target[key];
        }
      },
      set: (target, key, val, receiver) => {
        console.log(key);

        if ((key + "_set") in handlers) {
          handlers[key + "_set"].call(target, val);
        } else {
          target[key] = val;
        }

        return true;
      }
    };

    let proxy = new Proxy(this, handler);
    let anim = new Animator(proxy);

    anim.onend = () => {
      this._active_animations.remove(anim);
    };

    this._active_animations.push(anim);
    return anim;
  }

  abortAnimations() {
    for (let anim of list(this._active_animations)) {
      anim.end();
    }

    this._active_animations = [];
  }
}

function drawRoundBox2(elem, options = {}) {
  drawRoundBox(elem, options.canvas, options.g, options.width, options.height, options.r, options.op, options.color, options.margin, options.no_clear);
}

/**okay, I need to refactor this function,
 it needs to take x, y as well as width, height,
 and be usable for more use cases.*/
function drawRoundBox(elem, canvas, g, width, height, r      = undefined,
                             op = "fill", color = undefined, margin = undefined,
                             no_clear                               = false) {
  width = width === undefined ? canvas.width : width;
  height = height === undefined ? canvas.height : height;
  g.save();

  let dpi = elem.getDPI();

  r = r === undefined ? elem.getDefault("border-radius") : r;

  if (margin === undefined) {
    margin = 1;
  }

  r *= dpi;
  let r1 = r, r2 = r;

  if (r > (height - margin*2)*0.5) {
    r1 = (height - margin*2)*0.5;
  }

  if (r > (width - margin*2)*0.5) {
    r2 = (width - margin*2)*0.5;
  }

  let bg = color;

  if (bg === undefined && canvas._background !== undefined) {
    bg = canvas._background;
  } else if (bg === undefined) {
    bg = elem.getDefault("background-color");
  }

  if (op === "fill" && !no_clear) {
    g.clearRect(0, 0, width, height);
  }

  g.fillStyle = bg;
  //hackish!
  g.strokeStyle = color === undefined ? elem.getDefault("border-color") : color;

  let w = width, h = height;

  let th = Math.PI/4;
  let th2 = Math.PI*0.75;

  g.beginPath();

  g.moveTo(margin, margin + r1);
  g.lineTo(margin, h - r1 - margin);

  g.quadraticCurveTo(margin, h - margin, margin + r2, h - margin);
  g.lineTo(w - margin - r2, h - margin);

  g.quadraticCurveTo(w - margin, h - margin, w - margin, h - margin - r1);
  g.lineTo(w - margin, margin + r1);

  g.quadraticCurveTo(w - margin, margin, w - margin - r2, margin);
  g.lineTo(margin + r2, margin);

  g.quadraticCurveTo(margin, margin, margin, margin + r1);
  g.closePath();

  if (op === "clip") {
    g.clip();
  } else if (op === "fill") {
    g.fill();
  } else {
    g.stroke();
  }

  g.restore();
};

function _getFont_new(elem, size, font = "DefaultText", do_dpi = true) {

  font = elem.getDefault(font);

  return font.genCSS(size);
}

function getFont(elem, size, font = "DefaultText", do_dpi = true) {
  return _getFont_new(elem, size, font = "DefaultText", do_dpi = true);
}

//size is optional, defaults to font's default size
function _getFont(elem, size, font = "DefaultText", do_dpi = true) {
  let dpi = elem.getDPI();

  let font2 = elem.getDefault(font);
  if (font2 !== undefined) {
    //console.warn("New style font detected", font2, font2.genCSS(size));
    return _getFont_new(elem, size, font, do_dpi);
  }

  throw new Error("unknown font " + font);
}

function _ensureFont(elem, canvas, g, size) {
  if (canvas.font) {
    g.font = canvas.font;
  } else {
    let font = elem.getDefault("DefaultText");
    g.font = font.genCSS(size);
  }
}

let _mc;

function get_measure_canvas() {
  if (_mc !== undefined) {
    return _mc;
  }

  _mc = document.createElement("canvas");
  _mc.width = 256;
  _mc.height = 256;
  _mc.g = _mc.getContext("2d");

  return _mc;
}

function measureTextBlock(elem, text, canvas                    = undefined,
                                 g = undefined, size = undefined, font = undefined) {
  let lines = text.split("\n");

  let ret = {
    width : 0,
    height: 0
  };

  if (size === undefined) {
    if (font !== undefined && typeof font === "object") {
      size = font.size;
    }

    if (size === undefined) {
      size = elem.getDefault("DefaultText").size;
    }
  }

  for (let line of lines) {
    let m = measureText(elem, line, canvas, g, size, font);

    ret.width = Math.max(ret.width, m.width);
    let h = m.height !== undefined ? m.height : size*1.25;

    ret.height += h;
  }

  return ret;
}

function measureText(elem, text, canvas                    = undefined,
                            g = undefined, size = undefined, font = undefined) {
  if (typeof canvas === "object" && canvas !== null && !(canvas instanceof HTMLCanvasElement) && canvas.tagName !== "CANVAS") {
    let args = canvas;

    canvas = args.canvas;
    g = args.g;
    size = args.size;
    font = args.font;

  }

  if (g === undefined) {
    canvas = get_measure_canvas();
    g = canvas.g;
  }

  if (font !== undefined) {
    if (typeof font === "object" && font instanceof CSSFont) {
      font = font.genCSS(size);
    }

    g.font = font;
  } else {
    _ensureFont(elem, canvas, g, size);
  }

  let ret = g.measureText(text);

  if (ret && isMobile()) {
    let ret2 = {};
    let dpi = UIBase$2.getDPI();

    for (let k in ret) {
      let v = ret[k];

      if (typeof v === "number") {
        v *= dpi;
        //v *= window.devicePixelRatio;
      }

      ret2[k] = v;
    }

    ret = ret2;
  }

  if (size !== undefined) {
    //clear custom font for next time
    g.font = undefined;
  }

  return ret;
}

//export function drawText(elem, x, y, text, canvas, g, color=undefined, size=undefined, font=undefined) {
function drawText(elem, x, y, text, args = {}) {
  let canvas = args.canvas, g = args.g, color = args.color, font = args.font;
  let size = args.size;

  if (size === undefined) {
    if (font !== undefined && font instanceof CSSFont) {
      size = font.size;
    } else {
      size = elem.getDefault("DefaultText").size;
    }
  }

  size *= UIBase$2.getDPI();


  if (color === undefined) {
    if (font && font.color) {
      color = font.color;
    } else {
      color = elem.getDefault("DefaultText").color;
    }
  }

  if (font === undefined) {
    _ensureFont(elem, canvas, g, size);
  } else if (typeof font === "object" && font instanceof CSSFont) {
    g.font = font = font.genCSS(size);
  } else if (font) {
    g.font = font;
  }

  if (typeof color === "object") {
    color = color2css(color);
  }


  g.fillStyle = color;
  g.fillText(text, x + 0.5, y + 0.5);

  if (size !== undefined) {
    //clear custom font for next time
    g.font = undefined;
  }
}

let PIDX = 0, PSHADOW = 1, PTOT = 2;

/**

 Saves UI layout data, like panel layouts, active tabs, etc.
 Uses the UIBase.prototype.[save/load]Data interface.

 Note that this is error-tolerant.
 */
function saveUIData(node, key) {
  if (key === undefined) {
    throw new Error("ui_base.saveUIData(): key cannot be undefined");
  }

  let paths = [];

  let rec = (n, path, ni, is_shadow) => {
    path = path.slice(0, path.length); //copy path

    let pi = path.length;
    for (let i = 0; i < PTOT; i++) {
      path.push(undefined);
    }

    path[pi] = ni;
    path[pi + 1] = is_shadow ? 1 : 0;

    if (n instanceof UIBase$2) {
      let path2 = path.slice(0, path.length);
      let data = n.saveData();

      let bad = !data;
      bad = bad || (typeof data === "object" && Object.keys(data).length === 0);

      if (!bad) {
        path2.push(data);

        if (path2[pi + 2]) {
          paths.push(path2);
        }
      }
    }

    for (let i = 0; i < n.childNodes.length; i++) {
      let n2 = n.childNodes[i];

      rec(n2, path, i, false);
    }

    let shadow = n.shadow;

    if (!shadow)
      return;

    for (let i = 0; i < shadow.childNodes.length; i++) {
      let n2 = shadow.childNodes[i];

      rec(n2, path, i, true);
    }
  };

  rec(node, [], 0, false);

  return JSON.stringify({
    key        : key,
    paths      : paths,
    _ui_version: 1
  });
}

window._saveUIData = saveUIData;

function loadUIData(node, buf) {
  if (buf === undefined || buf === null) {
    return;
  }

  let obj = JSON.parse(buf);
  let key = buf.key;

  for (let path of obj.paths) {
    let n = node;

    let data = path[path.length - 1];
    path = path.slice(2, path.length - 1); //in case some api doesn't want me calling .pop()

    for (let pi = 0; pi < path.length; pi += PTOT) {
      let ni = path[pi], shadow = path[pi + 1];

      let list;

      if (shadow) {
        list = n.shadow;

        if (list) {
          list = list.childNodes;
        }
      } else {
        list = n.childNodes;
      }

      if (list === undefined || list[ni] === undefined) {
        //console.log("failed to load a ui data block", path);
        n = undefined;
        break;
      }

      n = list[ni];
    }

    if (n !== undefined && n instanceof UIBase$2) {
      n._init(); //ensure init's been called, _init will check if it has
      n.loadData(data);

      //console.log(n, path, data);
    }
  }
}

UIBase$2.PositionKey = "fixed";

window._loadUIData = loadUIData;

//avoid explicit circular references
_setUIBase(UIBase$2);
//ui_save.setUIBase(UIBase);

"use strict";

let keymap$1 = keymap;

let EnumProperty$2 = EnumProperty,
    PropTypes$1 = PropTypes;

let UIBase$3 = UIBase$2,
    PackFlags$1 = PackFlags,
    IconSheets$1 = IconSheets;

let parsepx$2 = parsepx$1;

exports.DEBUG.buttonEvents = true;

class ButtonEventBase extends UIBase$3 {
  constructor() {
    super();

    this._auto_depress = true;
    this._highlight = false;
    this._pressed = false;
  }

  bindEvents() {
    let press_gen = 0;
    let depress;

    let press = (e) => {
      e.stopPropagation();

      if (!this.modalRunning) {
        let this2 = this;

        this.pushModal({
          on_pointerdown(e) {
            this.end(e);
          },

          on_pointerup(e) {
            this.end(e);
          },

          on_pointercancel(e) {
            console.warn("Pointer cancel in button");
            this2.popModal();
          },

          on_keydown(e) {
            switch (e.keyCode) {
              case keymap$1["Enter"]:
              case keymap$1["Escape"]:
              case keymap$1["Space"]:
                this.end();
                break;
            }
          },

          end(e) {
            if (!this2.modalRunning) {
              return;
            }

            this2.popModal();
            depress(e);
          }
        }, undefined, e.pointerId);
      }

      if (exports.DEBUG.buttonEvents) {
        console.log("button press", this._pressed, this.disabled, e.button);
      }

      if (this.disabled) return;

      this._pressed = true;

      if (this._onpress) {
        this._onpress(this);
      }

      this._redraw();

      e.preventDefault();
    };

    depress = (e) => {
      if (exports.DEBUG.buttonEvents)
        console.log("button depress", e.button, e.was_touch);

      if (this._auto_depress) {
        this._pressed = false;

        if (this.disabled) return;

        this._redraw();
      }

      e.preventDefault();
      e.stopPropagation();

      if (isMobile() || e.type === "pointerup" && e.button) {
        return;
      }

      this._redraw();

      if (exports.DEBUG.buttonEvents)
        console.log("button click callback:", this.onclick, this._onpress, this.onpress);

      if (this.onclick && e.pointerType !== "mouse") {
        this.onclick(this);
      }

      this.undoBreakPoint();
    };

    this.addEventListener("click", () => {
      this._pressed = false;
      this._highlight = false;
      this._redraw();
    });

    this.addEventListener("pointerdown", press, {captured : true, passive : false});
    this.addEventListener("pointerup", depress, {captured : true, passive : false});
    this.addEventListener("pointerover", (e) => {
      if (this.disabled)
        return;

      this._highlight = true;
      this._redraw();
    });

    this.addEventListener("pointerout", (e) => {
      if (this.disabled)
        return;

      this._highlight = false;
      this._redraw();
    });

    this.addEventListener("keydown", (e) => {
      if (this.disabled) return;

      if (exports.DEBUG.buttonEvents)
        console.log(e.keyCode);

      switch (e.keyCode) {
        case 27: //escape
          this.blur();
          e.preventDefault();
          e.stopPropagation();
          break;
        case 32: //spacebar
        case 13: //enter
          this.click();
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    });

    this.addEventListener("focusin", () => {
      if (this.disabled) return;

      this._focus = 1;
      this._redraw();
      this.focus();
    });

    this.addEventListener("blur", () => {
      if (this.disabled) return;

      this._focus = 0;
      this._redraw();
    });
  }

  _redraw() {

  }
}

class Button extends ButtonEventBase {
  constructor() {
    super();

    this.label = document.createElement("span");
    this.label.innerText = "button";
    this.shadow.appendChild(this.label);

    this.label.style["pointer-events"] = "none";

    this._pressed = false;
    this._highlight = false;

    this._auto_depress = true;

    this._last_name = undefined;
    this._last_disabled = undefined;
  }

  init() {
    super.init();
    this.tabIndex = 0;

    this.bindEvents();

    this.setCSS();
  }

  get name() {
    return "" + this.getAttribute("name");
  }

  set name(val) {
    this.setAttribute("name", val);
  }

  setCSS() {
    super.setCSS();

    let subkey = undefined;

    if (this.disabled) {
      subkey = "disabled";
    } else if (this._pressed && this._highlight) {
      subkey = "highlight-pressed";
    } else if (this._pressed) {
      subkey = "pressed";
    } else if (this._highlight) {
      subkey = "highlight";
    }

    let h = this.getDefault("height");

    this.setBoxCSS(subkey);

    this.label.style["padding"] = this.label.style["margin"] = "0px";
    this.style["background-color"] = this.getSubDefault(subkey, "background-color");

    let font = this.getSubDefault(subkey, "DefaultText");
    this.label.style["font"] = font.genCSS();
    this.label.style["color"] = font.color;

    this.style["display"] = "flex";
    this.style["align-items"] = "center";
    this.style["width"] = "max-content";
    this.style["height"] = h + "px";

    this.style["user-select"] = "none";
    this.label.style["user-select"] = "none";
  }

  click() {
    if (this._onpress) {
      let rect = this.getClientRects();
      let x = rect.x + rect.width*0.5;
      let y = rect.y + rect.height*0.5;

      let e = {x : x, y : y, stopPropagation : () => {}, preventDefault : () => {}};

      this._onpress(e);
    }

    super.click();
  }


  _redraw() {
    this.setCSS();
  }

  updateDisabled() {
    if (this._last_disabled !== this.disabled) {
      this._last_disabled = this.disabled;

      //setTimeout(() => {

      this._redraw();

      if (exports.DEBUG.buttonEvents)
        console.log("disabled update!", this.disabled, this.style["background-color"]);
      //}, 100);
    }
  }

  update() {
    if (this._last_name !== this.name) {
      this.label.innerHTML = this.name;
      this._last_name = this.name;
    }
  }

  static define() {
    return {
      tagname: "button-x",
      style  : "button"
    };
  }
}
UIBase$3.register(Button);

//use .setAttribute("linear") to disable nonlinear sliding
class OldButton extends ButtonEventBase {
  constructor() {
    super();

    let dpi = this.getDPI();

    this._last_but_update_key = "";

    this._name = "";
    this._namePad = undefined;
    this._leftPad = 5; //extra pad before text
    this._rightPad = 5; //extra pad after text

    this._last_w = 0;
    this._last_h = 0;

    this._last_dpi = dpi;

    this._lastw = undefined;
    this._lasth = undefined;

    this.dom = document.createElement("canvas");
    this.g = this.dom.getContext("2d");

    this.dom.setAttribute("class", "canvas1");
    this.dom.tabIndex = 0;

    this._last_bg = undefined;

    this.addEventListener("keydown", (e) => {
      if (this.disabled) return;

      if (exports.DEBUG.buttonEvents)
        console.log(e.keyCode);

      switch (e.keyCode) {
        case 27: //escape
          this.blur();
          e.preventDefault();
          e.stopPropagation();
          break;
        case 32: //spacebar
        case 13: //enter
          this.click();
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    });

    this.addEventListener("focusin", () => {
      if (this.disabled) return;

      this._focus = 1;
      this._redraw();
      this.focus();
    });

    this.addEventListener("blur", () => {
      if (this.disabled) return;

      this._focus = 0;
      this._redraw();
    });

    this._last_disabled = false;
    this._auto_depress = true;

    this.shadow.appendChild(this.dom);
  }

  click() {
    if (this._onpress) {
      let rect = this.getClientRects();
      let x = rect.x + rect.width*0.5;
      let y = rect.y + rect.height*0.5;

      let e = {x : x, y : y, stopPropagation : () => {}, preventDefault : () => {}};

      this._onpress(e);
    }

    super.click();
  }

  init() {
    let dpi = this.getDPI();

    //set default dimensions
    let width = ~~(this.getDefault("width"));
    let height = ~~(this.getDefault("height"));

    this.dom.style["width"] = width + "px";
    this.dom.style["height"] = height + "px";
    this.dom.style["padding"] = this.dom.style["margin"] = "0px";

    this.dom.width = Math.ceil(width*dpi); //parsepx(this.dom.style["width"])*dpi;
    this.dom.height = Math.ceil(parsepx$2(this.dom.style["height"])*dpi);

    this._name = undefined;
    this.updateName();

    this.bindEvents();
    this._redraw();
  }

  setAttribute(key, val) {
    super.setAttribute(key, val);

    if (key === "name") {
      this.updateName();
      this.updateWidth();
    }
  }

  get r() {
    return this.getDefault("border-radius");
  }

  set r(val) {
    this.overrideDefault("border-radius", val);
  }

  old_bindEvents() {
    let press_gen = 0;

    let press = (e) => {
      e.stopPropagation();

      if (exports.DEBUG.buttonEvents) {
        console.log("button press", this._pressed, this.disabled, e.button);
      }

      if (this.disabled) return;

      this._pressed = true;

      if (isMobile() && this.onclick && e.button === 0) {
        this.onclick();
      }

      if (this._onpress) {
        this._onpress(this);
      }

      this._redraw();

      e.preventDefault();
    };

    let depress = (e) => {
      if (exports.DEBUG.buttonEvents)
        console.log("button depress", e.button, e.was_touch);

      if (this._auto_depress) {
        this._pressed = false;

        if (this.disabled) return;

        this._redraw();
      }

      e.preventDefault();
      e.stopPropagation();

      if (isMobile() || e.type === "pointerup" && e.button) {
        return;
      }

      this._redraw();

      if (exports.DEBUG.buttonEvents) {
        console.log("button click callback:", this.onclick, this._onpress, this.onpress);
      }

      if (this.onclick && e.pointerType !== "mouse") {
        this.onclick(this);
      }

      this.undoBreakPoint();
    };

    this.addEventListener("mousedown", press, {captured : true, passive : false});
    this.addEventListener("mouseup", depress, {captured : true, passive : false});
    this.addEventListener("mouseover", (e) => {
      if (this.disabled)
        return;

      this._highlight = true;
      this._repos_canvas();
      this._redraw();
    });

    this.addEventListener("mouseout", (e) => {
      if (this.disabled)
        return;

      this._highlight = false;
      this._repos_canvas();
      this._redraw();
    });
  }

  updateDisabled() {
    if (this._last_disabled !== this.disabled) {
      this._last_disabled = this.disabled;

      //setTimeout(() => {
      this.dom._background = this.getDefault("background-color");

      this._repos_canvas();
      this._redraw();

      if (exports.DEBUG.buttonEvents)
        console.log("disabled update!", this.disabled, this.style["background-color"]);
      //}, 100);
    }
  }

  updateDefaultSize() {
    let height = ~~(this.getDefault("height")) + this.getDefault("padding");
    let size = this.getDefault("DefaultText").size * 1.33;

    if (height === undefined || size === undefined || isNaN(height) || isNaN(size)) {
      return;
    }

    height = ~~Math.max(height, size);
    height = height + "px";

    if (height !== this.style["height"]) {
      this.style["height"] = height;
      this.dom.style["height"] = height;

      this._repos_canvas();
      this._redraw();
    }
  }

  _calcUpdateKey() {
    return _themeUpdateKey;
  }

  update() {
    super.update();

    this.style["user-select"] = "none";
    this.dom.style["user-select"] = "none";

    this.updateDefaultSize();
    this.updateWidth();
    this.updateDPI();
    this.updateName();
    this.updateDisabled();

    if (this.background !== this._last_bg) {
      this._last_bg = this.background;
      this._repos_canvas();
      this._redraw();
    }

    let key = this._calcUpdateKey();
    if (key !== this._last_but_update_key) {
      this._last_but_update_key = key;

      this.setCSS();
      this._repos_canvas();
      this._redraw();
    }
  }

  setCSS() {
    super.setCSS();

    this.dom.style["margin"] = this.getDefault("margin", undefined, 0) + "px";
    this.dom.style["margin-left"] = this.getDefault("margin-left", undefined, 0) + "px";
    this.dom.style["margin-right"] = this.getDefault("margin-right", undefined, 0) + "px";
    this.dom.style["margin-top"] = this.getDefault("margin-top", undefined, 0) + "px";
    this.dom.style["margin-bottom"] = this.getDefault("margin-bottom", undefined, 0) + "px";

    let name = this._name;
    if (name === undefined) {
      return;
    }

    let dpi = this.getDPI();

    let pad = this.getDefault("padding");
    let ts = this.getDefault("DefaultText").size;

    let tw = measureText(this, this._genLabel(),{
      size : ts,
      font : this.getDefault("DefaultText")
    }).width + 2.0*pad + this._leftPad + this._rightPad;

    if (this._namePad !== undefined) {
      tw += this._namePad;
    }

    let w = this.getDefault("width");

    w = Math.max(w, tw);
    w = ~~w;
    this.dom.style["width"] = w+"px";
    this.updateBorders();
  }

  updateBorders() {
    let lwid = this.getDefault("border-width");

    if (lwid) {
      this.dom.style["border-color"] = this.getDefault("border-color");
      this.dom.style["border-width"] = lwid + "px";
      this.dom.style["border-style"] = "solid";
      this.dom.style["border-radius"] = this.getDefault("border-radius") + "px";
    } else {
      this.dom.style["border-color"] = "none";
      this.dom.style["border-width"] = "0px";
      this.dom.style["border-radius"] = this.getDefault("border-radius") + "px";
    }

  }

  updateName() {
    if (!this.hasAttribute("name")) {
      return;
    }

    let name = this.getAttribute("name");

    if (name !== this._name) {
      this._name = name;

      this.setCSS();
      this._repos_canvas();
      this._redraw();
    }
  }

  updateWidth(w_add=0) {
  }

  _repos_canvas() {
    let dpi = this.getDPI();

    let w = parsepx$2(this.dom.style["width"]);
    let h = parsepx$2(this.dom.style["height"]);

    let w2 = ~~(w*dpi);
    let h2 = ~~(h*dpi);

    w = w2/dpi;
    h = h2/dpi;

    this.dom.width = w2;
    this.dom.style["width"] = w + "px";

    this.dom.height = h2;
    this.dom.style["height"] = h + "px";
  }

  updateDPI() {
    let dpi = this.getDPI();

    if (this._last_dpi !== dpi) {
      //console.log("update dpi", dpi);

      this._last_dpi = dpi;

      this.g.font = undefined; //reset font

      this.setCSS();
      this._repos_canvas();
      this._redraw();
    }

    if (this.style["background-color"]) {
      this.dom._background = this.style["background-color"];
      this.style["background-color"] = "";
    }

    //console.log(">", this.dom.style["background-color"], "-----");
    //console.log("width:", this.clientWidth)
  }

  _genLabel() {
    return "" + this._name;
  }

  _getSubKey() {
    if (this._pressed) {
      return 'depressed';
    } else if (this._highlight) {
      return 'highlight';
    } else {
      return undefined; //make getSubDefault forward to getDefault
    }
  }

  _redraw(draw_text=true) {
    //console.log("button draw");

    let dpi = this.getDPI();

    let subkey = this._getSubKey();

    if (this._pressed && this._highlight) {
      this.dom._background = this.getSubDefault(subkey, "highlight-pressed", "BoxHighlight");
    } else if (this._pressed) {
      this.dom._background = this.getSubDefault(subkey, "pressed","BoxDepressed");
    } else if (this._highlight) {
      this.dom._background = this.getSubDefault(subkey, "highlight", "BoxHighlight");
    } else {
      this.dom._background = this.getSubDefault(subkey, "background-color", "background-color");
    }

    drawRoundBox(this, this.dom, this.g);

    //drawn with CSS now
    /*
    let lwid = this.getDefault("border-width");
    if (lwid) {
      this.g.lineWidth = lwid*dpi;
      ui_base.drawRoundBox(this, this.dom, this.g, undefined, undefined, undefined, "stroke");
    }
     */

    this.updateBorders();

    if (this._focus) {
      let w = this.dom.width, h = this.dom.height;
      let p = 1/dpi;

      //XXX remove this.g.translate lines after refactoring drawRoundBox, see comment in ui_base.js
      this.g.translate(p, p);
      let lw = this.g.lineWidth;


      this.g.lineWidth = this.getDefault("focus-border-width", undefined, 1.0)*dpi;

      drawRoundBox(this, this.dom, this.g, w-p*2, h-p*2, this.r, "stroke", this.getDefault("BoxHighlight"));

      this.g.lineWidth = lw;
      this.g.translate(-p, -p);
    }

    if (draw_text) {
      this._draw_text();
    }
  }

  _draw_text() {
    let dpi = this.getDPI();

    let subkey = this._getSubKey();

    //if (util.isMobile()) {
    //dpi = dpi; //visualViewport.scale;
    //}

    let font = this.getSubDefault(subkey, "DefaultText");

    let pad = this.getDefault("padding") * dpi;
    let ts = font.size * dpi;

    let text = this._genLabel();

    //console.log(text, "text", this._name);

    let w = this.dom.width, h = this.dom.height;

    let tw = measureText(this, text, undefined, undefined, ts, font).width;

    let cx = pad*0.5 + this._leftPad*dpi;
    let cy = ts + (h-ts)/3.0;

    let g = this.g;

    drawText(this, ~~cx, ~~cy, text, {
      canvas : this.dom,
      g : this.g,
      size : ts / dpi,
      font : font
    });
  }

  static define() {
    return {
      tagname: "old-button-x",
      style  : "button"
    };
  }
}
UIBase$3.internalRegister(OldButton);

"use strict";

function myToFixed$1(s, n) {
  s = s.toFixed(n);

  while (s.endsWith('0')) {
    s = s.slice(0, s.length-1);
  }
  if (s.endsWith("\.")) {
    s = s.slice(0, s.length-1);
  }

  return s;
}

let keymap$2 = keymap;

let EnumProperty$3 = EnumProperty,
    PropTypes$2 = PropTypes;

let UIBase$4 = UIBase$2,
    PackFlags$2 = PackFlags,
    IconSheets$2 = IconSheets;

let parsepx$3 = parsepx$1;

class TextBoxBase extends UIBase$4 {
  static define() {return {
    modalKeyEvents : true
  }}
}

class TextBox$1 extends TextBoxBase {
  constructor() {
    super();

    this._width = this.getDefault("width") + "px";
    this._textBoxEvents = true;

    let margin = Math.ceil(3 * this.getDPI());

    this._had_error = false;

    this.decimalPlaces = undefined; //will inherit from property defaults

    this.baseUnit = undefined; //will automatically use defaults
    this.displayUnit = undefined; //will automatically use defaults

    this.dom = document.createElement("input");

    this.dom.tabIndex = 0;
    this.dom.setAttribute("tabindex", 0);
    this.dom.setAttribute("tab-index", 0);
    this.dom.style["margin"] = margin + "px";

    this.dom.setAttribute("type", "textbox");
    this.dom.onchange = (e) => {
      this._change(this.dom.value);
    };

    this.radix = 16;

    this.dom.oninput = (e) => {
      this._change(this.dom.value);
    };

    this.shadow.appendChild(this.dom);

    this.dom.addEventListener("focus", (e) => {
      console.log("Textbox focus", this.isModal);

      this._focus = 1;

      if (this.isModal) {
        this._startModal();
        this.setCSS();
      }
    });

    this.dom.addEventListener("blur", (e) => {
      console.log("Textbox blur");

      this._focus = 0;

      if (this._modal) {
        this._endModal(true);
        this.setCSS();
      }
    });

  }

  /** realtime dom attribute getter, defaults to true in absence of attribute*/
  get realtime() {
    let ret = this.getAttribute("realtime");

    if (!ret) {
      return true;
    }

    ret = ret.toLowerCase().trim();

    return ret === 'yes' || ret === 'true' || ret === 'on';
  }

  set realtime(val) {
    this.setAttribute('realtime', val ? 'true' : 'false');
  }

  get isModal() {
    let ret = this.getAttribute("modal");

    if (!ret) {
      return false;
    }

    ret = ret.toLowerCase().trim();

    return ret === 'yes' || ret === 'true' || ret === 'on';
  }

  set isModal(val) {
    this.setAttribute('modal', val ? 'true' : 'false');
  }

  _startModal() {
    console.warn("textbox modal");

    if (this._modal) {
      this._endModal(true);
    }

    let ignore = 0;

    let finish = (ok) => {
      this._endModal(ok);
    };

    let keydown = (e) => {
      e.stopPropagation();

      switch (e.keyCode) {
        case keymap$2.Enter:
          finish(true);
          break;
        case keymap$2.Escape:
          finish(false);
          break;
      }

      return;
      if (ignore) return;

      let e2 = new KeyboardEvent(e.type, e);

      ignore = 1;
      this.dom.dispatchEvent(e2);
      ignore = 0;
    };

    this._modal = true;
    this.pushModal({
      on_mousemove : (e) => {
        e.stopPropagation();
      },

      on_keydown : keydown,
      on_keypress : keydown,
      on_keyup : keydown,

      on_mousedown : (e) => {
        e.stopPropagation();
        console.log("mouse down", e, e.x, e.y);
      }
    }, false);
  }

  _flash_focus() {
    //don't focus on flash
  }

  _endModal(ok) {
    console.log("textbox end modal");

    this._modal = false;
    this.popModal();

    this.blur();

    if (this.onend) {
      this.onend(ok);
    } else {
      this._updatePathVal(this.dom.value);
    }

    this.blur();
  }

  get tabIndex() {
    return this.dom.tabIndex;
  }

  set tabIndex(val) {
    this.dom.tabIndex = val;
  }

  init() {
    super.init();

    //set isModal default
    if (!this.hasAttribute('modal')) {
      this.isModal = true;
    }

    this.style["display"] = "flex";
    this.style["width"] = this._width;

    this.setCSS();
  }

  set width(val) {
    if (typeof val === "number") {
      val += "px";
    }

    this._width = val;
    this.style["width"] = val;
  }

  setCSS() {
    super.setCSS();

    this.overrideDefault("background-color", this.getDefault("background-color"));

    this.background = this.getDefault("background-color");
    this.dom.style["margin"] = this.dom.style["padding"] = "0px";

    if (this.getDefault("background-color")) {
      this.dom.style["background-color"] = this.getDefault("background-color");
    }

    if (this._focus) {
      this.dom.style["border"] = `2px dashed ${this.getDefault('focus-border-color')}`;
    } else {
      this.dom.style["border"] = "none";
    }

    if (this.style["font"]) {
      this.dom.style["font"] = this.style["font"];
    } else {
      this.dom.style["font"] = this.getDefault("DefaultText").genCSS();
      this.dom.style["color"] = this.getDefault("DefaultText").color;
    }

    this.dom.style["width"] = "100%";
    this.dom.style["height"] = "100%";
  }

  updateDataPath() {
    if (!this.ctx || !this.hasAttribute("datapath")) {
      return;
    }
    if (this._focus || this._flashtimer !== undefined || (this._had_error && this._focus)) {
      return;
    }

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));
    if (val === undefined || val === null) {
      console.error("invalid datapath " + this.getAttribute("datapath"), val);

      this.internalDisabled = true;
      return;
    } else {
      this.internalDisabled = false;
    }


    let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));

    let text = this.text;

    if (!prop) {
      console.error("datapath error " + this.getAttribute("datapath"), val);
      return;
    }

    let is_num = prop.type & (PropTypes$2.FLOAT|PropTypes$2.INT);
    if (typeof val === "number" && (prop.type & (PropTypes$2.VEC2|PropTypes$2.VEC3|PropTypes$2.VEC4|PropTypes$2.QUAT))) {
      is_num = true;
    }

    if (is_num) {
      let is_int = prop.type === PropTypes$2.INT;

      this.radix = prop.radix;

      let decimalPlaces = this.decimalPlaces !== undefined ? this.decimalPlaces : prop.decimalPlaces;
      if (this.hasAttribute("decimalPlaces")) {
        decimalPlaces = parseInt(this.getAttribute("decimalPlaces"));
      }

      let baseUnit = this.baseUnit ?? prop.baseUnit;
      if (this.hasAttribute("baseUnit")) {
        baseUnit = this.getAttribute("baseUnit");
      }

      let displayUnit = this.displayUnit ?? prop.displayUnit;
      if (this.hasAttribute("displayUnit")) {
        displayUnit = this.getAttribute("displayUnit");
      }

      if (is_int && this.radix === 2) {
        text = val.toString(this.radix);
        text = "0b" + text;
      } else if (is_int && this.radix === 16) {
        text += "h";
      } else {
        text = buildString(val, baseUnit, decimalPlaces, displayUnit);
      }
    } else if (prop !== undefined && prop.type === PropTypes$2.STRING) {
      text = val;
    }

    if (this.text !== text) {
      this.text = text;
    }
  }

  update() {
    super.update();

    if (this.dom.style["width"] !== this.style["width"]) {
      this.dom.style["width"] = this.style["width"];
    }
    if (this.dom.style["height"] !== this.style["height"]) {
      this.dom.style["height"] = this.style["height"];
    }

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }

    this.setCSS();
  }

  select() {
    this.dom.select();
    //return this.dom.select.apply(this, arguments);
  }

  focus() {
    return this.dom.focus();
  }

  blur() {
    return this.dom.blur();
  }

  static define() {return {
    tagname : "textbox-x",
    style   : "textbox",
    modalKeyEvents : true
  };}

  get text() {
    return this.dom.value;
  }

  set text(value) {
    this.dom.value = value;
  }

  _prop_update(prop, text) {
    let is_num = prop.type & (PropTypes$2.FLOAT|PropTypes$2.INT);
    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (typeof val === "number" && (prop.type & (PropTypes$2.VEC2|PropTypes$2.VEC3|PropTypes$2.VEC4|PropTypes$2.QUAT))) {
      is_num = true;
    }

    if (is_num) {
      let is_int = prop.type === PropTypes$2.INT;

      this.radix = prop.radix;

      let decimalPlaces = this.decimalPlaces !== undefined ? this.decimalPlaces : prop.decimalPlaces;
      if (this.hasAttribute("decimalPlaces")) {
        decimalPlaces = parseInt(this.getAttribute("decimalPlaces"));
      }

      let baseUnit = this.baseUnit ?? prop.baseUnit;
      if (this.hasAttribute("baseUnit")) {
        baseUnit = this.getAttribute("baseUnit");
      }

      let displayUnit = this.displayUnit ?? prop.displayUnit;
      if (this.hasAttribute("displayUnit")) {
        displayUnit = this.getAttribute("displayUnit");
      }

      if (!isNumber(text.trim())) {
        this.flash(ErrorColors.ERROR, this.dom, undefined, false);
        this.focus();
        this.dom.focus();
        this._had_error = true;
      } else {
        let val = parseValue(text, baseUnit, displayUnit);

        if (this._had_error) {
          this.flash(ErrorColors.OK, this.dom, undefined, false);
        }

        this._had_error = false;
        this.setPathValue(this.ctx, this.getAttribute("datapath"), val);
      }
    } else if (prop.type === PropTypes$2.STRING) {
      try {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), this.text);

        if (this._had_error) {
          this.flash(ErrorColors.OK, this.dom, undefined, false);
          this.dom.focus();
        }

        this._had_error = false;
      } catch (error) {
        console.log(error.stack);
        console.log(error.message);
        console.warn("textbox error!");
        //this._had_error = true;

        this.flash(ErrorColors.ERROR, this.dom, undefined, false);
        this.dom.focus();
      }
    }
  }


  _updatePathVal(text) {
    if (this.hasAttribute("datapath") && this.ctx !== undefined) {
      let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));
      console.log(prop);

      if (prop) {
        this._prop_update(prop, text);
      }
    }

  }

  _change(text) {
    //console.log("onchange", this.ctx, this, this.dom.__proto__, this.hasFocus);
    //console.log("onchange", this._focus);

    console.log("change", text);

    if (this.realtime) {
      this._updatePathVal(text);
    }

    if (this.onchange) {
      this.onchange(text);
    }
  }
}

UIBase$4.internalRegister(TextBox$1);

/**

 Returns false if it's safe to call preventDefault.

 Returns true if the element at position x,y is
 either a textbox or is draggable.
 */
function checkForTextBox(screen, x, y) {
  let p = screen.pickElement(x, y);
  //console.log(p, x, y);

  while (p) {
    //don't prevent draggable elements from dragging
    if (p.draggable) {
      return true;
    }

    if (p instanceof UIBase$4) {
      //check immediate children of p
      for (let i=0; i<2; i++) {
        let nodes = i ? p.childNodes : p.shadow.childNodes;

        for (let child of nodes) {
          if (child.draggable) {
            return true;
          }
        }
      }
    }

    let ok = p instanceof TextBoxBase;
    ok = ok || p.constructor.define && p.constructor.define().modalKeyEvents;

    if (ok) {
      return true;
    }

    p = p.parentWidget ? p.parentWidget : p.parentNode;
  }

  return false;
}

_setTextboxClass(TextBox$1);

"use strict";

function myToFixed$2(s, n) {
  s = s.toFixed(n);

  while (s.endsWith('0')) {
    s = s.slice(0, s.length - 1);
  }
  if (s.endsWith("\.")) {
    s = s.slice(0, s.length - 1);
  }

  return s;
}

let keymap$3 = keymap;

let EnumProperty$4 = EnumProperty,
    PropTypes$3    = PropTypes;

let UIBase$5     = UIBase$2,
    PackFlags$3  = PackFlags,
    IconSheets$3 = IconSheets;

let parsepx$4 = parsepx$1;

class IconLabel extends UIBase$5 {
  constructor() {
    super();
    this._icon = -1;
    this.iconsheet = 1;
  }

  get icon() {
    return this._icon;
  }

  set icon(id) {
    this._icon = id;
    this.setCSS();
  }

  static define() {
    return {
      tagname: "icon-label-x"
    }
  }

  init() {
    super.init();

    this.style["display"] = "flex";
    this.style["margin"] = this.style["padding"] = "0px";

    this.setCSS();
  }

  setCSS() {
    let size = iconmanager.getTileSize(this.iconsheet);


    iconmanager.setCSS(this.icon, this);

    this.style["width"] = size + "px";
    this.style["height"] = size + "px";
  }
}

UIBase$5.internalRegister(IconLabel);

class ValueButtonBase extends OldButton {
  constructor() {
    super();
  }

  get value() {
    return this._value;
  }

  set value(val) {
    this._value = val;

    if (this.ctx && this.hasAttribute("datapath")) {
      this.setPathValue(this.ctx, this.getAttribute("datapath"), this._value);
    }
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) return;
    if (this.ctx === undefined) return;

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (val === undefined) {
      let redraw = !this.disabled;

      this.internalDisabled = true;

      if (redraw) this._redraw();

      return;
    } else {
      let redraw = this.disabled;

      this.internalDisabled = false;
      if (redraw) this._redraw();
    }

    if (val !== this._value) {
      this._value = val;
      this.updateWidth();
      this._repos_canvas();
      this._redraw();
      this.setCSS();
    }
  }

  update() {
    this.updateDataPath();

    super.update();
  }
}

class Check extends UIBase$5 {
  constructor() {
    super();

    this._checked = false;
    this._highlight = false;
    this._focus = false;

    let shadow = this.shadow;

    //let form = document.createElement("form");

    let span = document.createElement("span");
    span.setAttribute("class", "checkx");

    span.style["display"] = "flex";
    span.style["flex-direction"] = "row";
    span.style["margin"] = span.style["padding"] = "0px";
    //span.style["background"] = ui_base.iconmanager.getCSS(1);

    let sheet = 0;
    let size = iconmanager.getTileSize(0);

    let check = this.canvas = document.createElement("canvas");
    this.g = check.getContext("2d");

    check.setAttribute("id", check._id);
    check.setAttribute("name", check._id);

    let mdown = (e) => {
      this._highlight = false;
      this.checked = !this.checked;
    };

    let mup = (e) => {
      this._highlight = false;
      this.blur();
      this._redraw();
    };

    let mover = (e) => {
      this._highlight = true;
      this._redraw();
    };

    let mleave = (e) => {
      this._highlight = false;
      this._redraw();
    };

    span.addEventListener("pointerover", mover, {passive: true});
    span.addEventListener("mousein", mover, {passive: true});
    span.addEventListener("mouseleave", mleave, {passive: true});
    span.addEventListener("pointerout", mleave, {passive: true});

    this.addEventListener("blur", (e) => {
      this._highlight = this._focus = false;
      this._redraw();
    });
    this.addEventListener("focusin", (e) => {
      this._focus = true;
      this._redraw();
    });
    this.addEventListener("focus", (e) => {
      this._focus = true;
      this._redraw();
    });


    span.addEventListener("pointerdown", mdown, {passive: true});
    span.addEventListener("pointerup", mup, {passive: true});
    span.addEventListener("pointercancel", mup, {passive: true});

    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case keymap$3["Escape"]:
          this._highlight = undefined;
          this._redraw();
          e.preventDefault();
          e.stopPropagation();

          this.blur();
          break;
        case keymap$3["Enter"]:
        case keymap$3["Space"]:
          this.checked = !this.checked;
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    });
    this.checkbox = check;

    span.appendChild(check);

    let label = this._label = document.createElement("label");
    label.setAttribute("class", "checkx");
    span.setAttribute("class", "checkx");
    label.style["align-self"] = "center";

    let side = this.getDefault("CheckSide");
    if (side === "right") {
      span.prepend(label);
    } else {
      span.appendChild(label);
    }

    shadow.appendChild(span);
  }

  get internalDisabled() {
    return super.internalDisabled;
  }

  set internalDisabled(val) {
    if (!!this.internalDisabled === !!val) {
      return;
    }

    super.internalDisabled = val;
    this._redraw();
  }

  get value() {
    return this.checked;
  }

  set value(v) {
    this.checked = v;
  }

  get checked() {
    return this._checked;
  }

  set checked(v) {
    v = !!v;

    if (this._checked !== v) {
      this._checked = v;

      this.setCSS();

      //this.dom.checked = v;
      this._redraw();

      if (this.onclick) {
        this.onclick(v);
      }
      if (this.onchange) {
        this.onchange(v);
      }

      if (this.hasAttribute("datapath")) {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), this._checked);
      }
    }
  }

  get label() {
    return this._label.textContent;
  }

  set label(l) {
    this._label.textContent = l;
  }

  static define() {
    return {
      tagname    : "check-x",
      style      : "checkbox",
      parentStyle: "button"
    };
  }

  init() {
    this.tabIndex = 1;
    this.setAttribute("class", "checkx");


    let style = document.createElement("style");
    //let style = this.cssStyleTag();

    let color = this.getDefault("focus-border-color");

    style.textContent = `
      .checkx:focus {
        outline : none;
      }
    `;

    //document.body.prepend(style);
    this.prepend(style);
  }

  setCSS() {
    this._label.style["font"] = this.getDefault("DefaultText").genCSS();
    this._label.style["color"] = this.getDefault("DefaultText").color;

    this._label.style['font'] = 'normal 14px poppins'; // TODO - Jordan - add to settings

    super.setCSS();

    //force clear background
    this.style["background-color"] = "rgba(0,0,0,0)";
  }

  updateDataPath() {
    if (!this.getAttribute("datapath")) {
      return;
    }

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    let redraw = false;

    if (val === undefined) {
      this.internalDisabled = true;
      return;
    } else {
      redraw = this.internalDisabled;

      this.internalDisabled = false;
    }

    val = !!val;

    redraw = redraw || !!this._checked !== !!val;

    if (redraw) {
      this._checked = val;
      this._repos_canvas();
      this.setCSS();
      this._redraw();
    }
  }

  _repos_canvas() {
  }

  _redraw() {
    if (this.canvas === undefined) {
      //flag update
      this._updatekey = "";
      return;
    }

    let canvas = this.canvas, g = this.g;
    let dpi = UIBase$5.getDPI();
    let tilesize = iconmanager.getTileSize(0);
    let pad = this.getDefault("padding");

    let csize = tilesize + pad*2;

    canvas.style["margin"] = "2px";
    canvas.style["width"] = csize + "px";
    canvas.style["height"] = csize + "px";

    csize = ~~(csize*dpi + 0.5);
    tilesize = ~~(tilesize*dpi + 0.5);

    canvas.width = csize;
    canvas.height = csize;

    g.clearRect(0, 0, canvas.width, canvas.height);

    g.beginPath();
    g.rect(0, 0, canvas.width, canvas.height);
    g.fill();

    let color;

    if (!this._checked && this._highlight) {
      color = this.getDefault("BoxHighlight");
    }

    drawRoundBox(this, canvas, g, undefined, undefined, undefined, undefined, color);
    if (this._checked) {
      //canvasDraw(elem, canvas, g, icon, x=0, y=0, sheet=0) {
      let x = (csize - tilesize)*0.5, y = (csize - tilesize)*0.5;
      iconmanager.canvasDraw(this, canvas, g, Icons.LARGE_CHECK, x, y);
    }

    if (this._focus) {
      color = this.getDefault("focus-border-color");
      g.lineWidth *= dpi;
      drawRoundBox(this, canvas, g, undefined, undefined, undefined, "stroke", color);
    }
  }

  updateDPI() {
    let dpi = UIBase$5.getDPI();

    if (dpi !== this._last_dpi) {
      this._last_dpi = dpi;
      this._redraw();
    }
  }

  update() {
    super.update();

    this.updateDPI();

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }

    let updatekey = this.getDefault("DefaultText").hash();
    updatekey += this._checked + ":" + this._label.textContent;

    if (updatekey !== this._updatekey) {
      this._repos_canvas();
      this.setCSS();

      this._updatekey = updatekey;
      this._redraw();
    }
  }
}

UIBase$5.internalRegister(Check);

class IconButton extends UIBase$5 {
  constructor() {
    super();

    this._customIcon = undefined;

    this._pressed = false;
    this._highlight = false;
    this._draw_pressed = true;

    this._icon = -1;
    this._icon_pressed = undefined;
    this.iconsheet = 0;
    this.drawButtonBG = true;

    this._extraIcon = undefined; //draw another icon on top

    this.extraDom = undefined;

    //have to put icon in subdiv
    this.dom = document.createElement("div");
    this.shadow.appendChild(this.dom);

    this._last_iconsheet = undefined;

    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case keymap$3["Enter"]:
        case keymap$3["Space"]:
          this.click();
          break;
      }
    });
  }

  click() {
    if (this._onpress) {
      let rect = this.getClientRects();
      let x = rect.x + rect.width*0.5;
      let y = rect.y + rect.height*0.5;

      let e = {x : x, y : y, stopPropagation : () => {}, preventDefault : () => {}};

      this._onpress(e);
    }

    super.click();
  }

  get customIcon() {
    return this._customIcon;
  }

  set customIcon(domImage) {
    this._customIcon = domImage;
    this.setCSS();
  }

  get icon() {
    return this._icon;
  }

  set icon(val) {
    this._icon = val;
    this.setCSS();
  }

  static define() {
    return {
      tagname: "iconbutton-x",
      style  : "iconbutton"
    };
  }

  _on_press() {
    this._pressed = true;
    this.setCSS();
  }

  _on_depress() {
    this._pressed = false;
    this.setCSS();
  }

  updateDefaultSize() {

  }

  setCSS() {
    super.setCSS();

    let def;
    let pstyle = this.getDefault("depressed");
    let hstyle = this.getDefault("highlight");

    this.noMarginsOrPadding();

    if (this._pressed && this._draw_pressed) {
      def = k => pstyle && k in pstyle ? pstyle[k] : this.getDefault(k);
    } else if (this._highlight) {
      def = k => hstyle && k in hstyle ? hstyle[k] : this.getDefault(k);
    } else {
      def = k => this.getDefault(k);
    }

    let loadstyle = (key, addpx) => {
      let val = def(key);
      if (addpx) {
        val = ("" + val).trim();

        if (!val.toLowerCase().endsWith("px")) {
          val += "px";
        }
      }

      this.style[key] = val;
    };

    let keys = ["margin", "padding", "margin-left", "margin-right", "margin-top", "margin-botton",
                "padding-left", "padding-bottom", "padding-top", "padding-right",
                "border-radius"];

    for (let k of keys) {
      loadstyle(k, true);
    }
    loadstyle("background-color", false);
    loadstyle("color", false);

    let border = `${def("border-width", true)} ${def("border-style", false)} ${def("border-color", false)}`;
    this.style["border"] = border;

    let w = this.getDefault("width");

    let size = iconmanager.getTileSize(this.iconsheet);
    w = size;

    this.style["width"] = w + "px";
    this.style["height"] = w + "px";

    this.dom.style["width"] = w + "px";
    this.dom.style["height"] = w + "px";
    this.dom.style["margin"] = this.dom.style["padding"] = "0px";

    this.style["display"] = "flex";
    this.style["align-items"] = "center";

    if (this._customIcon) {
      this.dom.style["background-image"] = `url("${this._customIcon.src}")`;
      this.dom.style["background-size"] = "contain";
      this.dom.style["background-repeat"] = "no-repeat";
    } else {
      let icon = this.icon;

      if (this._pressed && this._icon_pressed !== undefined) {
        icon = this._icon_pressed;
      }

      iconmanager.setCSS(icon, this.dom, this.iconsheet);
    }

    if (this._extraIcon !== undefined) {
      let dom;

      if (!this.extraDom) {
        this.extraDom = dom = document.createElement("div");

        this.shadow.appendChild(dom);
      } else {
        dom = this.extraDom;
      }

      dom.style["position"] = "absolute";
      dom.style["margin"] = dom.style["padding"] = "0px";
      dom.style["pointer-events"] = "none";
      dom.style["width"] = size + "px";
      dom.style["height"] = size + "px";

      iconmanager.setCSS(this._extraIcon, dom, this.iconsheet);
    } else if (this.extraDom) {
      this.extraDom.remove();
    }
  }

  init() {
    super.init();

    let press = (e) => {
      e.stopPropagation();
      e.preventDefault();

      if (this.modalRunning) {
        this.popModal();
      }

      if (!eventWasTouch(e) && e.button !== 0) {
        return;
      }

      if (1) { //!eventWasTouch(e)) {
        let this2 = this;

        this.pushModal({
          on_mouseup(e) {
            //touch events aren't fireing onclick automatically the way mouse ones are

            if (this2.onclick && eventWasTouch(e)) {
              this2.onclick();
            }
            this.end();
          },
          on_touchcancel(e) {
            this.on_mouseup(e);
            this.end();
          },
          on_touchend(e) {
            this.on_mouseup(e);
            this.end();
          },
          on_keydown(e) {
            this.end();
          },
          end() {
            if (this2.modalRunning) {
              this2.popModal();
              this2._on_depress(e);
              this2.setCSS();
            }
          }
        });
      }

      this._on_press(e);
    };

    let depress = (e) => {
      e.stopPropagation();
      e.preventDefault();

      this._on_depress();
      this.setCSS();
    };

    let high = (e) => {
      this._highlight = true;
      this.setCSS();
    };

    let unhigh = (e) => {
      this._highlight = false;
      this.setCSS();
    };

    this.tabIndex = 0;

    this.addEventListener("mouseover", high);
    this.addEventListener("mouseexit", unhigh);
    this.addEventListener("mouseleave", unhigh);
    this.addEventListener("focus", high);
    this.addEventListener("blur", unhigh);

    this.addEventListener("mousedown", press, {capture: true});
    this.addEventListener("mouseup", depress, {capture: true});
    //this.addEventListener("touchstart", press, {capture: true});
    //this.addEventListener("touchcancel", depress, {capture: true});
    //this.addEventListener("touchend", depress, {capture: true});
    this.setCSS();

    this.dom.style["pointer-events"] = "none";
  }

  update() {
    super.update();

    if (this.iconsheet !== this._last_iconsheet) {
      this.setCSS();
      this._last_iconsheet = this.iconsheet;
    }
  }

  _getsize() {
    let margin = this.getDefault("padding");

    return iconmanager.getTileSize(this.iconsheet) + margin*2;
  }
}

UIBase$5.internalRegister(IconButton);


class IconCheck extends IconButton {
  constructor() {
    super();

    this._checked = undefined;
    this._drawCheck = undefined;
  }

  get drawCheck() {
    let ret = this._drawCheck;

    ret = ret === undefined ? this.getDefault("drawCheck") : ret;
    ret = ret === undefined ? true : ret;

    return ret;
  }

  set drawCheck(val) {
    val = !!val;

    if (val && (this.packflag & PackFlags$3.HIDE_CHECK_MARKS)) {
      this.packflag &= ~PackFlags$3.HIDE_CHECK_MARKS;
    }

    let old = !!this.drawCheck;
    this._drawCheck = val;

    if (val !== old) {
      this.updateDrawCheck();
      this.setCSS();
    }
  }

  click() {
    super.click();
    this.checked ^= true;
  }

  get icon() {
    return this._icon;
  }

  set icon(val) {
    this._icon = val;
    this.setCSS();
  }

  get checked() {
    return this._checked;
  }

  set checked(val) {
    if (!!val !== !!this._checked) {
      this._checked = val;
      this._updatePressed(!!val);
      this.setCSS();

      if (this.onchange) {
        this.onchange(val);
      }
    }
  }

  get noEmboss() {
    let ret = this.getAttribute("no-emboss");

    if (!ret) {
      return false;
    }

    ret = ret.toLowerCase().trim();

    return ret === 'true' || ret === 'yes' || ret === 'on';
  }

  set noEmboss(val) {
    this.setAttribute('no-emboss', val ? 'true' : 'false');
  }

  static define() {
    return {
      tagname    : "iconcheck-x",
      style      : "iconcheck",
      parentStyle: "iconbutton"
    };
  }

  _updatePressed(val) {
    //don't set _pressed if we have a custom icon for press state
    if (this._icon_pressed) {
      this._draw_pressed = false;
    }

    this._pressed = val;
    this.setCSS();
  }

  _on_depress() {
    return;
  }

  _on_press() {
    this.checked ^= true;

    if (this.hasAttribute("datapath")) {
      this.setPathValue(this.ctx, this.getAttribute("datapath"), !!this.checked);
    }

    this.setCSS();
  }

  updateDefaultSize() {

  }

  _calcUpdateKey() {
    return super._calcUpdateKey() + ":" + this._icon;
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath") || !this.ctx) {
      return;
    }

    if (this._icon < 0) {
      let rdef;
      try {
        rdef = this.ctx.api.resolvePath(this.ctx, this.getAttribute("datapath"));
      } catch (error) {
        if (error instanceof DataPathError) {
          return;
        } else {
          throw error;
        }
      }

      if (rdef !== undefined && rdef.prop) {
        let icon, icon2, title;

        if (rdef.prop.flag & PropFlags.NO_UNDO) {
          this.setUndo(false);
        } else {
          this.setUndo(true);
        }

        //console.log("SUBKEY", rdef.subkey, rdef.prop.iconmap);

        if (rdef.subkey && (rdef.prop.type === PropTypes$3.FLAG || rdef.prop.type === PropTypes$3.ENUM)) {
          icon = rdef.prop.iconmap[rdef.subkey];
          icon2 = rdef.prop.iconmap2[rdef.subkey];
          title = rdef.prop.descriptions[rdef.subkey];

          if (title === undefined && rdef.subkey.length > 0) {
            title = rdef.subkey;
            title = title[0].toUpperCase() + title.slice(1, title.length).toLowerCase();
          }
        } else {
          icon2 = rdef.prop.icon2;
          icon = rdef.prop.icon;
          title = rdef.prop.description;
        }

        if (icon2 !== undefined && icon2 !== -1) {
          this._icon_pressed = icon;
          icon = icon2;
        }

        if (icon !== undefined && icon !== this.icon)
          this.icon = icon;
        if (title !== undefined)
          this.description = title;
      }
    }

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (val === undefined) {
      this.internalDisabled = true;
      return;
    } else {
      this.internalDisabled = false;
    }

    val = !!val;

    if (val !== !!this._checked) {
      this._checked = val;
      this._updatePressed(!!val);
      this.setCSS();
    }
  }

  updateDrawCheck() {
    if (this.drawCheck) {
      this._extraIcon = this._checked ? Icons.ENUM_CHECKED : Icons.ENUM_UNCHECKED;
    } else {
      this._extraIcon = undefined;
    }
  }

  update() {
    if (this.packflag & PackFlags$3.HIDE_CHECK_MARKS) {
      this.drawCheck = false;
    }

    this.updateDrawCheck();

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }

    super.update();
  }

  _getsize() {
    let margin = this.getDefault("padding");
    return iconmanager.getTileSize(this.iconsheet) + margin*2;
  }

  setCSS() {
    this.updateDrawCheck();
    super.setCSS();
  }
}

UIBase$5.internalRegister(IconCheck);

class Check1 extends Button {
  constructor() {
    super();

    this._namePad = 40;
    this._value = undefined;
  }

  static define() {
    return {
      tagname    : "check1-x",
      parentStyle: "button"
    };
  }

  _redraw() {
    //console.log("button draw");

    let dpi = this.getDPI();

    let box = 40;
    drawRoundBox(this, this.dom, this.g, box);

    let ts = this.getDefault("DefaultText").size;

    let text = this._genLabel();

    //console.log(text, "text", this._name);

    let tw = measureText(this, text, this.dom, this.g).width;
    let cx = this.dom.width/2 - tw/2;
    let cy = this.dom.height/2;

    drawText(this, box, cy + ts/2, text, {
      canvas: this.dom, g: this.g
    });
  }
}

UIBase$5.internalRegister(Check1);

function saveFile(data, filename="unnamed", exts=[], mime="application/x-octet-stream") {
  let blob = new Blob([data], {type : mime});
  let url = URL.createObjectURL(blob);

  let a = document.createElement("a");
  a.setAttribute("href", url);
  a.setAttribute("download", filename);

  a.click();
}

//returns a promise
function loadFile(filename="unnamed", exts=[]) {
  let input = document.createElement("input");
  input.type = "file";

  exts = exts.join(",");

  input.setAttribute("accept", exts);
  return new Promise((accept, reject) => {
    input.onchange = function(e) {
      if (this.files === undefined || this.files.length !== 1) {
        reject("file load error");
        return;
      }

      let file = this.files[0];
      let reader = new FileReader();

      reader.onload = function(e2) {
        accept(e2.target.result);
      };

      reader.readAsArrayBuffer(file);
    };
    input.click();
  });
}

window._testLoadFile = function(exts=["*.*"]) {
  loadFile(undefined, exts).then((data) => {
    console.log("got file data:", data);
  });
};

window._testSaveFile = function() {
  let buf = _appstate.createFile();
  //console.log(buf);
  saveFile(buf, "unnamed.w3d", [".w3d"]);
};

var html5_fileapi1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  saveFile: saveFile,
  loadFile: loadFile
});

"use strict";

let EnumProperty$5 = EnumProperty,
    PropTypes$4    = PropTypes;

let UIBase$6     = UIBase$2,
    PackFlags$4  = PackFlags,
    IconSheets$4 = IconSheets;

function getpx(css) {
  return parseFloat(css.trim().replace("px", ""))
}

function debugmenu() {
  if (window.DEBUG && window.DEBUG.menu) {
    console.warn("%cmenu:", "color:blue", ...arguments);
  }
}


class Menu extends UIBase$6 {
  constructor() {
    super();

    this.parentMenu = undefined;

    this._was_clicked = false;

    this.items = [];
    this.autoSearchMode = true;

    this._ignoreFocusEvents = false;
    this.closeOnMouseUp = true;

    this._submenu = undefined;

    this.ignoreFirstClick = false;

    this.itemindex = 0;
    this.closed = false;
    this.started = false;
    this.activeItem = undefined;

    this.overrideDefault("DefaultText", this.getDefault("MenuText"));

    //we have to make a container for any submenus to
    this.container = document.createElement("span");
    this.container.style["display"] = "flex";
    this.container.style["color"] = this.getDefault("MenuText").color;

    //this.container.style["background-color"] = "red";
    this.container.setAttribute("class", "menucon");

    this.dom = document.createElement("ul");
    this.dom.setAttribute("class", "menu");
    /*
              place-items: start start;
              flex-wrap : nowrap;
              align-content : start;
              place-content : start;
              justify-content : start;

              align-items : start;
              place-items : start;
              justify-items : start;
    */

    let style = this.menustyle = document.createElement("style");
    this.buildStyle();

    this.dom.setAttribute("tabindex", -1);

    //the menu wrangler handles key events

    this.shadow.appendChild(style);
    this.shadow.appendChild(this.container);
  }

  static define() {
    return {
      tagname: "menu-x",
      style  : "menu"
    };
  }

  float(x, y, zindex = undefined) {
    let dpi = this.getDPI();
    let rect = this.dom.getClientRects();
    let maxx = this.getWinWidth() - 10;
    let maxy = this.getWinHeight() - 10;

    if (rect.length > 0) {
      rect = rect[0];
      if (y + rect.height > maxy) {
        y = maxy - rect.height - 1;
      }

      if (x + rect.width > maxx) {
        x = maxx - rect.width - 1;
      }
    }

    super.float(x, y, 50);
  }

  click() {
    if (this._was_clicked) {
      return;
    }

    if (this.ignoreFirstClick) {
      this.ignoreFirstClick = Math.max(this.ignoreFirstClick - 1, 0);
      return;
    }

    if (!this.activeItem || this.activeItem._isMenu) {
      return;
    }

    this._was_clicked = true;

    if (this.onselect) {
      try {
        this.onselect(this.activeItem._id);
      } catch (error) {
        print_stack$1(error);
        console.log("Error in menu callback");
      }
    }

    this.close();
  }

  _ondestroy() {
    if (this.started) {
      menuWrangler.popMenu(this);

      if (this.onclose) {
        this.onclose();
      }
    }
  }

  init() {
    super.init();
    this.setCSS();
  }

  close() {
    if (this.closed) {
      return;
    }

    this.closed = true;

    if (this.started) {
      menuWrangler.popMenu(this);
    }

    this.started = false;

    if (this._popup) {
      this._popup.end();
      this._popup = undefined;
    }

    this.remove();
    this.dom.remove();

    if (this.onclose) {
      this.onclose(this);
    }
  }

  _select(dir, focus = true) {
    if (this.activeItem === undefined) {
      for (let item of this.items) {
        if (!item.hidden) {
          this.setActive(item, focus);
          break;
        }
      }
    } else {
      let i = this.items.indexOf(this.activeItem);
      let item = this.activeItem;

      do {
        i = (i + dir + this.items.length)%this.items.length;
        item = this.items[i];

        if (!item.hidden) {
          break;
        }
      } while (item !== this.activeItem);

      this.setActive(item, focus);
    }

    if (this.hasSearchBox) {
      this.activeItem.scrollIntoView();
    }
  }

  selectPrev(focus = true) {
    return this._select(-1, focus);
  }

  selectNext(focus = true) {
    return this._select(1, focus);
  }

  start_fancy(prepend, setActive = true) {
    return this.startFancy(prepend, setActive);
  }

  setActive(item, focus = true) {
    if (this.activeItem === item) {
      return;
    }

    if (this.activeItem) {
      this.activeItem.style["background-color"] = this.getDefault("MenuBG");

      if (focus) {
        this.activeItem.blur();
      }
    }

    if (item) {
      item.style["background-color"] = this.getDefault("MenuHighlight");

      if (focus) {
        item.focus();
      }
    }

    this.activeItem = item;
  }

  startFancy(prepend, setActive = true) {
    this.hasSearchBox = true;
    this.started = true;
    menuWrangler.pushMenu(this);

    let dom2 = document.createElement("div");
    //let dom2 = document.createElement("div");

    this.dom.setAttribute("class", "menu");
    dom2.setAttribute("class", "menu");

    let sbox = this.textbox = UIBase$6.createElement("textbox-x");
    this.textbox.parentWidget = this;

    dom2.appendChild(sbox);
    dom2.appendChild(this.dom);

    dom2.style["height"] = "300px";
    this.dom.style["height"] = "300px";
    this.dom.style["overflow"] = "scroll";

    if (prepend) {
      this.container.prepend(dom2);
    } else {
      this.container.appendChild(dom2);
    }

    dom2.parentWidget = this.container;

    sbox.focus();
    sbox.onchange = () => {
      let t = sbox.text.trim().toLowerCase();

      for (let item of this.items) {
        item.hidden = true;
        item.remove();
      }

      for (let item of this.items) {
        let ok = t == "";
        ok = ok || item.innerHTML.toLowerCase().search(t) >= 0;

        if (ok) {
          item.hidden = false;
          this.dom.appendChild(item);
        } else if (item === this.activeItem) {
          this.selectNext(false);
        }
        //item.hidden = !ok;
      }
    };

    sbox.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case 27: //escape key
          this.close();
          break;
        case 13: //enter key
          this.click(this.activeItem);
          this.close();
          break;
      }
    });
  }

  start(prepend = false, setActive = true) {
    this.closed = false;

    this.started = true;
    this.focus();

    menuWrangler.pushMenu(this);

    let dokey = (key) => {
      let val = this.getDefault(key);
      if (typeof val === "number") {
        val = "" + val + "px";
      }

      if (val !== undefined) {
        this.dom.style[key] = val;
      }
    };

    dokey("padding");
    dokey("padding-top");
    dokey("padding-left");
    dokey("padding-right");
    dokey("padding-bottom");

    if (this.items.length > 15 && this.autoSearchMode) {
      return this.start_fancy(prepend, setActive);
    }

    if (prepend) {
      this.container.prepend(this.dom);
    } else {
      this.container.appendChild(this.dom);
    }

    if (!setActive)
      return;

    this.setCSS();
    this.flushUpdate();

    window.setTimeout(() => {
      this.flushUpdate();

      //select first child
      //TODO: cache last child entry

      if (this.activeItem === undefined) {
        this.activeItem = this.dom.childNodes[0];
      }

      if (this.activeItem === undefined) {
        return;
      }

      this.activeItem.focus();
    }, 0);
  }

  addItemExtra(text, id = undefined, hotkey, icon = -1, add = true, tooltip = undefined) {
    let dom = document.createElement("span");

    dom.style["display"] = "inline-flex";

    dom.hotkey = hotkey;
    dom.icon = icon;

    let icon_div;

    if (1) { //icon >= 0) {
      icon_div = makeIconDiv(icon, IconSheets$4.SMALL);
    } else {
      let tilesize = iconmanager.getTileSize(IconSheets$4.SMALL);

      //tilesize *= window.devicePixelRatio;

      icon_div = document.createElement("span");
      icon_div.style["padding"] = icon_div.style["margin"] = "0px";
      icon_div.style["width"] = tilesize + "px";
      icon_div.style["height"] = tilesize + "px";
    }

    icon_div.style["display"] = "inline-flex";
    icon_div.style["margin-right"] = "1px";
    icon_div.style["align"] = "left";

    let span = document.createElement("span");

    //stupid css doesn't get width right. . .
    span.style["font"] = getFont(this, undefined, "MenuText");

    let dpi = this.getDPI();
    let tsize = this.getDefault("MenuText").size;
    //XXX proportional font fail

    //XXX stupid!
    let canvas = document.createElement("canvas");
    let g = canvas.getContext("2d");

    g.font = span.style["font"];

    let rect = span.getClientRects();

    let twid = Math.ceil(g.measureText(text).width);
    let hwid;
    if (hotkey) {
      dom.hotkey = hotkey;
      g.font = getFont(this, undefined, "HotkeyText");
      hwid = Math.ceil(g.measureText(hotkey).width/UIBase$6.getDPI());
      twid += hwid + 8;
    }

    //let twid = Math.ceil(text.trim().length * tsize / dpi);

    span.innerText = text;

    span.style["word-wrap"] = "none";
    span.style["white-space"] = "pre";
    span.style["overflow"] = "hidden";
    span.style["text-overflow"] = "clip";

    span.style["width"] = ~~(twid) + "px";
    span.style["padding"] = "0px";
    span.style["margin"] = "0px";

    dom.style["width"] = "100%";

    dom.appendChild(icon_div);
    dom.appendChild(span);

    if (hotkey) {
      let hotkey_span = document.createElement("span");
      hotkey_span.innerText = hotkey;
      hotkey_span.style["display"] = "inline-flex";

      hotkey_span.style["margin"] = "0px";
      hotkey_span.style["margin-left"] = "auto";
      hotkey_span.style["margin-right"] = "0px";
      hotkey_span.style["padding"] = "0px";

      hotkey_span.style["font"] = getFont(this, undefined, "HotkeyText");
      hotkey_span.style["color"] = this.getDefault("HotkeyTextColor");

      //hotkey_span.style["width"] = ~~((hwid + 7)) + "px";
      hotkey_span.style["width"] = "max-content";

      //hotkey_span.style["background-color"] = "rgba(0,0,0,0)";

      hotkey_span.style["text-align"] = "right";
      hotkey_span.style["justify-content"] = "right";
      hotkey_span["flex-wrap"] = "nowrap";
      hotkey_span["text-wrap"] = "nowrap";

      //hotkey_span.style["border"] = "1px solid red";

      //hotkey_span.style["display"] = "inline";
      //hotkey_span.style["float"] = "right";

      dom.appendChild(hotkey_span);
    }

    let ret = this.addItem(dom, id, add);

    ret.hotkey = hotkey;
    ret.icon = icon;
    ret.label = text ? text : ret.innerText;

    if (tooltip) {
      ret.title = tooltip;
    }

    return ret;
  }

  //item can be menu or text
  addItem(item, id, add = true, tooltip = undefined) {
    id = id === undefined ? item : id;
    let text = item;

    if (typeof item === "string" || item instanceof String) {
      let dom = document.createElement("dom");
      dom.style["text-align"] = "left";

      dom.textContent = item;
      item = dom;
      //return this.addItemExtra(item, id);
    } else {
      text = item.textContent;
    }

    let li = document.createElement("li");

    li.setAttribute("tabindex", this.itemindex++);
    li.setAttribute("class", "menuitem");

    if (tooltip !== undefined) {
      li.title = tooltip;
    }

    if (item instanceof Menu) {
      //let dom = this.addItemExtra(""+item.title, id, "", -1, false);
      let dom = document.createElement("span");
      dom.innerHTML = "" + item.title;
      dom._id = dom.id = id;
      dom.setAttribute("class", "menu");

      //dom = document.createElement("div");
      //dom.innerText = ""+item.title;

      //dom.style["display"] = "inline-block";
      li.style["width"] = "100%";
      li.appendChild(dom);

      li._isMenu = true;
      li._menu = item;
      item.parentMenu = this;

      item.hidden = false;
      item.container = this.container;
    } else {
      li._isMenu = false;
      li.appendChild(item);
    }

    li._id = id;

    this.items.push(li);

    li.label = text ? text : li.innerText.trim();

    if (add) {
      li.addEventListener("blur", (e) => {
        if (this._ignoreFocusEvents) {
          return;
        }

        if (this.activeItem && !this.activeItem._isMenu) {
          this.setActive(undefined, false);
        }
      });

      let onfocus = (e) => {
        if (this._ignoreFocusEvents) {
          return;
        }

        let active = this.activeItem;

        if (this._submenu) {
          this._submenu.close();
          this._submenu = undefined;
        }

        if (li._isMenu) {
          li._menu.onselect = (item) => {
            this.onselect(item);
            li._menu.close();
            this.close();
          };

          li._menu.start(false, false);
          this._submenu = li._menu;
        }

        this.setActive(li, false);
      };

      let onclick = (e) => {
        onfocus(e);

        e.stopPropagation();
        e.preventDefault();

        if (this.activeItem !== undefined && this.activeItem._isMenu) {
          //ignore
          return;
        }

        this.click();
      };

      li.addEventListener("contextmenu", e => e.preventDefault());
      this.addEventListener("contextmenu", e => e.preventDefault());

      li.addEventListener("pointerup", onclick, {capture: true});
      li.addEventListener("click", onclick, {capture: true});
      li.addEventListener("pointerdown", onclick, {capture: true});

      li.addEventListener("focus", (e) => {
        onfocus(e);
        onfocus(e);
      });

      li.addEventListener("pointermove", (e) => {
        onfocus(e);
        li.focus();
      });
      li.addEventListener("mouseover", (e) => {
        onfocus(e);
        li.focus();
      });
      li.addEventListener("mouseenter", (e) => {
        onfocus(e);
        li.focus();
      });

      li.addEventListener("pointerover", (e) => {
        onfocus(e);
        li.focus();
      });

      this.dom.appendChild(li);
    }

    return li;
  }

  _getBorderStyle() {
    let r = this.getDefault("border-width");
    let s = this.getDefault("border-style");
    let c = this.getDefault("border-color");

    return `${r}px ${s} ${c}`;
  }

  buildStyle() {
    let pad1 = isMobile() ? 2 : 0;
    pad1 += this.getDefault("MenuSpacing");

    let boxShadow = "";
    if (this.hasDefault("box-shadow")) {
      boxShadow = "box-shadow: " + this.getDefault("box-shadow") + ';';
    }

    let sepcss = this.getDefault("MenuSeparator");
    if (typeof sepcss === "object") {
      let s = '';

      for (let k in sepcss) {
        let v = sepcss[k];

        if (typeof v === "number") {
          v = v.toFixed(4) + "px";
        }

        s += `    ${k}: ${v};\n`;
      }

      sepcss = s;
    }

    let itemRadius = 0;

    if (this.hasDefault("item-radius")) {
      itemRadius = this.getDefault("item-radius");
    } else {
      itemRadius = this.getDefault("border-radius");
    }

    this.menustyle.textContent = `
        .menucon {
          position:fixed;
          float:left;
          
          border-radius : ${this.getDefault("border-radius")}px;

          display: block;
          -moz-user-focus: normal;
          ${boxShadow}
        }
        
        ul.menu {
          display        : flex;
          flex-direction : column;
          flex-wrap      : nowrap;
          width          : max-content;
          
          margin : 0px;
          padding : 0px;
          border : ${this._getBorderStyle()};
          border-radius : ${this.getDefault("border-radius")}px;
          -moz-user-focus: normal;
          background-color: ${this.getDefault("MenuBG")};
          color : ${this.getDefault("MenuText").color};
        }
        
        .menuitem {
          display : flex;
          flex-wrap : nowrap;
          flex-direction : row;          
          
          list-style-type:none;
          -moz-user-focus: normal;
          
          margin : 0;
          padding : 0px;
          padding-right: 16px;
          padding-left: 16px;
          padding-top : ${pad1}px;
          padding-bottom : ${pad1}px;
          
          border-radius : ${itemRadius}px;
          
          color : ${this.getDefault("MenuText").color};
          font : ${this.getDefault("MenuText").genCSS()};
          background-color: ${this.getDefault("MenuBG")};
        }
        
        .menuseparator {
          ${sepcss}
        }
        
        .menuitem:focus {
          display : flex;
          text-align: left;
          
          border : none;
          outline : none;
          border-radius : ${itemRadius}px;
          
          background-color: ${this.getDefault("MenuHighlight")};
          color : ${this.getDefault("MenuText").color};
          -moz-user-focus: normal;
        }
      `;
  }

  setCSS() {
    super.setCSS();

    this.buildStyle();

    this.container.style["color"] = this.getDefault("MenuText").color;
    this.style["color"] = this.getDefault("MenuText").color;
  }

  seperator() {
    let bar = document.createElement("div");
    bar.setAttribute("class", "menuseparator");

    this.dom.appendChild(bar);

    return this;
  }

  menu(title) {
    let ret = UIBase$6.createElement("menu-x");

    ret.setAttribute("name", title);
    this.addItem(ret);

    return ret;
  }

  calcSize() {

  }
}

Menu.SEP = Symbol("menu seperator");
UIBase$6.internalRegister(Menu);

class DropBox extends OldButton {
  constructor() {
    super();

    this.lockTimer = 0;

    this._template = undefined;

    this._searchMenuMode = false;
    this.altKey = undefined;

    this._value = 0;

    this._last_datapath = undefined;

    this.r = 5;
    this._menu = undefined;
    this._auto_depress = false;
    //this.prop = new ui_base.EnumProperty(undefined, {}, "", "", 0);

    this._onpress = this._onpress.bind(this);
  }

  get searchMenuMode() {
    return this._searchMenuMode;
  }

  set searchMenuMode(v) {
    this._searchMenuMode = v;
  }

  get template() {
    return this._template;
  }

  set template(v) {
    this._template = v;
  }

  get value() {
    return this._value;
  }

  set value(v) {
    this.setValue(v);
  }

  get menu() {
    return this._menu;
  }

  set menu(val) {
    this._menu = val;

    if (val !== undefined) {
      this._name = val.title;
      this.updateName();
    }
  }

  static define() {
    return {
      tagname: "dropbox-x",
      style  : "dropbox"
    };
  }

  init() {
    super.init();

    this.setAttribute("menu-button", "true");

    this.updateWidth();
  }

  setCSS() {
    //do not call parent classes's setCSS here

    this.style["user-select"] = "none";
    this.dom.style["user-select"] = "none";

    let keys;
    if (this.getAttribute("simple")) {
      keys = ["margin-left", "margin-right", "padding-left", "padding-right"];
    } else {
      keys = [
        "margin", "margin-left", "margin-right",
        "margin-top", "margin-bottom", "padding",
        "padding-left", "padding-right", "padding-top",
        "padding-bottom"];
    }

    let setDefault = (key) => {
      if (this.hasDefault(key)) {
        this.dom.style[key] = this.getDefault(key, undefined, 0) + "px";
      }
    };

    for (let k of keys) {
      setDefault(k);
    }
  }

  _genLabel() {
    let s = super._genLabel();
    let ret = "";

    if (s.length === 0) {
      s = "(error)";
    }

    this.altKey = s[0].toUpperCase().charCodeAt(0);

    for (let i = 0; i < s.length; i++) {
      if (s[i] === "&" && i < s.length - 1 && s[i + 1] !== "&") {
        this.altKey = s[i + 1].toUpperCase().charCodeAt(0);
      } else if (s[i] === "&" && i < s.length - 1 && s[i + 1] === "&") {
        continue;
      } else {
        ret += s[i];
      }
    }

    return ret;
  }

  updateWidth() {
    //let ret = super.updateWidth(10);
    let dpi = this.getDPI();

    let ts = this.getDefault("DefaultText").size;
    let tw = this.g.measureText(this._genLabel()).width/dpi;
    //let tw = ui_base.measureText(this, this._genLabel(), undefined, undefined, ts).width + 8;
    tw = ~~tw;

    tw += 15;

    if (!this.getAttribute("simple")) {
      tw += 35;
    }

    if (tw !== this._last_w) {
      this._last_w = tw;
      this.dom.style["width"] = tw + "px";
      this.style["width"] = tw + "px";
      this.width = tw;

      this.overrideDefault("width", tw);
      this._repos_canvas();
      this._redraw();
    }

    return 0;
  }

  updateDataPath() {
    if (!this.ctx || !this.hasAttribute("datapath")) {
      return;
    }

    let wasError = false;
    let prop, val;

    try {
      this.pushReportContext(this._reportCtxName);
      prop = this.ctx.api.resolvePath(this.ctx, this.getAttribute("datapath")).prop;
      val = this.ctx.api.getValue(this.ctx, this.getAttribute("datapath"));
      this.popReportContext();
    } catch (error) {
      print_stack$1(error);
      wasError = true;
    }

    if (wasError) {
      this.disabled = true;
      this.setCSS();
      this._redraw();

      return;
    } else {
      this.disabled = false;
      this.setCSS();
      this._redraw();
    }

    if (!prop) {
      return;
    }

    if (this.prop === undefined) {
      this.prop = prop;
    }

    prop = this.prop;

    let name = this.getAttribute("name");

    if (prop.type & (PropTypes$4.ENUM | PropTypes$4.FLAG)) {
      name = prop.ui_value_names[prop.keys[val]];
    } else {
      name = "" + val;
    }

    if (name !== this.getAttribute("name")) {
      this.setAttribute("name", name);
      this.updateName();
    }
  }

  update() {
    let path = this.getAttribute("datapath");

    if (path && path !== this._last_datapath) {
      this._last_datapath = path;
      this.prop = undefined;

      this.updateDataPath();
    }

    super.update();

    let key = this.getDefault("dropTextBG");
    if (key !== this._last_dbox_key) {
      this._last_dbox_key = key;
      this.setCSS();
      this._redraw();
    }

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }
  }

  _build_menu_template() {
    if (this._menu !== undefined && this._menu.parentNode !== undefined) {
      this._menu.remove();
    }

    //let name = "" + this.getAttribute("name");
    let template = this._template;

    if (typeof template === "function") {
      template = template();
    }

    this._menu = createMenu(this.ctx, "", template);
    return this._menu;
  }

  _build_menu() {
    if (this._template) {
      this._build_menu_template();
      return;
    }

    let prop = this.prop;

    if (this.prop === undefined) {
      return;
    }

    if (this._menu !== undefined && this._menu.parentNode !== undefined) {
      this._menu.remove();
    }

    let menu = this._menu = UIBase$6.createElement("menu-x");

    //let name = "" + this.getAttribute("name");
    menu.setAttribute("name", "");
    menu._dropbox = this;

    let valmap = {};
    let enummap = prop.values;
    let iconmap = prop.iconmap;
    let uimap = prop.ui_value_names;
    let desr = prop.descriptions || {};

    for (let k in enummap) {
      let uk = k;

      valmap[enummap[k]] = k;

      if (uimap !== undefined && k in uimap) {
        uk = uimap[k];
      }

      let tooltip = desr[k];

      //menu.addItem(k, enummap[k], ":");
      if (iconmap && iconmap[k]) {
        menu.addItemExtra(uk, enummap[k], undefined, iconmap[k], undefined, tooltip);
      } else {
        menu.addItem(uk, enummap[k], undefined, tooltip);
      }
    }

    menu.onselect = (id) => {
      this._pressed = false;

      this._pressed = false;
      this._redraw();

      this._menu = undefined;

      //check if datapath system will be calling .prop.setValue instead of us
      let callProp = true;
      if (this.hasAttribute("datapath")) {
        let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));
        callProp = !prop || prop !== this.prop;
      }

      this._value = this._convertVal(id);

      if (callProp) {
        this.prop.setValue(id);
      }

      this.setAttribute("name", this.prop.ui_value_names[valmap[id]]);
      if (this.onselect) {
        this.onselect(id);
      }

      if (this.hasAttribute("datapath") && this.ctx) {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), id);
      }
    };
  }

  _onpress(e) {
    this.abortToolTips(1000);

    if (this._menu !== undefined) {
      this.lockTimer = time_ms();

      this._pressed = false;
      this._redraw();

      let menu = this._menu;
      this._menu = undefined;
      menu.close();
      return;
    }

    if (time_ms() - this.lockTimer < 200) {
      return;
    }

    this._build_menu();

    if (this._menu === undefined) {
      return;
    }

    this._menu.autoSearchMode = false;

    this._menu._dropbox = this;
    this.dom._background = this.getDefault("BoxDepressed");
    this._background = this.getDefault("BoxDepressed");
    this._redraw();
    this._pressed = true;
    this.setCSS();

    let onclose = this._menu.onclose;
    this._menu.onclose = () => {
      this.lockTimer = time_ms();

      this._pressed = false;
      this._redraw();

      let menu = this._menu;
      if (menu) {
        this._menu = undefined;
        menu._dropbox = undefined;
      }

      if (onclose) {
        onclose.call(menu);
      }
    };

    let menu = this._menu;
    let screen = this.getScreen();

    let dpi = this.getDPI();

    let x = e.x, y = e.y;
    let rects = this.dom.getBoundingClientRect(); //getClientRects();

    let rheight = rects.height;
    x = rects.x - window.scrollX;
    y = rects.y + rheight - window.scrollY; // + rects[0].height; // visualViewport.scale;

    if (!window.haveElectron) {
      //y -= 8;
    }

    /* need to figure out a better way to pop up a menu
    *  above a given y position */
    if (0) {// y > screen.size[1]*0.5 && !this.searchMenuMode) {
      let con = screen.popup(this, 500, 400, false, 0);

      con.style["z-index"] = "-10000";
      con.style["position"] = UIBase$6.PositionKey;
      document.body.appendChild(con);

      con.style["visibility"] = "hidden";

      con.add(menu);
      menu.start();

      let time = time_ms();

      let timer = window.setInterval(() => {
        if (time_ms() - time > 1500) {
          window.clearInterval(timer);
          return;
        }

        let r = menu.dom.getBoundingClientRect();

        if (!r || r.height < 55) {
          return;
        }

        window.clearInterval(timer);

        y -= r.height + rheight;

        menu.dom.remove();
        con.remove();

        let popup = this._popup = menu._popup = screen.popup(this, x, y, false, 0);
        popup.noMarginsOrPadding();

        //popup.shadow.appendChild(menu.dom);
        popup.add(menu);
        menu.start();

        popup.style["left"] = x + "px";
        popup.style["top"] = y + "px";
        //menu.setCSS();
      }, 1);

      return;
    }

    /*
    let w = document.createElement("div");
    w.style["width"] = w.style["height"] = "15px";
    w.style["background-color"] = "red";
    w.style["z-index"] = "5000";
    w.style["position"] = UIBase.PositionKey;
    w.style["pointer-events"] = "none";
    w.style["left"] = x + "px";
    w.style["top"] = y + "px";

    document.body.appendChild(w);
    //*/

    let con = this._popup = menu._popup = screen.popup(this, x, y, false, 0);
    con.noMarginsOrPadding();

    con.add(menu);
    if (this.searchMenuMode) {
      menu.startFancy();
    } else {
      menu.start();
    }
  }

  _redraw() {
    if (this.getAttribute("simple")) {
      let color;

      if (this._highlight) {
        drawRoundBox2(this, {canvas: this.dom, g: this.g, color: this.getDefault("BoxHighlight")});
      }

      if (this._focus) {
        drawRoundBox2(this, {
          canvas: this.dom, g: this.g, color: this.getDefault("BoxHighlight"), op: "stroke", no_clear: true
        });
        drawRoundBox(this, this.dom, this.g, undefined, undefined, 2, "stroke");
      }

      this._draw_text();
      return;
    }

    super._redraw(false);

    let g = this.g;
    let w = this.dom.width, h = this.dom.height;
    let dpi = this.getDPI();

    let p = 10*dpi;
    let p2 = dpi;

    //*
    let bg = this.getDefault("dropTextBG");
    if (bg !== undefined) {
      g.fillStyle = bg;

      g.beginPath();
      g.rect(p2, p2, this.dom.width - p2 - h, this.dom.height - p2*2);
      g.fill();
    }
    //*/

    g.fillStyle = "rgba(50, 50, 50, 0.2)";
    g.strokeStyle = "rgba(50, 50, 50, 0.8)";
    g.beginPath();
    /*
    g.moveTo(w-p, p);
    g.lineTo(w-(p+h*0.25), h-p);
    g.lineTo(w-(p+h*0.5), p);
    g.closePath();
    //*/

    let sz = 0.3;
    g.moveTo(w - h*0.5 - p, p);
    g.lineTo(w - p, p);
    g.moveTo(w - h*0.5 - p, p + sz*h/3);
    g.lineTo(w - p, p + sz*h/3);
    g.moveTo(w - h*0.5 - p, p + sz*h*2/3);
    g.lineTo(w - p, p + sz*h*2/3);

    g.lineWidth = 1;
    g.stroke();

    this._draw_text();
  }

  _convertVal(val) {
    if (typeof val === "string" && this.prop) {
      if (val in this.prop.values) {
        return this.prop.values[val];
      } else if (val in this.prop.keys) {
        return this.prop.keys[val];
      } else {
        return undefined;
      }
    }

    return val;
  }

  setValue(val, setLabelOnly = false) {
    if (val === undefined || val === this._value) {
      return;
    }

    val = this._convertVal(val);

    if (val === undefined) {
      console.warn("Bad val", arguments[0]);
      return;
    }

    this._value = val;

    if (this.prop !== undefined && !setLabelOnly) {
      this.prop.setValue(val);
      let val2 = val;

      if (val2 in this.prop.keys)
        val2 = this.prop.keys[val2];
      val2 = this.prop.ui_value_names[val2];

      this.setAttribute("name", "" + val2);
      this._name = "" + val2;
    } else {
      this.setAttribute("name", "" + val);
      this._name = "" + val;
    }

    if (this.onchange && !setLabelOnly) {
      this.onchange(val);
    }

    this.setCSS();
    this.updateDataPath();
    this._redraw();
  }
}

UIBase$6.internalRegister(DropBox);

class MenuWrangler {
  constructor() {
    this.screen = undefined;
    this.menustack = [];

    this.lastPickElemTime = time_ms();

    this._closetimer = 0;
    this.closeOnMouseUp = undefined;
    this.closereq = undefined;

    this.timer = undefined;
  }

  get closetimer() {
    return this._closetimer;
  }

  set closetimer(v) {
    debugmenu("set closertime", v);
    this._closetimer = v;
  }

  get menu() {
    return this.menustack.length > 0 ? this.menustack[this.menustack.length - 1] : undefined;
  }

  pushMenu(menu) {
    debugmenu("pushMenu");

    this.spawnreq = undefined;

    if (this.menustack.length === 0 && menu.closeOnMouseUp) {
      this.closeOnMouseUp = true;
    }

    this.menustack.push(menu);
  }

  popMenu(menu) {
    debugmenu("popMenu");

    return this.menustack.pop();
  }

  endMenus() {
    debugmenu("endMenus");

    for (let menu of this.menustack) {
      menu.close();
    }

    this.menustack = [];
  }

  searchKeyDown(e) {
    let menu = this.menu;

    e.stopPropagation();
    menu._ignoreFocusEvents = true;
    menu.textbox.focus();
    menu._ignoreFocusEvents = false;

    //if (e.shiftKey || e.altKey || e.ctrlKey || e.commandKey) {
    //  return;
    //}

    switch (e.keyCode) {
      case keymap["Enter"]: //return key
        menu.click(menu.activeItem);
        break;
      case keymap["Escape"]: //escape key
        menu.close();
        break;
      case keymap["Up"]:
        menu.selectPrev(false);
        break;
      case keymap["Down"]:
        menu.selectNext(false);
        break;
    }
  }

  on_keydown(e) {
    window.menu = this.menu;

    if (this.menu === undefined) {
      return;
    }

    if (this.menu.hasSearchBox) {
      return this.searchKeyDown(e);
    }

    let menu = this.menu;

    switch (e.keyCode) {
      case keymap["Left"]: //left
      case keymap["Right"]: //right
        if (menu._dropbox) {
          let dropbox = menu._dropbox;

          if (e.keyCode === keymap["Left"]) {
            dropbox = dropbox.previousElementSibling;
          } else {
            dropbox = dropbox.nextElementSibling;
          }

          if (dropbox !== undefined && dropbox instanceof DropBox) {
            this.endMenus();
            dropbox._onpress(e);
          }
        }
        break;
      case keymap["Up"]: //up
        menu.selectPrev();
        break;
      case keymap["Down"]: //down
        menu.selectNext();
        break;
      /*
      let item = menu.activeItem;
      if (!item) {
        item = menu.items[0];
      }

      if (!item) {
        return;
      }

      let item2;
      let i = menu.items.indexOf(item);

      if (e.keyCode == 38) {
        i = (i - 1 + menu.items.length) % menu.items.length;
      } else {
        i = (i + 1) % menu.items.length;
      }

      item2 = menu.items[i];

      if (item2) {
        menu.setActive(item2);
      }
      break;//*/
      case 13: //return key
      case 32: //space key
        menu.click(menu.activeItem);
        break;
      case 27: //escape key
        menu.close();
        break;
    }
  }

  on_pointerdown(e) {
    if (this.menu === undefined || this.screen === undefined) {
      this.closetimer = time_ms();
      return;
    }

    let screen = this.screen;
    let x = e.pageX, y = e.pageY;

    let element = screen.pickElement(x, y);

    if (element !== undefined && (element instanceof DropBox || isMobile())) {
      this.endMenus();
      e.preventDefault();
      e.stopPropagation();
    }
  }

  on_pointerup(e) {
    if (this.menu === undefined || this.screen === undefined) {
      this.closetimer = time_ms();
      return;
    }

    let screen = this.screen;
    let x = e.pageX, y = e.pageY;

    let element = screen.pickElement(x, y, undefined, undefined, DropBox);
    if (element !== undefined) {
      this.closeOnMouseUp = false;
    } else {
      element = screen.pickElement(x, y, undefined, undefined, Menu);

      //closeOnMouseUp
      if (element && this.closeOnMouseUp) {
        element.click();
      }
    }

  }

  findMenu(x, y) {
    let screen = this.screen;

    let element = screen.pickElement(x, y);

    if (element === undefined) {
      return;
    }

    if (element instanceof Menu) {
      return element;
    }

    let w = element;

    while (w) {
      if (w instanceof Menu) {//w === this.menu) {
        return w;
        break;
      }

      w = w.parentWidget;
    }

    return undefined;
  }

  on_pointermove(e) {
    if (this.menu && this.menu.hasSearchBox) {
      this.closetimer = time_ms();
      this.closereq = undefined;
      return;
    }

    if (this.menu === undefined || this.screen === undefined) {
      this.closetimer = time_ms();
      this.closereq = undefined;
      return;
    }

    let screen = this.screen;
    let x = e.pageX, y = e.pageY;

    let element;
    let menu = this.menu;

    if (menu) {
      let r = menu.getBoundingClientRect();
      let pad = 15;

      if (r && x >= r.x - pad && y >= r.y - pad && x <= r.x + r.width + pad*2 && y <= r.y + r.height + pad*2) {
        element = menu;
      }
    }

    if (!element && time_ms() - this.lastPickElemTime > 250) {
      element = screen.pickElement(x, y);
      this.lastPickElemTime = time_ms();
    }

    if (element === undefined) {
      return;
    }

    if (element instanceof Menu) {
      this.closetimer = time_ms();
      this.closereq = undefined;
      return;
    }

    let destroy = element.hasAttribute("menu-button") && element.hasAttribute("simple");
    destroy = destroy && element.menu !== this.menu;

    if (destroy) {
      /* check that dropbox doesn't contain our parent menu either */

      let menu2 = this.menu;
      while (menu2 !== element.menu) {
        menu2 = menu2.parentMenu;
        destroy = destroy && menu2 !== element.menu;
      }
    }

    if (destroy) {
      //destroy entire menu stack
      this.endMenus();

      this.closetimer = time_ms();
      this.closereq = undefined;

      //start new menu
      element._onpress(e);
      return;
    }

    let ok = false;

    let w = element;
    while (w) {
      if (w instanceof Menu) {//w === this.menu) {
        ok = true;
        break;
      }

      if (w.hasAttribute("menu-button") && w.menu === this.menu) {
        ok = true;
        break;
      }

      w = w.parentWidget;
    }

    if (!ok) {
      this.closereq = this.menu;
    } else {
      this.closetimer = time_ms();
      this.closereq = undefined;
    }
  }

  update() {
    let closetime = exports.menu_close_time;
    closetime = closetime === undefined ? 50 : closetime;

    let close = this.closereq && this.closereq === this.menu;
    close = close && time_ms() - this.closetimer > closetime;

    if (close) {
      this.closereq = undefined;
      this.endMenus();
    }
  }

  startTimer() {
    if (this.timer) {
      this.stopTimer();
    }

    this.timer = setInterval(() => {
      debugmenu("start menu wrangler interval");

      this.update();
    }, 150);
  }

  stopTimer() {
    if (this.timer) {
      debugmenu("stop menu wrangler interval");

      clearInterval(this.timer);
      this.timer = undefined;
    }
  }
}

let menuWrangler = new MenuWrangler();
let wrangerStarted = false;

function startMenuEventWrangling(screen) {
  menuWrangler.screen = screen;

  if (wrangerStarted) {
    return;
  }

  wrangerStarted = true;

  for (let k in DomEventTypes) {
    if (menuWrangler[k] === undefined) {
      continue;
    }

    let dom = k.search("key") >= 0 ? window : document.body;
    dom = window;
    dom.addEventListener(DomEventTypes[k], menuWrangler[k].bind(menuWrangler), {passive: false, capture: true});
  }

  menuWrangler.screen = screen;
  menuWrangler.startTimer();
}

function setWranglerScreen(screen) {
  startMenuEventWrangling(screen);
}

function getWranglerScreen() {
  return menuWrangler.screen;
}

function createMenu(ctx, title, templ) {
  let menu = UIBase$6.createElement("menu-x");
  menu.ctx = ctx;
  menu.setAttribute("name", title);

  let SEP = menu.constructor.SEP;
  let id = 0;
  let cbs = {};

  let doItem = (item) => {
    if (item !== undefined && item instanceof Menu) {
      menu.addItem(item);
    } else if (typeof item == "string") {
      let def, hotkey;

      try {
        def = ctx.api.getToolDef(item);
      } catch (error) {
        menu.addItem("(tool path error)", id++);
        return;
      }

      //3Extra(text, id=undefined, hotkey, icon=-1, add=true) {
      if (!def.hotkey) {
        try {
          hotkey = ctx.api.getToolPathHotkey(ctx, item);
        } catch (error) {
          print_stack$1(error);
          console.warn("error getting hotkey for tool " + item);
          hotkey = undefined;
        }
      } else {
        hotkey = def.hotkey;
      }

      menu.addItemExtra(def.uiname, id, hotkey, def.icon);

      cbs[id] = (function (toolpath) {
        return function () {
          ctx.api.execTool(ctx, toolpath);
        }
      })(item);

      id++;
    } else if (item === SEP) {
      menu.seperator();
    } else if (typeof item === "function" || item instanceof Function) {
      doItem(item());
    } else if (item instanceof Array) { //old array-based api for custom entries
      let hotkey = item.length > 2 ? item[2] : undefined;
      let icon = item.length > 3 ? item[3] : undefined;
      let tooltip = item.length > 4 ? item[4] : undefined;
      let id2 = item.length > 5 ? item[5] : id++;

      if (hotkey !== undefined && hotkey instanceof HotKey) {
        hotkey = hotkey.buildString();
      }

      menu.addItemExtra(item[0], id2, hotkey, icon, undefined, tooltip);

      cbs[id2] = (function (cbfunc, arg) {
        return function () {
          cbfunc(arg);
        }
      })(item[1], id2);
    } else if (typeof item === "object") { //new object-based api for custom entries
      let {name, callback, hotkey, icon, tooltip} = item;

      let id2 = item.id !== undefined ? item.id : id++;
      if (hotkey !== undefined && hotkey instanceof HotKey) {
        hotkey = hotkey.buildString();
      }

      menu.addItemExtra(name, id2, hotkey, icon, undefined, tooltip);

      cbs[id2] = (function (cbfunc, arg) {
        return function () {
          cbfunc(arg);
        }
      })(callback, id2);
    }
  };

  for (let item of templ) {
    doItem(item);
  }

  menu.onselect = (id) => {
    cbs[id]();
  };

  return menu;
}

function startMenu(menu, x, y, searchMenuMode = false, safetyDelay = 55) {
  menuWrangler.endMenus();

  let screen = menu.ctx.screen;
  let con = menu._popup = screen.popup(undefined, x, y, false, safetyDelay);
  con.noMarginsOrPadding();

  con.add(menu);
  if (searchMenuMode) {
    menu.startFancy();
  } else {
    menu.start();
  }

  menu.flushUpdate();
  menu.flushSetCSS();

  menu._popup.flushUpdate();
  menu._popup.flushSetCSS();
}

//bind module to global var to get at it in console.
//
//note that require has an api for handling circular 
//module refs, in such cases do not use these vars.

var _ui = undefined;

let PropFlags$1 = PropFlags;
let PropSubTypes$2 = PropSubTypes$1;

let EnumProperty$6 = EnumProperty;

let Vector2$4   = Vector2,
    UIBase$7    = UIBase$2,
    PackFlags$5 = PackFlags,
    PropTypes$5 = PropTypes;

class Label extends UIBase$2 {
  constructor() {
    super();

    this._label = "";

    this._lastText = "";

    this.dom = document.createElement("div");
    this.dom.setAttribute("class", "_labelx");

    let style = document.createElement("style");
    style.textContent = `
      div._labelx::selection {
        color: none;
        background: none;
         -webkit-user-select:none;
         user-select:none;
      }
    `;

    this.shadow.appendChild(style);
    this.shadow.appendChild(this.dom);

    this.font = "LabelText";
  }

  get font() {
    return this._font;
  }

  /**Set a font defined in ui_base.defaults
   e.g. DefaultText*/
  set font(fontDefaultName) {
    if (typeof fontDefaultName === "string") {
      this._font = this.getDefault(fontDefaultName);
      if (!this._font) {
        console.warn("Invalid font", fontDefaultName);
      }
    } else if (typeof fontDefaultName === "object" && fontDefaultName instanceof CSSFont) {
      this._font = fontDefaultName;
    } else {
      console.warn("Invalid font", fontDefaultName);
    }

    this._updateFont();
  }

  get text() {
    return this._label;
    //return this.dom.innerText;
  }

  set text(text) {
    this._label = text;

    if (!this.hasAttribute("datapath")) {
      this.dom.innerText = text;
    }
  }

  static define() {
    return {
      tagname: "label-x",
      style  : "label"
    };
  }

  init() {
    this.dom.style["width"] = "max-content";
  }

  setCSS() {
    super.setCSS(false);
    this.setBoxCSS();
  }

  on_disabled() {
    super.on_disabled();
    this._enabled_font = this.font;
    this.font = "DefaultText";
    this._updateFont();
  }

  on_enabled() {
    super.on_enabled();
    this.font = this._enabled_font;
    this._updateFont();
  }

  _updateFont() {
    let font = this._font;
    if (!font) return;

    this.dom.style["font"] = font.genCSS();
    this.dom.style["color"] = font.color;
  }

  updateDataPath() {
    if (this.ctx === undefined) {
      return;
    }

    let path = this.getAttribute("datapath");
    let prop = this.getPathMeta(this.ctx, path);
    let val = this.getPathValue(this.ctx, path);

    if (val === undefined) {
      return;
    }

    //console.log(path);
    if (prop.type & (PropTypes$5.INT | PropTypes$5.FLOAT)) {
      val = buildString(val, prop.baseUnit, prop.decimalPlaces, prop.displayUnit);
    }

    val = "" + this._label + " " + val;

    if (val !== this._lastText) {
      this._lastText = val;
      this.dom.innerText = val;
    }
  }

  update() {
    let key = "";

    if (this._font !== undefined && this._font instanceof CSSFont) {
      key += this._font.genKey();
    }

    if (key !== this._last_font) {
      this._last_font = key;
      this._updateFont();
    }

    this.dom.style["pointer-events"] = this.style["pointer-events"];

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }
  }
}

UIBase$2.internalRegister(Label);

class Container extends UIBase$2 {
  constructor() {
    super();

    this.dataPrefix = '';
    this.massSetPrefix = '';

    this.inherit_packflag = 0;

    let style = this.styletag = document.createElement("style");
    style.textContent = `
    `;

    this.shadow.appendChild(style);
    this.reversed = false;

    this._prefixstack = [];
    this._mass_prefixstack = [];
  }

  set background(bg) {
    this.__background = bg;

    this.styletag.textContent = `div.containerx {
        background-color : ${bg};
      }
    `;
    this.style["background-color"] = bg;
  }

  get children() {
    let list = [];

    this._forEachChildWidget((n) => {
      list.push(n);
    });

    return list
  }

  static define() {
    return {
      tagname: "container-x"
    };
  }

  /** recursively change path prefix for all children*/
  changePathPrefix(newprefix) {
    let prefix = this.dataPrefix.trim();
    this.dataPrefix = newprefix;

    if (prefix.length > 0) {
      prefix += ".";
    }

    let rec = (n, con) => {
      if (n instanceof Container && n !== this) {
        if (n.dataPrefix.startsWith(prefix)) {
          n.dataPrefix = n.dataPath.slice(prefix.length, n.dataPrefix.length);
          n.dataPrefix = con._joinPrefix(n.dataPrefix);
          con = n;
        }
      }

      if (n.hasAttribute("datapath")) {
        let path = n.getAttribute("datapath");

        if (path.startsWith(prefix)) {
          path = path.slice(prefix.length, path.length);
          path = con._joinPrefix(path);
          n.setAttribute("datapath", path);

          //update helper tooltips
          n.description = n.description;
        }
      }

      n._forEachChildWidget((n2) => {
        rec(n2, con);
      });
    };

    rec(this, this);
  }

  reverse() {
    this.reversed ^= true;
    return this;
  }

  pushMassSetPrefix(val) {
    this._mass_prefixstack.push(this.massSetPrefix);
    this.massSetPrefix = val;
    return this;
  }

  pushDataPrefix(val) {
    this._prefixstack.push(this.dataPrefix);
    this.dataPrefix = val;
    return this;
  }

  popDataPrefix() {
    this.dataPrefix = this._prefixstack.pop();
    return this;
  }

  popMassSetPrefix() {
    this.massSetPrefix = this._mass_prefixstack.pop();
    return this;
  }

  saveData() {
    if (this.scrollTop || this.scrollLeft) {
      return {
        scrollTop : this.scrollTop,
        scrollLeft: this.scrollLeft
      }
    } else {
      return {};
    }
  }

  loadData(obj) {
    if (!obj) return;

    let x = obj.scrollLeft || 0;
    let y = obj.scrollTop || 0;

    this.doOnce(() => {
      this.scrollTo(x, y);
    }, 12);
  }

  init() {
    this.style["display"] = "flex";
    this.style["flex-direction"] = this.reversed ? "column-reverse" : "column";
    this.style["flex-wrap"] = "nowrap";
    this.style["flex-grow"] = "" + this.getDefault("flex-grow", undefined, "1");

    this.setCSS();

    super.init();

    this.setAttribute("class", "containerx");
  }

  /** Returns previous icon flags */
  useIcons(enabled_or_sheet = true) {
    let enabled = !!enabled_or_sheet;

    let mask = PackFlags$5.USE_ICONS | PackFlags$5.SMALL_ICON | PackFlags$5.LARGE_ICON;
    mask = mask | PackFlags$5.CUSTOM_ICON_SHEET;
    mask = mask | (255<<PackFlags$5.CUSTOM_ICON_SHEET_START);

    let previous = this.packflag & mask;

    if (!enabled) {
      this.packflag &= ~PackFlags$5.USE_ICONS;
      this.inherit_packflag &= ~PackFlags$5.USE_ICONS;

      return previous;
    }

    let sheet = enabled_or_sheet;

    if (sheet === true) {
      sheet = PackFlags$5.SMALL_ICON;
    } else if (sheet === 1) {
      sheet = PackFlags$5.LARGE_ICON;
    } else {
      sheet = PackFlags$5.CUSTOM_ICON_SHEET | (sheet<<(PackFlags$5.CUSTOM_ICON_SHEET_START));
    }

    //clear any existing sizing flags
    this.packflag &= ~(PackFlags$5.SMALL_ICON | PackFlags$5.LARGE_ICON | PackFlags$5.CUSTOM_ICON_SHEET);
    this.packflag &= ~(255<<PackFlags$5.CUSTOM_ICON_SHEET_START);

    this.packflag |= PackFlags$5.USE_ICONS | sheet;
    this.inherit_packflag |= PackFlags$5.USE_ICONS | sheet;

    return previous;
  }

  /**
   *
   * @param mode: flexbox wrap mode, can be wrap, nowrap, or wrap-reverse
   * @returns {Container}
   */
  wrap(mode = "wrap") {
    this.style["flex-wrap"] = mode;
    return this;
  }

  noMarginsOrPadding() {
    super.noMarginsOrPadding();

    let keys = ["margin", "padding", "margin-block-start", "margin-block-end"];
    keys = keys.concat(["padding-block-start", "padding-block-end"]);

    for (let k of keys) {
      this.style[k] = "0px";
    }

    return this;
  }

  setCSS() {
    let rest = '';

    let add = (style) => {
      if (!this.hasDefault(style)) {
        return;
      }

      let val = this.getDefault(style);

      if (val !== undefined) {
        rest += `  ${style} = ${val};\n`;
        this.style[style] = val;
      }
    };

    add("border-radius");
    add("border-width");
    add("border-top");
    add("border-bottom");
    add("border-left");
    add("border-right");

    this.styletag.textContent = `div.containerx {
        background-color : ${this.getDefault("background-color")};
        ${rest}
      }
      `;
  }

  overrideDefault(key, val) {
    super.overrideDefault(key, val);
    this.setCSS();

    return this;
  }

  /*
  * shorthand for:
  *
  * .row().noMarginsOrPadding().oneAxisPadding()
  * */
  strip(themeClass = "strip", margin1 = this.getDefault("oneAxisPadding"), margin2 = 1, horiz = undefined) {
    if (horiz === undefined) {
      horiz = this instanceof RowFrame;
      horiz = horiz || this.style["flex-direction"] === "row";
    }

    let flag = horiz ? PackFlags$5.STRIP_HORIZ : PackFlags$5.STRIP_VERT;

    let strip = (horiz ? this.row() : this.col());

    if (typeof margin1 !== "number") {
      throw new Error("margin1 was not a number");
    }
    if (typeof margin2 !== "number") {
      throw new Error("margin2 was not a number");
    }

    strip.packflag |= flag;
    strip.dataPrefix = this.dataPrefix;
    strip.massSetPrefix = this.massSetPrefix;

    if (themeClass in theme) {
      strip.overrideClass(themeClass);
      strip.background = strip.getDefault("background-color");
      strip.setCSS();
      strip.overrideClass(themeClass);

      let lastkey;

      strip.update.after(function () {
        let bradius = strip.getDefault("border-radius");
        let bline = strip.getDefault("border-width");
        let bstyle = strip.getDefault("border-style") || 'solid';
        let padding = strip.getDefault("padding");
        let bcolor = strip.getDefault("border-color") || "rgba(0,0,0,0)";
        let margin = strip.getDefault("margin") || 0;

        bline = bline === undefined ? 0 : bline;
        bradius = bradius === undefined ? 0 : bradius;
        padding = padding === undefined ? 5 : padding;

        let bg = strip.getDefault("background-color");

        let key = "" + bradius + ":" + bline + ":" + bg + ":" + padding + ":";
        key += bstyle + ":" + padding + ":" + bcolor + ":" + margin;

        if (key !== lastkey) {
          lastkey = key;

          strip.oneAxisPadding(margin1 + padding, margin2 + padding);
          strip.setCSS();

          strip.background = bg;

          strip.style["margin"] = "" + margin + "px";
          strip.style["border"] = `${bline}px ${bstyle} ${bcolor}`;
          strip.style["border-radius"] = "" + bradius + "px";
        }
      });
    } else {
      console.warn(this.constructor.name + ".strip(): unknown theme class " + themeClass);
    }

    /*
    let prev = strip.previousElementSibling;
    if (prev !== undefined && (prev.packflag & flag)) {
      if (horiz) {
        prev.style["padding-right"] = "0px";
      } else {
        prev.style["padding-top"] = "0px";
      }
    }//*/

    return strip;
  }

  /**
   * tries to set margin along one axis only in smart manner
   * */
  oneAxisMargin(m = this.getDefault("oneAxisMargin"), m2 = 0) {
    this.style["margin-top"] = this.style["margin-bottom"] = "" + m + "px";
    this.style["margin-left"] = this.style["margin-right"] = "" + m2 + "px";

    return this;
  }

  /**
   * tries to set padding along one axis only in smart manner
   * */
  oneAxisPadding(axisPadding = this.getDefault("oneAxisPadding"), otherPadding = 0) {
    this.style["padding-top"] = this.style["padding-bottom"] = "" + axisPadding + "px";
    this.style["padding-left"] = this.style["padding-right"] = "" + otherPadding + "px";

    return this;
  }

  setMargin(m) {
    this.style["margin"] = m + "px";

    return this;
  }

  setPadding(m) {
    this.style["padding"] = m + "px";

    return this;
  }

  setSize(width, height) {
    if (width !== undefined) {
      if (typeof width == "number")
        this.style["width"] = this.div.style["width"] = ~~width + "px";
      else
        this.style["width"] = this.div.style["width"] = width;
    }

    if (height !== undefined) {
      if (typeof height == "number")
        this.style["height"] = this.div.style["height"] = ~~height + "px";
      else
        this.style["height"] = this.div.style["height"] = height;
    }

    return this;
  }

  save() {
  }

  load() {
  }

  saveVisibility() {
    localStorage[this.storagePrefix + "_settings"] = JSON.stringify(this);
    return this;
  }

  loadVisibility() {
    let key = this.storagePrefix + "_settings";
    let ok = true;

    if (key in localStorage) {
      console.log("loading UI visibility state. . .");

      try {
        this.loadJSON(JSON.parse(localStorage[key]));
      } catch (error) {
        print_stack$1(error);
        ok = false;
      }
    }

    return ok;
  }

  toJSON() {
    let ret = {
      opened: !this.closed
    };

    return Object.assign(super.toJSON(), ret);
  }

  _ondestroy() {
    this._forEachChildWidget((n) => {
      n._ondestroy();
    });

    super._ondestroy();
  }

  loadJSON(obj) {
    //console.error("ui.js:Container.loadJSON: implement me!");

    return this;
  }

  redrawCurves() {
    throw new Error("Implement me (properly!)");

    if (this.closed)
      return;

    for (let cw of this.curve_widgets) {
      cw.draw();
    }
  }

  listen() {
    window.setInterval(() => {
      this.update();
    }, 150);
  }

  update() {
    super.update();
  }

  appendChild(child) {
    if (child instanceof UIBase$2) {
      child.ctx = this.ctx;
      child.parentWidget = this;
      this.shadow.appendChild(child);

      if (child.onadd) {
        child.onadd();
      }

      return;
    }

    return super.appendChild(child);
  }

  clear(trigger_on_destroy = true) {
    for (let child of this.children) {
      if (child instanceof UIBase$2) {
        child.remove(trigger_on_destroy);
      }
    }
  }

  removeChild(child, trigger_on_destroy = true) {
    let ret = super.removeChild(child);

    if (child.on_remove) {
      child.on_remove();
    }

    if (trigger_on_destroy && child.on_destroy) {
      child.on_destroy();
    }

    child.parentWidget = undefined;

    return ret;
  }

  prepend(child) {
    if (child instanceof UIBase$7) {
      this._prepend(child);
    } else {
      super.prepend(child);
    }
  }

  //*
  _prepend(child) {
    return this._add(child, true);
  }//*/

  add(child) {
    return this._add(child);
  }

  insert(i, ch) {
    ch.parentWidget = this;
    ch.ctx = this;

    if (i >= this.shadow.childNodes.length) {
      this.add(ch);
    } else {
      this.shadow.insertBefore(ch, list(this.children)[i]);
    }

    if (ch.onadd) {
      ch.onadd();
    }
  }

  _add(child, prepend = false) {
    //paranoia check for if we accidentally got a DOM NodeList
    if (child instanceof NodeList) {
      throw new Error("eek!");
    }

    child.ctx = this.ctx;
    child.parentWidget = this;
    child._useDataPathUndo = this._useDataPathUndo;

    if (!child._themeOverride && this._themeOverride) {
      child.overrideTheme(this._themeOverride);
    }

    if (prepend) {
      this.shadow.prepend(child);
    } else {
      this.shadow.appendChild(child);
    }

    /*
    if (child._ctx) {
      child._init();
    }//*/

    if (child.onadd)
      child.onadd();

    return child;
  }

  //TODO: make sure this works on Electron?
  dynamicMenu(title, list, packflag = 0) {
    //actually, .menu works for now
    return this.menu(title, list, packflag);
  }

  /**example usage:

   .menu([
   "some_tool_path.tool()|CustomLabel",
   ui_widgets.Menu.SEP,
   "some_tool_path.another_tool()",
   ["Name", () => {console.log("do something")}]
   ])

   **/
  menu(title, list, packflag = 0) {
    let dbox = UIBase$7.createElement("dropbox-x");

    dbox._name = title;
    dbox.setAttribute("simple", true);
    dbox.setAttribute("name", title);

    if (list instanceof HTMLElement && list.constructor.name === "Menu") {
      dbox._build_menu = function () {
        if (this._menu !== undefined && this._menu.parentNode !== undefined) {
          this._menu.remove();
        }

        this._menu = createMenu(this.ctx, title, templ);
        return this._menu;
      };
    } else if (list) {
      dbox.template = list;
    }

    this._container_inherit(dbox, packflag);

    this._add(dbox);
    return dbox;
  }

  toolPanel(path_or_cls, args = {}) {
    let tdef;
    let cls;

    if (typeof path_or_cls === "string") {
      cls = this.ctx.api.parseToolPath(path_or_cls);
    } else {
      cls = path_or_cls;
    }

    tdef = cls._getFinalToolDef();

    let packflag = args.packflag || 0;
    let label = args.label || tdef.uiname;
    let createCb = args.createCb || args.create_cb;
    let container = args.container || this.panel(label);
    let defaultsPath = args.defaultsPath || "toolDefaults";

    if (defaultsPath.length > 0 && !defaultsPath.endsWith(".")) {
      defaultsPath += ".";
    }

    let path = defaultsPath + tdef.toolpath;

    container.useIcons(false);

    let inputs = tdef.inputs || {};
    for (let k in inputs) {
      let prop = inputs[k];

      if (prop.flag & PropFlags$1.PRIVATE) {
        continue;
      }

      let apiname = prop.apiname || k;
      let path2 = path + "." + apiname;

      container.prop(path2);
    }

    container.tool(path_or_cls, packflag, createCb, label);

    return container;
  }

  tool(path_or_cls, packflag_or_args = {}, createCb = undefined, label = undefined) {
    let cls;
    let packflag;

    if (typeof packflag_or_args === "object") {
      let args = packflag_or_args;

      packflag = args.packflag;
      createCb = args.createCb;
      label = args.label;
    } else {
      packflag = packflag_or_args || 0;
    }

    if (typeof path_or_cls == "string") {
      if (path_or_cls.search(/\|/) >= 0) {
        path_or_cls = path_or_cls.split("|");

        if (label === undefined && path_or_cls.length > 1) {
          label = path_or_cls[1].trim();
        }

        path_or_cls = path_or_cls[0].trim();
      }

      if (this.ctx === undefined) {
        console.warn("this.ctx was undefined in tool()");
        return;
      }

      cls = this.ctx.api.parseToolPath(path_or_cls);

      if (cls === undefined) {
        console.warn("Unknown tool for toolpath \"" + path_or_cls + "\"");
        return;
      }
    } else {
      cls = path_or_cls;
    }

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;
    let hotkey;

    if (createCb === undefined) {
      createCb = (cls) => {
        return this.ctx.api.createTool(this.ctx, path_or_cls);
      };
    }

    let cb = () => {
      console.log("tool run");

      let toolob = createCb(cls);
      this.ctx.api.execTool(this.ctx, toolob);
    };

    let def = typeof path_or_cls === "string" ? this.ctx.api.getToolDef(path_or_cls) : cls.tooldef();
    let tooltip = def.description === undefined ? def.uiname : def.description;

    //is there a hotkey hardcoded in the class?
    if (def.hotkey !== undefined) {
      tooltip += "\n\t" + def.hotkey;
      hotkey = def.hotkey;
    } else { //if not, use getToolPathHotkey api
      let path = path_or_cls;

      if (typeof path != "string") {
        path = def.toolpath;
      }

      let hotkey = this.ctx.api.getToolPathHotkey(this.ctx, path);
      if (hotkey) {
        tooltip += "\n\tHotkey: " + hotkey;
      }
    }

    let ret;

    if (def.icon !== undefined && (packflag & PackFlags$5.USE_ICONS)) {
      label = label === undefined ? tooltip : label;

      ret = this.iconbutton(def.icon, label, cb);

      ret.iconsheet = iconSheetFromPackFlag(packflag);
      ret.packflag |= packflag;
    } else {
      label = label === undefined ? def.uiname : label;

      ret = this.button(label, cb);
      ret.description = tooltip;
      ret.packflag |= packflag;
    }

    return ret;
  }

  //supports number types
  textbox(inpath, text, cb = undefined, packflag = 0) {
    let path;

    if (inpath) {
      path = this._joinPrefix(inpath);
    }

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let ret = UIBase$7.createElement("textbox-x");

    if (path !== undefined) {
      ret.setAttribute("datapath", path);
    }

    ret.ctx = this.ctx;
    ret.parentWidget = this;
    ret._init();
    this._add(ret);

    ret.setCSS();
    ret.update();

    ret.packflag |= packflag;
    ret.onchange = cb;
    ret.text = text;

    return ret;
  }

  pathlabel(inpath, label = "", packflag = 0) {
    let path;

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    if (inpath) {
      path = this._joinPrefix(inpath);
    }

    let ret = UIBase$7.createElement("label-x");

    ret.text = label;
    ret.packflag = packflag;
    ret.setAttribute("datapath", path);

    this._add(ret);

    return ret;
  }

  label(text) {
    let ret = UIBase$7.createElement("label-x");
    ret.text = text;

    this._add(ret);

    return ret;
  }

  /**
   *
   * makes a button for a help picker tool
   * to view tooltips on mobile devices
   * */
  helppicker() {
    let ret = this.iconbutton(Icons.HELP, "Help Picker", () => {
      this.getScreen().hintPickerTool();
    });

    if (isMobile()) {
      //ret.iconsheet = 2;
      //XXX look up in mobile theme properly
    }

    if (ret.ctx) {
      ret._init();
      ret.setCSS();
    }

    return ret;
  }

  iconbutton(icon, description, cb, thisvar, packflag = 0) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let ret = UIBase$7.createElement("iconbutton-x");

    ret.packflag |= packflag;

    ret.setAttribute("icon", icon);
    ret.description = description;
    ret.icon = icon;

    ret.iconsheet = iconSheetFromPackFlag(packflag);

    ret.onclick = cb;

    this._add(ret);

    return ret;
  }

  button(label, cb, thisvar, id, packflag = 0) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let ret = UIBase$7.createElement("button-x");

    ret.packflag |= packflag;

    ret.setAttribute("name", label);
    ret.setAttribute("buttonid", id); //XXX no longer used?
    ret.onclick = cb;

    this._add(ret);

    return ret;
  }

  _joinPrefix(path, prefix = this.dataPrefix.trim()) {
    if (path === undefined) {
      return undefined;
    }

    path = path.trim();
    if (path[0] === "/") {
      return path;
    }

    if (prefix.length > 0 && path.length > 0 && !prefix.endsWith(".") && !path.startsWith(".")) {
      path = "." + path;
    }

    return prefix + path;
  }

  colorbutton(inpath, packflag, mass_set_path = undefined) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    let ret = UIBase$7.createElement("color-picker-button-x");

    if (inpath !== undefined) {
      inpath = this._joinPrefix(inpath);
      ret.setAttribute("datapath", inpath);
    }

    if (mass_set_path !== undefined) {
      ret.setAttribute("mass_set_path", mass_set_path);
    }

    ret.packflag |= packflag;

    this._add(ret);
    return ret;
  }

  noteframe(packflag = 0) {
    let ret = UIBase$7.createElement("noteframe-x");

    ret.packflag |= (this.inherit_packflag & ~PackFlags$5.NO_UPDATE) | packflag;

    this._add(ret);
    return ret;
  }

  curve1d(inpath, packflag = 0, mass_set_path = undefined) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    let ret = UIBase$7.createElement("curve-widget-x");

    ret.ctx = this.ctx;
    ret.packflag |= packflag;

    if (inpath) {
      inpath = this._joinPrefix(inpath);
      ret.setAttribute("datapath", inpath);
    }

    if (mass_set_path)
      ret.setAttribute("mass_set_path", mass_set_path);

    this.add(ret);

    return ret;
  }

  vecpopup(inpath, packflag = 0, mass_set_path = undefined) {
    let button = UIBase$7.createElement("vector-popup-button-x");

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;
    let name = "vector";

    if (inpath) {
      inpath = this._joinPrefix(inpath);

      button.setAttribute("datapath", inpath);
      if (mass_set_path) {
        button.setAttribute("mass_set_path", mass_set_path);
      }

      let rdef = this.ctx.api.resolvePath(this.ctx, inpath);
      if (rdef && rdef.prop) {
        name = rdef.prop.uiname || rdef.prop.name;
      }
    }

    button.setAttribute("name", name);
    button.packflag |= packflag;

    this.add(button);
    return button;
  }

  _getMassPath(ctx, inpath, mass_set_path) {
    if (mass_set_path === undefined && this.massSetPrefix.length > 0) {
      mass_set_path = ctx.api.getPropName(ctx, inpath);
    }

    if (mass_set_path === undefined) {
      return undefined;
    }

    return this._joinPrefix(mass_set_path, this.massSetPrefix);
  }

  prop(inpath, packflag = 0, mass_set_path = undefined) {
    if (!this.ctx) {
      console.warn(this.id + ".ctx was undefined");
      let p = this.parentWidget;

      while (p) {
        if (p.ctx) {
          console.warn("Fetched this.ctx from parent");
          this.ctx = p.ctx;
          break;
        }

        p = p.parentWidget;
      }

      if (!this.ctx) {
        throw new Error("ui.Container.prototype.prop(): this.ctx was undefined");
      }
    }

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let rdef = this.ctx.api.resolvePath(this.ctx, this._joinPrefix(inpath), true);

    if (rdef === undefined || rdef.prop === undefined) {
      console.warn("Unknown property at path", this._joinPrefix(inpath), this.ctx.api.resolvePath(this.ctx, this._joinPrefix(inpath), true));
      return;
    }
    //slider(path, name, defaultval, min, max, step, is_int, do_redraw, callback, packflag=0) {
    let prop = rdef.prop;

    let useDataPathUndo = !(prop.flag & PropFlags$1.NO_UNDO);

    //console.log(prop, PropTypes, PropSubTypes);

    function makeUIName(name) {
      if (typeof name === "number" && isNaN(name)) {
        console.warn("Subkey error in data api", inpath);
        return "" + name;
      }

      name = "" + name;
      name = name[0].toUpperCase() + name.slice(1, name.length).toLowerCase();
      name = name.replace(/_/g, " ");
      return name;
    }

    if (prop.type === PropTypes$5.REPORT) {
      return this.pathlabel(inpath, prop.uiname);
    } else if (prop.type === PropTypes$5.STRING) {
      let ret;

      if (prop.flag & PropFlags$1.READ_ONLY) {
        ret = this.pathlabel(inpath, prop.uiname);
      } else if (prop.multiLine) {
        ret = this.textarea(inpath, rdef.value, packflag, mass_set_path);
        ret.useDataPathUndo = useDataPathUndo;
      } else {
        let strip = this.strip();

        let uiname = prop.uiname !== undefined ? prop.uiname : ToolProperty.makeUIName(prop.apiname);

        strip.label(prop.uiname);

        ret = strip.textbox(inpath);
        ret.useDataPathUndo = useDataPathUndo;

        if (mass_set_path) {
          ret.setAttribute("mass_set_path", mass_set_path);
        }
      }

      ret.packflag |= packflag;
      return ret;
    } else if (prop.type === PropTypes$5.CURVE) {
      let ret = this.curve1d(inpath, packflag, mass_set_path);
      ret.useDataPathUndo = useDataPathUndo;
      return ret;
    } else if (prop.type === PropTypes$5.INT || prop.type === PropTypes$5.FLOAT) {
      let ret;
      if (packflag & PackFlags$5.SIMPLE_NUMSLIDERS) {
        ret = this.simpleslider(inpath, {packflag: packflag});
      } else {
        ret = this.slider(inpath, {packflag: packflag});
      }

      ret.useDataPathUndo = useDataPathUndo;
      ret.packflag |= packflag;

      if (mass_set_path) {
        ret.setAttribute("mass_set_path", mass_set_path);
      }

      return ret;
    } else if (prop.type === PropTypes$5.BOOL) {
      let ret = this.check(inpath, prop.uiname, packflag, mass_set_path);
      ret.useDataPathUndo = useDataPathUndo;
      return ret;
    } else if (prop.type === PropTypes$5.ENUM) {
      if (rdef.subkey !== undefined) {
        let subkey = rdef.subkey;
        let name = rdef.prop.ui_value_names[rdef.subkey];

        if (name === undefined) {
          name = makeUIName(rdef.subkey);
        }

        let check = this.check(inpath, name, packflag, mass_set_path);
        let tooltip = rdef.prop.descriptions[subkey];

        check.useDataPathUndo = useDataPathUndo;

        check.description = tooltip === undefined ? rdef.prop.ui_value_names[subkey] : tooltip;
        check.icon = rdef.prop.iconmap[rdef.subkey];

        return check;
      }

      if (!(packflag & PackFlags$5.USE_ICONS)) {
        if (packflag & PackFlags$5.FORCE_PROP_LABELS) {
          let strip = this.strip();
          strip.label(prop.uiname);

          return strip.listenum(inpath, {packflag, mass_set_path}).setUndo(useDataPathUndo);
        } else {
          return this.listenum(inpath, {packflag, mass_set_path}).setUndo(useDataPathUndo);
        }

      } else {
        if (packflag & PackFlags$5.FORCE_PROP_LABELS) {
          let strip = thdis.strip();
          strip.label(prop.uiname);

          return strip.checkenum(inpath, undefined, packflag).setUndo(useDataPathUndo);
        } else {
          return this.checkenum(inpath, undefined, packflag).setUndo(useDataPathUndo);
        }
      }
    } else if (prop.type & (PropTypes$5.VEC2 | PropTypes$5.VEC3 | PropTypes$5.VEC4)) {
      if (rdef.subkey !== undefined) {
        let ret;

        if (packflag & PackFlags$5.SIMPLE_NUMSLIDERS)
          ret = this.simpleslider(inpath, {packflag: packflag});
        else
          ret = this.slider(inpath, {packflag: packflag});

        ret.packflag |= packflag;
        return ret.setUndo(useDataPathUndo);
      } else if (prop.subtype === PropSubTypes$2.COLOR) {
        return this.colorbutton(inpath, packflag, mass_set_path).setUndo(useDataPathUndo);
        //return this.colorPicker(inpath, packflag, mass_set_path);
      } else {
        let ret = UIBase$7.createElement("vector-panel-x");

        mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

        ret.packflag |= packflag | (this.inherit_packflag & ~PackFlags$5.NO_UPDATE);
        ret.inherit_packflag |= packflag | (this.inherit_packflag & ~PackFlags$5.NO_UPDATE);

        if (inpath) {
          ret.setAttribute("datapath", this._joinPrefix(inpath));
        }

        if (mass_set_path) {
          ret.setAttribute("mass_set_path", mass_set_path);
        }

        this.add(ret);

        return ret.setUndo(useDataPathUndo);
      }
    } else if (prop.type === PropTypes$5.FLAG) {
      if (rdef.subkey !== undefined) {
        let tooltip = rdef.prop.descriptions[rdef.subkey];
        let name = rdef.prop.ui_value_names[rdef.subkey];

        if (typeof rdef.subkey === "number") {
          name = rdef.prop.keys[rdef.subkey];
          if (name && name in rdef.prop.ui_value_names) {
            name = rdef.prop.ui_value_names[name];
          } else {
            name = makeUIName(name ? name : "(error)");
          }
        }

        if (name === undefined) {
          name = "(error)";
        }

        let ret = this.check(inpath, name, packflag, mass_set_path);

        ret.icon = rdef.prop.iconmap[rdef.subkey];

        if (tooltip) {
          ret.description = tooltip;
        }

        return ret.setUndo(useDataPathUndo);
      } else {
        let con = this;

        if (packflag & PackFlags$5.FORCE_PROP_LABELS) {
          con = this.strip();
          con.label(prop.uiname);
        }

        if (packflag & PackFlags$5.PUT_FLAG_CHECKS_IN_COLUMNS) {
          let i = 0;
          let row = con.row();
          let col1 = row.col();
          let col2 = row.col();

          for (let k in prop.values) {
            let name = prop.ui_value_names[k];
            let tooltip = prop.descriptions[k];

            if (name === undefined) {
              name = makeUIName(k);
            }

            let con2 = i & 1 ? col1 : col2;
            let check = con2.check(`${inpath}[${k}]`, name, packflag, mass_set_path);

            if (tooltip) {
              check.description = tooltip;
            }

            check.setUndo(useDataPathUndo);

            i++;
          }

          return row;
        }

        if (packflag & PackFlags$5.WRAP_CHECKBOXES) {
          let isrow = this.style["flex-direction"] === "row";
          isrow = isrow || this.style["flex-direction"] === "row-reverse";

          let wrapChars;

          let strip, con;

          if (isrow) {
            wrapChars = this.getDefault("checkRowWrapLimit", undefined, 24);
            strip = this.col().strip();
            strip.packflag |= packflag;
            strip.inherit_packflag |= packflag;

            con = strip.row();
          } else {
            wrapChars = this.getDefault("checkColWrapLimit", undefined, 5);
            strip = this.row().strip();
            strip.packflag |= packflag;
            strip.inherit_packflag |= packflag;

            con = strip.col();
          }

          let x = 0;
          let y = 0;

          for (let k in prop.values) {
            let name = prop.ui_value_names[k];
            let tooltip = prop.descriptions[k];

            if (name === undefined) {
              name = makeUIName(k);
            }

            let check = con.check(`${inpath}[${k}]`, name, packflag, mass_set_path);

            if (tooltip) {
              check.description = tooltip;
            }

            x += name.length;
            y += 1;

            if (isrow && x > wrapChars) {
              x = 0;
              con = strip.row();
            } else if (!isrow && y > wrapChars) {
              y = 0;
              con = strip.col();
            }
          }

          return strip;
        }

        if (con === this) {
          con = this.strip();
        }

        let rebuild = () => {
          con.clear();

          for (let k in prop.values) {
            let name = prop.ui_value_names[k];
            let tooltip = prop.descriptions[k];

            if (name === undefined) {
              name = makeUIName(k);
            }

            let check = con.check(`${inpath}[${k}]`, name, packflag, mass_set_path);
            check.useDataPathUndo = useDataPathUndo;

            if (tooltip) {
              check.description = tooltip;
            }

            check.setUndo(useDataPathUndo);
          }
        };

        rebuild();
        let last_hash = prop.calcHash();

        con.update.after(() => {
          let hash = prop.calcHash();

          if (last_hash !== hash) {
            last_hash = hash;
            console.error("Property definition update");
            rebuild();
          }
        });

        return con;
      }
    }
  }

  iconcheck(inpath, icon, name, mass_set_path) {
    let ret = UIBase$7.createElement("iconcheck-x");
    ret.icon = icon;
    ret.description = name;

    if (inpath) {
      ret.setAttribute("datapath", inpath);
    }

    if (mass_set_path) {
      ret.setAttribute("mass_set_path", mass_set_path);
    }

    this.add(ret);

    return ret;
  }

  check(inpath, name, packflag = 0, mass_set_path = undefined) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let path = inpath !== undefined ? this._joinPrefix(inpath) : undefined;

    //let prop = this.ctx.getProp(path);
    let ret;
    if (packflag & PackFlags$5.USE_ICONS) {
      ret = UIBase$7.createElement("iconcheck-x");

      ret.iconsheet = iconSheetFromPackFlag(packflag);
    } else {
      ret = UIBase$7.createElement("check-x");
    }

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    ret.packflag |= packflag;
    ret.label = name;
    ret.noMarginsOrPadding();

    if (inpath) {
      ret.setAttribute("datapath", path);
    }

    if (mass_set_path) {
      ret.setAttribute("mass_set_path", mass_set_path);
    }

    this._add(ret);

    //ret.update();

    return ret;
  }

  /*
  *
  * new (optional) form: checkenum(inpath, args)
  * */
  checkenum(inpath, name, packflag, enummap, defaultval, callback, iconmap, mass_set_path) {
    if (typeof name === "object" && name !== null) {
      let args = name;

      name = args.name;
      packflag = args.packflag;
      enummap = args.enummap;
      defaultval = args.defaultval;
      callback = args.callback;
      iconmap = args.iconmap;
      mass_set_path = args.mass_set_path;
    }

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    packflag = packflag === undefined ? 0 : packflag;
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let path = this._joinPrefix(inpath);

    let has_path = path !== undefined;
    let prop;
    let frame;

    if (path !== undefined) {
      prop = this.ctx.api.resolvePath(this.ctx, path, true);

      if (prop !== undefined)
        prop = prop.prop;
    }

    if (path !== undefined) {
      if (prop === undefined) {
        console.warn("Bad path in checkenum", path);
        return;
      }

      frame = this.strip();
      frame.oneAxisPadding();

      if (packflag & PackFlags$5.USE_ICONS) {
        for (let key in prop.values) {
          let check = frame.check(inpath + "[" + key + "]", "", packflag);

          check.packflag |= PackFlags$5.HIDE_CHECK_MARKS;

          check.icon = prop.iconmap[key];
          check.drawCheck = false;

          check.style["padding"] = "0px";
          check.style["margin"] = "0px";

          check.dom.style["padding"] = "0px";
          check.dom.style["margin"] = "0px";

          check.description = prop.descriptions[key];
          //console.log(check.description, key, prop.keys[key], prop.descriptions, prop.keys);
        }
      } else {
        if (name === undefined) {
          name = prop.uiname;
        }

        frame.label(name).font = "TitleText";

        let checks = {};

        let ignorecb = false;

        function makecb(key) {
          return () => {
            if (ignorecb) return;

            ignorecb = true;
            for (let k in checks) {
              if (k !== key) {
                checks[k].checked = false;
              }
            }
            ignorecb = false;

            if (callback) {
              callback(key);
            }
          }
        }

        for (let key in prop.values) {
          let check = frame.check(inpath + " = " + prop.values[key], prop.ui_value_names[key]);
          checks[key] = check;

          if (mass_set_path) {
            check.setAttribute("mass_set_path", mass_set_path);
          }


          check.description = prop.descriptions[prop.keys[key]];
          if (!check.description) {
            check.description = "" + prop.ui_value_names[key];
          }
          check.onchange = makecb(key);
          //console.log("PATH", path);
        }
      }
    }

    return frame;
  }

  checkenum_panel(inpath, name, packflag = 0, callback = undefined, mass_set_path = undefined, prop = undefined) {
    packflag = packflag === undefined ? 0 : packflag;
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    let path = this._joinPrefix(inpath);
    let frame;

    let has_path = path !== undefined;

    if (path !== undefined && prop === undefined) {
      prop = this.ctx.api.resolvePath(this.ctx, path, true);

      if (prop !== undefined)
        prop = prop.prop;
    }

    if (!name && prop) {
      name = prop.uiname;
    }

    if (path !== undefined) {
      if (prop === undefined) {
        console.warn("Bad path in checkenum", path);
        return;
      }

      frame = this.panel(name, name, packflag);

      frame.oneAxisPadding();
      frame.setCSS.after(frame.background = this.getDefault("BoxSub2BG"));

      if (packflag & PackFlags$5.USE_ICONS) {
        for (let key in prop.values) {
          let check = frame.check(inpath + " == " + prop.values[key], "", packflag);

          check.icon = prop.iconmap[key];
          check.drawCheck = false;

          check.style["padding"] = "0px";
          check.style["margin"] = "0px";

          check.dom.style["padding"] = "0px";
          check.dom.style["margin"] = "0px";

          check.description = prop.descriptions[key];
          //console.log(check.description, key, prop.keys[key], prop.descriptions, prop.keys);
        }
      } else {
        if (name === undefined) {
          name = prop.uiname;
        }

        frame.label(name).font = "TitleText";

        let checks = {};

        let ignorecb = false;

        function makecb(key) {
          return () => {
            if (ignorecb) return;

            ignorecb = true;
            for (let k in checks) {
              if (k !== key) {
                checks[k].checked = false;
              }
            }
            ignorecb = false;

            if (callback) {
              callback(key);
            }
          }
        }

        for (let key in prop.values) {
          let check = frame.check(inpath + " = " + prop.values[key], prop.ui_value_names[key]);
          checks[key] = check;

          if (mass_set_path) {
            check.setAttribute("mass_set_path", mass_set_path);
          }


          check.description = prop.descriptions[prop.keys[key]];
          if (!check.description) {
            check.description = "" + prop.ui_value_names[key];
          }
          check.onchange = makecb(key);
          //console.log("PATH", path);
        }
      }
    }

    return frame;
  }

  /*
    enummap is an object that maps
    ui names to keys, e.g.:

    ui.listenum("color", "Color", {
      RED   : 0,
      GREEN : 1,
      BLUE  : 2
    });

    path can be undefined, in which case, use callback,
    which gets the current enum as an argument

    defaultval cannot be undefined
  */
  listenum(inpath, name, enumDef, defaultval, callback, iconmap, packflag = 0) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;
    let mass_set_path;

    if (name && typeof name === "object") {
      let args = name;

      name = args.name;
      enumDef = args.enumDef;
      defaultval = args.defaultval;
      callback = args.callback;
      iconmap = args.iconmap;
      packflag = args.packflag || 0;
      mass_set_path = args.mass_set_path;
    }

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    let path;

    if (inpath !== undefined) {
      path = this._joinPrefix(inpath);
    }

    let ret = UIBase$7.createElement("dropbox-x");
    if (enumDef !== undefined) {
      if (enumDef instanceof EnumProperty) {
        ret.prop = enumDef;
      } else {
        ret.prop = new EnumProperty(defaultval, enumDef, path, name);
      }

      if (iconmap !== undefined) {
        ret.prop.addIcons(iconmap);
      }
    } else {
      let res = this.ctx.api.resolvePath(this.ctx, path, true);

      if (res !== undefined) {
        ret.prop = res.prop;

        name = name === undefined ? res.prop.uiname : name;
      }
    }

    mass_set_path = this._getMassPath(this.ctx, inpath, mass_set_path);

    if (path !== undefined) {
      ret.setAttribute("datapath", path);
    }
    if (mass_set_path !== undefined) {
      ret.setAttribute("mass_set_path", mass_set_path);
    }

    ret.setAttribute("name", name);

    if (defaultval) {
      ret.setValue(defaultval);
    }

    ret.onchange = callback;
    ret.onselect = callback;

    ret.packflag |= packflag;

    this._add(ret);
    return ret;
  }

  getroot() {
    let p = this;

    while (p.parent !== undefined) {
      p = p.parent;
    }

    return p;
  }

  simpleslider(inpath, name, defaultval, min, max, step, is_int, do_redraw, callback, packflag = 0) {
    if (arguments.length === 2 || typeof name === "object") {
      let args = Object.assign({}, name);

      args.packflag = (args.packflag || 0) | PackFlags$5.SIMPLE_NUMSLIDERS;
      return this.slider(inpath, args);
      //new-style api call
    } else {
      return this.slider(inpath, name, defaultval, min, max, step, is_int, do_redraw, callback, packflag | PackFlags$5.SIMPLE_NUMSLIDERS);
    }
  }

  /**
   *
   * usage: .slider(inpath, {
   *  name : bleh,
   *  defaultval : number,
   *  etc...
   * });
   * */
  slider(inpath, name, defaultval, min, max, step, is_int, do_redraw, callback, packflag = 0) {
    if (arguments.length === 2 || typeof name === "object") {
      //new-style api call

      let args = name;

      name = args.name;
      defaultval = args.defaultval;
      min = args.min;
      max = args.max;
      step = args.step;
      is_int = args.is_int || args.isInt;
      do_redraw = args.do_redraw;
      callback = args.callback;
      packflag = args.packflag || 0;
    }

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;
    let ret;

    if (inpath) {
      inpath = this._joinPrefix(inpath);

      let rdef = this.ctx.api.resolvePath(this.ctx, inpath, true);
      if (rdef && rdef.prop && (rdef.prop.flag & PropFlags$1.SIMPLE_SLIDER)) {
        packflag |= PackFlags$5.SIMPLE_NUMSLIDERS;
      }
      if (rdef && rdef.prop && (rdef.prop.flag & PropFlags$1.FORCE_ROLLER_SLIDER)) {
        packflag |= PackFlags$5.FORCE_ROLLER_SLIDER;
      }
    }

    let simple = (packflag & PackFlags$5.SIMPLE_NUMSLIDERS) || exports.simpleNumSliders;
    simple = simple && !(packflag & PackFlags$5.FORCE_ROLLER_SLIDER);

    let extraTextBox = exports.useNumSliderTextboxes && !(packflag & PackFlags$5.NO_NUMSLIDER_TEXTBOX);

    if (extraTextBox) {
      if (simple) {
        ret = UIBase$7.createElement("numslider-simple-x");
      } else {
        ret = UIBase$7.createElement("numslider-textbox-x");
      }
    } else {
      if (simple) {
        ret = UIBase$7.createElement("numslider-simple-x");
      } else {
        ret = UIBase$7.createElement("numslider-x");
      }
    }

    ret.packflag |= packflag;

    let decimals;

    if (inpath) {
      ret.setAttribute("datapath", inpath);
    }

    if (name) {
      ret.setAttribute("name", name);
    }

    if (min !== undefined) {
      ret.setAttribute("min", min);
    }
    if (max !== undefined) {
      ret.setAttribute("max", max);
    }

    if (defaultval !== undefined) {
      ret.setValue(defaultval);
    }

    if (is_int) {
      ret.setAttribute("integer", is_int);
    }

    if (decimals !== undefined) {
      ret.decimalPlaces = decimals;
    }

    if (callback) {
      ret.onchange = callback;
    }

    this._add(ret);

    if (this.ctx) {
      ret.setCSS();
      ret.update();
    }

    return ret;
  }

  _container_inherit(elem, packflag = 0) {
    //don't inherit NO_UPDATE

    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    elem.packflag |= packflag;
    elem.inherit_packflag |= packflag;
    elem.dataPrefix = this.dataPrefix;
    elem.massSetPrefix = this.massSetPrefix;
  }

  treeview() {
    let ret = UIBase$7.createElement("tree-view-x");
    ret.ctx = this.ctx;
    this.add(ret);

    this._container_inherit(ret);

    return ret;
  }

  panel(name, id, packflag = 0, tooltip = undefined) {
    id = id === undefined ? name : id;

    let ret = UIBase$7.createElement("panelframe-x");

    this._container_inherit(ret, packflag);

    if (tooltip) {
      ret.setHeaderToolTip(tooltip);
    }

    ret.setAttribute("label", name);
    ret.setAttribute("id", id);

    this._add(ret);


    if (this.ctx) {//check init was called
      ret.ctx = this.ctx;
      ret._init();
      //ret.headerLabel = name;

      ret.contents.ctx = ret.ctx;
    }

    ret.contents.dataPrefix = this.dataPrefix;
    ret.contents.massSetPrefix = this.massSetPrefix;

    return ret;
  }

  row(packflag = 0) {
    let ret = UIBase$7.createElement("rowframe-x");

    this._container_inherit(ret, packflag);

    this._add(ret);

    ret.ctx = this.ctx;

    return ret;
  }

  listbox(packflag = 0) {
    let ret = UIBase$7.createElement("listbox-x");

    this._container_inherit(ret, packflag);

    this._add(ret);
    return ret;
  }

  table(packflag = 0) {
    let ret = UIBase$7.createElement("tableframe-x");

    this._container_inherit(ret, packflag);

    this._add(ret);
    return ret;
  }

  twocol(parentDepth = 1, packflag = 0) {
    let ret = UIBase$7.createElement("two-column-x");

    ret.parentDepth = parentDepth;

    this._container_inherit(ret, packflag);

    this._add(ret);
    return ret;
  }

  col(packflag = 0) {
    let ret = UIBase$7.createElement("colframe-x");

    this._container_inherit(ret, packflag);

    this._add(ret);
    return ret;
  }

  colorPicker(inpath, packflag_or_args = 0, mass_set_path = undefined, themeOverride = undefined) {
    let packflag;

    if (typeof packflag_or_args === "object") {
      let args = packflag_or_args;

      packflag = args.packflag !== undefined ? args.packflag : 0;
      mass_set_path = args.massSetPath;
      themeOverride = args.themeOverride;
    }

    let path;

    if (inpath) {
      path = this._joinPrefix(inpath);
    }

    let ret = UIBase$7.createElement("colorpicker-x");

    if (themeOverride) {
      ret.overrideClass(themeOverride);
    }

    packflag |= PackFlags$5.SIMPLE_NUMSLIDERS;

    this._container_inherit(ret, packflag);

    ret.ctx = this.ctx;
    ret.parentWidget = this;
    ret._init();
    ret.packflag |= packflag;
    ret.inherit_packflag |= packflag;
    ret.constructor.setDefault(ret);

    if (path !== undefined) {
      ret.setAttribute("datapath", path);
    }

    console.warn("mass_set_path", mass_set_path);
    if (mass_set_path) {
      ret.setAttribute("mass_set_path", mass_set_path);
    }

    //XXX
    window.colorpicker = ret;

    this._add(ret);
    return ret;
  }

  textarea(datapath = undefined, value = "", packflag = 0, mass_set_path = undefined) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    mass_set_path = this._getMassPath(this.ctx, datapath, mass_set_path);

    let ret = UIBase$7.createElement("rich-text-editor-x");
    ret.ctx = this.ctx;

    ret.packflag |= packflag;

    if (value !== undefined) {
      ret.value = value;
    }

    if (datapath)
      ret.setAttribute("datapath", datapath);
    if (mass_set_path)
      ret.setAttribute("mass_set_path", mass_set_path);

    this.add(ret);
    return ret;
  }

  /**
   * html5 viewer
   * */
  viewer(datapath = undefined, value = "", packflag = 0, mass_set_path = undefined) {
    packflag |= this.inherit_packflag & ~PackFlags$5.NO_UPDATE;

    mass_set_path = this._getMassPath(this.ctx, datapath, mass_set_path);

    let ret = UIBase$7.createElement("html-viewer-x");
    ret.ctx = this.ctx;

    ret.packflag |= packflag;

    if (value !== undefined) {
      ret.value = value;
    }

    if (datapath)
      ret.setAttribute("datapath", datapath);
    if (mass_set_path)
      ret.setAttribute("mass_set_path", mass_set_path);

    this.add(ret);
    return ret;
  }

  //
  tabs(position = "top", packflag = 0) {

    let ret = UIBase$7.createElement("tabcontainer-x");

    ret.constructor.setDefault(ret);
    ret.setAttribute("bar_pos", position);

    this._container_inherit(ret, packflag);

    this._add(ret);
    return ret;
  }

  asDialogFooter() {
    this.style['margin-top'] = '15px';
    this.style['justify-content'] = 'flex-end';

    return this;
  }

};

UIBase$2.internalRegister(Container, "div");


class RowFrame extends Container {
  constructor() {
    super();
  }

  static define() {
    return {
      tagname: 'rowframe-x'
    };
  }

  //try to set styling as early as possible
  connectedCallback() {
    super.connectedCallback();

    this.style['display'] = 'flex';
    this.style['flex-direction'] = this.reversed ? 'row-reverse' : 'row';
  }

  init() {
    super.init();

    this.style['display'] = 'flex';
    this.style['flex-direction'] = this.reversed ? 'row-reverse' : 'row';

    if (!this.style['align-items'] || this.style['align-items'] == '') {
      this.style['align-items'] = 'center';
    }

    if (this.getDefault("slider-style") === "simple") {
      this.packflag |= PackFlags$5.SIMPLE_NUMSLIDERS;
      this.inherit_packflag |= PackFlags$5.SIMPLE_NUMSLIDERS;
    }
  }

  oneAxisMargin(m = this.getDefault('oneAxisMargin'), m2 = 0) {
    this.style['margin-left'] = this.style['margin-right'] = m + 'px';
    this.style['margin-top'] = this.style['margin-bottom'] = '' + m2 + 'px';

    return this;
  }

  oneAxisPadding(m = this.getDefault('oneAxisPadding'), m2 = 0) {
    this.style['padding-left'] = this.style['padding-right'] = '' + m + 'px';
    this.style['padding-top'] = this.style['padding-bottom'] = '' + m2 + 'px';

    return this;
  }

  update() {
    super.update();
  }
}

UIBase$7.internalRegister(RowFrame);

class ColumnFrame extends Container {
  constructor() {
    super();
  }

  static define() {
    return {
      tagname: "colframe-x"
    };
  }

  init() {
    super.init();

    this.style["display"] = "flex";
    this.style["flex-direction"] = "column";
    this.style["justify-content"] = "right";
  }

  update() {
    super.update();
  }

  oneAxisMargin(m = this.getDefault('oneAxisMargin'), m2 = 0) {
    this.style['margin-top'] = this.style['margin-bottom'] = '' + m + 'px';
    this.style['margin-left'] = this.style['margin-right'] = m2 + 'px';

    return this;
  }

  oneAxisPadding(m = this.getDefault('oneAxisPadding'), m2 = 0) {
    this.style['padding-top'] = this.style['padding-bottom'] = '' + m + 'px';
    this.style['padding-left'] = this.style['padding-right'] = '' + m2 + 'px';

    return this;
  }
}

UIBase$7.internalRegister(ColumnFrame);


class TwoColumnFrame extends Container {
  constructor() {
    super();

    this._colWidth = 256;
    this.parentDepth = 1;
  }

  get colWidth() {
    if (this.hasAttribute("colWidth")) {
      return parsepx(this.getAttribute("colWidth"));
    }

    return this._colWidth;
  }

  set colWidth(v) {
    if (this.hasAttribute("colWidth")) {
      this.setAttribute("colWidth", "" + v);
    } else {
      this._colWidth = v;
    }
  }

  static define() {
    return {
      tagname: "two-column-x"
    }
  }

  init() {
    super.init();

    this.style["display"] = "flex";
    this.style["flex-direction"] = "column";
  }

  update() {
    super.update();

    let p = this;

    for (let i = 0; i < this.parentDepth; i++) {
      p = p.parentWidget ? p.parentWidget : p;
    }

    if (!p) {
      return;
    }

    let r = p.getBoundingClientRect();

    if (!r) {
      return;
    }

    let style = r.width > this.colWidth*2.0 ? 'row' : 'column';

    if (this.style["flex-direction"] !== style) {
      this.style["flex-direction"] = style;
    }
  }
}

UIBase$7.internalRegister(TwoColumnFrame);

let UIBase$8 = UIBase$2;

class Note extends UIBase$2 {
  constructor() {
    super();

    let style = document.createElement("style");

    this._noteid = undefined;
    this.height = 20;

    this.showExclMark = true;

    style.textContent = `
    .notex {
      display : flex;
      flex-direction : row;
      flex-wrap : nowrap;
      height : {this.height}px;
      padding : 0px;
      margin : 0px;
    }
    `;

    this.dom = document.createElement("div");
    this.dom.setAttribute("class", "notex");
    this.color = "red";

    this.shadow.appendChild(style);
    this.shadow.append(this.dom);
    this.setLabel("");
  }

  static define() {
    return {
      tagname: "note-x",
      style  : 'notification',
    }
  }

  setLabel(s) {
    let color = this.color;
    if (this.showExclMark && this.mark === undefined) {
      this.mark = document.createElement("div");
      this.mark.style["display"] = "flex";
      this.mark.style["flex-direction"] = "row";
      this.mark.style["flex-wrap"] = "nowrap";

      //this.mark.style["width"]
      let sheet = 0;

      let size = iconmanager.getTileSize(sheet);

      this.mark.style["width"] = "" + size + "px";
      this.mark.style["height"] = "" + size + "px";

      this.dom.appendChild(this.mark);

      this.ntext = document.createElement("div");
      this.ntext.style["display"] = "inline-flex";
      this.ntext.style["flex-wrap"] = "nowrap";

      this.dom.appendChild(this.ntext);

      iconmanager.setCSS(Icons.NOTE_EXCL, this.mark, sheet);

      //this.mark.style["margin"] = this.ntext.style["margin"] = "0px"
      //this.mark.style["padding"] = this.ntext.style["padding"] = "0px"
      //this.mark.style["background-color"] = color;
    } else if (!this.showExclMark && this.mark) {
      this.mark.remove();
      this.mark = undefined;
    }

    let ntext = this.ntext;
    //mark.innerText = "!";
    ntext.innerText = " " + s;
  }

  init() {
    super.init();

    this.setAttribute("class", "notex");

    this.style["display"] = "flex";
    this.style["flex-wrap"] = "nowrap";
    this.style["flex-direction"] = "row";
    this.style["border-radius"] = "7px";
    this.style["padding"] = "2px";

    this.style["color"] = this.getDefault("DefaultText").color;
    let clr = css2color$1(this.color);
    clr = color2css$2([clr[0], clr[1], clr[2], 0.25]);

    this.style["background-color"] = clr;
    this.setCSS();
  }

  setCSS() {
    super.setCSS(false);
  }
}

UIBase$8.internalRegister(Note);

class ProgBarNote extends Note {
  constructor() {
    super();

    this._percent = 0.0;
    this.barWidth = 100;

    let bar = this.bar = document.createElement("div");
    bar.style["display"] = "flex";
    bar.style["flex-direction"] = "row";
    bar.style["width"] = this.barWidth + "px";
    bar.style["height"] = this.height + "px";
    bar.style["background-color"] = this.getDefault("ProgressBarBG");
    bar.style["border-radius"] = "12px";
    bar.style["align-items"] = "center";
    bar.style["padding"] = bar.style["margin"] = "0px";

    let bar2 = this.bar2 = document.createElement("div");
    let w = 50.0;

    bar2.style["display"] = "flex";
    bar2.style["flex-direction"] = "row";
    bar2.style["height"] = this.height + "px";
    bar2.style["background-color"] = this.getDefault("ProgressBar");
    bar2.style["border-radius"] = "12px";
    bar2.style["align-items"] = "center";
    bar2.style["padding"] = bar2.style["margin"] = "0px";

    this.bar.appendChild(bar2);
    this.dom.appendChild(this.bar);
  }

  get percent() {
    return this._percent;
  }

  set percent(val) {
    this._percent = val;
    this.setCSS();
  }

  static define() {
    return {
      tagname: "note-progress-x",
      style  : 'notification',
    }
  }

  setCSS() {
    super.setCSS();

    let w = ~~(this.percent*this.barWidth + 0.5);

    this.bar2.style["width"] = w + "px";
  }

  init() {
    super.init();
  }
}

UIBase$8.internalRegister(ProgBarNote);

class NoteFrame extends RowFrame {
  constructor() {
    super();
    this._h = 20;
  }

  static define() {
    return {
      tagname: "noteframe-x",
      style  : 'noteframe',
    }
  }

  init() {
    super.init();

    this.noMarginsOrPadding();

    noteframes.push(this);
    this.background = this.getDefault("background-color");
    this.style['flex-grow'] = 'unset';
  }

  setCSS() {
    super.setCSS();

    this.style["width"] = "min-contents";
    this.style["height"] = this._h + "px";
  }

  _ondestroy() {
    if (noteframes.indexOf(this) >= 0) {
      noteframes.remove(this);
    }

    super._ondestroy();
  }

  progbarNote(msg, percent, color = "rgba(255,0,0,0.2)", timeout = 700, id = msg) {
    let note;

    for (let child of this.children) {
      if (child._noteid === id) {
        note = child;
        break;
      }
    }

    let f = (100.0*Math.min(percent, 1.0)).toFixed(1);

    if (note === undefined) {
      note = this.addNote(msg, color, -1, "note-progress-x");
      note._noteid = id;
    }

    //note.setLabel(msg + " " + f + "%");
    note.percent = percent;

    if (percent >= 1.0) {
      //note.setLabel(msg + " " + f + "%");

      window.setTimeout(() => {
        note.remove();
      }, timeout);
    }

    return note;
  }

  addNote(msg, color = "rgba(255,0,0,0.2)", timeout = 1200, tagname = "note-x", showExclMark=true) {
    //let note = UIBase.createElement("note-x");

    //note.ctx = this.ctx;
    //note.background = "red";
    //note.dom.innerText = msg;

    //this._add(note);

    let note = UIBase$8.createElement(tagname);

    note.color = color;
    note.setLabel(msg);

    note.style["text-align"] = "center";

    note.style["font"] = getFont(note, "DefaultText");
    note.style["color"] = this.getDefault("DefaultText").color;
    note.showExclMark = showExclMark;

    this.add(note);

    this.noMarginsOrPadding();
    note.noMarginsOrPadding();

    //this.dom.style["position"] = UIBase.PositionKey;
    //this.style["position"] = UIBase.PositionKey;
    //note.style["position"] = UIBase.PositionKey;

    note.style["height"] = this._h + "px";
    note.height = this._h;

    if (timeout !== -1) {
      window.setTimeout(() => {
        //console.log("remove!");
        note.remove();
      }, timeout);
    }

    //this.appendChild(note);
    return note;

  }
}

UIBase$8.internalRegister(NoteFrame);

function getNoteFrames(screen) {
  let ret = [];

  let rec = (n) => {

    if (n instanceof NoteFrame) {
      ret.push(n);
    }

    if (n.childNodes !== undefined) {
      for (let node of n.childNodes) {
        rec(node);
      }
    }

    if (n instanceof UIBase$2 && n.shadow !== undefined && n.shadow.childNodes) {
      for (let node of n.shadow.childNodes) {
        rec(node);
      }
    }
  };

  rec(screen);
  return ret;
}

let noteframes = [];

function sendNote(screen, msg, color, timeout = 3000, showExclMark=true) {
  noteframes = getNoteFrames(screen);

  for (let frame of noteframes) {
    try {
      frame.addNote(msg, color, timeout, undefined, showExclMark);
    } catch (error) {
      print_stack(error);
      console.log(error.stack, error.message);
      console.log("bad notification frame");
    }
  }
}

window._sendNote = sendNote;

function error(screen, msg, timeout) {
  return sendNote(screen, msg, color2css$2([1.0, 0.0, 0.0, 1.0]), timeout);
}

function warning(screen, msg, timeout) {
  return sendNote(screen, msg, color2css$2([0.78, 0.78, 0.2, 1.0]), timeout);
}

function message(screen, msg, timeout) {
  return sendNote(screen, msg, color2css$2([0.2, 0.9, 0.1, 1.0]), timeout, false);
}


function progbarNote(screen, msg, percent, color, timeout) {
  noteframes = getNoteFrames(screen);

  for (let frame of noteframes) {
    try {
      frame.progbarNote(msg, percent, color, timeout);
    } catch (error) {
      print_stack(error);
      console.log(error.stack, error.message);
      console.log("bad notification frame");
    }
  }
}

var ui_noteframe = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Note: Note,
  ProgBarNote: ProgBarNote,
  NoteFrame: NoteFrame,
  getNoteFrames: getNoteFrames,
  get noteframes () { return noteframes; },
  sendNote: sendNote,
  error: error,
  warning: warning,
  message: message,
  progbarNote: progbarNote
});

let UIBase$9 = UIBase$2, Icons$1 = Icons;

class RichEditor extends TextBoxBase {
  constructor() {
    super();

    this._internalDisabled = false;
    this._value = "";

    this.textOnlyMode = false;

    this.styletag = document.createElement("style");
    this.styletag.textContent = `
      div.rich-text-editor-x {
        width        :   100%;
        height       :   100%;
        min-height   :   150px;
        overflow     :   scroll;
        padding      :   5px;
        white-space  :   pre-wrap;
      }
      
      rich-text-editor-x {
        display        : flex;
        flex-direction : column;
      }
    `;

    this.shadow.appendChild(this.styletag);

    let controls = this.controls = UIBase$9.createElement("rowframe-x");


    let makeicon = (icon, description, cb) => {
      icon = controls.iconbutton(icon, description, cb);
      icon.iconsheet = 1; //use second smallest icon size
      icon.overrideDefault("padding", 3);

      return icon;
    };

    makeicon(Icons$1.BOLD, "Bold", () => {
      document.execCommand("bold");
    });
    makeicon(Icons$1.ITALIC, "Italic", () => {
      document.execCommand("italic");
    });
    makeicon(Icons$1.UNDERLINE, "Underline", () => {
      document.execCommand("underline");
    });
    makeicon(Icons$1.STRIKETHRU, "Strikethrough", () => {
      document.execCommand("strikeThrough");
    });

    controls.background = this.getDefault("background-color");

    this.shadow.appendChild(controls);

    this.textarea = document.createElement("div");
    this.textarea.contentEditable = true;
    this.textarea.setAttribute("class", "rich-text-editor-x");

    this.textarea.style["font"] = this.getDefault("DefaultText").genCSS();
    this.textarea.style["background-color"] = this.getDefault("background-color");
    this.textarea.setAttribute("white-space", "pre-wrap");

    this.textarea.addEventListener("keydown", (e) => {
      if (e.keyCode === keymap["S"] && e.shiftKey && (e.ctrlKey || e.commandKey)) {
        this.toggleStrikeThru();

        e.preventDefault();
        e.stopPropagation();
      }
    });

    this.textarea.addEventListener("focus", (e) => {
      this._focus = 1;
      this.setCSS();
    });
    this.textarea.addEventListener("blur", (e) => {
      this._focus = 0;
      this.setCSS();
    });

    document.execCommand("styleWithCSS", true);

    window.ta = this;

    this.textarea.addEventListener("selectionchange", (e) => {
      console.log("sel1");
    });

    document.addEventListener("selectionchange", (e, b) => {
      console.log("sel2", document.getSelection().startNode, b);
    });

    this.textarea.addEventListener("input", (e) => {
      if (this.internalDisabled) {
        return;
      }

      console.log("text input", e);

      let text;

      if (this.textOnlyMode) {
        text = this.textarea.innerText;
      } else {
        text = this.textarea.innerHTML;
      }

      if (this.textOnlyMode && text === this._value) {
        //formatting changed?
        console.log("detected formatting change");
        return;
      }

      //console.log("text changed", ...arguments);
      let sel = document.getSelection();
      let range = sel.getRangeAt(0);
      //console.log(range.startOffset, range.endOffset, range.startContainer);

      let node = sel.anchorNode;
      let off = sel.anchorOffset;

      this._value = text;

      //sel.collapse(node, off);

      if (this.hasAttribute("datapath")) {
        let path = this.getAttribute("datapath");
        this.setPathValue(this.ctx, path, this.value);
      }

      if (this.onchange) {
        this.onchange(this._value);
      }
      if (this.oninput) {
        this.oninput(this._value);
      }

      this.dispatchEvent(new InputEvent(this));
      this.dispatchEvent(new CustomEvent('change'));
    });

    this.shadow.appendChild(this.textarea);
  }

  /**
   * Only available in textOnlyMode.  Called when starting text formatting
  */
  formatStart() {
  }

  /**
  * Only available in textOnlyMode.  Formats html-formated line.
   *
   * @param line : line to format
   * @parem text : whole text
  * */
  formatLine(line, text) {
    return line;
  }

  toggleStrikeThru() {
    console.log("strike thru!");
    document.execCommand("strikeThrough");
  }
  /**
   * Only available in textOnlyMode.  Called when starting text formatting
   */
  formatEnd() {
  }

  init() {
    super.init();

    window.rc = this;

    document.execCommand("defaultParagraphSeparator", false, "div");


    this.setCSS();
  }

  get internalDisabled() {
    return this._internalDisabled;
  }

  set internalDisabled(val) {
    let changed = !!this._internalDisabled !== !!val;

    if (changed || 1) {
      this._internalDisabled = !!val;
      super.internalDisabled = val;

      this.textarea.internalDisabled = val;
      this.textarea.contentEditable = !val;
      this.setCSS();
    }
  }

  set value(val) {
    this._value = val;

    if (this.textOnlyMode) {
      let val2 = "";
      for (let l of val.split("\n")) {
        val2 += l + "<br>";
      }
      val = val2;
    }

    this.textarea.innerHTML = val;
  }

  get value() {
    return this._value;
  }

  setCSS() {
    super.setCSS();

    this.controls.background = this.getDefault("background-color");

    if (this._focus) {
      this.textarea.style["border"] = `2px dashed ${this.getDefault('focus-border-color')}`;
    } else {
      this.textarea.style["border"] = "none";
    }

    if (this.style["font"]) {
      this.textarea.style["font"] = this.style["font"];
    } else {
      this.textarea.style["font"] = this.getDefault("DefaultText").genCSS();
    }

    if (this.style["color"]) {
      this.textarea.style["color"] = this.style["color"];
    }  else {
      this.textarea.style["color"] = this.getDefault("DefaultText").color;
    }


    if (this.disabled) {
      this.textarea.style["background-color"] = this.getDefault("DisabledBG");
    } else {
      this.textarea.style["background-color"] = this.getDefault("background-color");
    }
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let path = this.getAttribute("datapath");
    let prop = this.getPathMeta(this.ctx, path);

    if (prop === undefined) {
      console.warn("invalid datapath " + path);

      this.internalDisabled = true;
      return;
    }

    this.internalDisabled = false;
    let value = this.getPathValue(this.ctx, path);

    if (value !== this._value) {
      console.log("text change");
      this.value = value;
    }
  }

  update() {
    super.update();

    this.updateDataPath();
  }

  static define() {return {
    tagname : "rich-text-editor-x",
    style   : "richtext",
    modalKeyEvents : true
  }}
}
UIBase$9.internalRegister(RichEditor);

class RichViewer extends UIBase$9 {
  constructor() {
    super();

    this.contents = document.createElement("div");
    this.contents.style["padding"] = "10px";
    this.contents.style["margin"] = "10px";
    this.contents.style["overflow"] = "scroll";

    this.shadow.appendChild(this.contents);
    this._value = "";
  }

  hideScrollBars() {
    this.contents.style["overflow"] = "hidden";
  }

  showScrollBars() {
    this.contents.style["overflow"] = "scroll";
  }

  //transforms text into final html form
  //note that client code is allowed to override this directly
  textTransform(text) {
    return text;
  }
  set value(val) {
    this._value = val;

    this.contents.innerHTML = this.textTransform(val);
  }

  get value() {
    return this._value;
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let path = this.getAttribute("datapath");
    let prop = this.getPathMeta(this.ctx, path);

    if (prop === undefined) {
      console.warn("invalid datapath " + path);

      this.internalDisabled = true;
      return;
    }

    this.internalDisabled = false;
    let value = this.getPathValue(this.ctx, path);

    if (value !== this.value) {
      this.value = value;
    }
  }

  update() {
    super.update();

    this.updateDataPath();
  }

  static define() {return {
    tagname : "html-viewer-x",
    style   : "html_viewer"
  }}
}
UIBase$9.internalRegister(RichViewer);

"use strict";

let keymap$4 = keymap;

class VectorPopupButton extends Button {
  constructor() {
    super();

    this.value = new Vector4();
  }

  static define() {return {
    tagname : "vector-popup-button-x",
    style : "vecPopupButton"
  }}

  _onpress(e) {
    if (e.button && e.button !== 0) {
      return;
    }

    let panel = UIBase$2.createElement("vector-panel-x");
    let screen = this.ctx.screen;

    let popup = screen.popup(this, this);

    popup.add(panel);
    popup.button("ok", () => {
      popup.end();
    });

    if (this.hasAttribute("datapath")) {
      panel.setAttribute("datapath", this.getAttribute("datapath"));
    }
    if (this.hasAttribute("mass_set_path")) {
      panel.setAttribute("mass_set_path", this.getAttribute("mass_set_path"));
    }

    popup.flushUpdate();
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let value = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (!value) {
      this.internalDisabled = true;
      return;
    }

    if (this.internalDisabled) {
      this.internalDisabled = false;
    }

    if (this.value.length !== value.length) {
      switch (value.length) {
        case 2:
          this.value = new Vector2();
          break;
        case 3:
          this.value = new Vector3();
          break;
        case 4:
          this.value = new Vector4();
          break;
      }
    }

    if (this.value.vectorDistance(value) > 0.0001) {
      this.value.load(value);
      console.log("updated vector popup button value");
    }
  }

  update() {
    super.update();
    this.updateDataPath();
  }

}
UIBase$2.internalRegister(VectorPopupButton);

class VectorPanel extends ColumnFrame {
  constructor() {
    super();

    this.range = [-1e17, 1e17];

    this.name = "";

    this.axes = "XYZW";
    this.value = new Vector3();
    this.sliders = [];
    this.hasUniformSlider = false;

    this.packflag |= PackFlags.FORCE_ROLLER_SLIDER|PackFlags.NO_NUMSLIDER_TEXTBOX;

    let makeParam = (key) => {
      Object.defineProperty(this, key, {
        get : function() {
          return this._getNumParam(key);
        },

        set : function(val) {
          this._setNumParam(key, val);
        }
      });
    };

    this.__range = [-1e17, 1e17];
    this._range = new Array(2);

    Object.defineProperty(this._range, 0, {
      get : () => this.__range[0],
      set : (val) => this.__range[0] = val
    });
    Object.defineProperty(this._range, 1, {
      get : () => this.__range[1],
      set : (val) => this.__range[1] = val
    });

    makeParam("isInt");
    makeParam("radix");
    makeParam("decimalPlaces");
    makeParam("baseUnit");
    makeParam("displayUnit");
    makeParam("step");
    makeParam("expRate");
    makeParam("stepIsRelative");

    window.vp = this;
  }

  init() {
    super.init();
    this.rebuild();
    this.setCSS();

    this.background = this.getDefault("InnerPanelBG");
  }

  _getNumParam(key) {
    return this["_"+key];
  }

  _setNumParam(key, val) {
    if (key === "range") {
      this.__range[0] = val[0];
      this.__range[1] = val[1];

      return;
    }

    this["_"+key] = val;

    for (let slider of this.sliders) {
      slider[key] = val;
    }
  }

  rebuild() {
    this.clear();

    if (this.name) {
      this.label(this.name);
    }

    let frame, row;

    if (this.hasUniformSlider) {
      row = this.row();
      frame = row.col();
    } else {
      frame = this;
    }

    this.sliders = [];

    for (let i=0; i<this.value.length; i++) {
      //inpath, name, defaultval, min, max, step, is_int, do_redraw, callback, packflag = 0) {

      let slider = frame.slider(undefined, {
        name       : this.axes[i],
        defaultval : this.value[i],
        min        : this.range[0],
        max        : this.range[1],
        step       : this.step || 0.001,
        is_int     : this.isInt,
        packflag   : this.packflag
      });

      //let slider = frame.slider(undefined, this.axes[i], this.value[i], this.range[0], this.range[1], 0.001, this.isInt);
      slider.axis = i;
      let this2 = this;

      slider.baseUnit = this.baseUnit;
      slider.displayUnit = this.displayUnit;
      slider.isInt = this.isInt;
      slider.range = this.__range;
      slider.radix = this.radix;
      slider.step = this.step;
      slider.expRate = this.expRate;
      slider.stepIsRelative= this.stepIsRelative;

      if (this.stepIsRelative) {
        slider.step = ToolProperty$1.calcRelativeStep(this.step, this.value[i]);
      }

      slider.onchange = function(e) {
        this2.value[this.axis] = this.value;

        if (this2.hasAttribute("datapath")) {
          this2.setPathValue(this2.ctx, this2.getAttribute("datapath"), this2.value);
        }

        if (this2.uslider) {
          this2.uslider.setValue(this2.uniformValue, false);
        }

        if (this2.onchange) {
          this2.onchange(this2.value);
        }
      };

      this.sliders.push(slider);
    }

    if (this.hasUniformSlider) {
      let uslider = this.uslider = UIBase$2.createElement("numslider-x");
      row._prepend(uslider);

      uslider.range = this.range;
      uslider.baseUnit = this.baseUnit;
      uslider.displayUnit = this.displayUnit;
      uslider.expRate = this.expRate;
      uslider.step = this.step;
      uslider.expRate = this.expRate;
      uslider.isInt = this.isInt;
      uslider.radix = this.radix;
      uslider.decimalPlaces = this.decimalPlaces;
      uslider.stepIsRelative= this.stepIsRelative;

      uslider.vertical = true;
      uslider.setValue(this.uniformValue, false);

      this.sliders.push(uslider);

      uslider.onchange = () => {
        this.uniformValue = uslider.value;
      };
    } else {
      this.uslider = undefined;
    }

    this.setCSS();
  }

  get uniformValue() {
    let sum = 0.0;

    for (let i=0; i<this.value.length; i++) {
      sum += isNaN(this.value[i]) ? 0.0 : this.value[i];
    }

    return sum / this.value.length;
  }

  set uniformValue(val) {
    let old = this.uniformValue;
    let doupdate = false;

    if (old === 0.0 || val === 0.0) {
      doupdate = this.value.dot(this.value) !== 0.0;

      this.value.zero();
    } else {
      let ratio = val / old;
      for (let i = 0; i < this.value.length; i++) {
        this.value[i] *= ratio;
      }

      doupdate = true;
    }

    if (doupdate) {
      if (this.hasAttribute("datapath")) {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), this.value);
      }

      if (this.onchange) {
        this.onchange(this.value);
      }

      for (let i=0; i<this.value.length; i++) {
        this.sliders[i].setValue(this.value[i], false);
        this.sliders[i]._redraw();
      }

      if (this.uslider) {
        this.uslider.setValue(val, false);
        this.uslider._redraw();
      }
    }
  }

  setValue(value) {
    if (!value) {
      return;
    }

    if (value.length !== this.value.length) {
      switch (value.length) {
        case 2:
          this.value = new Vector2(value);
          break;
        case 3:
          this.value = new Vector3(value);
          break;
        case 4:
          this.value = new Vector4(value);
          break;
        default:
          throw new Error("invalid vector size " + value.length);
      }

      this.rebuild();
    } else {
      this.value.load(value);
    }

    if (this.onchange) {
      this.onchange(this.value);
    }

    return this;
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let path = this.getAttribute("datapath");

    let val = this.getPathValue(this.ctx, path);
    if (val === undefined) {
      this.internalDisabled = true;
      return;
    }


    let meta = this.getPathMeta(this.ctx, path);
    let name = meta.uiname !== undefined ? meta.uiname : meta.name;
    if (this.hasAttribute("name")) {
      name = this.getAttribute("name");
    }

    if (name && name !== this.name) {
      this.name = name;
      this.rebuild();
      return;
    }

    let loadNumParam = (k, do_rebuild=false) => {
      if (meta && meta[k] !== undefined && this[k] === undefined) {
        this[k] = meta[k];

        if (this[k] !== meta[k] && do_rebuild) {
          this.doOnce(this.rebuild);
        }
      }
    };


    loadNumParam("baseUnit");
    loadNumParam("displayUnit");
    loadNumParam("decimalPlaces");
    loadNumParam("isInt");
    loadNumParam("radix");
    loadNumParam("step");
    loadNumParam("expRate");
    loadNumParam("stepIsRelative");

    if (meta && meta.hasUniformSlider !== undefined && meta.hasUniformSlider !== this.hasUniformSlider) {
      this.hasUniformSlider = meta.hasUniformSlider;
      this.doOnce(this.rebuild);
    }

    if (meta && meta.range) {
      let update = this.range[0] !== meta.range[0];
      update= update || this.range[1] !== meta.range[1];

      this.range[0] = meta.range[0];
      this.range[1] = meta.range[1];

      if (update) {
        this.doOnce(this.rebuild);
      }
    }

    this.internalDisabled = false;

    let length = val.length;

    if (meta && (meta.flag & PropFlags.USE_CUSTOM_GETSET)) {
      let rdef = this.ctx.api.resolvePath(this.ctx, path);

      meta.ctx = this.ctx;
      meta.dataref = rdef.obj;
      meta.datapath = path;

      length = meta.getValue().length;

      meta.dataref = undefined;
    }

    if (this.value.length !== length) {
      switch (length) {
        case 2:
          val = new Vector2(val);
          break;
        case 3:
          val = new Vector3(val);
          break;
        case 4:
          val = new Vector4(val);
          break;
        default:
          val = meta.getValue().copy().load(val);
          break;
      }

      this.value = val;
      this.rebuild();

      for (let i=0; i<this.value.length; i++) {
        this.sliders[i].setValue(val[i], false);
        this.sliders[i]._redraw();
      }
    } else {
      if (this.value.vectorDistance(val) > 0) {
        this.value.load(val);

        if (this.uslider) {
          this.uslider.setValue(this.uniformValue, false);
        }

        for (let i=0; i<this.value.length; i++) {
          this.sliders[i].setValue(val[i], false);
          this.sliders[i]._redraw();
        }
      }
    }
  }

  update() {
    super.update();

    this.updateDataPath();

    if (this.stepIsRelative) {
      for (let slider of this.sliders) {
        slider.step = ToolProperty$1.calcRelativeStep(this.step, slider.value);
      }
    }

    if (this.uslider) {
      this.uslider.step = this.step;
      if (this.stepIsRelative) {
        this.uslider.step = ToolProperty$1.calcRelativeStep(this.step, this.uniformValue);
      }

    }
  }

  static define() {return {
    tagname : "vector-panel-x"
  }}
}
UIBase$2.internalRegister(VectorPanel);


class ToolTip extends UIBase$2 {
  constructor() {
    super();

    this.visibleToPick = false;
    this.div = document.createElement("div");

    this.shadow.appendChild(this.div);
    this._start_time = undefined;
    this.timeout = undefined;
  }

  static show(message, screen, x, y) {
    let ret = UIBase$2.createElement(this.define().tagname);

    ret._start_time = time_ms();
    ret.timeout = ret.getDefault("timeout");

    ret.text = message;
    let size = ret._estimateSize();

    let pad = 5;
    size = [size[0] + pad, size[1] + pad];

    console.log(size);
    x = Math.min(Math.max(x, 0), screen.size[0] - size[0]);
    y = Math.min(Math.max(y, 0), screen.size[1] - size[1]);

    let dpi = UIBase$2.getDPI();

    x += 10/dpi;
    y += 15/dpi;

    ret._popup = screen.popup(ret, x, y);
    ret._popup.background = "rgba(0,0,0,0)";
    ret._popup.style["border"] = "none";
    ret.div.style["padding"] = "15px";

    ret._popup.add(ret);

    return ret;
  }

  end() {
    this._popup.end();
  }

  init() {
    super.init();
    this.setCSS();
  }

  set text(val) {
    this.div.innerHTML = val.replace(/[\n]/g, "<br>\n");
  }

  get text() {
    return this.div.innerHTML;
  }

  _estimateSize() {
    let text = this.div.textContent;
    let block = measureTextBlock(this, text, undefined, undefined, undefined, this.getDefault("ToolTipText"));

    return [block.width+50, block.height+30];
  }

  update() {
    super.update();

    if (time_ms() - this._start_time > this.timeout) {
      this.end();
    }
  }

  setCSS() {
    super.setCSS();

    let color = this.getDefault("background-color");
    let bcolor = this.getDefault("border-color");

    this.background = color;

    let radius = this.getDefault("border-radius", undefined, 5);
    let bstyle = this.getDefault("border-style", undefined, "solid");
    let bwidth = this.getDefault("border-width", undefined, 1);
    let padding = this.getDefault("padding", undefined, 15);

    this.noMarginsOrPadding();

    this.div.style["padding"] = padding + "px";

    this.div.style["background-color"] = "rgba(0,0,0,0)";
    this.div.style["border"] = `${bwidth}px ${bstyle} ${bcolor}`;
    this.div.style["border-radius"] = radius + "px";
    this.style["border-radius"] = radius + "px";

    let font = this.getDefault("ToolTipText");
    this.div.style["color"] = font.color;
    this.div.style["font"] = font.genCSS();
  }

  static define() {return {
    tagname : "tool-tip-x",
    style   : "tooltip"
  }}
};
UIBase$2.internalRegister(ToolTip);

window._ToolTip = ToolTip;

"use strict";

/*
why am I using a toolstack here at all?  time to remove!
*/

let toolstack_getter = function () {
  throw new Error("must pass a toolstack getter to registerToolStackGetter")
};

function registerToolStackGetter(func) {
  toolstack_getter = func;
}

let Vector2$5   = Vector2,
    Vector3$1   = Vector3,
    UndoFlags$1 = UndoFlags,
    ToolFlags$1 = ToolFlags;

//import {keymap} from './events';

class ToolBase extends ToolOp {
  constructor(screen) {
    super();
    this.screen = screen;
    //super();

    this._finished = false;
  }

  start(elem, pointerId) {
    //toolstack_getter().execTool(this);
    this.modalStart(undefined, elem, pointerId);
  }

  cancel() {
    this.finish();
  }

  finish() {
    this._finished = true;
    this.popModal(this.screen);
  }

  popModal() {
    this.overdraw.end();
    popModalLight(this.modaldata);
    this.modaldata = undefined;
  }

  modalStart(ctx, elem, pointerId) {
    this.ctx = ctx;

    if (this.modaldata !== undefined) {
      console.log("Error, modaldata was not undefined");
      popModalLight(this.modaldata);
    }

    this.overdraw = UIBase$2.createElement("overdraw-x");
    this.overdraw.start(this.screen);

    let handlers = {};
    let keys = Object.getOwnPropertyNames(this);
    for (let k in this.__proto__) {
      keys.push(k);
    }
    for (let k of Object.getOwnPropertyNames(this.__proto__)) {
      keys.push(k);
    }

    for (let k in this) {
      keys.push(k);
    }

    for (let k of keys) {
      if (k.startsWith("on")) {
        handlers[k] = this[k].bind(this);
      }
    }

    //window.setTimeout(() => {
    if (pointerId !== undefined) {
      handlers.on_pointerdown = handlers.on_mousedown;
      handlers.on_pointermove = handlers.on_mousemove;
      handlers.on_pointerup = handlers.on_mouseup;
      handlers.on_pointercancel = handlers.on_mouseup;
      handlers.on_pointerend = handlers.on_mouseup;

      this.modaldata = pushPointerModal(handlers, elem, pointerId);
    } else {
      this.modaldata = pushModalLight(handlers);
    }
    //console.log("HANDLERS", this.modaldata.handlers);

    //}, 100);

    //window.addEventListener("touchmove", (e) => {
    //  console.log("touchmove");
    //}, {passive : false});
  }

  on_mousemove(e) {
  }

  on_mouseup(e) {
    this.finish();
  }

  on_keydown(e) {
    console.log("s", e.keyCode);

    switch (e.keyCode) {
      case keymap.Escape: //esc
        this.cancel();
        break;
      case keymap.Space: //space
      case keymap.Enter: //return
        this.finish();
        break;
    }
  }
}

class AreaResizeTool extends ToolBase {
  constructor(screen, border, mpos) {
    if (screen === undefined) screen = _appstate.screen; //XXX hackish!

    super(screen);

    this.start_mpos = new Vector2$5(mpos);

    this.sarea = border.sareas[0];
    if (!this.sarea || border.dead) {
      console.log(border.dead, border);
      throw new Error("border corruption");
    }

    this.screen = screen;

    this.side = this.sarea._side(border);
  }

  get border() {
    return this.sarea._borders[this.side];
  }

  static tooldef() {
    return {
      uiname     : "Resize Area",
      toolpath   : "screen.area.resize",
      icon       : Icons.RESIZE,
      description: "change size of area",
      is_modal   : true,
      undoflag   : UndoFlags$1.NO_UNDO,
      flag       : 0,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }

  getBorders() {
    let horiz = this.border.horiz;

    let ret = [];
    let visit = new Set();

    let rec = (v) => {
      if (visit.has(v._id)) {
        return;
      }

      visit.add(v._id);

      for (let border of v.borders) {
        if (border.horiz == horiz && !visit.has(border._id)) {
          visit.add(border._id);
          ret.push(border);

          rec(border.otherVertex(v));
        }
      }
    };

    rec(this.border.v1);
    rec(this.border.v2);

    return ret;
  }

  on_mouseup(e) {
    this.finish();
  }

  finish() {
    super.finish();
    this.screen.snapScreenVerts();
    this.screen.regenBorders();
    this.screen.snapScreenVerts();
    this.screen.loadFromVerts();
  }

  on_keydown(e) {
    switch (e.keyCode) {
      case keymap["Escape"]:
      case keymap["Enter"]:
      case keymap["Space"]:
        this.finish();
        break;
    }
  }

  on_mousemove(e) {
    let mpos = new Vector2$5([e.x, e.y]);

    mpos.sub(this.start_mpos);

    let axis = this.border.horiz ? 1 : 0;

    //console.log(this.border.horiz);

    this.overdraw.clear();

    let visit = new Set();
    let borders = this.getBorders();

    let color = exports.DEBUG.screenborders ? "rgba(1.0, 0.5, 0.0, 0.1)" : "rgba(1.0, 0.5, 0.0, 1.0)";

    let bad = false;

    for (let border of borders) {
      bad = bad || !this.screen.isBorderMovable(border);

      border.oldv1 = new Vector2$5(border.v1);
      border.oldv2 = new Vector2$5(border.v2);
    }

    if (bad) {
      console.log("border is not movable");
      return;
    }

    let check = () => {
      let count = 0;

      for (let sarea of this.screen.sareas) {
        if (sarea.size[0] < 15 || sarea.size[1] < 15) {
          count++;
        }
      }

      return count;
    };

    let badcount = check();


    let snapMode = true;

    let df = mpos[axis];
    let border = this.border;

    this.screen.moveBorder(border, df, false);

    for (let border of borders) {
      //if false, stead of forcing areas to fit within screen bounds
      //in snapScreenVerts the screen bounds will be modified instead.

      if (border.outer) {
        snapMode = false;
      }

      this.overdraw.line(border.v1, border.v2, color);
    }

    this.start_mpos[0] = e.x;
    this.start_mpos[1] = e.y;
    this.screen.loadFromVerts();
    this.screen.setCSS();

    if (check() != badcount) {
      console.log("bad");

      for (let border of borders) {
        border.v1.load(border.oldv1);
        border.v2.load(border.oldv2);
      }
    }


    this.screen.snapScreenVerts(snapMode);
    this.screen.loadFromVerts();
    this.screen.solveAreaConstraints(snapMode);
    this.screen.setCSS();
    this.screen.updateDebugBoxes();
    this.screen._fireResizeCB();
  }
}

//controller.registerTool(AreaResizeTool);

class SplitTool extends ToolBase {
  constructor(screen) {
    if (screen === undefined) screen = _appstate.screen; //XXX hackish!

    super(screen);

    this.done = false;
    this.screen = screen;
    this.ctx = screen.ctx;
    this.sarea = undefined;
    this.t = undefined;

    this.started = false;
  }

  static tooldef() {
    return {
      uiname     : "Split Area",
      toolpath   : "screen.area.split",
      icon       : Icons.SMALL_PLUS,
      description: "split an area in two",
      is_modal   : true,
      undoflag   : UndoFlags$1.NO_UNDO,
      flag       : 0,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }

  modalStart(ctx) {
    if (this.started) {
      console.trace("double call to modalStart()");
      return;
    }

    this.overdraw = UIBase$2.createElement("overdraw-x");
    this.overdraw.start(this.screen);

    super.modalStart(ctx);
  }

  cancel() {
    return this.finish(true);
  }

  finish(canceled = false) {
    if (this.done) {
      return;
    }

    this.done = true;
    this.overdraw.end();

    this.popModal(this.screen);

    if (canceled || !this.sarea) {
      return;
    }

    let sarea = this.sarea, screen = this.screen;
    let t = this.t;

    screen.splitArea(sarea, t, this.horiz);
    screen._internalRegenAll();
  }

  on_mousemove(e) {
    let x = e.x, y = e.y;

    let screen = this.screen;

    let sarea = screen.findScreenArea(x, y);

    this.overdraw.clear();

    if (sarea !== undefined) {
      //x -= sarea.pos[0];
      //y -= sarea.pos[1];
      x = (x - sarea.pos[0])/(sarea.size[0]);
      y = (y - sarea.pos[1])/(sarea.size[1]);

      let dx = 1.0 - Math.abs(x - 0.5);
      let dy = 1.0 - Math.abs(y - 0.5);

      this.sarea = sarea;
      let horiz = this.horiz = dx < dy;

      if (horiz) {
        this.t = y;
        this.overdraw.line([sarea.pos[0], e.y], [sarea.pos[0] + sarea.size[0], e.y]);
      } else {
        this.t = x;
        this.overdraw.line([e.x, sarea.pos[1]], [e.x, sarea.pos[1] + sarea.size[1]]);
      }
    }
    //console.warn("sarea:", sarea);

    //let sarea = this.
    //console.log(e.x, e.y);
    //this.overdraw.clear();
    //this.overdraw.line([e.x, e.y-200], [e.x, e.y+200], "grey");
  }

  on_mousedown(e) {
  }

  on_mouseup(e) {
    this.finish();

    if (e.button) {
      this.stopPropagation();
      this.preventDefault();
    }
  }

  on_keydown(e) {
    console.log("s", e.keyCode);

    switch (e.keyCode) {
      case keymap.Escape: //esc
        this.cancel();
        break;
      case keymap.Space: //space
      case keymap.Enter: //return
        this.finish();
        break;
    }
  }
}


class RemoveAreaTool extends ToolBase {
  constructor(screen, border) {
    if (screen === undefined) screen = _appstate.screen; //XXX hackish!

    super(screen);

    this.border = border;

    this.done = false;
    this.screen = screen;
    this.ctx = screen.ctx;
    this.sarea = undefined;
    this.t = undefined;

    this.started = false;
  }

  static tooldef() {
    return {
      uiname     : "Remove Area",
      toolpath   : "screen.area.pick_remove",
      icon       : Icons.SMALL_PLUS,
      description: "Collapse a window",
      is_modal   : true,
      undoflag   : UndoFlags$1.NO_UNDO,
      flag       : 0,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }

  modalStart(ctx) {
    if (this.started) {
      console.trace("double call to modalStart()");
      return;
    }

    this.overdraw = UIBase$2.createElement("overdraw-x");
    this.overdraw.start(this.screen);

    super.modalStart(ctx);
  }

  cancel() {
    return this.finish(true);
  }

  finish(canceled = false) {
    if (this.done) {
      return;
    }

    this.done = true;
    this.overdraw.end();

    this.popModal(this.screen);

    if (canceled || !this.sarea) {
      return;
    }

    let sarea = this.sarea, screen = this.screen;
    let t = this.t;

    if (sarea) {
      screen.collapseArea(sarea, this.border);
      screen._internalRegenAll();
    }
  }

  on_mousemove(e) {
    let x = e.x, y = e.y;

    let screen = this.screen;

    let sarea = screen.findScreenArea(x, y);

    this.overdraw.clear();

    if (sarea !== undefined) {
      this.sarea = sarea;
      this.overdraw.rect(sarea.pos, sarea.size, "rgba(0,0,0,0.1)");
    }
    //console.warn("sarea:", sarea);

    //let sarea = this.
    //console.log(e.x, e.y);
    //this.overdraw.clear();
    //this.overdraw.line([e.x, e.y-200], [e.x, e.y+200], "grey");
  }

  on_mousedown(e) {
  }

  on_mouseup(e) {
    this.finish();

    if (e.button) {
      this.stopPropagation();
      this.preventDefault();
    }
  }

  on_keydown(e) {
    console.log("s", e.keyCode);

    switch (e.keyCode) {
      case keymap.Escape: //esc
        this.cancel();
        break;
      case keymap.Space: //space
      case keymap.Enter: //return
        this.finish();
        break;
    }
  }
}

//controller.registerTool(SplitTool);


class AreaDragTool extends ToolBase {
  constructor(screen, sarea, mpos) {
    if (screen === undefined) screen = _appstate.screen; //XXX hackish!

    super(screen);

    this.dropArea = false;
    this.excludeAreas = new Set();
    this.cursorbox = undefined;
    this.boxes = [];
    this.boxes.active = undefined;

    this.sarea = sarea;
    this.start_mpos = new Vector2$5(mpos);
    this.screen = screen;
  }

  static tooldef() {
    return {
      uiname     : "Drag Area",
      toolpath   : "screen.area.drag",
      icon       : Icons.TRANSLATE,
      description: "move or duplicate area",
      is_modal   : true,
      undoflag   : UndoFlags$1.NO_UNDO,
      flag       : 0,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }

  finish() {
    super.finish();

    this.screen.regenBorders();
    this.screen.solveAreaConstraints();
    this.screen.snapScreenVerts();
    this.screen._recalcAABB();
  }

  getBoxRect(b) {
    let sa = b.sarea;
    let pos, size;

    if (b.horiz == -1) {
      //replacement mode
      pos = sa.pos;
      size = sa.size;
    } else if (b.horiz) {
      if (b.side == 'b') {
        pos = [sa.pos[0], sa.pos[1] + sa.size[1]*b.t];
        size = [sa.size[0], sa.size[1]*(1.0 - b.t)];
      } else {
        pos = [sa.pos[0], sa.pos[1]];
        size = [sa.size[0], sa.size[1]*b.t];
      }
    } else {
      if (b.side == 'r') {
        pos = [sa.pos[0] + sa.size[0]*b.t, sa.pos[1]];
        size = [sa.size[0]*(1.0 - b.t), sa.size[1]];
      } else {
        pos = [sa.pos[0], sa.pos[1]];
        size = [sa.size[0]*b.t, sa.size[1]];
      }
    }

    let color = "rgba(100, 100, 100, 0.2)";

    let ret = this.overdraw.rect(pos, size, color);
    ret.style["pointer-events"] = "none";

    return ret;
  }

  doSplit(b) {
    if (this.sarea) {
      return this.doSplitDrop(b);
    }

    let src = this.sarea, dst = b.sarea;
    let screen = this.screen;

    let t = b.t;

    screen.splitArea(dst, t, b.horiz);

    screen._internalRegenAll();
  }

  doSplitDrop(b) {
    //first check if there was no change
    if (b.horiz === -1 && b.sarea === this.sarea) {
      return;
    }

    let can_rip = false;
    let sa = this.sarea;
    let screen = this.screen;

    //rip conditions
    can_rip = sa.size[0] === screen.size[0] || sa.size[1] === screen.size[1];
    can_rip = can_rip || this.sarea.floating;
    can_rip = can_rip && b.sarea !== sa;
    can_rip = can_rip && (b.horiz === -1 || !screen.areasBorder(sa, b.sarea));

    let expand = b.horiz === -1 && b.sarea !== sa && screen.areasBorder(b.sarea, sa);

    can_rip = can_rip || expand;

    console.log("can_rip:", can_rip, expand);

    if (can_rip) {
      screen.removeArea(sa);
      screen.snapScreenVerts();
    }

    if (b.horiz === -1) {
      //replacement
      let src = this.sarea, dst = b.sarea;

      if (can_rip && src !== dst) {
        let mm;

        //handle case of one area "consuming" another
        if (expand) {
          mm = screen.minmaxArea(src);
          screen.minmaxArea(dst, mm);
        }

        console.log("replacing. . .", expand);

        if (src.floating) {
          let old = dst.editors;

          dst.editors = [];
          dst.editormap = {};

          if (!(dst.area.constructor.define().areaname in src.editormap)) {
            dst.area.push_ctx_active();
            dst.area.on_area_inactive();
            dst.area.remove();
            dst.area.pop_ctx_active();
          }

          for (let editor of old) {
            let def = editor.constructor.define();

            let bad = false;
            //bad = !(def.areaname in src.editormap);

            for (let editor2 of src.editors) {
              if (editor.constructor === editor2.constructor) {
                bad = true;
                break;
              }
            }

            if (!bad) {
              dst.editors.push(editor);
              dst.editormap[def.areaname] = editor;
            }
          }

          for (let editor of src.editors) {
            let def = editor.constructor.define();

            dst.editormap[def.areaname] = editor;
            dst.editors.push(editor);

            if (editor.owning_sarea) {
              editor.owning_sarea = dst;
            }

            if (editor.parentWidget) {
              editor.parentWidget = dst;
            }
          }

          if (exports.useAreaTabSwitcher) {
            for (let editor of dst.editors) {
              if (editor.switcher) {
                editor.switcher.flagUpdate();
              }
            }
          }

          dst.area = src.area;
          dst.shadow.appendChild(src.area);

          src.area = undefined;
          src.editors = [];
          src.editormap = {};

          dst.on_resize(dst.size, dst.size);

          dst.flushSetCSS();
          dst.flushUpdate();

          screen.removeArea(src);
          screen.snapScreenVerts();

          return;
        } else {
          screen.replaceArea(dst, src);
        }

        if (expand) {
          console.log("\nEXPANDING:", src.size[0], src.size[1]);

          src.pos[0] = mm.min[0];
          src.pos[1] = mm.min[1];

          src.size[0] = mm.max[0] - mm.min[0];
          src.size[1] = mm.max[1] - mm.min[1];

          src.loadFromPosSize();

          screen._internalRegenAll();
        }
      } else {
        //console.log("copying. . .");
        screen.replaceArea(dst, src.copy());
        screen._internalRegenAll();
      }
    } else {
      let src = this.sarea, dst = b.sarea;

      let t = b.t;

      let nsa = screen.splitArea(dst, t, b.horiz);

      if (b.side === 'l' || b.side === 't') {
        nsa = dst;
      }

      if (can_rip) {
        //console.log("replacing");
        screen.replaceArea(nsa, src);
      } else {
        //console.log("copying");
        screen.replaceArea(nsa, src.copy());
      }

      screen._internalRegenAll();
    }
  }

  makeBoxes(sa) {
    let sz = isMobile() ? 100 : 40;
    let cx = sa.pos[0] + sa.size[0]*0.5;
    let cy = sa.pos[1] + sa.size[1]*0.5;

    let color = this.color = "rgba(200, 200, 200, 0.55)";
    let hcolor = this.hcolor = "rgba(230, 230, 230, 0.75)";
    let idgen = 0;
    let boxes = this.boxes;

    let box = (x, y, sz, horiz, t, side) => {
      //console.log(x, y, sz);

      let b = this.overdraw.rect([x - sz[0]*0.5, y - sz[1]*0.5], sz, color);
      b.style["border-radius"] = "14px";

      boxes.push(b);

      b.sarea = sa;

      let style = document.createElement("style");
      let cls = `mybox_${idgen++}`;

      b.horiz = horiz;
      b.t = t;
      b.side = side;
      b.setAttribute("class", cls);
      b.setAttribute("is_box", true);

      b.addEventListener("mousemove", this.on_mousemove.bind(this));

      let onclick = b.onclick = (e) => {
        let type = e.type.toLowerCase();

        if ((e.type === "mousedown" || e.type === "mouseup") && e.button !== 0) {
          return; //another handler will cancel
        }

        console.log("split click");

        if (!this._finished) {
          this.finish();
          this.doSplit(b);

          e.preventDefault();
          e.stopPropagation();
        }
      };

      b.addEventListener("click", onclick);
      b.addEventListener("mousedown", onclick);
      b.addEventListener("mouseup", onclick);

      b.addEventListener("mouseenter", (e) => {
        if (this.curbox !== undefined) {
          if (this.curbox.rect) {
            this.curbox.rect.remove();
            this.curbox.rect = undefined;
          }
        }

        if (b.rect !== undefined) {
          b.rect.remove();
          b.rect = undefined;
        }

        b.rect = this.getBoxRect(b);
        this.curbox = b;

        b.setColor(hcolor);
        //b.style["background-color"] = hcolor;
      });

      b.addEventListener("mouseleave", (e) => {
        if (b.rect) {
          b.rect.remove();
          b.rect = undefined;
        }

        if (this.curbox === b) {
          this.curbox = undefined;
        }

        b.setColor(color);
        //b.style["background-color"] = color;
      });

      style.textContent = `
        .${cls}:hover {
          background-color : orange;
          fill:orange;stroke-width:2
        }
      `;
      //console.log(style.textContent);
      b.appendChild(style);
      b.setAttribute("class", cls);

      return b;
    };

    let pad = 5;

    if (this.sarea) {
      box(cx, cy, [sz, sz], -1, -1, -1);
    }

    box(cx - sz*0.75 - pad, cy, [sz*0.5, sz], false, 0.5, 'l');
    box(cx - sz*1.2 - pad, cy, [sz*0.25, sz], false, 0.3, 'l');

    box(cx + sz*0.75 + pad, cy, [sz*0.5, sz], false, 0.5, 'r');
    box(cx + sz*1.2 + pad, cy, [sz*0.25, sz], false, 0.7, 'r');

    box(cx, cy - sz*0.75 - pad, [sz, sz*0.5], true, 0.5, 't');
    box(cx, cy - sz*1.2 - pad, [sz, sz*0.25], true, 0.3, 't');

    box(cx, cy + sz*0.75 + pad, [sz, sz*0.5], true, 0.5, 'b');
    box(cx, cy + sz*1.2 + pad, [sz, sz*0.25], true, 0.7, 'b');
  }

  getActiveBox(x, y) {
    for (let n of this.boxes) {
      if (n.hasAttribute && n.hasAttribute("is_box")) {
        let rect = n.getClientRects()[0];

        //console.log(rect.x, rect.y);
        if (x >= rect.x && y >= rect.y && x < rect.x + rect.width && y < rect.y + rect.height) {
          //console.log("found rect");
          return n;
        }
      }
    }
  }

  on_drag(e) {
    this.on_mousemove(e);
  }

  on_dragend(e) {
    this.on_mouseup(e);
  }

  on_mousemove(e) {
    let wid = 55;
    let color = "rgb(200, 200, 200, 0.7)";

    //console.trace("mouse move!", e.x, e.y, this.sarea);

    /*
     manually feed events to boxes so as to work right
     with touch events; note that pushModalLight routes
     touch to mouse events (if no touch handlers are present).
     */
    let n = this.getActiveBox(e.x, e.y);

    if (n !== undefined) {
      n.setColor(this.hcolor); //"rgba(250, 250, 250, 0.75)");
    }
    //console.log("mouse move", n);

    if (this.boxes.active !== undefined && this.boxes.active !== n) {
      this.boxes.active.setColor(this.color);
      this.boxes.active.dispatchEvent(new MouseEvent("mouseleave", e));
    }

    if (n !== undefined) {
      n.dispatchEvent(new MouseEvent("mouseenter", e));
    }

    this.boxes.active = n;
    /*
    let rec = (n) => {
      if (n.hasAttribute && n.hasAttribute("is_box")) {
        let rect = n.getClientRects()[0];

        console.log(rect.x, rect.y);
        if (x >= rect.x && x >= rect.y && x < rect.x+rect.width && y < rect.y+rect.height) {
          console.log("found rect");
          n.dispatchEvent("mouseenter", new MouseEvent("mouseenter", e));
        }
      }
      if (n === undefined || n.childNodes === undefined) {
        return;
      }

      for (let n2 of n.childNodes) {
        rec(n2);
      }
      if (n.shadow) {
        for (let n2 of n.shadow.childNodes) {
          rec(n2);
        }
      }
    };

    rec(this.overdraw);
    //*/
    if (this.sarea === undefined) {
      return;
    }

    if (this.cursorbox === undefined) {
      wid = 25;
      this.cursorbox = this.overdraw.rect([e.x - wid*0.5, e.y - wid*0.5], [wid, wid], color);
      this.cursorbox.style["pointer-events"] = "none";
    } else {
      this.cursorbox.style["x"] = (e.x - wid*0.5) + "px";
      this.cursorbox.style["y"] = (e.y - wid*0.5) + "px";
    }
  }

  on_pointerup(e) {
    this.on_mouseup(e);
  }

  on_mouseup(e) {
    console.log("e.button", e.button, e, e.x, e.y, this.getActiveBox(e.x, e.y));

    if (e.button) {
      e.stopPropagation();
      e.preventDefault();
    } else {
      let box = this.getActiveBox(e.x, e.y);

      if (box !== undefined) {
        box.onclick(e);
      }
    }

    this.finish();
  }

  modalStart(ctx) {
    super.modalStart(...arguments);

    let screen = this.screen;

    this.overdraw.clear();

    if (this.sarea && !this.excludeAreas.has(this.sarea)) {
      let sa = this.sarea;
      let box = this.overdraw.rect(sa.pos, sa.size, "rgba(100, 100, 100, 0.5)");

      box.style["pointer-events"] = "none";
    }

    for (let sa of screen.sareas) {
      if (this.excludeAreas.has(sa)) {
        continue;
      }

      this.makeBoxes(sa);
    }
  }

  on_keydown(e) {
    switch (e.keyCode){
      case keymap["Escape"]:
      case keymap["Enter"]:
      case keymap["Space"]:
        this.finish();
        break;
    }
  }
}


class AreaMoveAttachTool extends AreaDragTool {
  constructor(screen, sarea, mpos) {
    super(screen, sarea, mpos);

    this.excludeAreas = new Set([sarea]);

    this.dropArea = true;
    this.first = true;
    this.sarea = sarea;
    this.mpos = new Vector2$5(mpos);
    this.start_mpos2 = new Vector2$5(mpos);
    this.start_pos = new Vector2$5(sarea.pos);
  }

  on_mousemove(e) {
    let dx = e.x - this.start_mpos2[0];
    let dy = e.y - this.start_mpos2[1];

    let sarea = this.sarea;

    if (this.first) {
      this.start_mpos2 = new Vector2$5([e.x, e.y]);
      this.first = false;
      return;
    }


    sarea.pos[0] = this.start_pos[0] + dx;
    sarea.pos[1] = this.start_pos[1] + dy;

    sarea.loadFromPosSize();

    this.mpos.loadXY(e.x, e.y);
    super.on_mousemove(e);
  }

  on_mouseup(e) {
    super.on_mouseup(e);
  }

  on_mousedown(e) {
    super.on_mousedown(e);
  }

  on_keydown(e) {
    super.on_keydown(e);
  }
}

//controller.registerTool(AreaDragTool);

class ToolTipViewer extends ToolBase {
  constructor(screen) {
    super(screen);

    this.tooltip = undefined;
    this.element = undefined;
  }

  static tooldef() {
    return {
      uiname     : "Help Tool",
      toolpath   : "screen.help_picker",
      icon       : Icons.HELP,
      description: "view tooltips",
      is_modal   : true,
      undoflag   : UndoFlags$1.NO_UNDO,
      flag       : 0,
      inputs     : {}, //tool properties
      outputs    : {}  //tool properties
    }
  }

  on_mousemove(e) {
    this.pick(e);
  }

  on_mousedown(e) {
    this.pick(e);
  }

  on_mouseup(e) {
    this.finish();
  }

  finish() {
    super.finish();
  }

  on_keydown(e) {
    switch (e.keyCode) {
      case keymap.Escape:
      case keymap.Enter:
      case Keymap.Space:
        if (this.tooltip) {
          this.tooltip.end();
        }
        this.finish();
        break;
    }
  }

  pick(e) {
    let x = e.x, y = e.y;

    let ele = this.screen.pickElement(x, y);
    console.log(ele ? ele.tagName : ele);

    if (ele !== undefined && ele !== this.element && ele.title) {
      if (this.tooltip) {
        this.tooltip.end();
      }

      this.element = ele;
      let tip = ele.title;

      this.tooltip = ToolTip.show(tip, this.screen, x, y);
    }
    e.preventDefault();
    e.stopPropagation();
  }
}

let SnapLimit = 1;

const BORDER_ZINDEX_BASE = 25;

function snap(c, snap_limit = SnapLimit) {
  if (Array.isArray(c)) {
    for (let i = 0; i < c.length; i++) {
      c[i] = Math.floor(c[i]/snap_limit)*snap_limit;
    }
  } else {
    c = Math.floor(c/snap_limit)*snap_limit;
  }

  return c;
}

function snapi(c, snap_limit = SnapLimit) {
  //return snap(c, snap_limit);

  if (Array.isArray(c)) {
    for (let i = 0; i < c.length; i++) {
      c[i] = Math.ceil(c[i]/snap_limit)*snap_limit;
    }
  } else {
    c = Math.ceil(c/snap_limit)*snap_limit;
  }

  return c;
}

class ScreenVert extends Vector2 {
  constructor(pos, id, added_id) {
    super(pos);

    this.added_id = added_id;
    this.sareas = [];
    this.borders = [];

    this._id = id;
  }

  static hash(pos, added_id, limit) {
    let x = snap(pos[0], limit);
    let y = snap(pos[1], limit);

    return "" + x + ":" + y + ": + added_id";
  }

  valueOf() {
    return ScreenVert.hash(this, this.added_id);
  }

  [Symbol.keystr]() {
    return ScreenVert.hash(this, this.added_id);
  }

  loadSTRUCT(reader) {
    reader(this);
  }
}

ScreenVert.STRUCT = `
pathux.ScreenVert {
  0 : float;
  1 : float;
}
`;
nstructjs.register(ScreenVert);

class ScreenHalfEdge {
  constructor(border, sarea) {
    this.sarea = sarea;
    this.border = border;
    this.side = sarea._side(border);
  }

  get v1() {
    return this.border.v1;
  }

  get v2() {
    return this.border.v2;
  }

  [Symbol.keystr]() {
    return this.sarea._id + ":" + this.border._id;
  }

}

class ScreenBorder extends UIBase$2 {
  constructor() {
    super();

    this.visibleToPick = false;

    this.screen = undefined;
    this.v1 = undefined;
    this.v2 = undefined;
    this._id = undefined;

    this._hash = undefined;

    this.outer = undefined;

    this.halfedges = []; //all bordering borders, including ones with nonshared verts
    this.sareas = [];

    this._innerstyle = document.createElement("style");
    this._style = undefined;

    this.shadow.appendChild(this._innerstyle);

    this.inner = document.createElement("div");
    //this.inner.innerText = "sdfsdfsdf";
    this.shadow.appendChild(this.inner);

    let call_menu = ScreenBorder.bindBorderMenu(this);

    this.addEventListener("mousedown", (e) => {
      let ok = this.movable;

      if (e.button === 2) {
        call_menu(e);
        return;
      }

      if (!ok) {
        console.log("border is not movable");
        return;
      }

      console.log("area resize start!");
      let tool = new AreaResizeTool(this.screen, this, [e.x, e.y]);

      tool.start();

      e.preventDefault();
      e.stopPropagation();
    }, {capture: true});
  }

  static bindBorderMenu(elem, usePickElement=false) {
    let on_dblclick = (e) => {
      if (usePickElement && elem.pickElement(e.x, e.y) !== elem) {
        return;
      }

      let menu = [
        ["Split Area", () => {
          elem.ctx.screen.splitTool();
        }],
        Menu.SEP,
        ["Collapse Area", () => {
          elem.ctx.screen.removeAreaTool(elem instanceof ScreenBorder ? elem : undefined);
        }],
      ];

      menu = createMenu(elem.ctx, "", menu);
      //if (e.button === 2) {
      menu.ignoreFirstClick = 2;
      //}

      elem.ctx.screen.popupMenu(menu, e.x-15, e.y-15);

      e.preventDefault();
      e.stopPropagation();
    };

    elem.addEventListener("contextmenu", (e) => e.preventDefault());
    elem.addEventListener("dblclick", on_dblclick, {capture: true});

    return on_dblclick;
  }
  getOtherSarea(sarea) {
    console.log(this.halfedges, this.halfedges.length);

    for (let he of this.halfedges) {
      console.log(he);

      let ok = he.sarea !== sarea;
      ok = ok && he.sarea._verts.indexOf(this.v1) >= 0;
      ok = ok && he.sarea._verts.indexOf(this.v2) >= 0;

      if (ok) {
        return he.sarea;
      }
    }
  }

  get locked() {
    for (let sarea of this.sareas) {
      let mask = 1<<sarea._borders.indexOf(this);
      let lock = sarea.borderLock & mask;

      if (lock || (sarea.flag & AreaFlags.NO_COLLAPSE)) {
        return true;
      }
    }

    return false;
  }

  get dead() {
    return !this.parentNode;
  }

  get side() {
    throw new Error("side accedd");
  }

  set side(val) {
    throw new Error("side accedd");
  }

  get valence() {
    let ret = 0; //this.sareas.length;
    let horiz = this.horiz;

    let visit = {};

    for (let i = 0; i < 2; i++) {
      let sv = i ? this.v2 : this.v1;
      //console.log(sv);

      for (let sa of sv.borders) {
        if (sa.horiz != this.horiz)
          continue;
        if (sa._id in visit)
          continue;

        visit[sa._id] = 1;

        let a0x = Math.min(this.v1[0], this.v2[0]);
        let a0y = Math.min(this.v1[1], this.v2[1]);
        let a1x = Math.max(this.v1[0], this.v2[0]);
        let a1y = Math.max(this.v1[1], this.v2[1]);

        let b0x = Math.min(sa.v1[0], sa.v2[0]);
        let b0y = Math.min(sa.v1[1], sa.v2[1]);
        let b1x = Math.min(sa.v1[0], sa.v2[0]);
        let b1y = Math.min(sa.v1[1], sa.v2[1]);

        let ok;

        let eps = 0.001;
        if (horiz) {
          ok = (a0y <= b1y + eps && a1y >= a0y - eps);
        } else {
          ok = (a0x <= b1x + eps && a1x >= a0x - eps);
        }

        if (ok) {
          //console.log("found");
          ret += sa.sareas.length;
        }
      }
    }

    return ret;
  }

  get horiz() {
    let dx = this.v2[0] - this.v1[0];
    let dy = this.v2[1] - this.v1[1];

    return Math.abs(dx) > Math.abs(dy);
  }

  static hash(v1, v2) {
    return Math.min(v1._id, v2._id) + ":" + Math.max(v1._id, v2._id);
  }

  static define() {
    return {
      tagname: "screenborder-x",
      style  : "screenborder"
    };
  }

  otherVertex(v) {
    if (v === this.v1)
      return this.v2;
    else
      return this.v1;
  }

  setCSS() {
    this.style["pointer-events"] = this.movable ? "auto" : "none";

    if (this._style === undefined) {
      this._style = document.createElement("style");
      this.appendChild(this._style);
    }

    let dpi = UIBase$2.getDPI();

    let pad = this.getDefault("mouse-threshold") / dpi;
    let wid = this.getDefault("border-width");

    let v1 = this.v1, v2 = this.v2;
    let vec = new Vector2(v2).sub(v1);

    let x = Math.min(v1[0], v2[0]), y = Math.min(v1[1], v2[1]);
    let w, h;
    let cursor, bstyle;


    this.style["display"] = "flex";
    this.style["display"] = this.horiz ? "row" : "column";
    this.style["justify-content"] = "center";
    this.style["align-items"] = "center";

    if (!this.horiz) {
      this.style["padding-left"] = this.style["padding-right"] = pad + "px";
      x -= wid*0.5 + pad;

      w = wid*2;
      h = Math.abs(vec[1]);

      cursor = 'e-resize';
      bstyle = "border-left-style : solid;\n    border-right-style : solid;\n";
      bstyle = "border-top-style : none;\n    border-bottom-style : none;\n";
    } else {
      this.style["padding-top"] = this.style["padding-bottom"] = pad + "px";
      y -= wid*0.5 + pad;

      w = Math.abs(vec[0]);
      h = wid;

      cursor = 'n-resize';
      bstyle = "border-top-style : solid;\n    border-bottom-style : solid;\n";
    }


    let color = this.getDefault("border-outer");
    let debug = exports.DEBUG.screenborders;

    if (debug) {
      wid = 4;
      let alpha = 1.0;
      let c = this.sareas.length*75;

      let r = 0, g = 0, b = 0;

      if (this.movable) {
        b = 255;
      }
      if (this.halfedges.length > 1) {
        g = 255;
      }
      if (this.outer) {
        r = 255;
      }
      color = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }


    let innerbuf = `
        .screenborder_inner_${this._id} {
          ${bstyle}
          ${this.horiz ? 'height' : 'width'} : ${wid}px;
          ${!this.horiz ? 'height' : 'width'} : 100%;
          margin : 0px;
          padding : 0px;
          
          background-color : ${this.getDefault("border-inner")};
          border-color : ${color};
          border-width : ${wid*0.5}px;
          border-style : ${debug && this.outer ? "dashed" : "solid"};
          pointer-events : none;
        }`;

    let sbuf = `
        .screenborder_${this._id} {
        }
    `;

    let ok = this.movable;
    if (!this.outer) {
      for (let sarea of this.sareas) {
        ok = ok || sarea.floating;
      }
    }

    if (ok) {
      sbuf += `
        .screenborder_${this._id}:hover {
          cursor : ${cursor};
        }
      `;
    }

    this._style.textContent = sbuf;
    this._innerstyle.textContent = innerbuf;

    this.setAttribute("class", "screenborder_" + this._id);
    this.inner.setAttribute("class", "screenborder_inner_" + this._id);

    this.style["position"] = UIBase$2.PositionKey;
    this.style["left"] = x + "px";
    this.style["top"] = y + "px";
    this.style["width"] = w + "px";
    this.style["height"] = h + "px";
    this.style["z-index"] = "" + BORDER_ZINDEX_BASE;
  }

  valueOf() {
    return ScreenBorder.hash(this.v1, this.v2);
  }

  [Symbol.keystr]() {
    return ScreenBorder.hash(this.v1, this.v2);
  }
}

UIBase$2.internalRegister(ScreenBorder);

let _ScreenArea = undefined;

let UIBase$a = UIBase$2;

let Vector2$6 = Vector2;
let Screen$1 = undefined;

const AreaFlags = {
  HIDDEN                : 1,
  FLOATING              : 2,
  INDEPENDENT           : 4, //area is indpendent of the screen mesh
  NO_SWITCHER           : 8,
  NO_HEADER_CONTEXT_MENU: 16,
  NO_COLLAPSE           : 32,
};

window._contextWrangler = contextWrangler;

const BorderMask = {
  LEFT  : 1,
  BOTTOM: 2,
  RIGHT : 4,
  TOP   : 8,
  ALL   : 1 | 2 | 4 | 8
};

const BorderSides = {
  LEFT  : 0,
  BOTTOM: 1,
  RIGHT : 2,
  TOP   : 3
};

/**
 * Base class for all editors
 **/
class Area$1 extends UIBase$2 {
  constructor() {
    super();

    /**
     * -----b4----
     *
     * b1       b3
     *
     * -----b2----
     *
     * */

    let def = this.constructor.define();

    //set bits in mask to keep
    //borders from moving
    this.borderLock = def.borderLock || 0;
    this.flag = def.flag || 0;

    this.inactive = true;
    this.areaDragToolEnabled = true;

    this.owning_sarea = undefined;
    this._area_id = contextWrangler.idgen++;

    this.pos = undefined; //set by screenarea parent
    this.size = undefined; //set by screenarea parent
    this.minSize = [5, 5];
    this.maxSize = [undefined, undefined];

    let appendChild = this.shadow.appendChild;
    this.shadow.appendChild = (child) => {
      appendChild.call(this.shadow, child);
      if (child instanceof UIBase$a) {
        child.parentWidget = this;
      }
    };

    let prepend = this.shadow.prepend;
    this.shadow.prepend = (child) => {
      prepend.call(this.shadow, child);

      if (child instanceof UIBase$a) {
        child.parentWidget = this;
      }
    };
  }

  get floating() {
    return ~~(this.flag & AreaFlags.FLOATING);
  }

  set floating(val) {
    if (val) {
      this.flag |= AreaFlags.FLOATING;
    } else {
      this.flag &= ~AreaFlags.FLOATING;
    }
  }

  /**
   * Get active area as defined by push_ctx_active and pop_ctx_active.
   *
   * Type should be an Area subclass, if undefined the last accessed area
   * will be returned.
   * */
  static getActiveArea(type) {
    return contextWrangler.getLastArea(type);
  }

  static unregister(cls) {
    let def = cls.define();

    if (!def.areaname) {
      throw new Error("Missing areaname key in define()");
    }

    if (def.areaname in areaclasses) {
      delete areaclasses[def.areaname];
    }
  }

  /*
  addEventListener(type, cb, options) {
    let cb2 = (e) => {
      let x, y;
      let screen = this.getScreen();

      if (!screen) {
        console.warn("no screen!");
        return cb(elem);
      }

      if (type.startsWith("mouse")) {
        x = e.x; y = e.y;
      } else if (type.startsWith("touch") && e.touches && e.touches.length > 0) {
        x = e.touches[0].pageX; y = e.touches[0].pageY;
      } else if (type.startsWith("pointer")) {
        x = e.x; y = e.y;
      } else {
        if (screen) {
          x = screen.mpos[0];
          y = screen.mpos[1];
        } else {
          x = y = -100;
        }
      }

      let elem = screen.pickElement(x, y);
      console.log(elem ? elem.tagName : undefined);

      if (elem === this || elem === this.owning_sarea) {
        return cb(elem);
      }
    };

    cb.__cb2 = cb2;
    return super.addEventListener(type, cb2, options);
  }

  removeEventListener(type, cb, options) {
    super.removeEventListener(type, cb.__cb2, options);
  }
  //*/

  static register(cls) {
    let def = cls.define();

    if (!def.areaname) {
      throw new Error("Missing areaname key in define()");
    }

    areaclasses[def.areaname] = cls;

    UIBase$2.internalRegister(cls);
  }

  static makeAreasEnum() {
    let areas = {};
    let icons = {};
    let i = 0;

    for (let k in areaclasses) {
      let cls = areaclasses[k];
      let def = cls.define();

      if (def.flag & AreaFlags.HIDDEN)
        continue;

      let uiname = def.uiname;

      if (uiname === undefined) {
        uiname = k.replace("_", " ").toLowerCase();
        uiname = uiname[0].toUpperCase() + uiname.slice(1, uiname.length);
      }

      areas[uiname] = k;
      icons[uiname] = def.icon !== undefined ? def.icon : -1;
    }

    let prop = new EnumProperty(undefined, areas);
    prop.addIcons(icons);

    return prop;
  }

  static define() {
    return {
      tagname : "pathux-editor-x", // tag name, e.g. editor-x
      areaname: undefined, //api name for area type
      flag    : 0, //see AreaFlags
      uiname  : undefined,
      icon    : undefined //icon representing area in MakeHeader's area switching menu. Integer.
    };
  }

  static newSTRUCT() {
    return UIBase$a.createElement(this.define().tagname);
  }

  init() {
    super.init();

    this.style["overflow"] = "hidden";
    this.noMarginsOrPadding();

    let onover = (e) => {
      //console.log(this._area_id, this.ctx.workspace._area_id);

      //try to trigger correct entry in context area stacks
      this.push_ctx_active();
      this.pop_ctx_active();
    };

    //*
    super.addEventListener("mouseover", onover, {passive: true});
    super.addEventListener("mousemove", onover, {passive: true});
    super.addEventListener("mousein", onover, {passive: true});
    super.addEventListener("mouseenter", onover, {passive: true});
    super.addEventListener("touchstart", onover, {passive: true});
    super.addEventListener("focusin", onover, {passive: true});
    super.addEventListener("focus", onover, {passive: true});
    //*/
  }

  _get_v_suffix() {
    if (this.flag & AreaFlags.INDEPENDENT) {
      return this._id;
    } else {
      return "";
    }
  }

  /**
   * Return a list of keymaps used by this editor
   * @returns {Array<KeyMap>}
   */
  getKeyMaps() {
    return this.keymap !== undefined ? [this.keymap] : [];
  }

  on_fileload(isActiveEditor) {
    contextWrangler.reset();
  }

  buildDataPath() {
    let p = this;

    let sarea = this.owning_sarea;

    if (sarea === undefined || sarea.screen === undefined) {
      console.warn("Area.buildDataPath(): Failed to build data path");
      return "";
    }

    let screen = sarea.screen;

    let idx1 = screen.sareas.indexOf(sarea);
    let idx2 = sarea.editors.indexOf(this);

    if (idx1 < 0 || idx2 < 0) {
      throw new Error("malformed area data");
    }

    let ret = `screen.sareas[${idx1}].editors[${idx2}]`;
    return ret;
  }

  saveData() {
    return {
      _area_id: this._area_id,
      areaName: this.areaName
    };
  }

  loadData(obj) {
    let id = obj._area_id;

    if (id !== undefined && id !== null) {
      this._area_id = id;
    }
  }

  draw() {
  }

  copy() {
    console.warn("You might want to implement this, Area.prototype.copy based method called");
    let ret = UIBase$a.createElement(this.constructor.define().tagname);
    return ret;
  }

  on_resize(size, oldsize) {
    super.on_resize(size, oldsize);
  }

  on_area_focus() {

  }

  on_area_blur() {

  }

  /** called when editors are swapped with another editor type*/
  on_area_active() {
  }

  /** called when editors are swapped with another editor type*/
  on_area_inactive() {
  }

  /*
  * This is needed so UI controls can know what their parent area is.
  * For example, a slider with data path "view2d.zoomfac" needs to know where
  * to find view2d.
  *
  * Typically this works by adding a field to a ContextOverlay:
  *
  * class ContextOverlay {
  *   get view3d() {
  *     return Area.getActiveArea(View3D);
  *   }
  * }
  *
  * Make sure to wrap event callbacks in push_ctx_active and pop_ctx_active.
  * */
  push_ctx_active(dontSetLastRef = false) {
    contextWrangler.push(this.constructor, this, !dontSetLastRef);
  }

  /**
   * see push_ctx_active
   * */
  pop_ctx_active(dontSetLastRef = false) {
    contextWrangler.pop(this.constructor, this, !dontSetLastRef);
  }

  getScreen() {
    //XXX
    //return _appstate.screen;
    throw new Error("replace me in Area.prototype");
  }

  toJSON() {
    return Object.assign(super.toJSON(), {
      areaname: this.constructor.define().areaname,
      _area_id: this._area_id
    });
  }

  loadJSON(obj) {
    super.loadJSON(obj);
    this._area_id = obj._area_id;

    return this;
  }

  getBarHeight() {
    return this.header.getClientRects()[0].height;
  }

  makeAreaSwitcher(container) {
    if (exports.useAreaTabSwitcher) {
      let ret = UIBase$a.createElement("area-docker-x");
      container.add(ret);
      return ret;
    }

    let prop = Area$1.makeAreasEnum();

    let dropbox = container.listenum(undefined, {
      name    : this.constructor.define().uiname,
      enumDef : prop,
      callback: (id) => {
        let cls = areaclasses[id];
        this.owning_sarea.switch_editor(cls);
      }
    });

    dropbox.update.after(() => {
      let name = this.constructor.define().uiname;
      let val = prop.values[name];

      if (dropbox.value !== val && val in prop.keys) {
        val = prop.keys[val];
      }

      if (dropbox.value !== val) {
        dropbox.setValue(prop.values[name], true);
      }
    });

    return dropbox;
  }

  makeHeader(container, add_note_area = true, make_draggable = true) {
    let switcherRow;
    let row;
    let helpRow;

    if (!(this.flag & AreaFlags.NO_SWITCHER) && exports.useAreaTabSwitcher) {
      let col = this.header = container.col();

      switcherRow = helpRow = col.row();
      row = col.row();
    } else {
      row = helpRow = this.header = container.row();
    }

    if (!(this.flag & AreaFlags.NO_HEADER_CONTEXT_MENU)) {
      let callmenu = ScreenBorder.bindBorderMenu(this.header, true);

      this.addEventListener("mousedown", e => {
        if (e.button !== 2 || this.header.pickElement(e.x, e.y) !== this.header) {
          return;
        }

        console.log("CLIKWER!");

        callmenu(e);
      });
    }

    this.header.remove();
    container._prepend(this.header);

    row.setCSS.after(() => row.background = this.getDefault("AreaHeaderBG"));

    let rh = ~~(16*this.getDPI());

    //container.setSize(undefined, rh);
    //row.setSize(undefined, rh);
    //row.setSize(undefined, rh);

    container.noMarginsOrPadding();
    row.noMarginsOrPadding();

    row.style["width"] = "100%";
    row.style["margin"] = "0px";
    row.style["padding"] = "0px";

    if (!(this.flag & AreaFlags.NO_SWITCHER)) {
      if (this.switcher) {
        this.switcher.remove();
      }
      this.switcher = this.makeAreaSwitcher(exports.useAreaTabSwitcher ? switcherRow : row);
    }

    if (isMobile() || exports.addHelpPickers) {
      if (this.helppicker) {
        this.helppicker.remove();
      }

      this.helppicker = helpRow.helppicker();
      this.helppicker.iconsheet = 0;
    }

    if (add_note_area) {
      let notef = UIBase$a.createElement("noteframe-x");
      notef.ctx = this.ctx;
      row._add(notef);
    }

    /* don't do normal dragging for tab switchers */
    if (exports.useAreaTabSwitcher) {
      return row;
    }

    let eventdom = this.header;

    let mdown = false;
    let mpos = new Vector2$6();

    let mpre = (e, pageX, pageY) => {
      if (haveModal()) {
        return;
      }

      pageX = pageX === undefined ? e.x : pageX;
      pageY = pageY === undefined ? e.y : pageY;

      let node = this.getScreen().pickElement(pageX, pageY);

      /*
      while (node) {
        if (node === row) {
          break;
        }
        node = node.parentWidget;
      }//*/

      //console.log(node === row, node ? node._id : undefined, row._id)

      if (node !== row) {
        return false;
      }

      return true;
    };

    eventdom.addEventListener("pointerout", (e) => {
      console.log("pointerout", e);
      mdown = false;
    });
    eventdom.addEventListener("pointerleave", (e) => {
      mdown = false;
      console.log("pointerleave", e);
    });

    eventdom.addEventListener("pointerdown", (e) => {
      console.log("pointerdown", e, mpre(e));

      if (!mpre(e)) return;

      mpos[0] = e.pageX;
      mpos[1] = e.pageY;
      mdown = true;
    });

    let last_time = time_ms();

    let do_mousemove = (e, pageX, pageY) => {
      if (haveModal() || !make_draggable) {
        return;
      }

      let mdown2 = e.buttons !== 0 || (e.touches && e.touches.length > 0);
      mdown2 = mdown2 && mdown;

      //console.log("area drag?", e, mdown2, e.pageX, e.pageY, mpre(e, pageX, pageY), e.was_touch);

      //calls to pickElement in mpre are expensive
      if (time_ms() - last_time < 250) {
        return;
      }

      last_time = time_ms;

      if (!mdown2 || !mpre(e, pageX, pageY)) return;


      if (e.type === "mousemove" && e.was_touch) {
        //okay how are patched events getting here?
        //avoid double call. . .
        return;
      }

      //console.log(mdown);
      let dx = pageX - mpos[0];
      let dy = pageY - mpos[1];

      let dis = dx*dx + dy*dy;
      let limit = 7;

      if (dis > limit*limit) {
        let sarea = this.owning_sarea;
        if (sarea === undefined) {
          console.warn("Error: missing sarea ref");
          return;
        }

        let screen = sarea.screen;
        if (screen === undefined) {
          console.log("Error: missing screen ref");
          return;
        }

        if (!this.areaDragToolEnabled) {
          return;
        }
        mdown = false;
        console.log("area drag tool!", e.type, e);
        screen.areaDragTool(this.owning_sarea);
      }
    };

    //not working on mobile
    //row.setAttribute("draggable", true);
    //row.draggable = true;
    /*
    eventdom.addEventListener("dragstart", (e) => {
      return;
      console.log("drag start!", e);
      e.dataTransfer.setData("text/json", "SplitAreaDrag");

      let canvas = document.createElement("canvas");
      let g = canvas.g;

      canvas.width = 32;
      canvas.height = 32;

      e.dataTransfer.setDragImage(canvas, 0, 0);

      mdown = false;
      console.log("area drag tool!");
      this.getScreen().areaDragTool(this.owning_sarea);
    });

    eventdom.addEventListener("drag", (e) => {
      console.log("drag!", e);
    });*/

    eventdom.addEventListener("pointermove", (e) => {
      return do_mousemove(e, e.pageX, e.pageY);
    }, false);
    eventdom.addEventListener("pointerup", (e) => {
      console.log("pointerup", e);
      mdown = false;
    }, false);
    eventdom.addEventListener("pointercancel", (e) => {
      console.log("pointercancel", e);
      mdown = false;
    }, false);

    return row;
  }

  setCSS() {
    if (this.size !== undefined) {
      this.style["position"] = UIBase$a.PositionKey;
      //this.style["left"] = this.pos[0] + "px";
      //this.style["top"] = this.pos[1] + "px";
      this.style["width"] = this.size[0] + "px";
      this.style["height"] = this.size[1] + "px";
    }
  }

  update() {
    //don't update non-active editors
    if (this.owning_sarea === undefined || this !== this.owning_sarea.area) {
      return;
    }

    super.update();

    //see FrameManager.js, we use a single update
    //function for everything now
    //this._forEachChildWidget((n) => {
    //  n.update();
    //});
  }

  loadSTRUCT(reader) {
    reader(this);
  }

  _isDead() {
    if (this.dead) {
      return true;
    }

    let screen = this.getScreen();

    if (screen === undefined)
      return true;

    if (screen.parentNode === undefined)
      return true;
  }

  //called by owning ScreenArea on file load
  afterSTRUCT() {
    let f = () => {
      if (this._isDead()) {
        return;
      }
      if (!this.ctx) {
        this.doOnce(f);
        return;
      }

      try {
        loadUIData(this, this.saved_uidata);
        this.saved_uidata = undefined;
      } catch (error) {
        console.log("failed to load ui data");
        print_stack$1(error);
      }
    };

    this.doOnce(f);
  }

  loadSTRUCT(reader) {
    reader(this);
  }

  _getSavedUIData() {
    return saveUIData(this, "area");
  }
}

Area$1.STRUCT = `
pathux.Area { 
  flag : int;
  saved_uidata : string | obj._getSavedUIData();
}
`;

nstructjs.register(Area$1, "pathux.Area");
UIBase$2.internalRegister(Area$1);

class ScreenArea extends UIBase$2 {
  constructor() {
    super();

    this._flag = undefined;

    this.flag = 0; /** holds AreaFlags.FLOATING and AreaFlags.INDEPENDENT */

    this._borders = [];
    this._verts = [];
    this.dead = false;

    this._sarea_id = contextWrangler.idgen++;

    this._pos = new Vector2$6();
    this._size = new Vector2$6([512, 512]);

    if (exports.DEBUG.screenAreaPosSizeAccesses) {
      let wrapVector = (name, axis) => {
        Object.defineProperty(this[name], axis, {
          get: function () {
            return this["_" + axis];
          },

          set: function (val) {
            console.warn(`ScreenArea.${name}[${axis}] set:`, val);
            this["_" + axis] = val;
          }
        });
      };

      wrapVector("size", 0);
      wrapVector("size", 1);
      wrapVector("pos", 0);
      wrapVector("pos", 1);
    }

    this.area = undefined;
    this.editors = [];
    this.editormap = {};

    this.addEventListener("mouseover", (e) => {
      if (haveModal()) {
        return;
      }

      //console.log("screen area mouseover");
      let screen = this.getScreen();
      if (screen.sareas.active !== this && screen.sareas.active && screen.sareas.active.area) {
        screen.sareas.active.area.on_area_blur();
      }

      if (this.area && screen.sareas.active !== this) {
        this.area.on_area_focus();
      }

      screen.sareas.active = this;
    });

    //this.addEventListener("mouseleave", (e) => {
    //console.log("screen area mouseleave");
    //});
  }

  /*
  saveData() {
    return {
      _sarea_id : this._sarea_id,
      pos       : this.pos,
      size      : this.size,
    };
  }
  loadData(obj) {
    super.loadData(obj);

    let id = obj._sarea_id;
    
    let type = obj.areatype;
    
    if (id !== undefined && id !== null) {
      this._sarea_id = id;
    }
    
    for (let area of this.editors) {
      if (area.areaType == type) {
        console.log("             found saved area type");
        
        this.switch_editor(area.constructor);
      }
    }
    
    this.pos.load(obj.pos);
    this.size.load(obj.size);
  }//*/

  get floating() {
    return this.flag & AreaFlags.FLOATING;
  }

  set floating(val) {
    if (val) {
      this.flag |= AreaFlags.FLOATING;
    } else {
      this.flag &= ~AreaFlags.FLOATING;
    }
  }

  get flag() {
    let flag = this._flag & (AreaFlags.FLOATING | AreaFlags.INDEPENDENT);

    if (this.area) {
      flag |= this.area.flag;
    }

    return flag;
  }

  set flag(v) {
    this._flag &= ~(AreaFlags.FLOATING | AreaFlags.INDEPENDENT);
    this._flag |= v & (AreaFlags.FLOATING | AreaFlags.INDEPENDENT);

    if (this.area) {
      this.area.flag |= v & ~(AreaFlags.FLOATING | AreaFlags.INDEPENDENT);
    }
  }

  get borderLock() {
    return this.area !== undefined ? this.area.borderLock : 0;
  }

  get minSize() {
    return this.area !== undefined ? this.area.minSize : this.size;
  }

  get maxSize() {
    return this.area !== undefined ? this.area.maxSize : this.size;
  }

  get pos() {
    return this._pos;
  }

  set pos(val) {
    if (exports.DEBUG.screenAreaPosSizeAccesses) {
      console.log("ScreenArea set pos", val);
    }
    this._pos.load(val);
  }

  get size() {
    return this._size;
  }

  set size(val) {
    if (exports.DEBUG.screenAreaPosSizeAccesses) {
      console.log("ScreenArea set size", val);
    }
    this._size.load(val);
  }

  static newSTRUCT() {
    return UIBase$a.createElement("screenarea-x");
  }

  static define() {
    return {
      tagname: "screenarea-x"
    };
  }

  _get_v_suffix() {
    return this.area ? this.area._get_v_suffix() : "";
  }

  bringToFront() {
    let screen = this.getScreen();

    HTMLElement.prototype.remove.call(this);
    screen.sareas.remove(this);

    screen.appendChild(this);

    let zindex = BORDER_ZINDEX_BASE + 1;

    if (screen.style["z-index"]) {
      zindex = parseInt(screen.style["z-index"]) + 1;
    }

    for (let sarea of screen.sareas) {
      let zindex = sarea.style["z-index"];
      if (sarea.style["z-index"]) {
        zindex = Math.max(zindex, parseInt(sarea.style["z-index"]) + 1);
      }
    }

    this.style["z-index"] = zindex;
  }

  _side(border) {
    let ret = this._borders.indexOf(border);
    if (ret < 0) {
      throw new Error("border not in screen area");
    }

    return ret;
  }

  init() {
    super.init();

    this.noMarginsOrPadding();
  }

  draw() {
    if (this.area && this.area.draw) {
      this.area.push_ctx_active();
      this.area.draw();
      this.area.pop_ctx_active();
    }
  }

  _isDead() {
    if (this.dead) {
      return true;
    }

    let screen = this.getScreen();

    if (screen === undefined)
      return true;

    if (screen.parentNode === undefined)
      return true;
  }

  toJSON() {
    let ret = {
      editors  : this.editors,
      _sarea_id: this._sarea_id,
      area     : this.area.constructor.define().areaname,
      pos      : this.pos,
      size     : this.size
    };

    return Object.assign(super.toJSON(), ret);
  }

  on_keydown(e) {
    if (this.area.on_keydown) {
      this.area.push_ctx_active();
      this.area.on_keydown(e);
      this.area.pop_ctx_active();
    }
  }

  loadJSON(obj) {
    if (obj === undefined) {
      console.warn("undefined in loadJSON");
      return;
    }

    super.loadJSON(obj);

    this.pos.load(obj.pos);
    this.size.load(obj.size);

    for (let editor of obj.editors) {
      let areaname = editor.areaname;

      //console.log(editor);

      let tagname = areaclasses[areaname].define().tagname;
      let area = UIBase$a.createElement(tagname);

      area.owning_sarea = this;
      this.editormap[areaname] = area;
      this.editors.push(this.editormap[areaname]);

      area.pos = new Vector2$6(obj.pos);
      area.size = new Vector2$6(obj.size);
      area.ctx = this.ctx;

      area.inactive = true;
      area.loadJSON(editor);
      area.owning_sarea = undefined;

      if (areaname === obj.area) {
        this.area = area;
      }
    }

    if (this.area !== undefined) {
      this.area.ctx = this.ctx;
      this.area.style["width"] = "100%";
      this.area.style["height"] = "100%";
      this.area.owning_sarea = this;
      this.area.parentWidget = this;

      this.area.pos = this.pos;
      this.area.size = this.size;

      this.area.inactive = false;
      this.shadow.appendChild(this.area);
      this.area.on_area_active();
      this.area.onadd();
    }

    this.setCSS();
  }

  _ondestroy() {
    super._ondestroy();

    this.dead = true;

    for (let editor of this.editors) {
      if (editor === this.area) continue;

      editor._ondestroy();
    }
  }

  getScreen() {
    if (this.screen !== undefined) {
      return this.screen;
    }

    //try to walk up graph, if possible
    let p = this.parentNode;
    let _i = 0;

    while (p && !(p instanceof Screen$1) && p !== p.parentNode) {
      p = this.parentNode;

      if (_i++ > 1000) {
        console.warn("infinite loop detected in ScreenArea.prototype.getScreen()");
        return undefined;
      }
    }

    return p && p instanceof Screen$1 ? p : undefined;
  }

  copy(screen) {
    let ret = UIBase$a.createElement("screenarea-x");

    ret.screen = screen;
    ret.ctx = this.ctx;

    ret.pos[0] = this.pos[0];
    ret.pos[1] = this.pos[1];

    ret.size[0] = this.size[0];
    ret.size[1] = this.size[1];

    for (let area of this.editors) {
      let cpy = area.copy();

      cpy.ctx = this.ctx;

      cpy.parentWidget = ret;
      ret.editors.push(cpy);
      ret.editormap[cpy.constructor.define().areaname] = cpy;

      if (area === this.area) {
        ret.area = cpy;
      }
    }

    //console.trace("RET.AREA", this.area, ret.area);

    ret.ctx = this.ctx;

    if (ret.area !== undefined) {
      ret.area.ctx = this.ctx;

      ret.area.pos = ret.pos;
      ret.area.size = ret.size;
      ret.area.owning_sarea = ret;
      ret.area.parentWidget = ret;

      ret.shadow.appendChild(ret.area);
      //ret.area.onadd();

      if (ret.area._init_done) {
        ret.area.push_ctx_active();
        ret.area.on_area_active();
        ret.area.pop_ctx_active();
      } else {
        ret.doOnce(() => {
          if (this.dead) {
            return;
          }
          ret._init();
          ret.area._init();
          ret.area.push_ctx_active();
          ret.area.on_area_active();
          ret.area.pop_ctx_active();
        });
      }
    }

    return ret;
  }

  snapToScreenSize() {
    let screen = this.getScreen();
    let co = new Vector2$6();
    let changed = 0;

    for (let v of this._verts) {
      co.load(v);

      v[0] = Math.min(Math.max(v[0], 0), screen.size[0]);
      v[1] = Math.min(Math.max(v[1], 0), screen.size[1]);

      if (co.vectorDistance(v) > 0.1) {
        changed = 1;
      }
    }

    if (changed) {
      this.loadFromVerts();
    }
  }

  /**
   *
   * Sets screen verts from pos/size
   * */
  loadFromPosSize() {
    if (this.floating && this._verts.length > 0) {
      let p = this.pos, s = this.size;

      this._verts[0].loadXY(p[0], p[1]);
      this._verts[1].loadXY(p[0], p[1] + s[1]);
      this._verts[2].loadXY(p[0] + s[0], p[1] + s[1]);
      this._verts[3].loadXY(p[0] + s[0], p[1]);

      for (let border of this._borders) {
        border.setCSS();
      }

      this.setCSS();
      return;
    }

    let screen = this.getScreen();
    if (!screen) return;

    for (let b of this._borders) {
      screen.freeBorder(b);
    }

    this.makeBorders(screen);
    this.setCSS();

    return this;
  }

  /**
   *
   * Sets pos/size from screen verts
   * */
  loadFromVerts() {
    if (this._verts.length == 0) {
      return;
    }

    let min = new Vector2$6([1e17, 1e17]);
    let max = new Vector2$6([-1e17, -1e17]);

    for (let v of this._verts) {
      min.min(v);
      max.max(v);
    }

    this.pos[0] = min[0];
    this.pos[1] = min[1];

    this.size[0] = max[0] - min[0];
    this.size[1] = max[1] - min[1];

    this.setCSS();
    return this;
  }

  on_resize(size, oldsize) {
    super.on_resize(size, oldsize);

    if (this.area !== undefined) {
      this.area.on_resize(size, oldsize);
    }
  }

  makeBorders(screen) {
    this._borders.length = 0;
    this._verts.length = 0;

    let p = this.pos, s = this.size;

    //s = snapi(new Vector2(s));

    let vs = [
      new Vector2$6([p[0], p[1]]),
      new Vector2$6([p[0], p[1] + s[1]]),
      new Vector2$6([p[0] + s[0], p[1] + s[1]]),
      new Vector2$6([p[0] + s[0], p[1]])
    ];

    let floating = this.floating;

    for (let i = 0; i < vs.length; i++) {
      vs[i] = snap(vs[i]);
      vs[i] = screen.getScreenVert(vs[i], i, floating);
      this._verts.push(vs[i]);
    }

    for (let i = 0; i < vs.length; i++) {
      let v1 = vs[i], v2 = vs[(i + 1)%vs.length];

      let b = screen.getScreenBorder(this, v1, v2, i);


      for (let j = 0; j < 2; j++) {
        let v = j ? b.v2 : b.v1;

        if (v.sareas.indexOf(this) < 0) {
          v.sareas.push(this);
        }
      }

      if (b.sareas.indexOf(this) < 0) {
        b.sareas.push(this);
      }

      this._borders.push(b);

      b.movable = screen.isBorderMovable(b);
    }

    return this;
  }

  setCSS() {
    this.style["position"] = UIBase$a.PositionKey;

    this.style["left"] = this.pos[0] + "px";
    this.style["top"] = this.pos[1] + "px";

    this.style["width"] = this.size[0] + "px";
    this.style["height"] = this.size[1] + "px";


    if (this.area !== undefined) {
      this.area.setCSS();
      //this.style["overflow"] = this.area.style["overflow"];

      //this.area.style["width"] = this.size[0] + "px";
      //this.area.style["height"] = this.size[1] + "px";
    }

    /*
    if (this.area) {
      let area = this.area;
      area.style["position"] = UIBase.PositionKey;

      area.style["width"] = this.size[0] + "px";
      area.style["height"] = this.size[1] + "px";
    }
    //*/
  }

  appendChild(child) {
    if (child instanceof Area$1) {
      child.ctx = this.ctx;
      child.pos = this.pos;
      child.size = this.size;

      if (this.editors.indexOf(child) < 0) {
        this.editors.push(child);
      }

      child.owning_sarea = undefined;
      if (this.area === undefined) {
        this.area = child;
      }
    }

    super.appendChild(child);

    if (child instanceof UIBase$2) {
      child.parentWidget = this;
      child.onadd();
    }
  }

  switch_editor(cls) {
    return this.switchEditor(cls);
  }

  switchEditor(cls) {
    let def = cls.define();
    let name = def.areaname;

    //areaclasses[name]
    if (!(name in this.editormap)) {
      this.editormap[name] = UIBase$a.createElement(def.tagname);
      this.editormap[name].ctx = this.ctx;
      this.editormap[name].parentWidget = this;
      this.editormap[name].owning_sarea = this;
      this.editormap[name].inactive = false;

      this.editors.push(this.editormap[name]);
    }

    //var finish = () => {
    if (this.area !== undefined) {
      //break direct pos/size references for old active area
      this.area.pos = new Vector2$6(this.area.pos);
      this.area.size = new Vector2$6(this.area.size);

      this.area.owning_sarea = undefined;
      this.area.inactive = true;
      this.area.push_ctx_active();
      this.area._init(); //check that init was called
      this.area.on_area_inactive();
      this.area.pop_ctx_active();

      this.area.remove();
    }

    this.area = this.editormap[name];

    this.area.inactive = false;
    this.area.parentWidget = this;

    //. . .and set references to pos/size
    this.area.pos = this.pos;
    this.area.size = this.size;
    this.area.owning_sarea = this;
    this.area.ctx = this.ctx;

    this.area.packflag |= this.packflag;

    this.shadow.appendChild(this.area);

    this.area.style["width"] = "100%";
    this.area.style["height"] = "100%";

    //propegate new size
    this.area.push_ctx_active();
    this.area._init(); //check that init was called
    this.area.on_resize(this.size, this.size);
    this.area.pop_ctx_active();

    this.area.push_ctx_active();
    this.area.on_area_active();
    this.area.pop_ctx_active();

    this.regenTabOrder();
    //}
  }

  _checkWrangler() {
    if (this.ctx)
      contextWrangler._checkWrangler(this.ctx);
  }

  update() {
    this._checkWrangler();

    super.update();

    //flag client controller implementation that
    //this area is active for its type
    if (this.area !== undefined) {
      this.area.owning_sarea = this;
      this.area.parentWidget = this;
      this.area.size = this.size;
      this.area.pos = this.pos;

      let screen = this.getScreen();
      let oldsize = [this.size[0], this.size[1]];

      let moved = screen ? screen.checkAreaConstraint(this, true) : 0;
      //*
      if (moved) {
        if (exports.DEBUG.areaConstraintSolver) {
          console.log("screen constraint solve", moved, this.area.minSize, this.area.maxSize, this.area.tagName, this.size);
        }

        screen.solveAreaConstraints();
        screen.regenBorders();
        this.on_resize(oldsize);
      }//*/

      this.area.push_ctx_active(true);
    }

    this._forEachChildWidget((n) => {
      n.update();
    });

    if (this.area !== undefined) {
      this.area.pop_ctx_active(true);
    }
  }

  appendChild(ch) {
    if (ch instanceof Area$1) {
      this.editors.push(ch);
      this.editormap[ch.constructor.define().areaname] = ch;
    } else {
      super.appendChild(ch);
    }
  }

  removeChild(ch) {
    if (ch instanceof Area$1) {
      ch.owining_sarea = undefined;
      ch.pos = undefined;
      ch.size = undefined;

      if (this.area === ch && this.editors.length > 1) {
        let i = (this.editors.indexOf(ch) + 1)%this.editors.length;
        this.switchEditor(this.editors[i].constructor);
      } else if (this.area === ch) {
        this.editors = [];
        this.editormap = {};
        this.area = undefined;

        ch.remove();
        return;
      }

      let areaname = ch.constructor.define().areaname;

      this.editors.remove(ch);
      delete this.editormap[areaname];

      ch.parentWidget = undefined;
    } else {
      return super.removeChild(ch);
    }
  }

  afterSTRUCT() {
    for (let area of this.editors) {
      area.pos = this.pos;
      area.size = this.size;
      area.owning_sarea = this;

      area.push_ctx_active();
      area._ctx = this.ctx;
      area.afterSTRUCT();
      area.pop_ctx_active();
    }
  }

  loadSTRUCT(reader) {
    reader(this);

    this.pos = new Vector2$6(this.pos);
    this.size = new Vector2$6(this.size);

    //find active editor

    let editors = [];

    for (let area of this.editors) {
      if (!area.constructor || !area.constructor.define || area.constructor === Area$1) {
        //failed to load this area
        continue;
      }

      /*
      if (area.constructor === undefined || area.constructor.define === undefined) {
        console.warn("Missing class for area", area, "maybe buggy loadSTRUCT()?");
        continue;
      }
      //*/

      let areaname = area.constructor.define().areaname;

      area.inactive = true;
      area.owning_sarea = undefined;
      this.editormap[areaname] = area;

      if (areaname === this.area) {
        this.area = area;
      }

      /*
      * originally inactive areas weren't supposed to have
      * a reference to their owning ScreenAreas.
      *
      * Unfortunately this will cause isDead() to return true,
      * which might lead to nasty problems.
      * */
      area.parentWidget = this;

      editors.push(area);
    }
    this.editors = editors;

    if (typeof this.area !== "object") {
      let area = this.editors[0];

      console.warn("Failed to find active area!", this.area);

      if (typeof area !== "object") {
        for (let k in areaclasses) {
          area = areaclasses[k].define().tagname;
          area = UIBase$a.createElement(area);
          let areaname = area.constructor.define().areaname;

          this.editors.push(area);
          this.editormap[areaname] = area;

          break;
        }
      }

      if (area) {
        this.area = area;
      }
    }

    if (this.area !== undefined) {
      this.area.style["width"] = "100%";
      this.area.style["height"] = "100%";
      this.area.owning_sarea = this;
      this.area.parentWidget = this;

      this.area.pos = this.pos;
      this.area.size = this.size;

      this.area.inactive = false;
      this.shadow.appendChild(this.area);

      let f = () => {
        if (this._isDead()) {
          return;
        }

        if (!this.ctx && this.parentNode) {
          console.log("waiting to start. . .");
          this.doOnce(f);
          return;
        }

        this.area.ctx = this.ctx;
        this.area._init(); //ensure init has been called already
        this.area.on_area_active();
        this.area.onadd();
      };

      this.doOnce(f);
    }

  }
}

ScreenArea.STRUCT = `
pathux.ScreenArea { 
  pos      : vec2;
  size     : vec2;
  type     : string;
  hidden   : bool;
  editors  : array(abstract(pathux.Area));
  area     : string | obj.area.constructor.define().areaname;
}
`;

nstructjs.register(ScreenArea, "pathux.ScreenArea");
UIBase$2.internalRegister(ScreenArea);

_setAreaClass(Area$1);

function setScreenClass$1(cls) {
  Screen$1 = cls;
}

var ScreenArea$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AreaFlags: AreaFlags,
  contextWrangler: contextWrangler,
  BorderMask: BorderMask,
  BorderSides: BorderSides,
  Area: Area$1,
  ScreenArea: ScreenArea,
  setScreenClass: setScreenClass$1,
  getAreaIntName: getAreaIntName,
  AreaTypes: AreaTypes,
  setAreaTypes: setAreaTypes,
  areaclasses: areaclasses,
  AreaWrangler: AreaWrangler
});

class ThemeEditor extends Container {
  constructor() {
    super();

    this.categoryMap = {};
  }

  static define() {
    return {
      tagname: "theme-editor-x",
      style  : "theme-editor"
    }
  }

  init() {
    super.init();

    this.build();
  }

  doFolder(catkey, obj, container = this) {
    let key = catkey.key;

    let panel = container.panel(key, undefined, undefined, catkey.help);
    panel.style["margin-left"] = "15px";

    let row = panel.row();
    let col1 = row.col();
    let col2 = row.col();


    let do_onchange = (key, k, obj) => {
      flagThemeUpdate();

      if (this.onchange) {
        this.onchange(key, k, obj);
      }

      this.ctx.screen.completeSetCSS();
      this.ctx.screen.completeUpdate();
    };

    let getpath = (path) => {
      let obj = theme;

      for (let i = 0; i < path.length; i++) {
        obj = obj[path[i]];
      }

      return obj;
    };

    let ok = false;
    let _i = 0;

    let dokey = (k, v, path) => {
      let col = _i%2 === 0 ? col1 : col2;

      if (k.toLowerCase().search("flag") >= 0) {
        return; //don't do flags
      }

      if (typeof v === "string") {
        let v2 = v.toLowerCase().trim();

        let iscolor = validateCSSColor$1(v2);

        if (iscolor) {
          let cw = col.colorbutton();
          ok = true;
          _i++;

          let color = css2color$1(v2);
          if (color.length < 3) {
            color = [color[0], color[1], color[2], 1.0];
          }

          try {
            cw.setRGBA(color);
          } catch (error) {
            console.warn("Failed to set color " + k, v2);
          }

          cw.onchange = () => {
            console.log("setting '" + k + "' to " + color2css$2(cw.rgba), key);
            getpath(path)[k] = color2css$2(cw.rgba);

            do_onchange(key, k);
          };
          cw.label = k;
        } else {
          col.label(k);

          let box = col.textbox();
          box.onchange = () => {
            getpath(path)[k] = box.text;
            do_onchange(key, k);
          };
          box.text = v;
        }
      } else if (typeof v === "number") {
        let slider = col.slider(undefined, k, v, 0, 256, 0.01, false);

        slider.baseUnit = slider.displayUnit = "none";

        ok = true;
        _i++;

        slider.onchange = () => {
          getpath(path)[k] = slider.value;

          do_onchange(key, k);
        };
      } else if (typeof v === "boolean") {
        let check = col.check(undefined, k);

        check.value = getpath(path)[k];

        check.onchange = () => {
          getpath(path)[k] = !!check.value;
          do_onchange(key, k);
        };
      } else if (typeof v === "object" && v instanceof CSSFont) {
        let panel2 = col.panel(k);
        ok = true;
        _i++;

        let textbox = (key) => {
          panel2.label(key);
          let tbox = panel2.textbox(undefined, v[key]);

          tbox.width = tbox.getDefault("width");

          tbox.onchange = function () {
            v[key] = this.text;
            do_onchange(key, k);
          };
        };

        textbox("font");
        textbox("variant");
        textbox("weight");
        textbox("style");

        let cw = panel2.colorbutton();
        cw.label = "color";
        cw.setRGBA(css2color$1(v.color));
        cw.onchange = () => {
          v.color = color2css$2(cw.rgba);
          do_onchange(key, k);
        };

        let slider = panel2.slider(undefined, "size", v.size);
        slider.onchange = () => {
          v.size = slider.value;
          do_onchange(key, k);
        };
        slider.setAttribute("min", 1);
        slider.setAttribute("max", 100);

        slider.baseUnit = slider.displayUnit = "none";

        panel2.closed = true;
      } else if (typeof v === "object") {
        let old = {
          panel, row, col1, col2
        };

        let path2 = path.slice(0, path.length);
        path2.push(k);

        panel = panel.panel(k);
        row = panel.row();
        col1 = row.col();
        col2 = row.col();
        for (let k2 in v) {
          let v2 = v[k2];

          dokey(k2, v2, path2);
        }

        panel = old.panel;
        row = old.row;
        col1 = old.col1;
        col2 = old.col2;
      }
    };

    for (let k in obj) {
      let v = obj[k];

      dokey(k, v, [key]);
    }

    if (!ok) {
      panel.remove();
    } else {
      panel.closed = true;
    }

  }

  build() {
    let categories = {};

    for (let k of Object.keys(theme)) {
      let catkey;

      if (k in this.categoryMap) {
        let cat = this.categoryMap[k];

        if (typeof cat === "string") {
          cat = {
            category: cat,
            help    : "",
            key     : k
          };
        }

        catkey = cat;
      } else {
        catkey = {category: k, help: '', key: k};
      }

      if (!catkey.key) {
        catkey.key = k;
      }

      if (!(catkey.category in categories)) {
        categories[catkey.category] = [];
      }

      categories[catkey.category].push(catkey);
    }

    function strcmp(a, b) {
      a = a.trim().toLowerCase();
      b = b.trim().toLowerCase();
      return a < b ? -1 : (a === b ? 0 : 1);
    }

    let keys = Object.keys(categories);
    keys.sort(strcmp);

    for (let k of keys) {
      let list = categories[k];
      list.sort((a, b) => strcmp(a.key, b.key));

      let panel = this;

      if (list.length > 1) {
        panel = this.panel(k);
      }

      for (let cat of list) {
        let k2 = cat.key;
        let v = theme[k2];

        if (typeof v === "object") {
          this.doFolder(cat, v, panel);
        }
      }

      if (list.length > 1) {
        panel.closed = true;
      }
    }
  }
}

UIBase$2.internalRegister(ThemeEditor);

const sliderDomAttributes = new Set([
  "min", "max", "integer", "displayUnit", "baseUnit", "labelOnTop",
  "radix", "step", "expRate", "stepIsRelative", "decimalPlaces",
  "slideSpeed"
]);

function updateSliderFromDom(dom, slider = dom) {
  let redraw = false;

  function getbool(attr, prop = attr) {
    if (!dom.hasAttribute(attr)) {
      return;
    }

    let v = dom.getAttribute(attr);
    let ret = v === null || v.toLowerCase() === "true" || v.toLowerCase === "yes";

    let old = slider[prop];
    if (old !== undefined && old !== ret) {
      redraw = true;
    }

    slider[prop] = ret;
    return ret;
  }

  function getfloat(attr, prop = attr) {
    if (!dom.hasAttribute(attr)) {
      return;
    }

    let v = dom.getAttribute(attr);
    let ret = parseFloat(v);

    let old = slider[prop];
    if (old !== undefined && Math.abs(old - v) < 0.00001) {
      redraw = true;
    }

    slider[prop] = ret;
    return ret;
  }

  function getint(attr, prop = attr) {
    if (!dom.hasAttribute(attr)) {
      return;
    }

    let v = ("" + dom.getAttribute(attr)).toLowerCase();
    let ret;

    if (v === "true") {
      ret = true;
    } else if (v === "false") {
      ret = false;
    } else {
      ret = parseInt(v);
    }

    if (isNaN(ret)) {
      console.error("bad value " + v);
      return 0.0;
    }

    let old = slider[prop];
    if (old !== undefined && Math.abs(old - v) < 0.00001) {
      redraw = true;
    }

    slider[prop] = ret;
    return ret;
  }

  if (dom.hasAttribute("min")) {
    slider.range = slider.range || [-1e17, 1e17];

    let r = slider.range[0];
    slider.range[0] = parseFloat(dom.getAttribute("min"));
    redraw = Math.abs(slider.range[0] - r) > 0.0001;
  }

  if (dom.hasAttribute("max")) {
    slider.range = slider.range || [-1e17, 1e17];

    let r = slider.range[1];
    slider.range[1] = parseFloat(dom.getAttribute("max"));
    redraw = redraw || Math.abs(slider.range[1] - r) > 0.0001;
  }

  if (dom.hasAttribute("displayUnit")) {
    let old = slider.displayUnit;
    slider.displayUnit = dom.getAttribute("displayUnit").trim();

    redraw = redraw || old !== slider.displayUnit;
  }

  getint("integer", "isInt");

  getint("radix");
  getint("decimalPlaces");

  getbool("labelOnTop");
  getbool("stepIsRelative");
  getfloat("expRate");
  getfloat("step");

  return redraw;
}

const SliderDefaults = {
  stepIsRelative: false,
  expRate       : 1.0 + 1.0/3.0,
  radix         : 10,
  decimalPlaces : 4,
  baseUnit      : "none",
  displayUnit   : "none",
  slideSpeed    : 1.0,
  step          : 0.1,
};

function NumberSliderBase(cls = UIBase$2, skip = new Set(), defaults = SliderDefaults) {
  skip = new Set(skip);

  return class NumberSliderBase extends cls {
    constructor() {
      super();

      for (let key of NumberConstraints) {
        if (skip.has(key)) {
          continue;
        }

        if (key in defaults) {
          this[key] = defaults[key];
        } else {
          this[key] = undefined;
        }
      }
    }

    loadConstraints(prop = undefined) {
      if (!this.hasAttribute("datapath")) {
        return;
      }

      if (!prop) {
        prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));
      }

      let loadAttr = (propkey, domkey = key, thiskey = key) => {
        if (this.hasAttribute(domkey)) {
          this[thiskey] = parseFloat(this.getAttribute(domkey));
        } else {
          this[thiskey] = prop[propkey];
        }
      };

      for (let key of NumberConstraints) {
        let thiskey = key, domkey = key;

        if (key === "range") { //handled later
          continue;
        }

        loadAttr(key, domkey, thiskey);
      }

      let range = prop.range;
      if (range && !this.hasAttribute("min")) {
        this.range[0] = range[0];
      } else if (this.hasAttribute("min")) {
        this.range[0] = parseFloat(this.getAttribute("min"));
      }

      if (range && !this.hasAttribute("max")) {
        this.range[1] = range[1];
      } else if (this.hasAttribute("max")) {
        this.range[1] = parseFloat(this.getAttribute("max"));
      }

      if (this.getAttribute("integer")) {
        let val = this.getAttribute("integer");
        val = ("" + val).toLowerCase();

        //handles anonymouse <numslider-x integer> case
        this.isInt = val === "null" || val === "true" || val === "yes" || val === "1";
      } else {
        this.isInt = prop instanceof IntProperty;
      }

      if (this.editAsBaseUnit === undefined) {
        if (prop.flag & PropFlags.EDIT_AS_BASE_UNIT) {
          this.editAsBaseUnit = true;
        } else {
          this.editAsBaseUnit = false;
        }
      }
    }
  }
}

//use .setAttribute("linear") to disable nonlinear sliding
class NumSlider extends NumberSliderBase(ValueButtonBase) {
  constructor() {
    super();

    this._highlight = undefined;
    this._last_label = undefined;

    this.mdown = false;
    this.ma = undefined;

    this.mpos = new Vector2();
    this.start_mpos = new Vector2();

    this._last_overarrow = false;

    this._name = "";
    this._value = 0.0;
    this.expRate = SliderDefaults.expRate;

    this.vertical = false;
    this._last_disabled = false;

    this.range = [-1e17, 1e17];
    this.isInt = false;
    this.editAsBaseUnit = undefined;

    this._redraw();
  }

  get value() {
    return this._value;
  }

  set value(val) {
    this.setValue(val);
  }

  /** Current name label.  If set to null label will
   * be pulled from the datapath api.*/
  get name() {
    return this.getAttribute("name") || this._name;
  }

  /** Current name label.  If set to null label will
   * be pulled from the datapath api.*/
  set name(name) {
    if (name === undefined || name === null) {
      this.removeAttribute("name");
    } else {
      this.setAttribute("name", name);
    }
  }

  static define() {
    return {
      tagname    : "numslider-x",
      style      : "numslider",
      parentStyle: "button"
    };
  }


  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));

    if (!prop) {
      return;
    }

    let name;

    if (this.hasAttribute("name")) {
      name = this.getAttribute("name");
    } else {
      name = "" + prop.uiname;
    }

    //lazily load constraints, since there's so much
    //accessing of DOM attributes
    let updateConstraints = false;

    if (name !== this._name) {
      this._name = name;
      this.setCSS();
      updateConstraints = true;
    }

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (val !== this._value) {
      updateConstraints = true;
      /* Note that super.updateDataPath will update .value for us*/
    }

    if (updateConstraints) {
      this.loadConstraints(prop);
    }

    super.updateDataPath();
  }

  update() {
    if (!!this._last_disabled !== !!this.disabled) {
      this._last_disabled = !!this.disabled;
      this._redraw();
      this.setCSS();
    }

    super.update(); //calls this.updateDataPath

    updateSliderFromDom(this);
  }

  swapWithTextbox() {
    let tbox = UIBase$2.createElement("textbox-x");

    tbox.ctx = this.ctx;
    tbox._init();

    tbox.decimalPlaces = this.decimalPlaces;
    tbox.isInt = this.isInt;
    tbox.editAsBaseUnit = this.editAsBaseUnit;

    if (this.isInt && this.radix != 10) {
      let text = this.value.toString(this.radix);
      if (this.radix === 2)
        text = "0b" + text;
      else if (this.radix === 16)
        text += "h";

      tbox.text = text;
    } else {
      tbox.text = buildString(this.value, this.baseUnit, this.decimalPlaces, this.displayUnit);
    }

    this.parentNode.insertBefore(tbox, this);
    //this.remove();
    this.hidden = true;
    //this.dom.hidden = true;

    let finish = (ok) => {
      tbox.remove();
      this.hidden = false;

      if (ok) {
        let val = tbox.text.trim();

        if (this.isInt && this.radix !== 10) {
          val = parseInt(val);
        } else {
          let displayUnit = this.editAsBaseUnit ? undefined : this.displayUnit;

          val = parseValue(val, this.baseUnit, displayUnit);
        }

        if (isNaN(val)) {
          console.log("Text input error", val, tbox.text.trim(), this.isInt);
          this.flash(ErrorColors.ERROR);
        } else {
          this.setValue(val);

          if (this.onchange) {
            this.onchange(this);
          }
        }
      }
    };

    tbox.onend = finish;
    tbox.focus();
    tbox.select();

    //this.shadow.appendChild(tbox);
    return;
  }

  bindEvents() {
    let dir = this.range && this.range[0] > this.range[1] ? -1 : 1;

    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case keymap["Left"]:
        case keymap["Down"]:
          this.setValue(this.value - dir*5*this.step);
          break;
        case keymap["Up"]:
        case keymap["Right"]:
          this.setValue(this.value + dir*5*this.step);
          break;
      }
    });

    let onmousedown = (e) => {
      e.preventDefault();

      if (this.disabled) {
        this.mdown = false;
        e.stopPropagation();

        return;
      }

      if (e.button) {
        return;
      }

      this.mdown = true;

      if (e.shiftKey) {
        e.preventDefault();
        e.stopPropagation();

        this.swapWithTextbox();
      } else if (this.overArrow(e.x, e.y)) {
        this._on_click(e);
      } else {
        this.dragStart(e);
        e.stopPropagation();
      }
    };

    this._on_click = (e) => {
      this.setMpos(e);

      if (this.disabled) {
        e.preventDefault();
        e.stopPropagation();

        return;
      }

      let step;

      if (step = this.overArrow(e.x, e.y)) {
        if (e.shiftKey) {
          step *= 0.1;
        }

        this.setValue(this.value + step);
      }
    };

    this.addEventListener("mousemove", (e) => {
      this.setMpos(e);

      if (this.mdown && !this._modaldata && this.mpos.vectorDistance(this.start_mpos) > 13) {
        this.dragStart(e);
      }
    });

    this.addEventListener("dblclick", (e) => {
      this.setMpos(e);

      this.mdown = false;

      if (this.disabled || this.overArrow(e.x, e.y)) {
        e.preventDefault();
        e.stopPropagation();

        return;
      }

      e.preventDefault();
      e.stopPropagation();

      this.swapWithTextbox();
    });

    this.addEventListener("mousedown", (e) => {
      this.setMpos(e);

      if (this.disabled) return;
      onmousedown(e);
    }, {capture: true});

    this.addEventListener("mouseup", (e) => {
      this.mdown = false;
    });
    /*
    this.addEventListener("touchstart", (e) => {
      if (this.disabled) return;

      e.x = e.touches[0].screenX;
      e.y = e.touches[0].screenY;

      this.dragStart(e);

      e.preventDefault();
      e.stopPropagation();
    }, {passive : false});
    //*/

    //this.addEventListener("mouseup", (e) => {
    //  return onmouseup(e);
    //});

    this.addEventListener("mouseover", (e) => {
      this.setMpos(e);
      if (this.disabled) return;

      if (!this._highlight) {
        this._highlight = true;
        this._repos_canvas();
        this._redraw();
      }
    });

    this.addEventListener("blur", (e) => {
      this._highlight = false;
      this.mdown = false;
    });

    this.addEventListener("mouseout", (e) => {
      this.setMpos(e);
      if (this.disabled) return;

      this._highlight = false;

      this.dom._background = this.getDefault("background-color");
      this._repos_canvas();
      this._redraw();
    });
  }

  overArrow(x, y) {
    let r = this.getBoundingClientRect();
    let rwidth, rx;

    if (this.vertical) {
      rwidth = r.height;
      rx = r.y;
      x = y;
    } else {
      rwidth = r.width;
      rx = r.x;
    }

    x -= rx;
    let sz = this._getArrowSize();

    let szmargin = sz + exports.numSliderArrowLimit;

    let step = this.step || 0.01;

    if (this.isInt) {
      step = Math.max(step, 1);
    }

    if (isNaN(step)) {
      console.error("NaN step size", "step:", this.step, "numslider:", this._id);
      this.flash("red");
      step = this.isInt ? 1 : 0.1;
    }

    if (x < szmargin) {
      return -step;
    } else if (x > rwidth - szmargin) {
      return step;
    }

    return 0;
  }

  doRange() {
    console.warn("Deprecated: NumSlider.prototype.doRange, use loadConstraints instead!");
    this.loadConstraints();
  }

  setValue(value, fire_onchange = true, setDataPath = true, checkConstraints = true) {
    this._value = value;

    if (this.hasAttribute("integer")) {
      this.isInt = true;
    }

    if (this.isInt) {
      this._value = Math.floor(this._value);
    }

    if (checkConstraints) {
      this.loadConstraints();
    }

    if (setDataPath && this.ctx && this.hasAttribute("datapath")) {
      this.setPathValue(this.ctx, this.getAttribute("datapath"), this._value);
    }

    if (fire_onchange && this.onchange) {
      this.onchange(this.value);
    }

    this._redraw();
  }

  setMpos(e) {
    this.mpos[0] = e.x;
    this.mpos[1] = e.y;

    if (!this.mdown) {
      this.start_mpos[0] = e.x;
      this.start_mpos[1] = e.y;
    }

    let over = this.overArrow(e.x, e.y);

    if (over !== this._last_overarrow) {
      this._last_overarrow = over;
      this._redraw();
    }
  }

  dragStart(e) {
    this.mdown = false;

    if (this.disabled) return;

    if (this.modalRunning) {
      console.log("modal already running for numslider", this);
      return;
    }

    this.last_time = time_ms();

    let last_background = this.dom._background;
    let cancel;

    this.ma = new MovingAvg(eventWasTouch(e) ? 8 : 2);

    let startvalue = this.value;
    let value = startvalue;

    let startx = this.vertical ? e.y : e.x, starty = this.vertical ? e.x : e.y;
    let sumdelta = 0;

    this.dom._background = this.getDefault("BoxDepressed");
    let fire = () => {
      if (this.onchange) {
        this.onchange(this);
      }
    };

    let handlers = {
      on_keydown: (e) => {
        switch (e.keyCode) {
          case 27: //escape key
            cancel(true);
          case 13: //enter key
            cancel(false);
            break;
        }

        e.preventDefault();
        e.stopPropagation();
      },

      on_mousemove: (e) => {
        if (this.disabled) return;

        e.preventDefault();
        e.stopPropagation();

        let x = this.ma.add(this.vertical ? e.y : e.x);
        let dx = x - startx;
        startx = x;

        if (time_ms() - this.last_time < 35) {
          return;
        }
        this.last_time = time_ms();

        if (e.shiftKey) {
          dx *= 0.1;
        }

        dx *= this.vertical ? -1 : 1;

        sumdelta += Math.abs(dx);

        value += dx*this.step*0.1*this.slideSpeed;

        let dvalue = value - startvalue;
        let dsign = Math.sign(dvalue);

        let expRate = this.expRate;

        //if (eventWasTouch(e)) {
        //  expRate = (1 + expRate)*0.5;
        //}

        if (!this.hasAttribute("linear")) {
          dvalue = Math.pow(Math.abs(dvalue), expRate)*dsign;
        }

        this.value = startvalue + dvalue;

        /*
        if (e.shiftKey) {
          dx *= 0.1;
          this.value = startvalue2 + dx*0.1*this.step*this.slideSpeed;
          startvalue3 = this.value;
        } else {
          startvalue2 = this.value;
          this.value = startvalue3 + dx*0.1*this.step*this.slideSpeed;
        }*/

        this.updateWidth();
        this._redraw();
        fire();
      },

      on_mouseup: (e) => {
        this.setMpos(e);

        this.undoBreakPoint();
        cancel(false);

        e.preventDefault();
        e.stopPropagation();
      },

      on_mouseout: (e) => {
        last_background = this.getDefault("background-color");

        e.preventDefault();
        e.stopPropagation();
      },

      on_mouseover: (e) => {
        last_background = this.getDefault("BoxHighlight");

        e.preventDefault();
        e.stopPropagation();
      },

      on_mousedown: (e) => {
        this.popModal();
      },
    };

    //events.pushModal(this.getScreen(), handlers);
    this.pushModal(handlers);

    cancel = (restore_value) => {
      if (restore_value) {
        this.value = startvalue;
        this.updateWidth();
        fire();
      }

      this.dom._background = last_background; //ui_base.getDefault("background-color");
      this._redraw();

      this.popModal();
    };

    /*
    cancel = (restore_value) => {
      if (restore_value) {
        this.value = startvalue;
        this.updateWidth();
        fire();
      }

      this.dom._background = last_background; //ui_base.getDefault("background-color");
      this._redraw();

      console.trace("end");

      window.removeEventListener("keydown", keydown, true);
      window.removeEventListener("mousemove", mousemove, {captured : true, passive : false});

      window.removeEventListener("touchend", touchend, true);
      window.removeEventListener("touchmove", touchmove, {captured : true, passive : false});
      window.removeEventListener("touchcancel", touchcancel, true);
      window.removeEventListener("mouseup", mouseup, true);

      this.removeEventListener("mouseover", mouseover, true);
      this.removeEventListener("mouseout", mouseout, true);
    }

    window.addEventListener("keydown", keydown, true);
    window.addEventListener("mousemove", mousemove, true);
    window.addEventListener("touchend", touchend, true);
    window.addEventListener("touchmove", touchmove, {captured : true, passive : false});
    window.addEventListener("touchcancel", touchcancel, true);
    window.addEventListener("mouseup", mouseup, true);

    this.addEventListener("mouseover", mouseover, true);
    this.addEventListener("mouseout", mouseout, true);
    //*/
  }

  setCSS() {
    //do not call parent class implementation
    let dpi = this.getDPI();

    let ts = this.getDefault("DefaultText").size*UIBase$2.getDPI();

    let dd = this.isInt ? 5 : this.decimalPlaces + 8;

    let label = this._genLabel();

    let tw = measureText(this, label, {
      size: ts,
      font: this.getDefault("DefaultText")
    }).width/dpi;

    tw = Math.max(tw + this._getArrowSize()*0, this.getDefault("width"));

    tw += ts;
    tw = ~~tw;

    //tw = Math.max(tw, w);
    if (this.vertical) {
      this.style["width"] = this.dom.style["width"] = this.getDefault("height") + "px";

      this.style["height"] = tw + "px";
      this.dom.style["height"] = tw + "px";
    } else {
      this.style["height"] = this.dom.style["height"] = this.getDefault("height") + "px";

      this.style["width"] = tw + "px";
      this.dom.style["width"] = tw + "px";
    }

    this._repos_canvas();
    this._redraw();
  }

  updateName(force) {
    if (!this.hasAttribute("name")) {
      return;
    }

    let name = this.getAttribute("name");

    if (force || name !== this._name) {
      this._name = name;
      this.setCSS();
    }

    let label = this._genLabel();
    if (label !== this._last_label) {
      this._last_label = label;
      this.setCSS();
    }
  }

  _genLabel() {
    let val = this.value;
    let text;

    if (val === undefined) {
      text = "error";
    } else {
      val = val === undefined ? 0.0 : val;

      if (this.isInt) {
        val = Math.floor(val);
      }

      val = buildString(val, this.baseUnit, this.decimalPlaces, this.displayUnit);

      text = val;
      if (this._name) {
        text = this._name + ": " + text;
      }
    }

    return text;
  }

  _redraw() {
    let g = this.g;
    let canvas = this.dom;

    let dpi = this.getDPI();
    let disabled = this.disabled;

    let r = this.getDefault("border-radius");
    if (this.isInt) {
      r *= 0.25;
    }

    let boxbg = this.getDefault(this._highlight ? "BoxHighlight" : "background-color");

    drawRoundBox(this, this.dom, this.g, undefined, undefined,
      r, "fill", disabled ? this.getDefault("DisabledBG") : boxbg);
    drawRoundBox(this, this.dom, this.g, undefined, undefined,
      r, "stroke", disabled ? this.getDefault("DisabledBG") : this.getDefault("border-color"));

    r *= dpi;
    let pad = this.getDefault("padding");
    let ts = this.getDefault("DefaultText").size;

    let text = this._genLabel();

    let tw = measureText(this, text, this.dom, this.g).width;
    let cx = ts + this._getArrowSize();
    let cy = this.dom.height/2;

    this.dom.font = undefined;

    g.save();

    let th = Math.PI*0.5;

    if (this.vertical) {
      g.rotate(th);

      drawText(this, cx, -ts*0.5, text, {
        canvas: this.dom,
        g     : this.g,
        size  : ts
      });
      g.restore();
    } else {
      drawText(this, cx, cy + ts/2, text, {
        canvas: this.dom,
        g     : this.g,
        size  : ts
      });
    }

    //}

    let arrowcolor = this.getDefault("arrow-color") || "33%";
    arrowcolor = arrowcolor.trim();

    if (arrowcolor.endsWith("%")) {
      arrowcolor = arrowcolor.slice(0, arrowcolor.length - 1).trim();
      let perc = parseFloat(arrowcolor)/100.0;
      let c = css2color$1(this.getDefault("arrow-color"));

      let f = 1.0 - (c[0] + c[1] + c[2])*perc;

      f = ~~(f*255);
      arrowcolor = `rgba(${f},${f},${f},0.95)`;

    }

    arrowcolor = css2color$1(arrowcolor);
    let higharrow = css2color$1(this.getDefault("BoxHighlight"));
    higharrow.interp(arrowcolor, 0.5);

    arrowcolor = color2css$2(arrowcolor);
    higharrow = color2css$2(higharrow);

    let over = this._highlight ? this.overArrow(this.mpos[0], this.mpos[1]) : 0;

    let d = 7, w = canvas.width, h = canvas.height;
    let sz = this._getArrowSize();

    if (this.vertical) {
      g.beginPath();
      g.moveTo(w*0.5, d);
      g.lineTo(w*0.5 + sz*0.5, d + sz);
      g.lineTo(w*0.5 - sz*0.5, d + sz);

      g.fillStyle = over < 0 ? higharrow : arrowcolor;
      g.fill();

      g.beginPath();
      g.moveTo(w*0.5, h - d);
      g.lineTo(w*0.5 + sz*0.5, h - sz - d);
      g.lineTo(w*0.5 - sz*0.5, h - sz - d);

      g.fillStyle = over > 0 ? higharrow : arrowcolor;
      g.fill();
    } else {
      g.beginPath();
      g.moveTo(d, h*0.5);
      g.lineTo(d + sz, h*0.5 + sz*0.5);
      g.lineTo(d + sz, h*0.5 - sz*0.5);

      g.fillStyle = over < 0 ? higharrow : arrowcolor;
      g.fill();

      g.beginPath();
      g.moveTo(w - d, h*0.5);
      g.lineTo(w - sz - d, h*0.5 + sz*0.5);
      g.lineTo(w - sz - d, h*0.5 - sz*0.5);

      g.fillStyle = over > 0 ? higharrow : arrowcolor;
      g.fill();
    }

    g.fill();
  }

  _getArrowSize() {
    return UIBase$2.getDPI()*10;
  }
}

UIBase$2.internalRegister(NumSlider);


class NumSliderSimpleBase extends NumberSliderBase(UIBase$2) {
  constructor() {
    super();

    this.baseUnit = undefined;
    this.displayUnit = undefined;
    this.editAsBaseUnit = undefined;

    this.canvas = document.createElement("canvas");
    this.g = this.canvas.getContext("2d");

    this.canvas.style["width"] = this.getDefault("width") + "px";
    this.canvas.style["height"] = this.getDefault("height") + "px";
    this.canvas.style["pointer-events"] = "none";

    this.highlight = false;
    this.isInt = false;

    this.shadow.appendChild(this.canvas);
    this.range = [0, 1];

    /** if not undefined defines subrange of visible slider */
    this.uiRange = undefined;

    this.step = 0.1;
    this._value = 0.5;
    this.ma = undefined;
    this._focus = false;

    this.modal = undefined;

    this._last_slider_key = '';
  }

  get value() {
    return this._value;
  }

  set value(val) {
    this.setValue(val);
  }

  static define() {
    return {
      tagname    : "numslider-simple-base-x",
      style      : "numslider_simple",
      parentStyle: "button"
    }
  }

  setValue(val, fire_onchange = true, setDataPath = true) {
    val = Math.min(Math.max(val, this.range[0]), this.range[1]);

    if (this.isInt) {
      val = Math.floor(val);
    }

    if (this._value !== val) {
      this._value = val;
      this._redraw();

      if (this.onchange && fire_onchange) {
        this.onchange(val);
      }

      if (setDataPath && this.getAttribute("datapath")) {
        let path = this.getAttribute("datapath");
        this.setPathValue(this.ctx, path, this._value);
      }
    }
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let path = this.getAttribute("datapath");

    if (!path || path === "null" || path === "undefined") {
      return;
    }

    let val = this.getPathValue(this.ctx, path);

    if (this.isInt) {
      val = Math.floor(val);
    }

    if (val !== this._value) {
      let prop = this.getPathMeta(this.ctx, path);
      if (!prop) {
        return;
      }

      this.loadConstraints(prop);
      this.setValue(val, true, false);
    }
  }

  _setFromMouse(e) {
    let rect = this.getClientRects()[0];
    if (rect === undefined) {
      return;
    }

    let x = e.x - rect.left;
    let dpi = UIBase$2.getDPI();
    let co = this._getButtonPos();

    let val = this._invertButtonX(x*dpi);
    this.value = val;
  }

  _startModal(e) {
    if (this.disabled) {
      return;
    }

    if (e !== undefined) {
      this._setFromMouse(e);
    }
    let dom = window;
    let evtargs = {capture: false};

    if (this.modal) {
      console.warn("Double call to _startModal!");
      return;
    }

    this.ma = new MovingAvg(eventWasTouch(e) ? 4 : 2);
    let handlers;

    let end = () => {
      if (handlers === undefined) {
        return;
      }

      this.popModal();
      handlers = undefined;
    };

    handlers = {
      mousemove: (e) => {
        let x = e.x, y = e.y;

        x = this.ma.add(x);

        let e2 = new MouseEvent(e, {
          x, y
        });
        this._setFromMouse(e);
      },

      mouseover : (e) => {
      },
      mouseout  : (e) => {
      },
      mouseleave: (e) => {
      },
      mouseenter: (e) => {
      },
      blur      : (e) => {
      },
      focus     : (e) => {
      },

      mouseup: (e) => {
        this.undoBreakPoint();
        end();
      },

      keydown: (e) => {
        switch (e.keyCode) {
          case keymap["Enter"]:
          case keymap["Space"]:
          case keymap["Escape"]:
            end();
        }
      }
    };

    function makefunc(f) {
      return (e) => {
        e.stopPropagation();
        e.preventDefault();

        return f(e);
      }
    }

    for (let k in handlers) {
      handlers[k] = makefunc(handlers[k]);
    }

    this.pushModal(handlers);
  }

  init() {
    super.init();

    if (!this.hasAttribute("tab-index")) {
      this.setAttribute("tab-index", 0);
    }

    this.updateSize();

    this.addEventListener("keydown", (e) => {
      let dt = this.range[1] > this.range[0] ? 1 : -1;

      switch (e.keyCode) {
        case keymap["Left"]:
        case keymap["Right"]:
          let fac = this.step;

          if (e.shiftKey) {
            fac *= 0.1;
          }

          if (this.isInt) {
            fac = Math.max(fac, 1);
          }

          this.value += e.keyCode === keymap["Left"] ? -dt*fac : dt*fac;

          break;
      }
    });

    this.addEventListener("focusin", () => {
      if (this.disabled) return;

      this._focus = 1;
      this._redraw();
      this.focus();
    });

    this.addEventListener("mousedown", (e) => {
      if (this.disabled) {
        return;
      }

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();
      this._startModal(e);
    });

    this.addEventListener("mousein", (e) => {
      this.setHighlight(e);
      this._redraw();
    });
    this.addEventListener("mouseout", (e) => {
      this.highlight = false;
      this._redraw();
    });
    this.addEventListener("mouseover", (e) => {
      this.setHighlight(e);
      this._redraw();
    });
    this.addEventListener("mousemove", (e) => {
      this.setHighlight(e);
      this._redraw();
    });
    this.addEventListener("mouseleave", (e) => {
      this.highlight = false;
      this._redraw();
    });
    this.addEventListener("blur", (e) => {
      this._focus = 0;
      this.highlight = false;
      this._redraw();
    });

    this.setCSS();
  }

  setHighlight(e) {
    this.highlight = this.isOverButton(e) ? 2 : 1;
  }

  _redraw() {
    let g = this.g, canvas = this.canvas;
    let w = canvas.width, h = canvas.height;
    let dpi = UIBase$2.getDPI();

    let color = this.getDefault("background-color");
    let sh = ~~(this.getDefault("SlideHeight")*dpi + 0.5);

    g.clearRect(0, 0, canvas.width, canvas.height);

    g.fillStyle = color;

    let y = (h - sh)*0.5;

    let r = this.getDefault("border-radius");

    g.translate(0, y);
    drawRoundBox(this, this.canvas, g, w, sh, r, "fill", color, undefined, true);

    let bcolor = this.getDefault('border-color');
    drawRoundBox(this, this.canvas, g, w, sh, r, "stroke", bcolor, undefined, true);
    g.translate(0, -y);

    if (this.highlight === 1) {
      color = this.getDefault("BoxHighlight");
    } else {
      color = this.getDefault("border-color");
    }

    g.strokeStyle = color;
    g.stroke();

    let co = this._getButtonPos();

    g.beginPath();

    if (this.highlight === 2) {
      color = this.getDefault("BoxHighlight");
    } else {
      color = this.getDefault("border-color");
    }

    g.arc(co[0], co[1], Math.abs(co[2]), -Math.PI, Math.PI);
    g.fill();

    g.strokeStyle = color;
    g.stroke();

    g.beginPath();
    g.setLineDash([4, 4]);

    if (this._focus) {
      g.strokeStyle = this.getDefault("BoxHighlight");
      g.arc(co[0], co[1], co[2] - 4, -Math.PI, Math.PI);
      g.stroke();
    }

    g.setLineDash([]);
  }

  isOverButton(e) {
    let x = e.x, y = e.y;
    let rect = this.getClientRects()[0];

    if (!rect) {
      return false;
    }

    x -= rect.left;
    y -= rect.top;

    let co = this._getButtonPos();

    let dpi = UIBase$2.getDPI();
    let dv = new Vector2([co[0]/dpi - x, co[1]/dpi - y]);
    let dis = dv.vectorLength();

    return dis < co[2]/dpi;
  }

  _invertButtonX(x) {
    let w = this.canvas.width;
    let dpi = UIBase$2.getDPI();
    let sh = ~~(this.getDefault("SlideHeight")*dpi + 0.5);
    let boxw = this.canvas.height - 4;
    let w2 = w - boxw;

    let range = this.uiRange || this.range;

    x = (x - boxw*0.5)/w2;
    x = x*(range[1] - range[0]) + range[0];

    return x;
  }

  _getButtonPos() {
    let w = this.canvas.width;
    let dpi = UIBase$2.getDPI();
    let sh = ~~(this.getDefault("SlideHeight")*dpi + 0.5);
    let x = this._value;

    let range = this.uiRange || this.range;

    x = (x - range[0])/(range[1] - range[0]);

    let boxw = this.canvas.height - 4;
    let w2 = w - boxw;

    x = x*w2 + boxw*0.5;

    return [x, boxw*0.5, boxw*0.5];
  }

  setCSS() {
    //UIBase.setCSS does annoying thing with background-color
    //super.setCSS();

    this.canvas.style["width"] = "min-contents";
    this.canvas.style["min-width"] = this.getDefault("width") + "px";
    this.canvas.style["height"] = this.getDefault("height") + "px";

    this.canvas.height = this.getDefault("height")*UIBase$2.getDPI();

    this.style["min-width"] = this.getDefault("width") + "px";
    this._redraw();
  }

  updateSize() {
    if (this.canvas === undefined) {
      return;
    }

    let rect = this.getClientRects()[0];

    if (rect === undefined) {
      return;
    }

    let dpi = UIBase$2.getDPI();
    let w = ~~(rect.width*dpi), h = ~~(rect.height*dpi);
    let canvas = this.canvas;

    if (w !== canvas.width || h !== canvas.height) {
      this.canvas.width = w;
      this.canvas.height = h;

      this.setCSS();
      this._redraw();
    }
  }

  _ondestroy() {
    if (this.modalRunning) {
      this.popModal();
    }
  }

  update() {
    super.update();

    let key = this.getDefault("width") + this.getDefault("height") + this.getDefault("SlideHeight");
    if (key !== this._last_slider_key) {
      this._last_slider_key = key;

      this.flushUpdate();
      this.setCSS();
      this._redraw();
    }

    if (this.getAttribute("tab-index") !== this.tabIndex) {
      this.tabIndex = this.getAttribute("tab-index");
    }

    this.updateSize();
    this.updateDataPath();
    updateSliderFromDom(this);
  }
}

UIBase$2.internalRegister(NumSliderSimpleBase);

class SliderWithTextbox extends ColumnFrame {
  constructor() {
    super();

    this._value = 0;
    this._name = undefined;
    this._lock_textbox = false;
    this._labelOnTop = undefined;

    this._last_label_on_top = undefined;

    this.container = this;

    this.textbox = UIBase$2.createElement("textbox-x");
    this.textbox.width = 55;
    this._numslider = undefined;

    this.textbox.overrideDefault("width", this.getDefault("TextBoxWidth"));
    this.textbox.setAttribute("class", "numslider_simple_textbox");

    this._last_value = undefined;
  }

  /**
   * whether to put label on top or to the left of sliders
   *
   * If undefined value will be either this.getAtttribute("labelOnTop"),
   * if "labelOnTop" attribute exists, or it will be this.getDefault("labelOnTop")
   * (theme default)
   **/
  get labelOnTop() {
    let ret = this._labelOnTop;

    if (ret === undefined && this.hasAttribute("labelOnTop")) {
      let val = this.getAttribute("labelOnTop");
      if (typeof val === "string") {
        val = val.toLowerCase();
        ret = val === "true" || val === "yes";
      } else {
        ret = !!val;
      }
    }

    if (ret === undefined) {
      ret = this.getDefault("labelOnTop");
    }

    return !!ret;
  }

  set labelOnTop(v) {
    this._labelOnTop = v;
  }

  get numslider() {
    return this._numslider;
  }

  //child classes set this in their constructors
  set numslider(v) {
    this._numslider = v;
    this.textbox.range = this._numslider.range;
  }

  get editAsBaseUnit() {
    return this.numslider.editAsBaseUnit;
  }

  set editAsBaseUnit(v) {
    this.numslider.editAsBaseUnit = v;
  }

  get range() {
    return this.numslider.range;
  }

  set range(v) {
    this.numslider.range = v;
  }

  get step() {
    return this.numslider.step;
  }

  set step(v) {
    this.numslider.step = v;
  }

  get expRate() {
    return this.numslider.expRate;
  }

  set expRate(v) {
    this.numslider.expRate = v;
  }

  get decimalPlaces() {
    return this.numslider.decimalPlaces;
  }

  set decimalPlaces(v) {
    this.numslider.decimalPlaces = v;
  }

  get isInt() {
    return this.numslider.isInt;
  }

  set isInt(v) {
    this.numslider.isInt = v;
  }

  get slideSpeed() {
    return this.numslider.slideSpeed;
  }

  set slideSpeed(v) {
    this.numslider.slideSpeed = v;
  }

  get radix() {
    return this.numslider.radix;
  }

  set radix(v) {
    this.numslider.radix = v;
  }

  get stepIsRelative() {
    return this.numslider.stepIsRelative;
  }

  set stepIsRelative(v) {
    this.numslider.stepIsRelative = v;
  }

  get displayUnit() {
    return this.textbox.displayUnit;
  }

  set displayUnit(val) {
    let update = val !== this.displayUnit;

    this.numslider.displayUnit = this.textbox.displayUnit = val;

    if (update) {
      //this.numslider._redraw();
      this.updateTextBox();
    }
  }

  get baseUnit() {
    return this.textbox.baseUnit;
  }

  set baseUnit(val) {
    let update = val !== this.baseUnit;

    this.numslider.baseUnit = this.textbox.baseUnit = val;

    if (update) {
      //this.slider._redraw();
      this.updateTextBox();
    }
  }

  get realTimeTextBox() {
    let ret = this.getAttribute("realtime");

    if (!ret) {
      return false;
    }

    ret = ret.toLowerCase().trim();

    return ret === 'true' || ret === 'on' || ret === 'yes';
  }

  set realTimeTextBox(val) {
    this.setAttribute("realtime", val ? "true" : "false");
  }

  get value() {
    return this._value;
  }

  set value(val) {
    this.setValue(val);
  }

  init() {
    super.init();

    this.rebuild();
    window.setTimeout(() => this.updateTextBox(), 500);
  }

  rebuild() {
    this._last_label_on_top = this.labelOnTop;

    this.container.clear();

    if (!this.labelOnTop) {
      this.container = this.row();
    } else {
      this.container = this;
    }

    if (this.hasAttribute("name")) {
      this._name = this.hasAttribute("name");
    } else {
      this._name = "slider";
    }


    this.l = this.container.label(this._name);
    this.l.overrideClass("numslider_textbox");
    this.l.font = "TitleText";
    this.l.style["display"] = "float";
    this.l.style["position"] = "relative";

    let strip = this.container.row();
    //strip.style['justify-content'] = 'space-between';
    strip.add(this.numslider);

    let path = this.hasAttribute("datapath") ? this.getAttribute("datapath") : undefined;

    let textbox = this.textbox;
    this.textbox.overrideDefault("width", this.getDefault("TextBoxWidth"));

    let apply_textbox = () => {
      let text = textbox.text;

      if (!isNumber(text)) {
        textbox.flash("red");
        return;
      } else {
        textbox.flash("green");

        let displayUnit = this.editAsBaseUnit ? undefined : this.displayUnit;

        let f = parseValue(text, this.baseUnit, displayUnit);

        if (isNaN(f)) {
          this.flash("red");
          return;
        }

        if (this.isInt) {
          f = Math.floor(f);
        }

        this._lock_textbox = 1;
        this.setValue(f);
        this._lock_textbox = 0;

      }
    };

    if (this.realTimeTextBox) {
      textbox.onchange = apply_textbox;
    }

    textbox.onend = apply_textbox;

    textbox.ctx = this.ctx;
    textbox.packflag |= this.inherit_packflag;
    textbox.overrideDefault("width", this.getDefault("TextBoxWidth"));

    textbox.style["height"] = (this.getDefault("height") - 2) + "px";
    textbox._init();

    strip.add(textbox);

    textbox.setCSS();
    this.linkTextBox();

    let in_onchange = 0;

    this.numslider.onchange = (val) => {
      this._value = this.numslider.value;
      this.updateTextBox();

      if (in_onchange) {
        return;
      }

      if (this.onchange !== undefined) {
        in_onchange++;
        try {
          if (this.onchange) {
            this.onchange(this);
          }
        } catch (error) {
          print_stack$1(error);
        }
      }

      in_onchange--;
    };
  }

  updateTextBox() {
    if (!this._init_done) {
      return;
    }

    if (this._lock_textbox > 0)
      return;

    this.textbox.text = this.formatNumber(this._value);
    this.textbox.update();

    updateSliderFromDom(this, this.numslider);
  }

  linkTextBox() {
    this.updateTextBox();

    let onchange = this.numslider.onchange;
    this.numslider.onchange = (e) => {
      this._value = e.value;
      this.updateTextBox();

      onchange(e);
    };
  }

  setValue(val, fire_onchange = true) {
    this._value = val;
    this.numslider.setValue(val, fire_onchange);
    this.updateTextBox();
  }

  updateName() {
    let name = this.getAttribute("name");

    if (!name && this.hasAttribute("datapath")) {
      let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));

      if (prop) {
        name = prop.uiname;
      }
    }

    if (!name) {
      name = "[error]";
    }

    if (name !== this._name) {
      this._name = name;
      this.l.text = name;
    }
  }

  updateLabelOnTop() {
    if (this.labelOnTop !== this._last_label_on_top) {
      this._last_label_on_top = this.labelOnTop;
      this.rebuild();
    }
  }

  updateDataPath() {
    if (!this.ctx || !this.getAttribute("datapath")) {
      return;
    }

    let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));

    if (!prop) {
      return;
    }

    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));
    if (val !== this._last_value) {
      this._last_value = this._value = val;
      this.updateTextBox();
    }
  }

  update() {
    this.updateLabelOnTop();
    super.update();

    this.updateDataPath();
    let redraw = false;

    updateSliderFromDom(this.numslider, this);
    updateSliderFromDom(this.textbox, this);

    if (redraw) {
      this.setCSS();
      this.numslider.setCSS();
      this.numslider._redraw();
    }

    this.updateName();

    this.numslider.description = this.description;
    this.textbox.description = this.title; //get full, transformed toolip

    if (this.hasAttribute("datapath")) {
      this.numslider.setAttribute("datapath", this.getAttribute("datapath"));
    }

    if (this.hasAttribute("mass_set_path")) {
      this.numslider.setAttribute("mass_set_path", this.getAttribute("mass_set_path"));
    }
  }

  setCSS() {
    super.setCSS();
    this.textbox.setCSS();
    //textbox.style["margin"] = "5px";

  }
}

class NumSliderSimple extends SliderWithTextbox {
  constructor() {
    super();

    this.numslider = UIBase$2.createElement("numslider-simple-base-x");
  }

  static define() {
    return {
      tagname: "numslider-simple-x",
      style  : "numslider_simple"
    }
  }

  _redraw() {
    this.numslider._redraw();
  }
}

UIBase$2.internalRegister(NumSliderSimple);

class NumSliderWithTextBox extends SliderWithTextbox {
  constructor() {
    super();

    this.numslider = UIBase$2.createElement("numslider-x");
  }

  static define() {
    return {
      tagname: "numslider-textbox-x",
      style  : "numslider_textbox"
    }
  }

  _redraw() {
    this.numslider._redraw();
  }
}

UIBase$2.internalRegister(NumSliderWithTextBox);

//stores xml sources

let pagecache = new Map();

var domTransferAttrs = new Set(["id", "title", "tab-index"]);
var domEventAttrs = new Set(["click", "mousedown", "mouseup", "mousemove", "keydown", "keypress"]);

function parseXML(xml) {
  let parser = new DOMParser();
  xml = `<root>${xml}</root>`;
  return parser.parseFromString(xml.trim(), "application/xml");
}

let num_re = /[0-9]+$/;

function getIconFlag(elem) {
  if (!elem.hasAttribute("useIcons")) {
    return 0;
  }

  let attr = elem.getAttribute("useIcons");

  if (typeof attr === "string") {
    attr = attr.toLowerCase().trim();
  }

  if (attr === "false" || attr === "no") {
    return 0;
  }

  if (attr === "true" || attr === "yes") {
    return PackFlags.USE_ICONS;
  } else if (attr === "small") {
    return PackFlags.SMALL_ICON | PackFlags.USE_ICONS;
  } else if (attr === "large") {
    return PackFlags.LARGE_ICON | PackFlags.USE_ICONS;
  } else {
    let isnum = typeof attr === "number";
    let sheet = attr;

    if (typeof sheet === "string" && sheet.search(num_re) === 0) {
      sheet = parseInt(sheet);
      isnum = true;
    }

    if (!isnum) {
      return PackFlags.USE_ICONS;
    }

    let flag = PackFlags.USE_ICONS | PackFlags.CUSTOM_ICON_SHEET;
    flag |= ((sheet - 1)<<PackFlags.CUSTOM_ICON_SHEET_START);

    return flag;
  }

  return 0;
}

function getPackFlag(elem) {
  let packflag = getIconFlag(elem);

  if (elem.hasAttribute("drawChecks")) {
    if (!getbool(elem, "drawChecks")) {
      packflag |= PackFlags.HIDE_CHECK_MARKS;
    } else {
      packflag &= ~PackFlags.HIDE_CHECK_MARKS;
    }
  }

  if (getbool(elem, "simpleSlider")) {
    packflag |= PackFlags.SIMPLE_NUMSLIDERS;
  }
  if (getbool(elem, "rollarSlider")) {
    packflag |= PackFlags.FORCE_ROLLER_SLIDER;
  }

  return packflag;
}

function myParseFloat(s) {
  s = '' + s;
  s = s.trim().toLowerCase();

  if (s.endsWith("px")) {
    s = s.slice(0, s.length - 2);
  }

  return parseFloat(s);
}

function getbool(elem, attr) {
  let ret = elem.getAttribute(attr);
  if (!ret) {
    return false;
  }

  ret = ret.toLowerCase();
  return ret === "1" || ret === "true" || ret === "yes";
}

function getfloat(elem, attr, defaultval) {
  if (!elem.hasAttribute(attr)) {
    return defaultval;
  }

  return myParseFloat(elem.getAttribute(attr));
}

/*
**
*
* a customHandler can be a callback, or the string "default", e.g.
*
* xmlpage.customHandlers["homegig-element-x"] = "default".
*
* The default case simply suppresses the warning that would otherwise
* be printed to the console.
* */
const customHandlers = {};

class Handler {
  constructor(ctx, container) {
    this.container = container;
    this.stack = [];
    this.ctx = ctx;
    this.codefuncs = {};

    this.templateVars = {};

    let attrs = list(sliderDomAttributes);

    //note that useIcons, showLabel and sliderMode are PackFlag bits and are inherited through that system

    this.inheritDomAttrs = {};
    this.inheritDomAttrKeys = new Set(attrs);
  }

  push() {
    this.stack.push(this.container);
    this.stack.push(new Set(this.inheritDomAttrKeys));
    this.stack.push(Object.assign({}, this.inheritDomAttrs));
  }

  pop() {
    this.inheritDomAttrs = this.stack.pop();
    this.inheritDomAttrKeys = this.stack.pop();
    this.container = this.stack.pop();
  }

  handle(elem) {
    if (elem.constructor === XMLDocument || elem.nodeName === 'root') {
      for (let child of elem.childNodes) {
        this.handle(child);
      }

      window.tree = elem;
      return;
    } else if (elem.constructor === Text || elem.constructor === Comment) {
      return;
    }

    let tagname = "" + elem.tagName;

    if (tagname in customHandlers) {
      customHandlers[tagname](this, elem);
    } else if (this[tagname]) {
      this[tagname](elem);
    } else {
      let elem2 = UIBase$2.createElement(tagname.toLowerCase());

      window.__elem = elem;
      //transfer DOM attributes
      for (let k of elem.getAttributeNames()) {
        elem2.setAttribute(k, elem.getAttribute(k));
      }

      if (elem2 instanceof UIBase$2) {
        if (!elem2.hasAttribute("datapath") && elem2.hasAttribute("path")) {
          elem2.setAttribute("datapath", elem2.getAttribute("path"));
        }

        if (elem2.hasAttribute("datapath")) {
          let path = elem2.getAttribute("datapath");
          path = this.container._joinPrefix(path);
          elem2.setAttribute("datapath", path);
        }

        if (elem2.hasAttribute("massSetPath") || this.container.massSetPrefix) {
          let massSetPath = "";

          if (elem2.hasAttribute("massSetPath")) {
            massSetPath = elem2.getAttribute("massSetPath");
          }

          let path = elem2.getAttribute("datapath");

          path = this.container._getMassPath(this.container.ctx, path, massSetPath);
          elem2.setAttribute("massSetPath", path);
          elem2.setAttribute("mass_set_path", path);
        }

        this.container.add(elem2);
        this._style(elem, elem2);

        if (elem2 instanceof Container) {
          this.push();

          this.container = elem2;
          this._container(elem, elem2, true);
          this.visit(elem);

          this.pop();

          return;
        }
      } else {
        console.warn("Unknown element " + elem.tagName + " (" + elem.constructor.name + ")");
        let elem2 = document.createElement(elem.tagName.toLowerCase());

        for (let attr of elem.getAttributeNames()) {
          elem2.setAttribute(attr, elem.getAttribute(attr));
        }

        this._basic(elem, elem2);

        this.container.shadow.appendChild(elem2);

        if (!(elem2 instanceof UIBase$2)) {
          elem2.pathux_ctx = this.container.ctx;
        } else {
          elem2.ctx = this.container.ctx;
        }
      }

      this.visit(elem);
    }
  }

  _style(elem, elem2) {
    let style = {};

    //try to handle class attribute, at least somewhat

    if (elem.hasAttribute("class")) {
      elem2.setAttribute("class", elem.getAttribute("class"));

      let cls = elem2.getAttribute("class").trim();
      let keys = [
        cls,
        (elem2.tagName.toLowerCase() + "." + cls).trim(),
        "#" + elem.getAttribute("id").trim()
      ];

      for (let sheet of document.styleSheets) {
        for (let rule of sheet.rules) {
          for (let k of keys) {
            if (rule.selectorText.trim() === k) {
              for (let k2 of rule.styleMap.keys()) {
                let val = rule.style[k2];

                style[k2] = val;
              }
            }
          }
        }
      }
    }

    if (elem.hasAttribute("style")) {
      let stylecode = elem.getAttribute("style");

      stylecode = stylecode.split(";");

      for (let row of stylecode) {
        row = row.trim();

        let i = row.search(/\:/);
        if (i >= 0) {
          let key = row.slice(0, i).trim();
          let val = row.slice(i + 1, row.length).trim();

          style[key] = val;
        }
      }
    }

    let keys = Object.keys(style);
    if (keys.length === 0) {
      return;
    }

    function setStyle() {
      for (let k of keys) {
        elem2.style[k] = style[k];
      }
    }

    if (elem2 instanceof UIBase$2) {
      elem2.setCSS.after(() => {
        setStyle();
      });
    }

    setStyle();
  }

  visit(node) {
    for (let child of node.childNodes) {
      this.handle(child);
    }
  }

  _getattr(elem, k) {
    let val = elem.getAttribute(k);

    if (!val) {
      return val;
    }

    if (val.startsWith("##")) {
      val = val.slice(2, val.length).trim();

      if (!(val in this.templateVars)) {
        console.error(`unknown template variable '${val}'`);
        val = '';
      } else {
        val = this.templateVars[val];
      }
    }

    return val;
  }

  _basic(elem, elem2) {
    this._style(elem, elem2);

    for (let k of elem.getAttributeNames()) {
      if (k.startsWith("custom")) {
        elem2.setAttribute(k, this._getattr(elem, k));
      }
    }

    let codeattrs = [];

    for (let k of elem.getAttributeNames()) {
      let val = ""+elem.getAttribute(k);

      if (val.startsWith('ng[')) {
        val = val.slice(3, val.endsWith("]") ? val.length-1 : val.length);

        codeattrs.push([k, "ng", val]);
      }
    }

    for (let k of domEventAttrs) {
      let k2 = 'on' + k;

      if (elem.hasAttribute(k2)) {
        codeattrs.push([k, "dom", elem.getAttribute(k2)]);
      }
    }

    for (let [k, eventType, id] of codeattrs) {
      if (!(id in this.codefuncs)) {
        console.error("Unknown code fragment " + id);
        continue;
      }

      if (eventType === "dom") {
        //click events usually don't go through normal
        //dom event system
        if (k === 'click') {
          let onclick = elem2.onclick;
          let func = this.codefuncs[id];

          elem2.onclick = function () {
            if (onclick) {
              onclick.apply(this, arguments);
            }

            return func.apply(this, arguments);
          };
        } else {
          elem2.addEventListener(k, this.codefuncs[id]);
        }
      } else if (eventType === "ng") {
        elem2.addEventListener(k, this.codefuncs[id]);
      }
    }


    for (let k of domTransferAttrs) {
      if (elem.hasAttribute(k)) {
        elem2.setAttribute(k, elem.getAttribute(k));
      }
    }

    for (let k in this.inheritDomAttrs) {
      if (!elem.hasAttribute(k)) {
        elem.setAttribute(k, this.inheritDomAttrs[k]);
      }
    }

    for (let k of sliderDomAttributes) {
      if (elem.hasAttribute(k)) {
        elem2.setAttribute(k, elem.getAttribute(k));
      }
    }

    if (!(elem2 instanceof UIBase$2)) {
      return;
    }

    if (elem.hasAttribute("theme-class")) {
      elem2.overrideClass(elem.getAttribute("theme-class"));

      if (elem2._init_done) {
        elem2.setCSS();
        elem2.flushUpdate();
      }
    }

    if (elem.hasAttribute("useIcons") && typeof elem2.useIcons === "function") {
      let val = elem.getAttribute("useIcons").trim().toLowerCase();

      if (val === "small" || val === "true" || val === "yes") {
        val = true;
      } else if (val === "large") {
        val = 1;
      } else if (val === "false" || val === "no") {
        val = false;
      } else {
        val = parseInt(val) - 1;
      }

      elem2.useIcons(val);
    }

    if (elem.hasAttribute("sliderTextBox")) {
      let textbox = getbool(elem, "sliderTextBox");

      if (textbox) {
        elem2.packflag &= ~PackFlags.NO_NUMSLIDER_TEXTBOX;
        elem2.inherit_packflag &= ~PackFlags.NO_NUMSLIDER_TEXTBOX;
      } else {
        elem2.packflag |= PackFlags.NO_NUMSLIDER_TEXTBOX;
        elem2.inherit_packflag |= PackFlags.NO_NUMSLIDER_TEXTBOX;
      }

      //console.error("textBox", textbox, elem2, elem.getAttribute("sliderTextBox"), elem2.packflag);
    }

    if (elem.hasAttribute("sliderMode")) {
      let sliderMode = elem.getAttribute("sliderMode");

      if (sliderMode === "slider") {
        elem2.packflag &= ~PackFlags.FORCE_ROLLER_SLIDER;
        elem2.inherit_packflag &= ~PackFlags.FORCE_ROLLER_SLIDER;

        elem2.packflag |= PackFlags.SIMPLE_NUMSLIDERS;
        elem2.inherit_packflag |= PackFlags.SIMPLE_NUMSLIDERS;
      } else if (sliderMode === "roller") {
        elem2.packflag &= ~PackFlags.SIMPLE_NUMSLIDERS;
        elem2.packflag |= PackFlags.FORCE_ROLLER_SLIDER;

        elem2.inherit_packflag &= ~PackFlags.SIMPLE_NUMSLIDERS;
        elem2.inherit_packflag |= PackFlags.FORCE_ROLLER_SLIDER;
      }

      //console.error("sliderMode", sliderMode, elem2, elem2.packflag & (PackFlags.SIMPLE_NUMSLIDERS | PackFlags.FORCE_ROLLER_SLIDER));
    }

    if (elem.hasAttribute("showLabel")) {
      let state = getbool(elem, "showLabel");

      if (state) {
        elem2.packflag |= PackFlags.FORCE_PROP_LABELS;
        elem2.inherit_packflag |= PackFlags.FORCE_PROP_LABELS;
      } else {
        elem2.packflag &= ~PackFlags.FORCE_PROP_LABELS;
        elem2.inherit_packflag &= ~PackFlags.FORCE_PROP_LABELS;
      }
    }

    function doBox(key) {
      if (elem.hasAttribute(key)) {
        let val = elem.getAttribute(key).toLowerCase().trim();

        if (val.endsWith("px")) {
          val = val.slice(0, val.length - 2).trim();
        }

        if (val.endsWith("%")) {
          //eek! don't support at all?
          //or use aspect overlay?

          console.warn(`Relative styling of '${key}' may be unstable for this element`, elem);

          elem.setCSS.after(function () {
            this.style[key] = val;
          });
        } else {
          val = parseFloat(val);

          if (isNaN(val) || typeof val !== "number") {
            console.error(`Invalid style ${key}:${elem.getAttribute(key)}`);
            return;
          }

          elem2.overrideDefault(key, val);
          elem2.setCSS();
          elem2.style[key] = "" + val + "px";
        }
      }
    }

    doBox("width");
    doBox("height");
    doBox("margin");
    doBox("padding");

    for (let i = 0; i < 2; i++) {
      let key = i ? "margin" : "padding";

      doBox(key + "-bottom");
      doBox(key + "-top");
      doBox(key + "-left");
      doBox(key + "-right");
    }
  }

  _handlePathPrefix(elem, con) {
    if (elem.hasAttribute("path")) {
      let prefix = con.dataPrefix;
      let path = elem.getAttribute("path").trim();

      if (prefix.length > 0) {
        prefix += ".";
      }

      prefix += path;
      con.dataPrefix = prefix;
    }

    if (elem.hasAttribute("massSetPath")) {
      let prefix = con.massSetPrefix;
      let path = elem.getAttribute("massSetPath").trim();

      if (prefix.length > 0) {
        prefix += ".";
      }

      prefix += path;
      con.massSetPrefix = prefix;
    }
  }

  _container(elem, con, ignorePathPrefix=false) {
    for (let k of this.inheritDomAttrKeys) {
      if (elem.hasAttribute(k)) {
        this.inheritDomAttrs[k] = elem.getAttribute(k);
      }
    }

    let packflag = getPackFlag(elem);

    con.packflag |= packflag;
    con.inherit_packflag |= packflag;

    this._basic(elem, con);

    if (!ignorePathPrefix) {
      this._handlePathPrefix(elem, con);
    }
  }
  noteframe(elem) {
    let ret = this.container.noteframe();

    if (ret) {
      this._basic(elem, ret);
    }
  }

  cell(elem) {
    this.push();
    this.container = this.container.cell();
    this._container(elem, this.container);
    this.visit(elem);
    this.pop();
  }

  table(elem) {
    this.push();
    this.container = this.container.table();
    this._container(elem, this.container);
    this.visit(elem);
    this.pop();
  }

  panel(elem) {
    let title = "" + elem.getAttribute("label");
    let closed = getbool(elem, "closed");

    this.push();
    this.container = this.container.panel(title);
    this.container.closed = closed;

    this._container(elem, this.container);

    this.visit(elem);

    this.pop();
  }

  pathlabel(elem) {
    this._prop(elem, "pathlabel");
  }

  /**
   handle a code element, which are wrapped in functions
   */
  code(elem) {
    window._codelem = elem;

    let buf = '';

    for (let elem2 of elem.childNodes) {
      if (elem2.nodeName === "#text") {
        buf += elem2.textContent + '\n';
      }
    }

    var func, $scope = this.templateScope;

    buf = `
func = function() {
  ${buf};
}
    `;

    eval(buf);

    let id = "" + elem.getAttribute("id");

    this.codefuncs[id] = func;
  }

  textbox(elem) {
    if (elem.hasAttribute("path")) {
      this._prop(elem, 'textbox');
    } else {
      //let elem2 = this.container.textbox();
      //this._basic(elem, elem2);
    }
  }

  label(elem) {
    let elem2 = this.container.label(elem.innerHTML);
    this._basic(elem, elem2);
  }

  colorfield(elem) {
    this._prop(elem, "colorfield");
  }

  /** simpleSliders=true enables simple sliders */
  prop(elem) {
    this._prop(elem, "prop");
  }

  _prop(elem, key) {
    let packflag = getPackFlag(elem);
    let path = elem.getAttribute("path");

    let elem2;
    if (key === 'pathlabel') {
      elem2 = this.container.pathlabel(path, elem.innerHTML, packflag);
    } else if (key === 'textbox') {
      elem2 = this.container.textbox(path, undefined, undefined, packflag);

      elem2.update();

      //make textboxes non-modal by default
      if (elem.hasAttribute("modal")) {
        elem2.setAttribute("modal", elem.getAttribute("modal"));
      }

      if (elem.hasAttribute("realtime")) {
        elem2.setAttribute("realtime", elem.getAttribute("realtime"));
      }
    } else if (key === "colorfield") {
      elem2 = this.container.colorPicker(path, {
        packflag,
        themeOverride: elem.hasAttribute("theme-class") ? elem.getAttribute("theme-class") : undefined
      });
    } else {
      elem2 = this.container[key](path, packflag);
    }

    if (!elem2) {
      elem2 = document.createElement("span");
      elem2.innerHTML = "error";
      this.container.shadow.appendChild(elem2);
    } else {
      this._basic(elem, elem2);

      if (elem.hasAttribute("massSetPath") || this.container.massSetPrefix) {
        let mpath = elem.getAttribute("massSetPath");
        if (!mpath) {
          mpath = elem.getAttribute("path");
        }

        mpath = this.container._getMassPath(this.container.ctx, path, mpath);

        elem2.setAttribute("mass_set_path", mpath);
      }
    }
  }

  strip(elem) {
    this.push();

    let dir;
    if (elem.hasAttribute("mode")) {
      dir = elem.getAttribute("mode").toLowerCase().trim();
      dir = dir === "horizontal";
    }

    let margin1 = getfloat(elem, "margin1", undefined);
    let margin2 = getfloat(elem, "margin2", undefined);

    this.container = this.container.strip(undefined, margin1, margin2, dir);
    this._container(elem, this.container);
    this.visit(elem);

    this.pop();
  }

  column(elem) {
    this.push();
    this.container = this.container.col();
    this._container(elem, this.container);
    this.visit(elem);
    this.pop();
  }

  row(elem) {
    this.push();
    this.container = this.container.row();
    this._container(elem, this.container);
    this.visit(elem);
    this.pop();
  }

  toolPanel(elem) {
    this.tool(elem, "toolPanel");
  }

  tool(elem, key = "tool") {
    let path = elem.getAttribute("path");
    let packflag = getPackFlag(elem);

    let noIcons = false, iconflags;

    if (getbool(elem, "useIcons")) {
      packflag |= PackFlags.USE_ICONS;
    } else if (elem.hasAttribute("useIcons")) {
      packflag &= ~PackFlags.USE_ICONS;
      noIcons = true;
    }

    let label = ("" + elem.textContent).trim();
    if (label.length > 0) {
      path += "|" + label;
    }

    if (noIcons) {
      iconflags = this.container.useIcons(false);
    }

    let elem2 = this.container[key](path, packflag);

    if (elem2) {
      this._basic(elem, elem2);
    } else {
      elem2 = document.createElement("strip");
      elem2.innerHTML = "error";
      this.container.shadow.appendChild(elem2);
      this._basic(elem, elem2);
    }

    if (noIcons) {
      this.container.inherit_packflag |= iconflags;
      this.container.packflag |= iconflags;
    }
  }

  dropbox(elem) {
    return this.menu(elem, true);
  }

  menu(elem, isDropBox = false) {
    let packflag = getPackFlag(elem);
    let title = elem.getAttribute("name");

    let list = [];

    for (let child of elem.childNodes) {
      if (child.tagName === "tool") {
        let path = child.getAttribute("path");
        let label = child.innerHTML.trim();

        if (label.length > 0) {
          path += "|" + label;
        }

        list.push(path);
      } else if (child.tagName === "sep") {
        list.push(Menu.SEP);
      } else if (child.tagName === "item") {
        let id, icon, hotkey, description;

        if (child.hasAttribute("id")) {
          id = child.getAttribute("id");
        }

        if (child.hasAttribute("icon")) {
          icon = child.getAttribute("icon").toUpperCase().trim();
          icon = Icons[icon];
        }

        if (child.hasAttribute("hotkey")) {
          hotkey = child.getAttribute("hotkey");
        }

        if (child.hasAttribute("description")) {
          description = child.getAttribute("description");
        }

        list.push({
          name: child.innerHTML.trim(),
          id, icon, hotkey, description
        });
      }
    }

    let ret = this.container.menu(title, list, packflag);
    if (isDropBox) {
      ret.removeAttribute("simple");
    }

    if (elem.hasAttribute("id")) {
      ret.setAttribute("id", elem.getAttribute("id"));
    }

    this._basic(elem, ret);

    return ret;
  }

  button(elem) {
    let title = elem.innerHTML.trim();

    let ret = this.container.button(title);

    if (elem.hasAttribute("id")) {
      ret.setAttribute("id", elem.getAttribute("id"));
    }

    this._basic(elem, ret);
  }

  iconbutton(elem) {
    let title = elem.innerHTML.trim();

    let icon = elem.getAttribute("icon");
    if (icon) {
      icon = UIBase$2.getIconEnum()[icon];
    }
    let ret = this.container.iconbutton(icon, title);

    if (elem.hasAttribute("id")) {
      ret.setAttribute("id", elem.getAttribute("id"));
    }

    this._basic(elem, ret);
  }

  tab(elem) {
    this.push();

    let title = "" + elem.getAttribute("label");

    let tabs = this.container;

    this.container = this.container.tab(title);

    if (elem.hasAttribute("overflow")) {
      this.container.setAttribute("overflow", elem.getAttribute("overflow"));
    }

    if (elem.hasAttribute("overflow-y")) {
      this.container.setAttribute("overflow-y", elem.getAttribute("overflow-y"));
    }

    this._container(elem, this.container);
    this.visit(elem);

    this.pop();
  }

  tabs(elem) {
    let pos = elem.getAttribute("pos") || "left";

    this.push();

    let tabs = this.container.tabs(pos);
    this.container = tabs;

    if (elem.hasAttribute("movable-tabs")) {
      tabs.setAttribute("movable-tabs", elem.getAttribute("movable-tabs"));
    }

    this._container(elem, tabs);
    this.visit(elem);

    this.pop();
  }
}

function initPage(ctx, xml, parentContainer = undefined, templateVars = {}, templateScope = {}) {
  let tree = parseXML(xml);
  let container = UIBase$2.createElement("container-x");

  container.ctx = ctx;
  if (ctx) {
    container._init();
  }

  if (parentContainer) {
    parentContainer.add(container);
  }

  let handler = new Handler(ctx, container);

  handler.templateVars = Object.assign({}, templateVars);
  handler.templateScope = templateScope;

  handler.handle(tree);

  return container;

}

function loadPage(ctx, url, parentContainer_or_args = undefined, loadSourceOnly = false,
                         modifySourceCB, templateVars, templateScope) {
  let source;
  let parentContainer;

  if (parentContainer_or_args !== undefined && !(parentContainer_or_args instanceof HTMLElement)) {
    let args = parentContainer_or_args;

    parentContainer = args.parentContainer;
    loadSourceOnly = args.loadSourceOnly;
    modifySourceCB = args.modifySourceCB;
    templateVars = args.templateVars;
    templateScope = args.templateScope;
  } else {
    parentContainer = parentContainer_or_args;
  }

  if (pagecache.has(url)) {
    source = pagecache.get(url);

    if (modifySourceCB) {
      source = modifySourceCB(source);
    }

    return new Promise((accept, reject) => {
      if (loadSourceOnly) {
        accept(source);
      } else {
        accept(initPage(ctx, source, parentContainer, templateVars, templateScope));
      }
    });
  } else {
    return new Promise((accept, reject) => {
      fetch(url).then(res => res.text()).then(data => {
        pagecache.set(url, data);

        if (modifySourceCB) {
          data = modifySourceCB(data);
        }

        if (loadSourceOnly) {
          accept(data);
        } else {
          accept(initPage(ctx, data, parentContainer, templateVars, templateScope));
        }
      });
    });
  }
}

function makeGenEnum() {
  let enumdef = {};
  let uinames = {};
  let icons = {};

  for (let cls of CurveConstructors) {
    let def = cls.define();

    let uiname = def.uiname;
    uiname = uiname === undefined ? def.name : uiname;

    enumdef[def.name] = cls.name;
    uinames[def.name] = uiname;
    icons[def.name] = def.icon !== undefined ? def.icon : -1;
  }

  //return enumdef;
  return new EnumProperty(undefined, enumdef).addUINames(uinames).addIcons(icons);
}

class Curve1DWidget extends ColumnFrame {
  constructor() {
    super();

    this.useDataPathUndo = false;

    this._on_draw = this._on_draw.bind(this);
    this.drawTransform = [1.0, [0, 0]];

    this._value = new Curve1D();
    this._value.on("draw", this._on_draw);

    this._value._on_change = (msg) => {
      if (this.onchange) {
        this.onchange(this._value);
      }

      if (this.hasAttribute("datapath")) {
        let path = this.getAttribute("datapath");
        if (this._value !== undefined) {
          let val = this.getPathValue(this.ctx, path);

          if (val) {
            val.load(this._value);
            this.setPathValue(this.ctx, path, val);
          } else {
            val = this._value.copy();
            this.setPathValue(this.ctx, path, val);
          }
        }
      }
    };

    this._gen_type = undefined;
    this._lastGen = undefined;

    this._last_dpi = undefined;
    this.canvas = document.createElement("canvas");

    this.g = this.canvas.getContext("2d");
    this.canvas.g = this.g;

    window.cw = this;
    this.shadow.appendChild(this.canvas);
  }

  get value() {
    return this._value;
  }

  _on_draw(e) {
    let curve = e.data;

    //console.log("draw");
    this._redraw();
  }

  set value(val) {
    this._value.load(val);
    this.update();
    this._redraw();
  }

  _on_change() {
    if (this.onchange) {
      this.onchange(this);
    }
  }

  init() {
    super.init();

    this.useDataPathUndo = false;
    let row = this.row();

    let prop = makeGenEnum();

    prop.setValue(this.value.generatorType);

    this.dropbox = row.listenum(undefined, "Type", prop, this.value.generatorType, (id) => {
      console.warn("SELECT", id, prop.keys[id]);

      this.value.setGenerator(id);
      this.value._on_change("curve type change");
    });
    this.dropbox._init();

    row.iconbutton(Icons.ZOOM_OUT, "Zoom Out", () => {
      let curve = this._value;
      if (!curve) return;
      //if (isNaN(curve.uiZoom))
      //  curve.uiZoom = 1.0;

      curve.uiZoom *= 0.9;
      if (this.getAttribute("datapath")) {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), curve);
      }

      this._redraw();
    }).iconsheet = 0;
    row.iconbutton(Icons.ZOOM_IN, "Zoom In", () => {
      let curve = this._value;
      if (!curve) return;
      //if (isNaN(curve.uiZoom))
      //  curve.uiZoom = 1.0;

      curve.uiZoom *= 1.1;
      if (this.getAttribute("datapath")) {
        this.setPathValue(this.ctx, this.getAttribute("datapath"), curve);
      }

      this._redraw();

    }).iconsheet = 0;

    this.container = this.col();
  }

  setCSS() {
    super.setCSS();

    this.style["width"] = "min-contents";
    this.style["height"] = "min-contents";
    this.updateSize();
  }

  updateSize() {
    let dpi = UIBase$2.getDPI();
    let w = ~~(this.getDefault("CanvasWidth")*dpi);
    let h = ~~(this.getDefault("CanvasHeight")*dpi);

    let bad = w !== this.canvas.width || h !== this.canvas.height;
    bad = bad || dpi !== this._last_dpi;

    if (!bad) {
      return;
    }

    this._last_dpi = dpi;
    this.canvas.width = w;
    this.canvas.height = h;

    this.canvas.style["width"] = (w/dpi) + "px";
    this.canvas.style["height"] = (h/dpi) + "px";

    this._redraw();
  }

  _redraw() {
    //forcibly clear canvas, works better then clearRect
    this.canvas.width = this.canvas.width;
    this.canvas.height = this.canvas.height;

    let canvas = this.canvas, g = this.g;

    //g.clearRect(0, 0, canvas.width, canvas.height);
    g.beginPath();
    g.rect(0, 0, canvas.width, canvas.height);
    g.fillStyle = this.getDefault("CanvasBG");
    g.fill();

    g.save();

    let zoom = this._value.uiZoom;
    let scale = Math.max(canvas.width, canvas.height);

    g.lineWidth /= scale;


    this.drawTransform[0] = scale*zoom;
    this.drawTransform[1][0] =  0.0;
    this.drawTransform[1][1] = -1.0;

    this.drawTransform[1][0] -= 0.5 - 0.5/zoom;
    this.drawTransform[1][1] += 0.5 - 0.5/zoom;

    //g.scale(scale, scale);

    g.scale(this.drawTransform[0], -this.drawTransform[0]);
    g.translate(this.drawTransform[1][0], this.drawTransform[1][1]);

    g.lineWidth /= zoom;

    this._value.draw(this.canvas, this.g, this.drawTransform);
    g.restore();
  }

  rebuild() {
    let ctx = this.ctx;
    if (ctx === undefined || this.container === undefined) {
      return;
    }


    this._gen_type = this.value.generatorType;
    let col = this.container;

    if (this._lastGen !== undefined) {
      this._lastGen.killGUI(col, this.canvas);
    }

    let onchange = this.dropbox.onchange;
    this.dropbox.onchange = undefined;
    this.dropbox.setValue(this.value.generatorType);
    this.dropbox.onchange = onchange;

    col.clear();

    let gen = this.value.generators.active;
    gen.makeGUI(col, this.canvas);

    this._lastGen = gen;

    this._redraw();
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let path = this.getAttribute("datapath");
    let val = this.getPathValue(this.ctx, path);

    if (this._lastu === undefined) {
      this._lastu = 0;
    }

    if (val && !val.equals(this._value) && time_ms() - this._lastu > 200) {
      this._lastu = time_ms();

      this._value.load(val);
      this.update();
      this._redraw();
    }
  }

  updateGenUI() {
    let bad = this._lastGen !== this.value.generators.active;
    
    if (bad) {
      this.rebuild();
      this._redraw();
    }
  }
  update() {
    super.update();

    this.updateDataPath();
    this.updateSize();
    this.updateGenUI();
  }

  static define() {return {
    tagname : "curve-widget-x",
    style   : "curvewidget"
  }}
}
UIBase$2.internalRegister(Curve1DWidget);

//bind module to global var to get at it in console.

var _ui$1 = undefined;

let PropFlags$2 = PropFlags;
let PropSubTypes$3 = PropSubTypes$1;

let EnumProperty$7 = EnumProperty;

let Vector2$7   = Vector2,
    UIBase$b    = UIBase$2,
    PackFlags$6 = PackFlags,
    PropTypes$6 = PropTypes;


//methods to forward to this.contents
let forward_keys = new Set([
  "row", "col", "strip", "noteframe", "helppicker", "vecpopup",
  "tabs", "table", "menu", "listbox", "panel",
  "pathlabel", "label", "listenum", "check", "iconcheck",
  "button", "iconbutton", "colorPicker", "twocol",
  "treeview", "slider", "simpleslider", "curve1d",
  "noteframe", "vecpopup",
  "prop", "tool", "toolPanel", "textbox", "dynamicMenu",
  "add", "prepend", "useIcons", "noMarginsOrPadding", "wrap"
]);

class PanelFrame extends ColumnFrame {
  constructor() {
    super();

    this.titleframe = super.row();

    this.contents = super.col();
    this.contents._remove = this.contents.remove;
    this.contents.remove = () => {
      this.remove();
    };

    this._panel = this; //compatibility alias

    this.contents._panel = this;
    this.iconcheck = UIBase$b.createElement("iconcheck-x");
    this.iconcheck.noEmboss = true;

    Object.defineProperty(this.contents, "closed", {
      get: () => {
        return this.closed;
      },

      set: (v) => {
        this.closed = v;
      }
    });

    Object.defineProperty(this.contents, "title", {
      get: () => this.titleframe.getAttribute("title"),
      set: (v) => this.setHeaderToolTip(v)
    });

    this.packflag = this.inherit_packflag = 0;

    this._closed = false;

    this.makeHeader();
  }

  get inherit_packflag() {
    if (!this.contents) return;
    return this.contents.inherit_packflag;
  }

  set inherit_packflag(val) {
    if (!this.contents) return;
    this.contents.inherit_packflag = val;
  }

  get packflag() {
    if (!this.contents) return;
    return this.contents.packflag;
  }

  set packflag(val) {
    if (!this.contents) return;
    this.contents.packflag = val;
  }

  appendChild(child) {
    return this.contents.shadow.appendChild(child);
  }

  get headerLabel() {
    return this.__label.text;
  }

  set headerLabel(v) {
    this.__label.text = v;
    this.__label._updateFont();

    if (this.hasAttribute("label")) {
      this.setAttribute("label", v);
    }

    if (this.ctx) {
      this.setCSS();
    }
  }

  get dataPrefix() {
    return this.contents ? this.contents.dataPrefix : "";
  }

  set dataPrefix(v) {
    if (this.contents) {
      this.contents.dataPrefix = v;
    }
  }

  get closed() {
    return this._closed;
  }

  set closed(val) {
    let update = !!val !== !!this.closed;
    this._closed = val;

    //console.log("closed set", update);
    if (update) {
      this._updateClosed(true);
    }
  }

  static define() {
    return {
      tagname            : "panelframe-x",
      style              : "panel",
      subclassChecksTheme: true
    };
  }

  setHeaderToolTip(tooltip) {
    this.titleframe.setAttribute("title", tooltip);

    this.titleframe._forEachChildWidget((child) => {
      child.setAttribute("title", tooltip);
    });
  }

  saveData() {
    let ret = {
      closed: this._closed
    };

    return Object.assign(super.saveData(), ret);
  }

  loadData(obj) {
    if (!("closed" in obj)) {
      this.closed = obj._closed;
    } else {
      this.closed = obj.closed;
    }
  }

  clear() {
    this.contents.clear();
    return this;
  }

  makeHeader() {
    let row = this.titleframe;

    let iconcheck = this.iconcheck;

    if (!iconcheck) {
      return;
    }

    iconcheck.overrideDefault("padding", 0);

    iconcheck.noMarginsOrPadding();

    iconcheck.overrideDefault("background-color", "rgba(0,0,0,0)");
    iconcheck.overrideDefault("BoxDepressed", "rgba(0,0,0,0)");
    iconcheck.overrideDefault("border-color", "rgba(0,0,0,0)");

    iconcheck.ctx = this.ctx;
    iconcheck._icon_pressed = Icons.UI_EXPAND;
    iconcheck._icon = Icons.UI_COLLAPSE;
    iconcheck.drawCheck = false;
    iconcheck.iconsheet = IconSheets.SMALL;
    iconcheck.checked = this._closed;

    this.iconcheck.onchange = (e) => {
      this.closed = this.iconcheck.checked;
    };

    row._add(iconcheck);

    //stupid css, let's just hackishly put " " to create spacing2

    let onclick = (e) => {
      iconcheck.checked = !iconcheck.checked;

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();
    };

    let label = this.__label = row.label(this.getAttribute("label"));

    this.__label.overrideClass("panel");
    this.__label.font = "TitleText";

    label._updateFont();

    label.noMarginsOrPadding();
    label.addEventListener("mousedown", onclick);
    label.addEventListener("touchdown", onclick);

    let bs = this.getDefault("border-style");

    row.background = this.getDefault("TitleBackground");
    row.style["border-radius"] = this.getDefault("border-radius") + "px";
    row.style["border"] = `${this.getDefault("border-width")}px ${bs} ${this.getDefault("border-color")}`;

    row.style["padding-right"] = "20px";
    row.style["padding-left"] = "5px";
    row.style["padding-top"] = this.getDefault("padding-top") + "px";
    row.style["padding-bottom"] = this.getDefault("padding-bottom") + "px";
  }

  init() {
    super.init();

    this.background = this.getDefault("background-color");
    this.style["width"] = "100%";

    this.contents.ctx = this.ctx;
    if (!this._closed) {
      super.add(this.contents);
      this.contents.flushUpdate();
    }

    this.contents.dataPrefix = this.dataPrefix;

    //con.style["margin-left"] = "5px";

    this.setCSS();
  }

  setCSS() {
    super.setCSS();

    if (!this.titleframe || !this.__label) {
      return;
    }

    let getDefault = (key, defval) => {
      let val = this.getDefault(key);
      return val !== undefined ? val : defval;
    };

    let bs = this.getDefault("border-style");

    let header_radius = this.getDefault("HeaderRadius");
    if (header_radius === undefined) {
      header_radius = this.getDefault("border-radius");
    }

    let boxmargin = getDefault("padding", 0);

    let paddingleft = getDefault("padding-left", 0);
    let paddingright = getDefault("padding-right", 0);

    paddingleft += boxmargin;
    paddingright += boxmargin;

    this.titleframe.background = this.getDefault("TitleBackground");
    this.titleframe.style["border-radius"] = header_radius + "px";
    this.titleframe.style["border"] = `${this.getDefault("border-width")}px ${bs} ${this.getDefault("TitleBorder")}`;
    this.style["border"] = `${this.getDefault("border-width")}px ${bs} ${this.getDefault("border-color")}`;
    this.style["border-radius"] = this.getDefault("border-radius") + "px";

    this.titleframe.style["padding-top"] = this.getDefault("padding-top") + "px";
    this.titleframe.style["padding-bottom"] = this.getDefault("padding-bottom") + "px";
    this.titleframe.style["padding-left"] = paddingleft + "px";
    this.titleframe.style["padding-right"] = paddingright + "px";
    this.titleframe.style["margin-bottom"] = "0px";
    this.titleframe.style["margin-top"] = "0px";

    this.__label.style["border"] = "unset";
    this.__label.style["border-radius"] = "unset";

    let bg = this.getDefault("background-color");

    this.background = bg;
    this.contents.background = bg;
    this.contents.parentWidget = this;
    this.contents.style["background-color"] = bg;
    this.style["background-color"] = bg;

    let margintop, marginbottom;

    if (this._closed) {
      margintop = getDefault('margin-top-closed', 0);
      marginbottom = getDefault('margin-bottom-closed', 5);
    } else {
      margintop = getDefault('margin-top', 0);
      marginbottom = getDefault('margin-bottom', 0);
    }

    let marginleft = getDefault('margin-left', 0);
    let marginright = getDefault('margin-right', 0);

    this.style['margin-left'] = marginleft + "px";
    this.style['margin-right'] = marginright + "px";

    this.style['margin-top'] = margintop + "px";
    this.style['margin-bottom'] = marginbottom + "px";

    //this.style["padding-left"] = paddingleft + "px";
    //this.style["padding-right"] = paddingright + "px";

    this.__label._updateFont();
  }

  on_disabled() {
    super.on_disabled();

    this.__label._updateFont();
    this.setCSS();
  }

  on_enabled() {
    super.on_enabled();

    this.__label.setCSS();
    this.__label.style["color"] = this.style["color"];
    this.setCSS();
  }

  update() {
    let text = this.getAttribute("label");

    let update = text !== this.__label.text;

    if (this.checkThemeUpdate()) {
      update = true;
      this._setVisible(this.closed, true);
      this.setCSS();
      this.flushSetCSS();
    }

    if (update) {
      this.headerLabel = this.getAttribute("label");

      this.__label._updateFont();
      this.setCSS();
    }

    super.update();
  }

  _onchange(isClosed) {
    if (this.onchange) {
      this.onchange(isClosed);
    }

    if (this.contents.onchange) {
      this.contents.onchange(isClosed);
    }
  }

  //catch setAttribute so we can detect label update
  //even if close and updates disabled
  setAttribute(key, value) {
    let ret = super.setAttribute(key, value);

    if (this.ctx) {
      this.update();
      this.flushUpdate();
    }

    return ret;
  }

  get noUpdateClosedContents() {
    if (!this.hasAttribute("update-closed-contents")) {
      return false;
    }

    let ret = this.getAttribute("update-closed-contents");
    return ret === "true" || ret === "on";
  }

  set noUpdateClosedContents(v) {
    this.setAttribute("update-closed-contents", v ? "true" : "false");
  }

  _setVisible(isClosed, changed) {
    changed = changed || !!isClosed !== !!this._closed;

    this._state = isClosed;

    if (isClosed) {
      this.contents.style.display = "none";

      //this.contents._remove();
      //this.contents.hide(true);
      if (!this.noUpdateClosedContents) {
        this.contents.packflag |= PackFlags$6.NO_UPDATE;
      }
    } else {
      //this.contents.hide(false);
      this.contents.style.display = "flex";
      this.contents.packflag &= ~PackFlags$6.NO_UPDATE;
      this.contents.flushUpdate();
    }

    this.contents.hidden = isClosed;

    if (this.parentWidget) {
      this.parentWidget.flushUpdate();
    } else {
      this.flushUpdate();
    }

    if (changed) {
      this._onchange(isClosed);
    }

    /*
    for (let c of this.shadow.childNodes) {
      if (c !== this.titleframe) {
        c.hidden = state;
      }
    }*/
  }

  _updateClosed(changed) {
    this._setVisible(this._closed, changed);

    if (this.iconcheck) {
      this.iconcheck.checked = this._closed;
    }
  }
}


let makeForward = (k) => {
  return function() {
    return this.contents[k](...arguments);
  }
};

for (let k of forward_keys) {
  PanelFrame.prototype[k] = makeForward(k);
}

UIBase$b.internalRegister(PanelFrame);

"use strict";

let Vector2$8 = Vector2,
    Vector3$2 = Vector3,
    Vector4$2 = Vector4,
    Matrix4$2 = Matrix4;

let UIBase$c     = UIBase$2,
    PackFlags$7  = PackFlags,
    IconSheets$5 = IconSheets;

let UPW = 1.25, VPW = 0.75;

//*
let sample_rets = new cachering$1(() => [0, 0], 64);

function inv_sample(u, v) {
  let ret = sample_rets.next();

  ret[0] = Math.pow(u, UPW);
  ret[1] = Math.pow(v, VPW);

  return ret;
}

function sample(u, v) {
  let ret = sample_rets.next();

  ret[0] = Math.pow(u, 1.0/UPW);
  ret[1] = Math.pow(v, 1.0/VPW);

  return ret;
}

//*/

/* shared methods for clipboard handling */
function colorClipboardCopy() {
  let rgba = this.getRGBA();

  let r = rgba[0]*255;
  let g = rgba[1]*255;
  let b = rgba[2]*255;
  let a = rgba[3];

  let data = `rgba(${r.toFixed(4)}, ${g.toFixed(4)}, ${b.toFixed(4)}, ${a.toFixed(4)})`;
  //cconst.setClipboardData("color", "text/css", data);

  exports.setClipboardData("color", "text/plain", data);
}

function colorClipboardPaste() {
  let data = exports.getClipboardData("text/plain");

  if (!data || !validateCSSColor("" + data.data)) {// || data.mime !== "text/css") {
    return;
  }

  let color;

  try {
    color = css2color(data.data);
  } catch (error) {
    //not a color
    console.log(error.stack);
    console.log(error.message);
  }

  if (color) {
    if (color.length < 4) {
      color.push(1.0);
    }

    this.setRGBA(color);
  }
}

let fieldrand = new MersenneRandom(0);

let huefields = {};

function getHueField(width, height, dpi) {
  let key = width + ":" + height + ":" + dpi.toFixed(4);

  if (key in huefields) {
    return huefields[key];
  }

  let field = new ImageData(width, height);
  let idata = field.data;

  for (let i = 0; i < width*height; i++) {
    let ix = i%width, iy = ~~(i/width);
    let idx = i*4;

    let rgb = hsv_to_rgb(ix/width, 1, 1);

    idata[idx] = rgb[0]*255;
    idata[idx + 1] = rgb[1]*255;
    idata[idx + 2] = rgb[2]*255;
    idata[idx + 3] = 255;
  }

  //*
  let canvas = document.createElement("canvas");
  canvas.width = field.width;
  canvas.height = field.height;
  let g = canvas.getContext("2d");
  g.putImageData(field, 0, 0);
  field = canvas;
  //*/

  huefields[key] = field;
  return field;
}

let fields = {};

function getFieldImage(fieldsize, width, height, hsva) {
  fieldrand.seed(0);

  /* render field at half res and upscale via canvas2d */
  let width2 = width>>1;
  let height2 = height>>1;
  let fieldsize2 = fieldsize>>1;

  let hue = hsva[0];
  let hue_rgb = hsv_to_rgb(hue, 1.0, 1.0);
  let key = fieldsize + ":" + width2 + ":" + height2 + ":" + hue.toFixed(5);

  if (key in fields)
    return fields[key];

  let size2 = fieldsize2;
  let valpow = 0.75;

  let image = {
    width : width,
    height: height,
    image : new ImageData(fieldsize2, fieldsize2),

    x2sat: (x) => {
      return Math.min(Math.max(x/width, 0), 1);
    },
    y2val: (y) => {
      y = 1.0 - Math.min(Math.max(y/height, 0), 1);

      return y === 0.0 ? 0.0 : y**valpow;
    },
    sat2x: (s) => {
      return s*width;
    },
    val2y: (v) => {
      if (v === 0)
        return height;

      v = v**(1.0/valpow);
      return (1.0 - v)*height;
    }
  };

  image.params = {
    box: {
      x     : 0,
      y     : 0,
      width : width,
      height: height
    }
  };

  let idata = image.image.data;
  for (let i = 0; i < idata.length; i += 4) {
    let i2 = i/4;
    let x = i2%size2, y = ~~(i2/size2);

    let v = 1.0 - (y/size2);
    let s = (x/size2);

    let rgb = hsv_to_rgb(hsva[0], s, v**valpow);

    idata[i] = rgb[0]*255;
    idata[i + 1] = rgb[1]*255;
    idata[i + 2] = rgb[2]*255;
    idata[i + 3] = 255;
  }

  //*
  let image2 = document.createElement("canvas");
  image2.width = size2;
  image2.height = size2;
  let g = image2.getContext("2d");
  g.putImageData(image.image, 0, 0);
  //*/
  image.canvas = image2;
  image.scale = width/size2;

  fields[key] = image;
  return image;
}


let _update_temp = new Vector4$2();

class SimpleBox {
  constructor(pos = [0, 0], size = [1, 1]) {
    this.pos = new Vector2$8(pos);
    this.size = new Vector2$8(size);
    this.r = 0;
  }
}

class HueField extends UIBase$c {
  constructor() {
    super();

    this.canvas = document.createElement("canvas");
    this.g = this.canvas.getContext("2d");
    this.shadow.appendChild(this.canvas);

    let setFromXY = (x, y) => {
      let dpi = this.getDPI();
      let pad = this._getPad();

      let w = this.canvas.width/dpi - pad*2.0;
      x -= pad;

      let h = x/w;
      h = Math.min(Math.max(h, 0.0), 1.0);

      this.hsva[0] = h;

      if (this.onchange) {
        this.onchange(this.hsva);
      }

      this._redraw();
    };

    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case keymap["Left"]:
        case keymap["Right"]:
          let sign = e.keyCode === keymap["Left"] ? -1 : 1;

          this.hsva[0] = Math.min(Math.max(this.hsva[0] + 0.05*sign, 0.0), 1.0);
          this._redraw();

          if (this.onchange) {
            this.onchange();
          }
          break;
      }
    });

    this.addEventListener("mousedown", (e) => {
      if (this.modalRunning) {
        return;
      }

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();

      let rect = this.canvas.getClientRects()[0];
      let x = e.clientX - rect.x, y = e.clientY - rect.y;

      setFromXY(x, y);

      this.pushModal({
        on_mousemove: (e) => {
          let rect = this.canvas.getClientRects()[0];
          let x = e.clientX - rect.x, y = e.clientY - rect.y;

          setFromXY(x, y);
        },
        on_mousedown: (e) => {
          this.popModal();
        },
        on_mouseup  : (e) => {
          this.popModal();
        },
        on_keydown  : (e) => {
          if (e.keyCode === keymap["Enter"] || e.keyCode === keymap["Escape"] || e.keyCode === keymap["Space"]) {
            this.popModal();
          }
        }
      });
    });
  }


  static define() {
    return {
      tagname          : "huefield-x",
      style            : "colorfield",
      havePickClipboard: true
    };
  }

  getRGBA() {
    let rgb = hsv_to_rgb(this.hsva[0], this.hsva[1], this.hsva[2]);
    return new Vector4$2().loadXYZW(rgb[0], rgb[1], rgb[2], this.hsva[3]);
  }

  setRGBA(rgba) {
    let hsv = rgb_to_hsv(rgba[0], rgba[1], rgba[2]);
    this.hsva.loadXYZW(hsv[0], hsv[1], hsv[2], rgba[3]);

    this._redraw();

    if (this.onchange) {
      this.onchange(this.hsva);
    }
  }

  clipboardCopy() {
    colorClipboardCopy.apply(this, arguments);
  }

  clipboardPaste() {
    colorClipboardPaste.apply(this, arguments);
  }

  _getPad() {
    return Math.max(this.getDefault("circleSize"), 15);
  }

  _redraw() {
    let g = this.g, canvas = this.canvas;
    let dpi = this.getDPI();

    let w = this.getDefault("width");
    let h = this.getDefault("hueHeight");

    canvas.width = ~~(w*dpi);
    canvas.height = ~~(h*dpi);

    canvas.style["width"] = w + "px";
    canvas.style["height"] = h + "px";

    /* create horizontal padding to make selection of
     *  endpoint hue easier */

    let rselector = ~~(this._getPad()*dpi); //~~(this.getDefault("circleSize")*dpi);
    let r_circle = this.getDefault("circleSize")*dpi;

    let w2 = canvas.width, h2 = canvas.height;

    w2 -= rselector*2.0;

    //g.drawImage(getHueField(w2, h2, dpi), 0, 0, w2, h2, rselector*2, 0, w2, h2);
    g.drawImage(getHueField(w2, h2, dpi), 0, 0, w2, h2, rselector, 0, w2, h2);

    let x = this.hsva[0]*w2 + rselector;
    let y = canvas.height*0.5;

    g.beginPath();
    g.arc(x, y, r_circle, -Math.PI, Math.PI);
    g.closePath();

    g.strokeStyle = "white";
    g.lineWidth = 3*dpi;
    g.stroke();

    g.strokeStyle = "grey";
    g.lineWidth = 1*dpi;
    g.stroke();

    if (this.disabled) {
      g.beginPath();
      g.fillStyle = "rgba(25,25,25,0.75)";
      g.rect(0, 0, this.canvas.width, this.canvas.height);
      g.fill();
    }
  }

  on_disabled() {
    this._redraw();
  }

  on_enabled() {
    this._redraw();
  }
}

UIBase$c.internalRegister(HueField);

class SatValField extends UIBase$c {
  constructor() {
    super();

    this.hsva = [0, 0, 0, 1];

    this.canvas = document.createElement("canvas");
    this.g = this.canvas.getContext("2d");
    this.shadow.appendChild(this.canvas);

    this.onchange = undefined;

    let setFromXY = (x, y) => {
      let field = this._getField();
      let r = ~~(this.getDefault("circleSize")*this.getDPI());

      let sat = field.x2sat(x - r);
      let val = field.y2val(y - r);

      this.hsva[1] = sat;
      this.hsva[2] = val;

      if (this.onchange) {
        this.onchange(this.hsva);
      }

      this._redraw();
    };

    this.addEventListener("keydown", (e) => {
      switch (e.keyCode) {
        case keymap["Left"]:
        case keymap["Right"]: {
          let sign = e.keyCode === keymap["Left"] ? -1 : 1;

          this.hsva[1] = Math.min(Math.max(this.hsva[1] + 0.05*sign, 0.0), 1.0);
          this._redraw();

          if (this.onchange) {
            this.onchange(this.hsva);
          }
          break;
        }

        case keymap["Up"]:
        case keymap["Down"]: {
          let sign = e.keyCode === keymap["Down"] ? -1 : 1;

          this.hsva[2] = Math.min(Math.max(this.hsva[2] + 0.05*sign, 0.0), 1.0);
          this._redraw();

          if (this.onchange) {
            this.onchange(this.hsva);
          }
          break;
        }
      }
    });

    this.canvas.addEventListener("mousedown", (e) => {
      if (this.modalRunning) {
        return;
      }

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();

      let rect = this.canvas.getClientRects()[0];
      let x = e.clientX - rect.x, y = e.clientY - rect.y;

      setFromXY(x, y);

      this.pushModal({
        on_pointermove(e) {
          this.on_mousemove(e);
        },
        on_mousemove: (e) => {
          let rect = this.canvas.getClientRects()[0];
          if (rect === undefined) {
            return;
          }

          let x = e.clientX - rect.x, y = e.clientY - rect.y;

          setFromXY(x, y);
        },
        on_mousedown: (e) => {
          this.popModal();
        },
        on_mouseup  : (e) => {
          this.popModal();
        },
        on_keydown  : (e) => {
          if (e.keyCode === keymap["Enter"] || e.keyCode === keymap["Escape"] || e.keyCode === keymap["Space"]) {
            this.popModal();
          }
        }
      });
    });

    this.canvas.addEventListener("touchstart", (e) => {
      if (this.modalRunning) {
        return;
      }

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();

      let rect = this.canvas.getClientRects()[0];
      let x = e.touches[0].clientX - rect.x, y = e.touches[0].clientY - rect.y;

      setFromXY(x, y);

      this.pushModal({
        on_mousemove  : (e) => {
          let rect = this.canvas.getClientRects()[0];
          let x, y;

          if (e.touches && e.touches.length) {
            x = e.touches[0].clientX - rect.x;
            y = e.touches[0].clientY - rect.y;
          } else {
            x = e.x;
            y = e.y;
          }

          setFromXY(x, y);
        },
        on_touchmove  : (e) => {
          let rect = this.canvas.getClientRects()[0];
          let x = e.touches[0].clientX - rect.x, y = e.touches[0].clientY - rect.y;

          setFromXY(x, y);
        },
        on_mousedown  : (e) => {
          this.popModal();
        },
        on_touchcancel: (e) => {
          this.popModal();
        },
        on_touchend   : (e) => {
          this.popModal();
        },
        on_mouseup    : (e) => {
          this.popModal();
        },
        on_keydown    : (e) => {
          if (e.keyCode === keymap["Enter"] || e.keyCode === keymap["Escape"] || e.keyCode === keymap["Space"]) {
            this.popModal();
          }
        }
      });
    });
  }

  static define() {
    return {
      tagname          : "satvalfield-x",
      style            : "colorfield",
      havePickClipboard: true
    };
  }

  getRGBA() {
    let rgb = hsv_to_rgb(this.hsva[0], this.hsva[1], this.hsva[2]);
    return new Vector4$2().loadXYZW(rgb[0], rgb[1], rgb[2], this.hsva[3]);
  }

  setRGBA(rgba) {
    let hsv = rgb_to_hsv(rgba[0], rgba[1], rgba[2]);
    this.hsva.loadXYZW(hsv[0], hsv[1], hsv[2], rgba[3]);

    this.update(true);
    this._redraw();

    if (this.onchange) {
      this.onchange(this.hsva);
    }
  }

  clipboardCopy() {
    colorClipboardCopy.apply(this, arguments);
  }

  clipboardPaste() {
    colorClipboardPaste.apply(this, arguments);
  }

  _getField() {
    let dpi = this.getDPI();
    let canvas = this.canvas;
    let r = this.getDefault("circleSize");
    let w = this.getDefault("width");
    let h = this.getDefault("height");

    //r = ~~(r*dpi);

    return getFieldImage(this.getDefault("fieldSize"), w - r*2, h - r*2, this.hsva);
  }

  update(force_update = false) {
    super.update();

    if (force_update) {
      this._redraw();
    }
  }

  _redraw() {
    let g = this.g, canvas = this.canvas;
    let dpi = this.getDPI();

    let w = this.getDefault("width");
    let h = this.getDefault("height");

    canvas.width = ~~(w*dpi);
    canvas.height = ~~(h*dpi);

    canvas.style["width"] = w + "px";
    canvas.style["height"] = h + "px";
    //SatValField

    let rselector = ~~(this.getDefault("circleSize")*dpi);

    let field = this._getField();
    let image = field.canvas;

    g.globalAlpha = 1.0;
    g.beginPath();
    g.rect(0, 0, canvas.width, canvas.height);
    g.fillStyle = "rgb(200, 200, 200)";
    g.fill();

    g.beginPath();

    let steps = 17;
    let dx = canvas.width/steps;
    let dy = canvas.height/steps;

    for (let i = 0; i < steps*steps; i++) {
      let x = (i%steps)*dx, y = (~~(i/steps))*dy;

      if (i%2 === 0) {
        continue;
      }
      g.rect(x, y, dx, dy);
    }

    g.fillStyle = "rgb(110, 110, 110)";
    g.fill();

    g.globalAlpha = this.hsva[3];
    g.drawImage(image, 0, 0, image.width, image.height, rselector, rselector, canvas.width - rselector*2, canvas.height - rselector*2);

    let hsva = this.hsva;

    let x = field.sat2x(hsva[1])*dpi + rselector;
    let y = field.val2y(hsva[2])*dpi + rselector;
    let r = rselector;

    g.beginPath();
    g.arc(x, y, r, -Math.PI, Math.PI);
    g.closePath();

    g.strokeStyle = "white";
    g.lineWidth = 3*dpi;
    g.stroke();

    g.strokeStyle = "grey";
    g.lineWidth = 1*dpi;
    g.stroke();

    if (this.disabled) {
      g.beginPath();
      g.fillStyle = "rgba(25,25,25,0.75)";
      g.rect(0, 0, this.canvas.width, this.canvas.height);
      g.fill();
    }
  }

  on_disabled() {
    this._redraw();
  }

  on_enabled() {
    this._redraw();
  }
}

UIBase$c.internalRegister(SatValField);

class ColorField extends ColumnFrame {
  constructor() {
    super();

    this.hsva = new Vector4$2([0.05, 0.6, 0.15, 1.0]);
    this.rgba = new Vector4$2([0, 0, 0, 0]);

    this._recalcRGBA();

    this._lastThemeStyle = this.constructor.define().style;

    /*
    this.hbox = new SimpleBox();
    this.svbox = new SimpleBox();
    //*/

    this._last_dpi = undefined;

    let satvalfield = this.satvalfield = UIBase$c.createElement("satvalfield-x");
    satvalfield.hsva = this.hsva;

    let huefield = this.huefield = UIBase$c.createElement("huefield-x");
    huefield.hsva = this.hsva;

    huefield.onchange = (e) => {
      this.satvalfield._redraw();
      this._recalcRGBA();

      if (this.onchange) {
        this.onchange(this.rgba);
      }
    };

    satvalfield.onchange = (e) => {
      this._recalcRGBA();

      if (this.onchange) {
        this.onchange(this.rgba);
      }
    };

    this._add(satvalfield);
    this._add(huefield);
    //this.shadow.appendChild(canvas);
    //this.shadow.appendChild(huecanvas);
  }

  static define() {
    return {
      tagname: "colorfield-x",
      style  : "colorfield"
    };
  }

  setCMYK(c, m, y, k) {
    let rgb = cmyk_to_rgb(c, m, y, k);
    let hsv = rgb_to_hsv(rgb[0], rgb[1], rgb[2]);

    this.setHSVA(hsv[0], hsv[1], hsv[2], this.hsva[3]);
  }

  getCMYK() {
    let rgb = hsv_to_rgb(this.hsva[0], this.hsva[1], this.hsva[2]);
    return rgb_to_cmyk(rgb[0], rgb[1], rgb[2]);
  }

  setHSVA(h, s, v, a = 1.0, fire_onchange = true) {
    this.hsva[0] = h;
    this.hsva[1] = s;
    this.hsva[2] = v;
    this.hsva[3] = a;

    this._recalcRGBA();
    this.update(true);

    if (this.onchange && fire_onchange) {
      this.onchange(this.hsva, this.rgba);
    }
  }

  _recalcRGBA() {
    let ret = hsv_to_rgb(this.hsva[0], this.hsva[1], this.hsva[2]);

    this.rgba[0] = ret[0];
    this.rgba[1] = ret[1];
    this.rgba[2] = ret[2];
    this.rgba[3] = this.hsva[3];

    return this;
  }

  updateDPI(force_update = false, _in_update = false) {
    let dpi = this.getDPI();

    let update = force_update;
    update = update || dpi != this._last_dpi;

    if (update) {
      this._last_dpi = dpi;

      if (!_in_update)
        this._redraw();

      return true;
    }
  }

  getRGBA() {
    let rgb = hsv_to_rgb(this.hsva[0], this.hsva[1], this.hsva[2]);
    return new Vector4$2().loadXYZW(rgb[0], rgb[1], rgb[2], this.hsva[3]);
  }

  setRGBA(r, g, b, a = 1.0, fire_onchange = true) {
    if (typeof r === "object") {
      g = r[1];
      b = r[2];
      a = r[3];
      r = r[0];
    }

    let hsv = rgb_to_hsv(r, g, b);

    this.hsva[0] = hsv[0];
    this.hsva[1] = hsv[1];
    this.hsva[2] = hsv[2];
    this.hsva[3] = a;

    this._recalcRGBA();
    this.update(true);

    if (this.onchange && fire_onchange) {
      this.onchange(this.hsva, this.rgba);
    }
  }

  updateThemeOverride() {
    let theme = this.getStyleClass();
    if (theme === this._lastThemeStyle) {
      return false;
    }

    this._lastThemeStyle = theme;
    this.huefield.overrideClass(theme);
    this.satvalfield.overrideClass(theme);

    for (let i=0; i<3; i++) {
      this.flushSetCSS();
      this.flushUpdate();
    }

    return true;
  }

  update(force_update = false) {
    super.update();

    this.updateThemeOverride();

    let redraw = this.updateDPI(force_update, true);
    redraw = redraw || force_update;

    if (redraw) {
      this.satvalfield.update(true);
      this._redraw();
    }
  }

  setCSS() {
    super.setCSS();

    this.style["flex-grow"] = this.getDefault("flex-grow");
  }

  _redraw() {
    this.satvalfield._redraw();
    this.huefield._redraw();
  }
}

UIBase$c.internalRegister(ColorField);

class ColorPicker extends ColumnFrame {
  constructor() {
    super();

    this._lastThemeStyle = this.constructor.define().style;
  }

  //*
  get hsva() {
    return this.field.hsva;
  }

  get rgba() {
    return this.field.rgba;
  }//*/

  set description(val) {
    //do not allow setting description of the colorpicker container
  }

  static setDefault(node) {
    let tabs, colorsPanel = node;

    if (node.getClassDefault("usePanels")) {
      let panel = colorsPanel = node.panel("Color");
      tabs = panel.tabs();
      panel.closed = true;

      panel.style["flex-grow"] = "unset";

      /* force compactness */
      panel.titleframe.style["flex-grow"] = "unset";
      //panel.titleframe.style["align-items"] = "unset";
    } else {
      tabs = node.tabs();
    }

    node.cssText = node.textbox();
    node.cssText.onchange = (val) => {
      let ok = validateWebColor(val);
      if (!ok) {
        node.cssText.flash("red");
        return;
      } else {
        node.cssText.flash("green");
      }

      val = val.trim();

      let color = web2color(val);

      node._no_update_textbox = true;
      node.field.setRGBA(color[0], color[1], color[2], color[3]);
      node._setSliders();

      node._no_update_textbox = false;
    };

    //tabs.overrideDefault("background-color", node.getDefault("background-color"));

    let tab = tabs.tab("HSV");

    node.h = tab.slider(undefined, "Hue", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let hsva = node.hsva;
      node.setHSVA(e.value, hsva[1], hsva[2], hsva[3]);
    });

    node.s = tab.slider(undefined, "Saturation", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let hsva = node.hsva;
      node.setHSVA(hsva[0], e.value, hsva[2], hsva[3]);
    });
    node.v = tab.slider(undefined, "Value", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let hsva = node.hsva;
      node.setHSVA(hsva[0], hsva[1], e.value, hsva[3]);
    });
    node.a = tab.slider(undefined, "Alpha", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let hsva = node.hsva;
      node.setHSVA(hsva[0], hsva[1], hsva[2], e.value);
    });

    node.h.baseUnit = node.h.displayUnit = "none";
    node.s.baseUnit = node.s.displayUnit = "none";
    node.v.baseUnit = node.v.displayUnit = "none";
    node.a.baseUnit = node.a.displayUnit = "none";

    tab = tabs.tab("RGB");

    node.r = tab.slider(undefined, "R", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let rgba = node.rgba;
      node.setRGBA(e.value, rgba[1], rgba[2], rgba[3]);
    });
    node.g = tab.slider(undefined, "G", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let rgba = node.rgba;
      node.setRGBA(rgba[0], e.value, rgba[2], rgba[3]);
    });
    node.b = tab.slider(undefined, "B", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let rgba = node.rgba;
      node.setRGBA(rgba[0], rgba[1], e.value, rgba[3]);
    });
    node.a2 = tab.slider(undefined, "Alpha", 0.0, 0.0, 1.0, 0.001, false, true, (e) => {
      let rgba = node.rgba;
      node.setRGBA(rgba[0], rgba[1], rgba[2], e.value);
    });

    node.r.baseUnit = node.r.displayUnit = "none";
    node.g.baseUnit = node.g.displayUnit = "none";
    node.b.baseUnit = node.b.displayUnit = "none";
    node.a2.baseUnit = node.a2.displayUnit = "none";

    if (!node.getDefault("noCMYK")) {
      tab = tabs.tab("CMYK");
      let cmyk = node.getCMYK();

      let makeCMYKSlider = (label, idx) => {
        let slider = tab.slider(undefined, {
          name      : label,
          min       : 0.0,
          max       : 1.0,
          is_int    : false,
          defaultval: cmyk[idx],
          callback  : (e) => {
            let cmyk = node.getCMYK();
            cmyk[idx] = e.value;
            node.setCMYK(cmyk[0], cmyk[1], cmyk[2], cmyk[3]);
          },
          step      : 0.001
        });

        slider.baseUnit = slider.displayUnit = "none";

        return slider;
      };

      node.cmyk = [
        makeCMYKSlider("C", 0),
        makeCMYKSlider("M", 1),
        makeCMYKSlider("Y", 2),
        makeCMYKSlider("K", 3),
      ];
    }

    node._setSliders();
  }

  static define() {
    return {
      tagname            : "colorpicker-x",
      style              : "colorfield",
      havePickClipboard  : true,
      copyForAllChildren : true,
      pasteForAllChildren: true,
    };
  }

  clipboardCopy() {
    colorClipboardCopy.apply(this, arguments);
  }

  clipboardPaste() {
    colorClipboardPaste.apply(this, arguments);
  }

  init() {
    super.init();

    this.field = UIBase$c.createElement("colorfield-x");
    this.field.setAttribute("class", "colorpicker");

    this.field.packflag |= this.inherit_packflag;
    this.field.packflag |= this.packflag;

    this.field.onchange = () => {
      this._setDataPath();
      this._setSliders();

      if (this.onchange) {
        this.onchange(this.field.rgba);
      }
    };

    let style = document.createElement("style");
    style.textContent = `
      .colorpicker {
        background-color : ${this.getDefault("background-color")};
      }
    `;

    this._style = style;

    let cb = this.colorbox = document.createElement("div");
    cb.style["width"] = "100%";
    cb.style["height"] = this.getDefault("colorBoxHeight") + "px";
    cb.style["background-color"] = "black";

    this.shadow.appendChild(style);
    this.field.ctx = this.ctx;

    this.add(this.colorbox);
    this.add(this.field);

    this.style["width"] = this.getDefault("width") + "px";
  }

  updateColorBox() {
    let r = this.field.rgba[0], g = this.field.rgba[1], b = this.field.rgba[2];
    //let a = this.field.rgba[3];

    r = ~~(r*255);
    g = ~~(g*255);
    b = ~~(b*255);

    let css = `rgb(${r},${g},${b})`;
    this.colorbox.style["background-color"] = css;
  }

  _setSliders() {
    if (this.h === undefined) {
      //setDefault() wasn't called
      console.warn("colorpicker ERROR");
      return;
    }

    let hsva = this.field.hsva;
    this.h.setValue(hsva[0], false);
    this.s.setValue(hsva[1], false);
    this.v.setValue(hsva[2], false);
    this.a.setValue(hsva[3], false);

    let rgba = this.field.rgba;

    this.r.setValue(rgba[0], false);
    this.g.setValue(rgba[1], false);
    this.b.setValue(rgba[2], false);
    this.a2.setValue(rgba[3], false);

    if (this.cmyk) {
      let cmyk = this.field.getCMYK();

      for (let i = 0; i < 4; i++) {
        this.cmyk[i].setValue(cmyk[i], false);
      }
    }

    this.updateColorBox();

    if (!this._no_update_textbox) {
      this.cssText.text = color2web(this.field.rgba);
    }
  }

  updateDataPath() {
    if (!this.hasAttribute("datapath")) {
      return;
    }

    let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));
    let val = this.getPathValue(this.ctx, this.getAttribute("datapath"));

    if (val === undefined) {
      //console.warn("Bad datapath", this.getAttribute("datapath"));
      this.internalDisabled = true;
      return;
    }

    this.internalDisabled = false;

    _update_temp.load(val);

    if (prop.type === PropTypes.VEC3) {
      _update_temp[3] = 1.0;
    }

    if (_update_temp.vectorDistance(this.field.rgba) > 0.01) {
      this.field.setRGBA(_update_temp[0], _update_temp[1], _update_temp[2], _update_temp[3], false);
      this._setSliders();
      this.field.update(true);
    }
  }

  updateThemeOverride() {
    let theme = this.getStyleClass();
    if (theme === this._lastThemeStyle) {
      return false;
    }

    this._lastThemeStyle = theme;
    this.field.overrideClass(theme);

    this.flushSetCSS();
    this.flushUpdate();

    return true;
  }

  update() {
    this.updateThemeOverride();

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }

    super.update();
  }

  _setDataPath() {
    if (this.hasAttribute("datapath")) {
      let prop = this.getPathMeta(this.ctx, this.getAttribute("datapath"));

      if (prop === undefined) {
        console.warn("Bad data path for color field:", this.getAttribute("datapath"));
      }

      let val = this.field.rgba;
      if (prop !== undefined && prop.type === PropTypes.VEC3) {
        val = new Vector3$2();
        val.load(this.field.rgba);
      }

      this.setPathValue(this.ctx, this.getAttribute("datapath"), val);
    }
  }

  getCMYK() {
    return this.field.getCMYK();
  }

  setCMYK(c, m, y, k) {
    this.field.setCMYK(c, m, y, k);
    this._setSliders();
    this._setDataPath();
  }

  setHSVA(h, s, v, a) {
    this.field.setHSVA(h, s, v, a);
    this._setSliders();
    this._setDataPath();
  }

  getRGBA() {
    return this.field.getRGBA();
  }

  setRGBA(r, g, b, a) {
    this.field.setRGBA(r, g, b, a);
    this._setSliders();
    this._setDataPath();
  }
}

UIBase$c.internalRegister(ColorPicker);


class ColorPickerButton extends UIBase$c {
  constructor() {
    super();

    this._highlight = false;
    this._depress = false;
    this._label = "error";

    this.customLabel = undefined;

    this.rgba = new Vector4$2([1, 1, 1, 1]);

    this.labelDom = document.createElement("span");
    this.labelDom.textContent = this._label;
    this.dom = document.createElement("canvas");
    this.g = this.dom.getContext("2d");

    this.shadow.appendChild(this.labelDom);
    this.shadow.appendChild(this.dom);
  }

  get label() {
    return this._label;
  }

  set label(val) {
    this._label = val;
    this.labelDom.textContent = val;
  }

  get font() {
    return this._font;
  }

  set font(val) {
    this._font = val;

    this.setCSS();
  }

  get noLabel() {
    let ret = "" + this.getAttribute("no-label");
    ret = ret.toLowerCase();

    return ret === "true" || ret === "yes" || ret === "on";
  }

  set noLabel(v) {
    this.setAttribute("no-label", v ? "true" : "false");
  }

  static define() {
    return {
      tagname          : "color-picker-button-x",
      style            : "colorpickerbutton",
      havePickClipboard: true
    }
  }

  init() {
    super.init();
    this._font = "DefaultText"; //this.getDefault("defaultFont");

    let enter = (e) => {
      this._highlight = true;
      this._redraw();
    };

    let leave = (e) => {
      this._highlight = false;
      this._redraw();
    };

    this.addEventListener("pointerover", enter, {capture: true, passive: true});
    this.addEventListener("pointerout", leave, {capture: true, passive: true});
    this.addEventListener("focus", leave, {capture: true, passive: true});


    this.addEventListener("mousedown", (e) => {
      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();

      this.click(e);
    });

    this.setCSS();
  }

  clipboardCopy() {
    colorClipboardCopy.apply(this, arguments);
  }

  clipboardPaste() {
    colorClipboardPaste.apply(this, arguments);
  }

  getRGBA() {
    return this.rgba;
  }

  click(e) {
    this.abortToolTips(4000);
    console.warn("CLICK COLORPICKER");
    this.blur();

    if (this.onclick) {
      this.onclick(e);
    }

    let colorpicker = this.ctx.screen.popup(this, this);
    let ctx = contextWrangler.makeSafeContext(this.ctx);

    colorpicker.ctx = ctx;
    colorpicker.useDataPathUndo = this.useDataPathUndo;

    let path = this.hasAttribute("datapath") ? this.getAttribute("datapath") : undefined;

    let widget = colorpicker.colorPicker(path, undefined, this.getAttribute("mass_set_path"));

    widget.ctx = ctx;
    widget._init();
    widget.setRGBA(this.rgba[0], this.rgba[1], this.rgba[2], this.rgba[3]);

    widget.style["padding"] = "20px";

    let onchange = () => {
      this.rgba.load(widget.rgba);
      this.redraw();

      if (this.onchange) {
        this.onchange(this);
      }
    };

    widget.onchange = onchange;

    colorpicker.style["background-color"] = widget.getDefault("background-color");
    //colorpicker.style["border-radius"] = "25px";
    colorpicker.style["border-width"] = widget.getDefault("border-width");
  }

  setRGBA(val) {
    let a = this.rgba[3];

    let old = new Vector4$2(this.rgba);

    this.rgba.load(val);

    if (val.length < 4) {
      this.rgba[3] = a;
    }

    if (this.rgba.vectorDistance(old) < 0.001) {
      return;
    }

    if (this.hasAttribute("datapath")) {
      this.setPathValue(this.ctx, this.getAttribute("datapath"), this.rgba);
    }

    if (this.onchange) {
      this.onchange();
    }

    this._redraw();
    return this;
  }

  on_disabled() {
    this.setCSS();
    this._redraw();
  }

  _redraw() {
    let canvas = this.dom, g = this.g;

    g.clearRect(0, 0, canvas.width, canvas.height);

    if (this.disabled) {
      let color = "rgb(55, 55, 55)";

      g.save();

      drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "fill", color);
      drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "clip");
      let steps = 5;
      let dt = canvas.width/steps, t = 0;

      g.beginPath();
      g.lineWidth = 2;
      g.strokeStyle = "black";

      for (let i = 0; i < steps; i++, t += dt) {
        g.moveTo(t, 0);
        g.lineTo(t + dt, canvas.height);
        g.moveTo(t + dt, 0);
        g.lineTo(t, canvas.height);
      }

      g.stroke();
      g.restore();
      return;
    }

    //do checker pattern for alpha
    g.save();

    let grid1 = "rgb(100, 100, 100)";
    let grid2 = "rgb(175, 175, 175)";

    drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "clip");
    drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "fill", grid1);

    let cellsize = 10;
    let totx = Math.ceil(canvas.width/cellsize), toty = Math.ceil(canvas.height/cellsize);

    drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "clip", undefined, undefined, true);
    g.clip();

    g.beginPath();
    for (let x = 0; x < totx; x++) {
      for (let y = 0; y < toty; y++) {
        if ((x + y) & 1) {
          continue;
        }

        g.rect(x*cellsize, y*cellsize, cellsize, cellsize);
      }
    }

    g.fillStyle = grid2;
    g.fill();

    //g.fillStyle = "orange";
    //g.beginPath();
    //g.rect(0, 0, canvas.width, canvas.height);
    //g.fill();

    let color = color2css(this.rgba);
    drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "fill", color, undefined, true);
    //drawRoundBox(elem, canvas, g, width, height, r=undefined, op="fill", color=undefined, pad=undefined) {

    if (this._highlight) {
      //let color = "rgba(200, 200, 255, 0.5)";
      let color = this.getDefault("BoxHighlight");
      drawRoundBox(this, canvas, g, canvas.width, canvas.height, undefined, "fill", color);
    }

    g.restore();
  }

  setCSS() {
    super.setCSS();

    let w = this.getDefault("width");
    let h = this.getDefault("height");
    let dpi = this.getDPI();

    this.style["width"] = "min-contents" + "px";
    this.style["height"] = h + "px";

    this.style["flex-direction"] = "row";
    this.style["display"] = "flex";

    this.labelDom.style["color"] = this.getDefault(this._font).color;
    this.labelDom.style["font"] = getFont(this, undefined, this._font, false);

    let canvas = this.dom;

    canvas.style["width"] = w + "px";
    canvas.style["height"] = h + "px";
    canvas.width = ~~(w*dpi);
    canvas.height = ~~(h*dpi);

    this.style["background-color"] = "rgba(0,0,0,0)";
    this._redraw();
  }

  updateDataPath() {
    if (!(this.hasAttribute("datapath"))) {
      return;
    }

    let path = this.getAttribute("datapath");
    let prop = this.getPathMeta(this.ctx, path);

    if ((prop === undefined || prop.data === undefined) && exports.DEBUG.verboseDataPath) {
      console.log("bad path", path);
      return;
    } else if (prop === undefined) {
      let redraw = !this.disabled;

      this.internalDisabled = true;

      if (redraw) {
        this._redraw();
      }
      return;
    }

    let redraw = this.disabled;

    this.internalDisabled = false;

    if (this.customLabel === undefined && prop.uiname !== this._label) {
      this.label = prop.uiname;
    }

    let val = this.getPathValue(this.ctx, path);

    if (val === undefined) {
      redraw = redraw || this.disabled !== true;

      this.internalDisabled = true;

      if (redraw) {
        this._redraw();
      }

    } else {
      this.internalDisabled = false;

      let dis;

      if (val.length === 3) {
        dis = Vector3$2.prototype.vectorDistance.call(val, this.rgba);
      } else {
        dis = this.rgba.vectorDistance(val);
      }

      if (dis > 0.0001) {
        if (prop.type === PropTypes.VEC3) {
          this.rgba.load(val);
          this.rgba[3] = 1.0;
        } else {
          this.rgba.load(val);
        }

        redraw = true;
      }

      if (redraw) {
        this._redraw();
      }
    }
  }

  update() {
    super.update();

    if (this.noLabel && this.labelDom.isConnected) {
      this.labelDom.remove();
    }

    if (this.customLabel !== undefined && this.customLabel !== this._label) {
      this.label = this.customLabel;
    }

    for (let i = 0; i < this.rgba.length; i++) {
      if (this.rgba[i] === undefined) {
        console.warn("corrupted color or alpha detected", this.rgba);
        this.rgba[i] = 1.0;
      }
    }

    let key = "" + this.rgba[0].toFixed(4) + " " + this.rgba[1].toFixed(4) + " " + this.rgba[2].toFixed(4) + " " + this.rgba[3].toFixed(4);
    key += this.disabled;

    if (key !== this._last_key) {
      this._last_key = key;
      this.redraw();
    }

    if (this.hasAttribute("datapath")) {
      this.updateDataPath();
    }
  }

  redraw() {
    this._redraw();
  }
};
UIBase$c.internalRegister(ColorPickerButton);

"use strict";

let UIBase$d      = UIBase$2,
    PackFlags$8   = PackFlags,
    IconSheets$6  = IconSheets,
    iconmanager$1 = iconmanager;

let tab_idgen = 1;
let debug$1 = false;
let Vector2$9 = Vector2;

function getpx$1(css) {
  return parseFloat(css.trim().replace("px", ""))
}

let FAKE_TAB_ID = Symbol("fake_tab_id");


class TabDragEvent extends PointerEvent {
}


/* subclass HTMLElement so tabs can be used as the .target
*  member of events*/
class TabItem extends UIBase$d {
  constructor() {
    super();

    this.name = name;
    this.icon = undefined;
    this.tooltip = "";
    this.movable = true;
    this.tbar = undefined;

    this.ontabclick = null;
    this.ontabdragstart = null;
    this.ontabdragmove = null;
    this.ontabdragend = null;

    let helper = (key) => {
      let key2 = "on" + key;

      this.addEventListener(key, (e) => {
        if (this[key2]) {
          return this[key2](e);
        }
      });
    };

    helper("tabclick");
    helper("tabdragstart");
    helper("tabdragmove");
    helper("tabdragend");

    this.dom = undefined;
    this.extra = undefined;
    this.extraSize = undefined;

    this.size = new Vector2$9();
    this.pos = new Vector2$9();

    this.abssize = new Vector2$9();
    this.abspos = new Vector2$9();

    this.addEventListener("pointerdown", (e) => {
      this.parentWidget.on_pointerdown(e);
    });

    this.addEventListener("pointermove", (e) => {
      this.parentWidget.on_pointermove(e);
    });

    this.addEventListener("pointerup", (e) => {
      this.parentWidget.on_pointerup(e);
    });
  }

  static define() {
    return {
      tagname: "tab-item-x"
    }
  }

  sendEvent(type, forwardEvent) {
    let cls;

    if (type === "tabdragstart" || type === "tabdragend") {
      cls = TabDragEvent;
    } else if (forwardEvent && forwardEvent instanceof Event) {
      cls = forwardEvent.constructor;
    } else {
      cls = PointerEvent;
    }

    let e2 = {};

    if (forwardEvent) {
      for (let k in forwardEvent) {
        if (k === "defaultPrevented" || k === "cancelBubble") {
          continue;
        }

        e2[k] = forwardEvent[k];
      }
    }

    e2.target = this;

    e2 = new cls(type, e2);

    this.dispatchEvent(e2);
    return e2;
  }

  getClientRects() {
    let r = this.tbar.getClientRects()[0];

    let s = this.abssize, p = this.abspos;

    s.load(this.size);
    p.load(this.pos);

    if (r) {
      p[0] += r.x;
      p[1] += r.y;
    }

    return [{
      x  : p[0], y: p[1], width: s[0], height: s[1], left: p[0],
      top: p[1], right: p[0] + s[0], bottom: p[1] + s[1]
    }];
  }

  setCSS() {
    let dpi = UIBase$d.getDPI();
    let x = this.pos[0]/dpi;
    let y = this.pos[1]/dpi;
    let w = this.size[0]/dpi;
    let h = this.size[1]/dpi;

    this.style["background-color"] = "transparent";

    this.style["margin"] = this.style["padding"] = "0px";
    this.style["position"] = "absolute";
    this.style["pointer-events"] = "auto";

    this.style["left"] = x + "px";
    this.style["top"] = y + "px";
    this.style["width"] = w + "px";
    this.style["height"] = h + "px";
  }
}
UIBase$d.internalRegister(TabItem);

class ModalTabMove extends EventHandler {
  constructor(tab, tbar, dom) {
    super();

    this.dom = dom;
    this.tab = tab;
    this.tbar = tbar;
    this.first = true;

    this.droptarget = undefined;
    this.start_mpos = new Vector2$9();
    this.mpos = undefined;

    this.dragtab = undefined;
    this.dragstate = false;
    this.finished = false;
  }

  finish() {
    if (debug$1) if (debug$1) console.log("finish");

    if (this.finished) {
      return;
    }

    this.finished = true;

    if (this.tbar.tool === this) {
      this.tbar.tool = undefined;
    }

    this.popModal(this.dom);
    this.tbar.update(true);
  }

  popModal() {
    if (this.dragcanvas !== undefined) {
      this.dragcanvas.remove();
    }
    let ret = super.popModal(...arguments);

    this.tab.sendEvent("tabdragend");

    return ret;
  }

  on_pointerleave(e) {
  }
  on_pointerenter(e) {
  }
  on_pointerenter(e) {
  }
  on_pointerstart(e) {
  }
  on_pointerend(e) {
  }

  on_pointerdown(e) {
    this.finish();
  }

  on_pointercancel(e) {
    this.finish();
  }

  on_pointerup(e) {
    this.finish();
  }

  on_pointermove(e) {
    return this._on_move(e, e.x, e.y);
  }

  _dragstate(e, x, y) {
    this.dragcanvas.style["left"] = x + "px";
    this.dragcanvas.style["top"] = y + "px";

    let ctx = this.tbar.ctx;
    let screen = ctx.screen;
    let elem = screen.pickElement(x, y);

    let e2 = new DragEvent("dragenter", this.dragevent);
    if (elem !== this.droptarget) {
      let e2 = new DragEvent("dragexit", this.dragevent);
      if (this.droptarget) {
        this.droptarget.dispatchEvent(e2);
      }

      e2 = new DragEvent("dragover", this.dragevent);
      this.droptarget = elem;
      if (elem) {
        elem.dispatchEvent(e2);
      }
    }
    //console.log(elem);
  }

  _on_move(e, x, y) {
    let r = this.tbar.getClientRects()[0];
    let dpi = UIBase$d.getDPI();

    if (r === undefined) {
      //element was removed during/before move
      this.finish();
      return;
    }

    if (this.dragstate) {
      this._dragstate(e, x, y);
      return;
    }

    x -= r.x;
    y -= r.y;

    let dx, dy;

    x *= dpi;
    y *= dpi;

    if (this.first) {
      this.first = false;
      this.start_mpos[0] = x;
      this.start_mpos[1] = y;
    }
    if (this.mpos === undefined) {
      this.mpos = [0, 0];
      dx = dy = 0;
    } else {
      dx = x - this.mpos[0];
      dy = y - this.mpos[1];
    }

    if (debug$1) console.log(x, y, dx, dy);

    let tab = this.tab, tbar = this.tbar;
    let axis = tbar.horiz ? 0 : 1;
    let distx, disty;

    if (tbar.horiz) {
      tab.pos[0] += dx;
      disty = Math.abs(y - this.start_mpos[1]);
    } else {
      tab.pos[1] += dy;
      disty = Math.abs(x - this.start_mpos[0]);
    }

    let limit = 50;
    let csize = tbar.horiz ? this.tbar.canvas.width : this.tbar.canvas.height;

    let dragok = tab.pos[axis] + tab.size[axis] < -limit || tab.pos[axis] >= csize + limit;
    dragok = dragok || disty > limit*1.5;
    dragok = dragok && (this.tbar.draggable || this.tbar.getAttribute("draggable"));

    //console.log(dragok, disty, this.tbar.draggable);

    if (dragok) {
      this.dragstate = true;
      this.dragevent = new DragEvent("dragstart", {
        dataTransfer: new DataTransfer()
      });

      this.dragtab = tab;
      let g = this.tbar.g;
      this.dragimg = g.getImageData(~~tab.pos[0], ~~tab.pos[1], ~~tab.size[0], ~~tab.size[1]);
      this.dragcanvas = document.createElement("canvas");
      let g2 = this.drag_g = this.dragcanvas.getContext("2d");

      this.dragcanvas.visibleToPick = false;
      this.dragcanvas.width = ~~tab.size[0];
      this.dragcanvas.height = ~~tab.size[1];
      this.dragcanvas.style["width"] = (tab.size[0]/dpi) + "px";
      this.dragcanvas.style["height"] = (tab.size[1]/dpi) + "px";
      this.dragcanvas.style["position"] = UIBase$d.PositionKey;
      this.dragcanvas.style["left"] = e.x + "px";
      this.dragcanvas.style["top"] = e.y + "px";
      this.dragcanvas.style["z-index"] = "500";
      document.body.appendChild(this.dragcanvas);
      g2.putImageData(this.dragimg, 0, 0);


      this.tbar.dispatchEvent(this.dragevent);

      return;
    }

    let ti = tbar.tabs.indexOf(tab);
    let next = ti < tbar.tabs.length - 1 ? tbar.tabs[ti + 1] : undefined;
    let prev = ti > 0 ? tbar.tabs[ti - 1] : undefined;

    if (next !== undefined && next.movable && tab.pos[axis] > next.pos[axis]) {
      tbar.swapTabs(tab, next);
    } else if (prev !== undefined && prev.movable && tab.pos[axis] < prev.pos[axis] + prev.size[axis]*0.5) {
      tbar.swapTabs(tab, prev);
    }

    tbar.update(true);

    this.mpos[0] = x;
    this.mpos[1] = y;

    let e2 = tab.sendEvent("tabdragmove", e);

    if (e2.defaultPrevented) {
      this.finish();
    }
  }

  on_keydown(e) {
    if (debug$1) console.log(e.keyCode);

    switch (e.keyCode) {
      case 27: //escape
      case 32: //space
      case 13: //enter
      case 9: //tab
        this.finish();
        break;
    }
  }
}

class TabBar extends UIBase$d {
  constructor() {
    super();

    let style = document.createElement("style");
    let canvas = document.createElement("canvas");

    this.iconsheet = 0;
    this.movableTabs = true;

    this.tabFontScale = 1.0;

    this.tabs = [];
    this.tabs.active = undefined;
    this.tabs.highlight = undefined;

    this._last_style_key = undefined;

    canvas.style["width"] = "145px";
    canvas.style["height"] = "45px";

    this.r = 8;

    this.canvas = canvas;
    this.g = canvas.getContext("2d");

    this.canvas.style["touch-action"] = "none";

    style.textContent = `
    `;

    this.shadow.appendChild(style);
    this.shadow.appendChild(canvas);

    this._last_dpi = undefined;
    this._last_pos = undefined;

    this.horiz = true;
    this.onchange = null;
    this.onselect = null; //onselect is like onchange, but fires even if tab hasn't changed

    let mx, my;

    this.canvas.addEventListener("pointermove", (e) => {
      this.on_pointermove(e);
    }, false);


    this.canvas.addEventListener("pointerdown", (e) => {
      this.on_pointerdown(e);
    });
  }

  _doelement(e, mx, my){
    for (let tab of this.tabs) {
      let ok;

      if (this.horiz) {
        ok = mx >= tab.pos[0] && mx <= tab.pos[0] + tab.size[0];
      } else {
        ok = my >= tab.pos[1] && my <= tab.pos[1] + tab.size[1];
      }

      if (ok && this.tabs.highlight !== tab) {
        this.tabs.highlight = tab;
        this.update(true);
      }
    }
  }

  _domouse (e) {
    let r = this.canvas.getClientRects()[0];

    let mx = e.x - r.x;
    let my = e.y - r.y;

    let dpi = this.getDPI();

    mx *= dpi;
    my *= dpi;

    this._doelement(e, mx, my);

    const is_mdown = e.type === "mousedown";
    if (is_mdown && this.onselect && this._fireOnSelect().defaultPrevented) {
      e.preventDefault();
    }
  }

  _doclick (e) {
    this._domouse(e);

    if (e.defaultPrevented) {
      return;
    }

    if (debug$1) console.log("mdown");

    if (e.button !== 0) {
      return;
    }

    let ht = this.tabs.highlight;

    let acte = {};
    for (let k in e) {
      if (k === "defaultPrevented" || k === "cancelBubble") {
        continue;
      }

      acte[k] = e[k];
    }

    acte.target = ht;
    acte.pointerId = e.pointerId;

    acte = new PointerEvent("tabactive", acte);

    let e2 = ht.sendEvent("tabclick", e);

    if (e2.defaultPrevented) {
      acte.preventDefault();
    }

    if (ht !== undefined && this.tool === undefined) {
      this.setActive(ht, acte);

      if (this.movableTabs && !acte.defaultPrevented) {
        this._startMove(ht, e);
      }

      e.preventDefault();
      e.stopPropagation();
    }
  }

  on_pointerdown(e) {
    this._doclick(e);
  }

  on_pointermove(e) {
    let r = this.canvas.getClientRects()[0];
    this._domouse(e);

    e.preventDefault();
    e.stopPropagation();
  }

  on_pointerup(e) {

  }


  static setDefault(e) {
    e.setAttribute("bar_pos", "top");
    e.updatePos(true);

    return e;
  }

  static define() {
    return {
      tagname: "tabbar-x",
      style  : "tabs"
    };
  }

  _ensureNoModal() {
    if (this.tool) {
      this.tool.finish();
      this.tool = undefined;
    }
  }

  get tool() {
    return this._tool;
  }

  set tool(v) {
    //console.warn("SET TOOL", v, this._id);
    this._tool = v;
  }

  _startMove(tab=this.tabs.active, event, pointerId=event ? event.pointerId : undefined, pointerElem=tab) {
    if (this.movableTabs) {
      let e2 = tab.sendEvent("tabdragstart", event);

      if (e2.defaultPrevented) {
        return;
      }

      if (this.tool) {
        this.tool.finish();
      }

      let edom = this.getScreen();
      let tool = this.tool = new ModalTabMove(tab, this, edom);

      if (event && pointerElem && pointerId !== undefined) {
        tool.pushPointerModal(pointerElem, pointerId);
      } else {
        tool.pushModal(edom, false);
      }
    }
  }

  _fireOnSelect() {
    let e = this._makeOnSelectEvt();

    if (this.onselect) {
      this.onselect(e);
    }

    return e;
  }

  _makeOnSelectEvt() {
    return {
      tab             : this.tabs.highlight,
      defaultPrevented: false,
      preventDefault() {
        this.defaultPrevented = true;
      }
    }
    /*
      return new MouseEvent("mousedown", {
        target : [this.tabs.highlight],
        tab : "sdfdsf"
      });

   */
  }

  getTab(name_or_id) {
    for (let tab of this.tabs) {
      if (tab.id === name_or_id || tab.name === name_or_id)
        return tab;
    }

    return undefined;
  }

  clear() {
    for (let t of this.tabs) {
      if (t.dom) {
        t.dom.remove();
        t.dom = undefined;
      }
    }

    this.tabs = [];
    this.setCSS();
    this._redraw();
  }

  saveData() {
    let taborder = [];

    for (let tab of this.tabs) {
      taborder.push(tab.name);
    }

    let act = this.tabs.active !== undefined ? this.tabs.active.name : "null";

    return {
      taborder: taborder,
      active  : act
    };
  }

  loadData(obj) {
    if (!obj.taborder) {
      return;
    }

    let tabs = this.tabs;
    let active = undefined;
    let ntabs = [];

    ntabs.active = undefined;
    ntabs.highlight = undefined;

    for (let tname of obj.taborder) {
      let tab = this.getTab(tname);

      if (tab === undefined) {
        continue;
      }

      if (tab.name === obj.active) {
        active = tab;
      }

      ntabs.push(tab);
    }

    for (let tab of tabs) {
      if (ntabs.indexOf(tab) < 0) {
        ntabs.push(tab);
      }
    }

    this.tabs = ntabs;

    try {
      if (active !== undefined) {
        this.setActive(active);
      } else {
        this.setActive(this.tabs[0]);
      }
    } catch (error) {
      print_stack$1(error);
    }

    this.update(true);

    return this;
  }

  swapTabs(a, b) {
    let tabs = this.tabs;

    let ai = tabs.indexOf(a);
    let bi = tabs.indexOf(b);

    tabs[ai] = b;
    tabs[bi] = a;

    this.update(true);
  }

  addIconTab(icon, id, tooltip, movable = true) {
    let tab = this.addTab("", id, tooltip, movable);
    tab.icon = icon;

    return tab;
  }

  addTab(name, id, tooltip = "", movable) {
    let tab = UIBase$d.createElement("tab-item-x", true);

    this.shadow.appendChild(tab);
    tab.parentWidget = this;


    tab.name = name;
    tab.id = id;
    tab.tooltip = tooltip;
    tab.movable = movable;
    tab.tbar = this;

    this.tabs.push(tab);
    this.update(true);

    if (this.tabs.length === 1) {
      this.setActive(this.tabs[0]);
    }

    return tab;
  }

  updatePos(force_update = false) {
    let pos = this.getAttribute("bar_pos");

    if (pos !== this._last_pos || force_update) {
      this._last_pos = pos;

      this.horiz = pos === "top" || pos === "bottom";
      if (debug$1) console.log("tab bar position update", this.horiz);

      if (this.horiz) {
        this.style["width"] = "100%";
        delete this.style["height"];
      } else {
        this.style["height"] = "100%";
        delete this.style["width"];
      }

      this._redraw();
    }
  }

  updateDPI(force_update = false) {
    let dpi = this.getDPI();

    if (dpi !== this._last_dpi) {
      if (debug$1) console.log("DPI update!");
      this._last_dpi = dpi;

      this.updateCanvas(true);
    }
  }

  updateCanvas(force_update = false) {
    let canvas = this.canvas;

    let dpi = this.getDPI();

    let rwidth = getpx$1(this.canvas.style["width"]);
    let rheight = getpx$1(this.canvas.style["height"]);

    let width = ~~(rwidth*dpi);
    let height = ~~(rheight*dpi);

    let update = force_update;
    update = update || canvas.width !== width || canvas.height !== height;

    if (update) {
      canvas.width = width;
      canvas.height = height;

      this._redraw();
    }
  }

  _getFont(tsize) {
    let font = this.getDefault("TabText");

    if (this.tabFontScale !== 1.0) {
      font = font.copy();
      font.size *= this.tabFontScale;
    }

    return font;
  }

  _layout() {
    if ((!this.ctx || !this.ctx.screen) && !this.isDead()) {
      this.doOnce(this._layout);
    }

    let g = this.g;

    if (debug$1) console.log("tab layout");

    let dpi = this.getDPI();

    let font = this._getFont();
    let tsize = (font.size*dpi);

    g.font = font.genCSS(tsize);

    let axis = this.horiz ? 0 : 1;

    let pad = 4*dpi + Math.ceil(tsize*0.25);
    let x = pad;
    let y = 0;

    let h = tsize + Math.ceil(tsize*0.5);
    let iconsize = iconmanager$1.getTileSize(this.iconsheet);
    let have_icons = false;

    for (let tab of this.tabs) {
      if (tab.icon !== undefined) {
        have_icons = true;
        h = Math.max(h, iconsize + 4);
        break;
      }
    }

    let r1 = this.parentWidget ? this.parentWidget.getClientRects()[0] : undefined;
    let r2 = this.canvas.getClientRects()[0];

    let rx = 0, ry = 0;
    if (r1 && r2) {
      rx = r2.x;//r2.x - r1.x;
      ry = r2.y; //r2.y - r1.y;
    }

    let ti = -1;

    let makeTabWatcher = (tab) => {
      if (tab.watcher) {
        clearInterval(tab.watcher.timer);
      }

      let watcher = () => {
        let dead = this.tabs.indexOf(tab) < 0;
        dead = dead || this.isDead();

        if (dead) {
          if (tab.dom)
            tab.dom.remove();
          tab.dom = undefined;

          if (tab.watcher.timer)
            clearInterval(tab.watcher.timer);
        }
      };

      tab.watcher = watcher;
      tab.watcher.timer = window.setInterval(watcher, 750);

      return tab.watcher.timer;
    };

    let haveTabDom = false;
    for (let tab of this.tabs) {
      if (tab.extra) {
        haveTabDom = true;
      }
    }

    if (haveTabDom && this.ctx && this.ctx.screen && !this._size_cb) {
      this._size_cb = () => {
        if (this.isDead()) {
          this.ctx.screen.removeEventListener("resize", this._size_cb);
          this._size_cb = undefined;
          return;
        }
        if (!this.ctx) return;

        this._layout();
        this._redraw();
      };

      this.ctx.screen.addEventListener("resize", this._size_cb);
    }

    for (let tab of this.tabs) {
      ti++;

      if (tab.extra && !tab.dom) {

        tab.dom = document.createElement("div");
        tab.dom.style["margin"] = tab.dom.style["padding"] = "0px";

        let z = this.calcZ();
        tab.dom.style["z-index"] = z + 1 + ti;

        document.body.appendChild(tab.dom);
        tab.dom.style["position"] = UIBase$d.PositionKey;
        tab.dom.style["display"] = "flex";
        tab.dom.style["flex-direction"] = this.horiz ? "row" : "column";

        tab.dom.style["pointer-events"] = "none";

        if (!this.horiz) {
          tab.dom.style["width"] = (tab.size[0]/dpi) + "px";
          tab.dom.style["height"] = (tab.size[1]/dpi) + "px";
          tab.dom.style["left"] = (rx + tab.pos[0]/dpi) + "px";
          tab.dom.style["top"] = (ry + tab.pos[1]/dpi) + "px";
        } else {
          tab.dom.style["width"] = (tab.size[0]/dpi) + "px";
          tab.dom.style["height"] = (tab.size[1]/dpi) + "px";
          tab.dom.style["left"] = (rx + tab.pos[0]/dpi) + "px";
          tab.dom.style["top"] = (ry + tab.pos[1]/dpi) + "px";
        }

        let font = this._getFont();
        tab.dom.style["font"] = font.genCSS();
        tab.dom.style["color"] = font.color;

        tab.dom.appendChild(tab.extra);

        //tab.dom.style["background-color"] = "red";

        makeTabWatcher(tab);
      }

      let w = g.measureText(tab.name).width;

      if (tab.extra) {
        w += tab.extraSize || tab.extra.getClientRects()[0].width;

      }

      if (tab.icon !== undefined) {
        w += iconsize;
      }

      //don't interfere with tab dragging
      let bad = this.tool !== undefined && tab === this.tabs.active;

      if (!bad) {
        tab.pos[axis] = x;
        tab.pos[axis ^ 1] = y;
      }

      //tab.size = [0, 0];
      tab.size[axis] = w + pad*2;
      tab.size[axis ^ 1] = h;

      x += w + pad*2;
    }

    x = (~~(x + pad))/dpi;
    h = (~~h)/dpi;


    if (this.horiz) {
      this.canvas.style["width"] = x + "px";
      this.canvas.style["height"] = h + "px";
    } else {
      this.canvas.style["height"] = x + "px";
      this.canvas.style["width"] = h + "px";
    }

    for (let tab of this.tabs) {
      tab.setCSS();
    }

    //this.canvas.width = x;
  }

  /** tab is a TabItem instance */
  setActive(tab, event) {
    if (tab.noSwitch) {
      return;
    }

    let update = tab !== this.tabs.active;
    this.tabs.active = tab;

    if (update) {
      if (this.onchange)
        this.onchange(tab, event);

      this.update(true);
    }
  }

  _redraw() {
    let g = this.g;

    let activecolor = this.getDefault("TabActive") || "rgba(0,0,0,0)";

    if (debug$1) console.log("tab draw");

    g.clearRect(0, 0, this.canvas.width, this.canvas.height);

    let dpi = this.getDPI();
    let font = this._getFont();

    let tsize = font.size;
    let iconsize = iconmanager$1.getTileSize(this.iconsheet);

    tsize = (tsize*dpi);
    g.font = font.genCSS(tsize);

    g.lineWidth = 2;
    g.strokeStyle = this.getDefault("TabStrokeStyle1");

    let r = this.r*dpi;
    this._layout();
    let tab;

    let ti = -1;
    for (tab of this.tabs) {
      ti++;

      if (tab === this.tabs.active)
        continue;

      let x = tab.pos[0], y = tab.pos[1];
      let w = tab.size[0], h = tab.size[1];
      //let tw = g.measureText(tab.name).width;
      let tw = measureText(this, tab.name, this.canvas, g, tsize, font).width;

      let x2 = x + (tab.size[this.horiz ^ 1] - tw)*0.5;
      let y2 = y + tsize;

      if (tab === this.tabs.highlight) {
        let p = 2;

        g.beginPath();
        g.rect(x + p, y + p, w - p*2, h - p*2);
        g.fillStyle = this.getDefault("TabHighlight");
        g.fill();
      }

      g.fillStyle = this.getDefault("TabText").color;

      if (!this.horiz) {
        let x3 = 0, y3 = y2;

        g.save();
        g.translate(x3, y3);
        g.rotate(Math.PI/2);
        g.translate(x3 - tsize, -y3 - tsize*0.5);
      }

      if (tab.icon !== undefined) {
        iconmanager$1.canvasDraw(this, this.canvas, g, tab.icon, x, y, this.iconsheet);
        x2 += iconsize + 4;
      }

      g.fillText(tab.name, x2, y2);

      if (!this.horiz) {
        g.restore();
      }

      let prev = this.tabs[Math.max(ti - 1 + this.tabs.length, 0)];
      let next = this.tabs[Math.min(ti + 1, this.tabs.length - 1)];

      if (tab !== this.tabs[this.tabs.length - 1] && prev !== this.tabs.active && next !== this.tabs.active) {
        g.beginPath();
        if (this.horiz) {
          g.moveTo(x + w, h - 5);
          g.lineTo(x + w, 5);
        } else {
          g.moveTo(w - 5, y + h);
          g.lineTo(5, y + h);
        }
        g.strokeStyle = this.getDefault("TabStrokeStyle1");
        g.stroke();
      }
    }

    let th = tsize;

    //draw active tab
    tab = this.tabs.active;
    if (tab) {
      let x = tab.pos[0], y = tab.pos[1];
      let w = tab.size[0], h = tab.size[1];
      //let tw = g.measureText(tab.name).width;
      let tw = measureText(this, tab.name, this.canvas, g, tsize, font).width;

      if (this.horiz) {
        h += 2;
      } else {
        w += 2;
      }

      let x2 = x + (tab.size[this.horiz ^ 1] - tw)*0.5;
      let y2 = y + tsize;

      if (tab === this.tabs.active) {
        /*
        let x = !this.horiz ? tab.y : tab.x;
        let y = !this.horiz ? tab.x : tab.y;
        let w = !this.horiz ? tab.size[1] : tab.size[0];
        let h = !this.horiz ? tab.size[0] : tab.size[1];

        if (!this.horiz) {
          //g.save();
          //g.translate(0, y);
          //g.rotate(Math.PI/16);
          //g.translate(0, -y);
        }//*/

        g.beginPath();
        //g.lineWidth *= 5;
        let ypad = 2;

        g.strokeStyle = this.getDefault("TabStrokeStyle2");
        g.fillStyle = activecolor;
        let r2 = r*1.5;

        if (this.horiz) {
          g.moveTo(x - r, h);
          g.quadraticCurveTo(x, h, x, h - r);
          g.lineTo(x, r2);
          g.quadraticCurveTo(x, ypad, x + r2, ypad);
          g.lineTo(x + w - r2, ypad);
          g.quadraticCurveTo(x + w, 0, x + w, r2);
          g.lineTo(x + w, h - r2);
          g.quadraticCurveTo(x + w, h, x + w + r, h);

          g.stroke();
          //
          g.closePath();
        } else {
          g.moveTo(w, y - r);
          g.quadraticCurveTo(w, y, w - r, y);
          ///*
          g.lineTo(r2, y);
          g.quadraticCurveTo(ypad, y, ypad, y + r2);
          g.lineTo(ypad, y + h - r2);
          g.quadraticCurveTo(0, y + h, r2, y + h);
          g.lineTo(w - r2, y + h);
          g.quadraticCurveTo(w, y + h, w, y + h + r);
          //*/
          g.stroke();
          //
          g.closePath();
        }

        let cw = this.horiz ? this.canvas.width : this.canvas.height;

        let worig = g.lineWidth;

        g.lineWidth *= 0.5;

        g.fill();
        //g.stroke();

        g.lineWidth = worig;

        if (!this.horiz) {
          let x3 = 0, y3 = y2;

          g.save();
          g.translate(x3, y3);
          g.rotate(Math.PI/2);
          g.translate(-x3 - tsize, -y3 - tsize*0.5);
        }

        g.fillStyle = this.getDefault("TabText").color;

        //y2 += tsize*0.3;
        g.fillText(tab.name, x2, y2);

        if (!this.horiz) {
          g.restore();
        }

        if (!this.horiz) {
          //g.restore();
        }
      }
    }
  }

  removeTab(tab) {
    this.tabs.remove(tab);
    if (tab === this.tabs.active) {
      this.tabs.active = this.tabs[0];
    }

    this._layout();
    this._redraw();
    this.setCSS();
  }

  setCSS() {
    super.setCSS(false);

    let r = this.getDefault("TabBarRadius");
    r = r !== undefined ? r : 3;

    this.style["touch-action"] = "none";


    this.canvas.style["background-color"] = this.getDefault("TabInactive");
    this.canvas.style["border-radius"] = r + "px";
    //this.style["background-color"] = this.getDefault("TabInactive");
  }

  updateStyle() {
    let key = "" + this.getDefault("background-color");
    key += this.getDefault("TabActive");
    key += this.getDefault("TabInactive");
    key += this.getDefault("TabBarRadius");
    key += this.getDefault("TabStrokeStyle1");
    key += this.getDefault("TabStrokeStyle2");
    key += this.getDefault("TabHighlight");
    key += JSON.stringify(this.getDefault("TabText"));
    key += this.tabFontScale;

    if (key !== this._last_style_key) {
      this._last_style_key = key;

      this._layout();
      this.setCSS();
      this._redraw();
    }
  }

  update(force_update = false) {
    let rect = this.getClientRects()[0];
    if (rect) {
      let key = Math.floor(rect.x*4.0) + ":" + Math.floor(rect.y*4.0);
      if (key !== this._last_p_key) {
        this._last_p_key = key;

        //console.log("tab bar autobuild");
        this._layout();
      }
    }
    super.update();

    this.updateStyle();
    this.updatePos(force_update);
    this.updateDPI(force_update);
    this.updateCanvas(force_update);
  }
}

UIBase$d.internalRegister(TabBar);

class TabContainer extends UIBase$d {
  constructor() {
    super();

    this._last_style_key = "";

    this.dataPrefix = "";

    this.inherit_packflag = 0;
    this.packflag = 0;

    this.tabFontScale = 1.0;

    this.tbar = UIBase$d.createElement("tabbar-x");
    this.tbar.parentWidget = this;
    this.tbar.setAttribute("class", "_tbar_" + this._id);
    this.tbar.constructor.setDefault(this.tbar);
    this.tbar.tabFontScale = this.tabFontScale;

    this._remakeStyle();

    this.tabs = {};

    this._last_horiz = undefined;
    this._last_bar_pos = undefined;
    this._tab = undefined;

    let div = document.createElement("div");
    div.setAttribute("class", `_tab_${this._id}`);
    div.appendChild(this.tbar);
    this.shadow.appendChild(div);

    this.tbar.parentWidget = this;

    this.tbar.onselect = (e) => {
      if (this.onselect) {
        this.onselect(e);
      }
    };

    this.tbar.onchange = (tab, event) => {
      if (this._tab) {
        HTMLElement.prototype.remove.call(this._tab);
      }

      this._tab = this.tabs[tab.id];
      //this._tab = document.createElement("div");
      //this._tab.innerText = "SDfdsfsdyay";

      this._tab.parentWidget = this;

      //ensure we get full update convergence when switching
      //tabs
      for (let i = 0; i < 2; i++) {
        this._tab.flushUpdate();
      }

      let div = document.createElement("div");

      this.tbar.setCSS.once(() => div.style["background-color"] = this.getDefault("background-color"), div);

      div.setAttribute("class", `_tab_${this._id}`);
      div.appendChild(this._tab);

      //XXX why is this necassary?
      //this._tab.style["margin-left"] = "40px";
      this.shadow.appendChild(div);

      if (this.onchange) {
        this.onchange(tab, event);
      }
    };
  }

  get movableTabs() {
    let attr;

    if (!this.hasAttribute("movable-tabs")) {
      attr = this.getDefault("movable-tabs");

      if (attr === undefined || attr === null) {
        attr = "true";
      }

      if (typeof attr === "boolean" || typeof attr === "number") {
        attr = attr ? "true" : "false";
      }
    } else {
      attr = "" + this.getAttribute("movable-tabs");
    }

    attr = attr.toLowerCase();

    return attr === "true";
  }

  set movableTabs(val) {
    val = !!val;

    this.setAttribute("movable-tabs", val ? "true" : "false");
    this.tbar.movableTabs = this.movableTabs;
  }

  get hideScrollBars() {
    let attr = ("" + this.getAttribute("hide-scrollbars")).toLowerCase();
    return attr === "true" || attr === "yes";
  }

  set hideScrollBars(val) {
    val = !!val;

    this.setAttribute("hide-scrollbars", "" + val);
  }

  static setDefault(e) {
    e.setAttribute("bar_pos", "top");

    return e;
  }

  static define() {
    return {
      tagname: "tabcontainer-x",
      style  : "tabs"
    };
  }

  _startMove(tab=this.tbar.tabs.active, event) {
    return this.tbar._startMove(tab, event);
  }

  _ensureNoModal() {
    return this.tbar._ensureNoModal();
  }

  saveData() {
    let json = super.saveData() || {};
    json.tabs = {};

    for (let k in this.tabs) {
      let tab = this.tabs[k];

      if (k === this.tbar.tabs.active.id) {
        //no need to save active tab here
        continue;
      }

      try {
        json.tabs[tab.id] = JSON.parse(saveUIData(tab, "tab"));
      } catch (error) {
        console.error("Failed to save tab UI layout", tab.id);
      }
    }

    return json;
  }

  loadData(json) {
    if (!json.tabs) {
      return;
    }

    for (let k in json.tabs) {
      if (!(k in this.tabs)) {
        continue;
      }

      let uidata = JSON.stringify(json.tabs[k]);
      loadUIData(this.tabs[k], uidata);
    }
  }

  enableDrag() {
    this.tbar.draggable = this.draggable = true;
    this.tbar.addEventListener("dragstart", (e) => {
      this.dispatchEvent(new DragEvent("dragstart", e));
    });
    this.tbar.addEventListener("dragover", (e) => {
      this.dispatchEvent(new DragEvent("dragover", e));
    });
    this.tbar.addEventListener("dragexit", (e) => {
      this.dispatchEvent(new DragEvent("dragexit", e));
    });
    /*
    let doms = [this, this.tbar, this.tbar.canvas];
    for (let dom of doms) {
      dom.setAttribute("draggable", "true");
      dom.draggable = true;

      dom.addEventListener("dragstart", (e) => {
        console.log("drag start", e);
      });

      dom.addEventListener("drag", (e) => {
        console.log("drag", e);
      });
    }*/
  }

  clear() {
    this.tbar.clear();
    if (this._tab !== undefined) {
      HTMLElement.prototype.remove.call(this._tab);
      this._tab = undefined;
    }

    this.tabs = {};
  }

  init() {
    super.init();

    this.background = this.getDefault("background-color");
  }

  setCSS() {
    super.setCSS();

    this.background = this.getDefault("background-color");
    this._remakeStyle();
  }

  _remakeStyle() {
    let horiz = this.tbar.horiz;
    let display = "flex";
    let flexDir = !horiz ? "row" : "column";
    let bgcolor = this.__background; //this.getDefault("background-color");

    //display = "inline" //XXX
    let style = document.createElement("style");
    style.textContent = `
      ._tab_${this._id} {
        display : ${display};
        flex-direction : ${flexDir};
        margin : 0px;
        padding : 0px;
        align-self : flex-start;
        ${!horiz ? "vertical-align : top;" : ""}
      }
      
      ._tbar_${this._id} {
        list-style-type : none;
        align-self : flex-start;
        background-color : ${bgcolor};
        flex-direction : ${flexDir};
        ${!horiz ? "vertical-align : top;" : ""}
      }
    `;

    if (this._style)
      this._style.remove();
    this._style = style;

    this.shadow.prepend(style);
  }

  icontab(icon, id, tooltip) {
    let t = this.tab("", id, tooltip);
    t._tab.icon = icon;

    return t;
  }

  removeTab(tab) {
    let tab2 = tab._tab;
    this.tbar.removeTab(tab2);
    tab.remove();
  }

  tab(name, id = undefined, tooltip = undefined, movable = true) {
    if (id === undefined) {
      id = tab_idgen++;
    }

    let col = UIBase$d.createElement("colframe-x");

    this.tabs[id] = col;

    col.dataPrefix = this.dataPrefix;

    col.ctx = this.ctx;
    col._tab = this.tbar.addTab(name, id, tooltip, movable);

    col.inherit_packflag |= this.inherit_packflag;
    col.packflag |= this.packflag;

    //let cls = this.tbar.horiz ? ui.ColumnFrame : ui.RowFrame;

    col.parentWidget = this;

    if (col.ctx) {
      col._init();
    }

    col.setCSS();

    if (this._tab === undefined) {
      this.setActive(col);
    }

    col.noSwitch = function () {
      this._tab.noSwitch = true;
      return this;
    };

    function defineTabEvent(key) {
      key = "on" + key;

      Object.defineProperty(col, key, {
        get() {
          return this._tab[key];
        },
        set(v) {
          this._tab[key] = v;
        }
      });
    }

    defineTabEvent("tabclick");
    defineTabEvent("tabdragmove");
    defineTabEvent("tabdragstart");
    defineTabEvent("tabdragend");

    return col;
  }

  setActive(tab) {
    if (typeof tab === "string") {
      tab = this.getTab(tab);
    }

    if (!tab) {
      return;
    }

    if (tab._tab !== this.tbar.tabs.active) {
      this.tbar.setActive(tab._tab);
    }
  }

  getTabCount() {
    return this.tbar.tabs.length;
  }

  moveTab(tab, i) {
    tab = tab._tab;

    let tab2 = this.tbar.tabs[i];

    if (tab !== tab2) {
      this.tbar.swapTabs(tab, tab2);
    }

    this.tbar.setCSS();
    this.tbar._layout();
    this.tbar._redraw();
  }

  getTab(name_or_id) {
    if (name_or_id in this.tabs) {
      return this.tabs[name_or_id];
    }

    for (let k in this.tabs) {
      let t = this.tabs[k];

      if (t.name === name_or_id) {
        return t;
      }
    }

    throw new Error("Unknown tab " + name_or_id);
  }

  updateBarPos() {
    let barpos = this.getAttribute("bar_pos");

    if (barpos !== this._last_bar_pos) {
      this.horiz = barpos === "top" || barpos === "bottom";
      this._last_bar_pos = barpos;

      this.tbar.setAttribute("bar_pos", barpos);
      this.tbar.update(true);
      this.update();
    }
  }

  updateHoriz() {
    let horiz = this.tbar.horiz;

    if (this._last_horiz !== horiz) {
      this._last_horiz = horiz;
      this._remakeStyle();
    }
  }

  updateStyle() {
    let key = "" + this.getDefault("background-color");

    if (key !== this._last_style_key) {
      this._last_style_key = key;
      this.setCSS();
    }
  }

  getActive() {
    return this.tbar.tabs.active;
  }

  update() {
    super.update();

    this.tbar.movableTabs = this.movableTabs;

    if (this._tab !== undefined) {
      this._tab.update();
    }

    this.style["display"] = "flex";
    this.style["flex-direction"] = !this.horiz ? "row" : "column";

    this.tbar.tabFontScale = this.tabFontScale;

    this.updateStyle();
    this.updateHoriz();
    this.updateBarPos();
    this.tbar.update();

    let act = this.tbar.tabs.active;

    if (act && !this.hideScrollBars) {
      let container = this.tabs[act.id];

      //propegate overflow-y to tab container as a whole

      if (container.hasAttribute("overflow-y") && this.style["overflow-y"] !== container.getAttribute("overflow-y")) {
        this.style["overflow-y"] = container.getAttribute("overflow-y");
        //container.style["overflow-y"] = "unset";
      } else if (!container.hasAttribute("overflow-y")) {
        this.style["overflow-y"] = this.getDefault("overflow-y") || "unset";
      }

      if (container.hasAttribute("overflow") && this.style["overflow"] !== container.getAttribute("overflow")) {
        this.style["overflow"] = container.getAttribute("overflow");
        //container.style["overflow-y"] = "unset";
      } else if (!container.hasAttribute("overflow")) {
        this.style["overflow"] = this.getDefault("overflow") || "unset";
      }
    } else if (this.hideScrollBars) {
      this.style["overflow"] = this.style["overflow-y"] = "unset";
    }
  }
}

UIBase$d.internalRegister(TabContainer);

//bind module to global var to get at it in console.

var _ui$2 = undefined;

let PropFlags$3 = PropFlags;
let PropSubTypes$4 = PropSubTypes$1;

let EnumProperty$8 = EnumProperty;

let Vector2$a = Vector2,
  UIBase$e = UIBase$2,
  PackFlags$9 = PackFlags,
  PropTypes$7 = PropTypes;


const list$1 = list;

class TableRow extends Container {
  constructor() {
    super();

    this.dom.remove();
    this.dom = document.createElement("tr");

    //kind of dumb, but this.dom doesn't live within this element itself, bleh
    //this.shadow.appendChild(this.dom);
    this.dom.setAttribute("class", "containerx");
  }

  static define() {return {
    tagname : "tablerow-x"
  };}

  _add(child) {
    child.ctx = this.ctx;
    child.parentWidget = this;

    let td = document.createElement("td");
    td.appendChild(child);

    this.dom.appendChild(td);
    child.onadd();
  }
};
UIBase$e.internalRegister(TableRow);

class TableFrame extends Container {
  constructor() {
    super();

    this.dom = document.createElement("table");
    this.shadow.appendChild(this.dom);
    this.dom.setAttribute("class", "containerx");

    //this.dom.style["display"] = "block";
  }

  update() {
    this.style["display"] = "inline-block";
    super.update();
  }

  _add(child) {
    child.ctx = this.ctx;
    child.parentWidget = this;
    this.dom.appendChild(child);
    child.onadd();
  }

  add(child) {
    this._add(child);
  }

  row() {
    let tr = document.createElement("tr");
    let cls = "table-tr";

    tr.setAttribute("class", cls);
    this.dom.appendChild(tr);
    let this2 = this;

    function maketd() {
      let td = document.createElement("td");
      tr.appendChild(td);

      td.style["margin"] = tr.style["margin"];
      td.style["padding"] = tr.style["padding"];

      let container = UIBase$e.createElement("rowframe-x");

      container.ctx = this2.ctx;
      container.parentWidget = this2;
      container.setAttribute("class", cls);

      td.setAttribute("class", cls);
      td.appendChild(container);

      return container;
    }

    //hrm wish I could subclass html elements easier
    let ret = {
      _tr : tr,

      style : tr.style,

      focus : function(args) {
        tr.focus(args);
      },

      blur : function(args) {
        tr.blur(args);
      },

      remove : () => {
        tr.remove();
      },

      addEventListener : function(type, cb, arg) {
        tr.addEventListener(type, cb, arg);
      },

      removeEventListener : function(type, cb, arg) {
        tr.removeEventListener(type, cb, arg);
      },

      setAttribute : function(attr, val) {
        if (attr == "class") {
          cls = val;
        }

        tr.setAttribute(attr, val);
      },

      scrollTo : function() {
        return this._tr.scrollTo(...arguments);
      },

      scrollIntoView : function() {
        return this._tr.scrollIntoView(...arguments);
      },

      clear : function() {
        for (let node of list$1(tr.childNodes)) {
          tr.removeChild(node);
        }
      }
    };

    function makefunc(f) {
      ret[f] = function() {
        let container = maketd();

        container.background = tr.style["background-color"]; //"rgba(0,0,0,0)";
        return container[f].apply(container, arguments);
      };
    }

    let _bg = "";

    //need to implement proper proxy here!
    Object.defineProperty(ret, "tabIndex", {
      set : function(f) {
        tr.tabIndex = f;
      },

      get : function(f) {
        return tr.tabIndex;
      }
    });

    Object.defineProperty(ret, "background", {
      set : function(bg) {
        _bg = bg;
        tr.style["background-color"] = bg;

        for (let node of tr.childNodes) {
          if (node.childNodes.length > 0) {
            node.childNodes[0].background = bg;
            node.style["background-color"] = bg;
          }
        }
      }, get : function() {
        return _bg;
      }
    });

    /*
    Object.defineProperty(ret, "class", {
      set(bg) {
        tr.class = bg;
      }
    });//*/

    ret.cell = () => {
      let container = maketd();
      container.background = tr.style["background-color"];
      return container;
    };
    
    //makefunc("cell");
    makefunc("label");
    makefunc("tool");
    makefunc("prop");
    makefunc("pathlabel");
    makefunc("button");
    makefunc("iconbutton");
    makefunc("textbox");
    makefunc("col");
    makefunc("row");
    makefunc("table");
    makefunc("listenum");
    makefunc("check");

    return ret;
  }

  update() {
    super.update();
  }

  clear() {
    super.clear();
    for (let child of list$1(this.dom.childNodes)) {
      child.remove();
    }
  }

  static define() {return {
    tagname : "tableframe-x"
  };}
}
UIBase$e.internalRegister(TableFrame);

"use strict";

let EnumProperty$9 = EnumProperty,
    PropTypes$8    = PropTypes;

let UIBase$f     = UIBase$2,
    PackFlags$a  = PackFlags,
    IconSheets$7 = IconSheets;

function getpx$2(css) {
  return parseFloat(css.trim().replace("px", ""))
}

class ListItem extends RowFrame {
  constructor() {
    super();

    let highlight = () => {
      //console.log("listitem mouseover");
      this.highlight = true;
      this.setBackground();
    };

    let unhighlight = () => {
      //console.log("listitem mouseleave");
      this.highlight = false;
      this.setBackground();
    };

    this.addEventListener("mouseover", highlight);
    this.addEventListener("mousein", highlight);

    this.addEventListener("mouseleave", unhighlight);
    this.addEventListener("mouseout", unhighlight);
    this.addEventListener("blur", unhighlight);

    this.addEventListener("click", (e) => {
      //console.log("click!");
      if (this.onclick) {
        this.onclick();
      }
    });

    let style = document.createElement("style");
    style.textContent = `
      .listitem {
        -moz-user-focus: normal;
        moz-user-focus: normal;
        user-focus: normal;
      }
    `;

    this.shadowRoot.prepend(style);
  }

  static define() {
    return {
      tagname: "listitem-x",
      style  : "listbox"
    }
  }

  init() {
    super.init();

    this.setAttribute("class", "listitem");

    this.style["width"] = "100%";
    this.style["height"] = this.getDefault("ItemHeight") + "px";
    this.style["flex-grow"] = "unset";

    this.setCSS();
  }

  setBackground() {
    if (this.highlight && this.is_active) {
      this.background = this.getDefault("ListActiveHighlight");
    } else if (this.highlight) {
      this.background = this.getDefault("ListHighlight");
    } else if (this.is_active) {
      this.background = this.getDefault("ListActive");
    } else {
      this.background = this.getDefault("background-color");
    }
  }
}

UIBase$f.internalRegister(ListItem);

class ListBox extends Container {
  constructor() {
    super();

    this.items = [];
    this.idmap = {};
    this.items.active = undefined;
    this.highlight = false;
    this.is_active = false;

    let style = document.createElement("style");
    style.textContent = `
      .listbox {
        -moz-user-focus: normal;
        moz-user-focus: normal;
        user-focus: normal;
      }
    `;
    this.shadow.prepend(style);

    this.onkeydown = (e) => {
      switch (e.keyCode) {
        case keymap["Up"]:
        case keymap["Down"]:
          if (this.items.length == 0)
            return;

          if (this.items.active === undefined) {
            this.setActive(this.items[0]);
            return;
          }

          let i = this.items.indexOf(this.items.active);
          let dir = e.keyCode == keymap["Up"] ? -1 : 1;

          i = Math.max(Math.min(i + dir, this.items.length - 1), 0);
          this.setActive(this.items[i]);

          break;
      }
    };

    //this.addEventListener("keydown", on_keydown);

    //this._table =  this.table();
  }

  static define() {
    return {
      tagname: "listbox-x",
      style  : "listbox"
    }
  }

  setCSS() {
    super.setCSS();
  }

  init() {
    super.init();

    this.setCSS();

    this.style["width"] = this.getDefault("width") + "px";
    this.style["height"] = this.getDefault("height") + "px";
    this.style["overflow"] = "scroll";

    //this.setAttribute("class", "listbox");
    //this.setAttribute("tabindex", 0);
    //this.tabIndex = 0;
  }

  addItem(name, id) {
    let item = UIBase$f.createElement("listitem-x");

    item._id = id === undefined ? this.items.length : id;
    this.idmap[item._id] = item;

    //item.addEventListener("keydown", this.onkeydown);
    this.tabIndex = 1;
    this.setAttribute("tabindex", 1);

    this.add(item);
    this.items.push(item);

    item.label(name);
    let this2 = this;

    item.onclick = function () {
      this2.setActive(this);
      this.setBackground();
    };

    return item;
  }

  removeItem(item) {
    if (typeof item == "number") {
      item = this.idmap[item];
    }

    item.remove();
    delete this.idmap[item._id];
    this.items.remove(item);
  }

  setActive(item) {
    if (typeof item == "number") {
      item = this.idmap[item];
    }

    //console.log("set active!");

    if (item === this.items.active) {
      return;
    }

    if (this.items.active !== undefined) {
      this.items.active.highlight = false;
      this.items.active.is_active = false;
      this.items.active.setBackground();
    }

    this.items.active = item;

    if (item) {
      item.is_active = true;

      item.setBackground();
      item.scrollIntoViewIfNeeded();
    }

    if (this.onchange) {
      this.onchange(item ? item._id : undefined, item);
    }
  }

  clear() {

  }
}

UIBase$f.internalRegister(ListBox);

class ProgressCircle extends UIBase$2 {
  constructor() {
    super();

    this.canvas = document.createElement("canvas");
    this.g = this.canvas.getContext("2d");

    this.shadow.appendChild(this.canvas);
    this.size = 150;
    this.animreq = undefined;
    this._value = 0.0;
    this.startTime = time_ms();
  }

  init() {
    super.init();
    this.flagRedraw();
    this.update();

    //enable keyboard focus
    this.tabIndex = 0;
    this.setAttribute("tab-index", 0);
    this.setAttribute("tabindex", 0);

    let onkey = (e) => {
      switch (e.keyCode) {
        case keymap["Escape"]:
          if (this.oncancel) {
            this.oncancel(this);
          }
          break;
      }
    };

    this.addEventListener("keydown", onkey);
    this.canvas.addEventListener("keydown", onkey);
  }

  flagRedraw() {
    if (this.animreq !== undefined) {
      return;
    }

    this.animreq = requestAnimationFrame(() => {
      this.animreq = undefined;
      this.draw();
    });
  }

  draw() {
    let c = this.canvas, g = this.g;

    let clr1 = "rgb(68,69,83)";
    let clr2 = "rgb(141,154,196)";
    let clr3 = "rgb(214,110,54)";

    let t = (time_ms() - this.startTime) / 1000.0;

    g.save();
    g.clearRect(0, 0, c.width, c.height);

    g.lineWidth /= c.width*0.5;
    g.scale(c.width, c.height);
    g.translate(0.5, 0.5);

    g.fillStyle = clr2;
    g.strokeStyle = clr1;

    g.beginPath();
    g.moveTo(0, 0);
    g.arc(0, 0, 0.45, Math.PI, -Math.PI);
    //g.closePath()

    g.moveTo(0, 0);
    g.arc(0, 0, 0.2, Math.PI, -Math.PI);
    //g.closePath()

    g.clip("evenodd");

    g.beginPath();
    g.arc(0, 0, 0.45, -Math.PI, Math.PI);
    g.fill();
    g.stroke();

    g.beginPath();
    g.arc(0, 0, 0.2, Math.PI, -Math.PI);
    g.stroke();

    g.beginPath();

    let th = this._value*Math.PI*2.0;

    let steps = 12;
    let dth = (Math.PI*2.0) / steps;
    let lwid = g.lineWidth;
    g.lineWidth *= 3;

    for (let i=0; i<steps; i++) {
      let th1 = i * dth;
      th1 += t;

      let r1 = 0.2;
      let r2 = 0.45;
      let th2 = th1 + dth*0.5;

      g.beginPath();
      g.moveTo(Math.cos(th1)*r1, Math.sin(th1)*r1);
      g.lineTo(Math.cos(th2)*r2, Math.sin(th2)*r2);
      g.strokeStyle = "rgba(255,255,255,0.5)";
      g.stroke();
    }

    g.lineWidth = lwid;

    g.beginPath();
    g.moveTo(0, 0);
    g.arc(0, 0, 0.4, Math.PI, -Math.PI);
    //g.closePath()

    g.clip("evenodd");

    g.beginPath();
    g.fillStyle = clr3;
    g.moveTo(0, 0);
    g.arc(0, 0, 0.45, 0, th);
    g.lineTo(0, 0);
    g.fill();

    g.strokeStyle = "rgb(141,154,196)";
    g.stroke();

    g.restore();
  }

  set value(percent) {
    this._value = percent;
    this.flagRedraw();
  }

  get value() {
    return this._value;
  }

  startTimer() {
    if (this.timer !== undefined) {
      return;
    }

    this.focus();

    window.setInterval(() => {
      if (!this.isConnected) {
        this.endTimer();
        return;
      }

      this.flagRedraw();
    }, 50);
  }

  endTimer() {
    if (this.timer !== undefined) {
      window.clearInterval(this.timer);
    }
    this.timer = undefined;
  }

  update() {
    if (!this.isConnected && this.timer) {
      this.endTimer();
    }

    let size = ~~(this.size*UIBase$2.getDPI());

    if (size !== this.canvas.width) {
      this.setCSS();
    }
  }

  setCSS() {
    let c = this.canvas;

    let size = ~~(this.size*UIBase$2.getDPI());

    if (c.width !== size) {
      c.width = c.height = size;

      size /= UIBase$2.getDPI();
      c.style["width"] = size + "px";
      c.style["height"] = size + "px";

      c.style["display"] = "flex";

      this.style["width"] = size + "px";
      this.style["height"] = size + "px";

      //forcibly redraw in this case, do not queue with flagRedraw
      this.draw();
    }

    this.style["display"] = "flex";
    this.style["align-items"] = "center";
    this.style["justify-content"] = "center";
    this.style["width"] = "100%";
    this.style["height"] = "100%";
  }

  static define() {
    return {
      tagname : "progress-circle-x"
    }
  }
}
UIBase$2.register(ProgressCircle);

const LastKey = Symbol("LastToolPanelId");
let tool_idgen$1 = 0;

function getLastToolStruct(ctx) {
  let ret = ctx.state._last_tool;

  if (!ret) {
    ret = ctx.toolstack.head;
  } else {
    let msg = "Passing the last tool to last-tool-panel via appstate._last_tool is deprecated;";
    msg += "\nctx.toolstack.head is now used instead.";

    console.warn(msg);
  }

  return ret;
}

/*
*
* This panel shows the most recently executed ToolOp's
* settings.  It assumes that recent toolops are accessible
* in ctx.last_tool.
* */
class LastToolPanel extends ColumnFrame {
  constructor() {
    super();

    this._tool_id = undefined;
    this.useDataPathUndo = false;
  }

  init() {
    super.init();

    this.useDataPathUndo = false;
    this.rebuild();
  }

  /** client code can subclass and override this method */
  getToolStackHead(ctx) {
    //don't process the root toolop
    let bad = ctx.toolstack.length === 0 || ctx.toolstack.cur >= ctx.toolstack.length;
    bad = bad || ctx.toolstack.cur < 0;
    bad = bad || ctx.toolstack[ctx.toolstack.cur].undoflag & UndoFlags.IS_UNDO_ROOT;

    if (bad) {
      return undefined;
    }

    return ctx.toolstack[ctx.toolstack.cur];
  }

  rebuild() {
    let ctx = this.ctx;
    if (ctx === undefined) {
      this._tool_id = -1; //wait for .ctx
      return;
    }

    this.clear();

    this.label("Recent Command Settings");

    let tool = this.getToolStackHead(ctx);

    if (!tool) {
      this.setCSS();
      return;
    }

    let def = tool.constructor.tooldef();
    let name = def.uiname !== undefined ? def.uiname : def.name;

    let panel = this.panel(def.uiname);

    this.buildTool(ctx, tool, panel);
    this.flushUpdate();
  }

  /** client code can subclass and override this method */
  buildTool(ctx, tool, panel) {
    let fakecls = {};
    fakecls.constructor = fakecls;

    //in theory it shouldn't matter if multiple last tool panels
    //override _last_tool, since they all access the same data
    this.ctx.state._last_tool = fakecls;
    let lastkey = tool[LastKey];

    let getTool = () => {
      let tool = this.ctx.toolstack[this.ctx.toolstack.cur];
      if (!tool || tool[LastKey] !== lastkey) {
        return undefined;
      }

      return tool;
    };

    if (tool.flag & ToolFlags.PRIVATE) {
      return;
    }

    let st = this.ctx.api.mapStruct(fakecls, true);
    let paths = [];

    function defineProp(k, key) {
      Object.defineProperty(fakecls, key, {
        get : function() {
          let tool = getTool();
          if (tool) {
            if (!tool.inputs[k]) {
              console.error("Missing property " + k, tool);
            }
            return tool.inputs[k].getValue();
          }
        },

        set : function(val) {
          let tool = getTool();
          if (tool) {
            tool.inputs[k].setValue(val);
            tool.saveDefaultInputs();

            ctx.toolstack.rerun(tool);
          }
        }
      });
    }

    for (let k in tool.inputs) {
      let prop = tool.inputs[k];

      if (prop.flag & (PropFlags.PRIVATE|PropFlags.READ_ONLY)) {
        continue;
      }

      let uiname = prop.uiname;
      if (!uiname) {
        uiname = ToolProperty$1.makeUIName(k);
      }

      prop.uiname = uiname;
      let apikey = k.replace(/[\t ]/g, "_");

      let dpath = new DataPath(apikey, apikey, prop, DataTypes.PROP);
      st.add(dpath);

      paths.push(dpath);

      defineProp(k, apikey);
    }

    panel.useDataPathUndo = false;

    for (let dpath of paths) {
      let path = "last_tool." + dpath.path;

      panel.label(dpath.data.uiname);
      let ret = panel.prop(path, PackFlags.FORCE_ROLLER_SLIDER);

      if (ret) {
        ret.useDataPathUndo = false;
      }
    }
    this.setCSS();

    //console.log("Building last tool settings");
  }

  update() {
    super.update();
    let ctx = this.ctx;

    if (!ctx) {
      return;
    }

    let tool = this.getToolStackHead(ctx);

    if (tool && (!(LastKey in tool) || tool[LastKey] !== this._tool_id)) {
      tool[LastKey] = tool_idgen$1++;
      this._tool_id = tool[LastKey];

      this.rebuild();
    }
  }

  static define() {return {
    tagname : "last-tool-panel-x"
  }}
}
UIBase$2.internalRegister(LastToolPanel);

class Constraint {
  constructor(name, func, klst, params, k=1.0) {
    this.glst = [];
    this.klst = klst;
    this.k = k;
    this.params = params;
    this.name = name;

    for (let ks of klst) {
      this.glst.push(new Float64Array(ks.length));
    }

    this.df = 0.0005;
    this.threshold = 0.0001;
    this.func = func;

    this.funcDv = null;
  }

  evaluate(no_dvs=false) {
    let r1 = this.func(this.params);

    if (this.funcDv) {
      this.funcDv(this.params, this.glst);
      return r1;
    }

    if (Math.abs(r1) < this.threshold)
      return 0.0;

    let df = this.df;

    if (no_dvs)
      return r1;

    for (let i=0; i<this.klst.length; i++) {
      let gs = this.glst[i];
      let ks = this.klst[i];

      for (let j=0; j<ks.length; j++) {
        let orig = ks[j];
        ks[j] += df;
        let r2 = this.func(this.params);
        ks[j] = orig;

        gs[j] = (r2 - r1) / df;
      }
    }

    return r1;
  }
}

class Solver {
  constructor() {
    this.constraints = [];
    this.gk = 0.99;
    this.simple = false;
    this.randCons = false;
  }

  add(con) {
    this.constraints.push(con);
  }

  solveStep(gk=this.gk) {
    let err = 0.0;

    let cons = this.constraints;
    for (let ci=0; ci<cons.length; ci++ ){
      let ri = ci;
      if (this.randCons) {
        ri = ~~(Math.random()*this.constraints.length*0.99999);
      }

      let con = cons[ri];

      let r1 = con.evaluate();

      if (r1 === 0.0)
        continue;

      err += Math.abs(r1);
      let totgs = 0.0;

      for (let i=0; i<con.klst.length; i++) {
        let ks = con.klst[i], gs = con.glst[i];
        for (let j=0; j<ks.length; j++) {
          totgs += gs[j]*gs[j];
        }
      }

      if (totgs === 0.0)  {
        continue;
      }

      r1 /= totgs;

      for (let i=0; i<con.klst.length; i++) {
        let ks = con.klst[i], gs = con.glst[i];
        for (let j=0; j<ks.length; j++) {
          ks[j] += -r1*gs[j]*con.k*gk;
        }
      }
    }

    return err;
  }

  solveStepSimple(gk=this.gk) {
    let err = 0.0;

    let cons = this.constraints;
    for (let ci=0; ci<cons.length; ci++ ){
      let ri = ci;
      if (this.randCons) {
        ri = ~~(Math.random()*this.constraints.length*0.99999);
      }

      let con = cons[ri];

      let r1 = con.evaluate();

      if (r1 === 0.0)
        continue;

      err += Math.abs(r1);
      let totgs = 0.0;

      for (let i=0; i<con.klst.length; i++) {
        let ks = con.klst[i], gs = con.glst[i];
        for (let j=0; j<ks.length; j++) {
          totgs += gs[j]*gs[j];
        }
      }

      if (totgs === 0.0)  {
        continue;
      }

      totgs = 0.0001 / Math.sqrt(totgs);

      for (let i=0; i<con.klst.length; i++) {
        let ks = con.klst[i], gs = con.glst[i];
        for (let j=0; j<ks.length; j++) {
          ks[j] += -totgs*gs[j]*con.k*gk;
        }
      }
    }

    return err;
  }

  solve(steps, gk=this.gk, printError=false) {
    let err = 0.0;

    for (let i=0; i<steps; i++) {
      if (this.simple) {
        err = this.solveStepSimple(gk);
      } else {
        err = this.solveStep(gk);
      }


      if (printError) {
        console.warn("average error:", (err/this.constraints.length).toFixed(4));
      }
      if (err < 0.01 / this.constraints.length) {
        break;
      }
    }

    return err;
  }
}

var solver1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Constraint: Constraint,
  Solver: Solver
});

"use strict";

let idgen = 0;

class PackNodeVertex extends Vector2 {
  constructor(node, co) {
    super(co);

    this.node = node;
    this._id = idgen++;
    this.edges = [];
    this._absPos = new Vector2();
  }

  get absPos() {
    this._absPos.load(this).add(this.node.pos);
    return this._absPos;
  }

  [Symbol.keystr]() {
    return this._id;
  }
}

class PackNode {
  constructor() {
    this.pos = new Vector2();
    this.vel = new Vector2();
    this.oldpos = new Vector2();
    this._id = idgen++;
    this.size = new Vector2();
    this.verts = [];
  }

  [Symbol.keystr]() {
    return this._id;
  }
}

function copyGraph(nodes) {
  let ret = [];
  let idmap = {};

  for (let n of nodes) {
    let n2 = new PackNode();
    n2._id = n._id;
    n2.pos.load(n.pos);
    n2.vel.load(n.vel);
    n2.size.load(n.size);

    n2.verts = [];
    idmap[n2._id] = n2;

    for (let v of n.verts) {
      let v2 = new PackNodeVertex(n2, v);
      v2._id = v._id;
      idmap[v2._id] = v2;

      n2.verts.push(v2);
    }

    ret.push(n2);
  }

  for (let n of nodes) {
    for (let v of n.verts) {
      let v2 = idmap[v._id];

      for (let v3 of v.edges) {
        v2.edges.push(idmap[v3._id]);
      }
    }
  }

  return ret;
}

function getCenter(nodes) {
  let cent = new Vector2();

  for (let n of nodes) {
    cent.add(n.pos);
  }

  if (nodes.length === 0)
    return cent;

  cent.mulScalar(1.0 / nodes.length);

  return cent;
}

function loadGraph(nodes, copy) {
  let idmap = {};

  for (let i=0; i<nodes.length; i++) {
    nodes[i].pos.load(copy[i].pos);
    nodes[i].oldpos.load(copy[i].oldpos);
    nodes[i].vel.load(copy[i].vel);
  }
}

function graphGetIslands(nodes) {
  let islands = [];
  let visit1 = new set$1();

  let rec = (n, island) => {
    island.push(n);
    visit1.add(n);

    for (let v of n.verts) {
      for (let e of v.edges) {
        let n2 = e.node;
        if (n2 !== n && !visit1.has(n2)) {
          rec(n2, island);
        }
      }
    }
  };

  for (let n of nodes) {
    if (visit1.has(n)) {
      continue;
    }

    let island = [];
    islands.push(island);
    rec(n, island);
  }

  return islands;
}

function graphPack(nodes, margin_or_args=15, steps=10, updateCb=undefined) {
  let margin = margin_or_args;
  let speed = 1.0;

  if (typeof margin === "object") {
    let args = margin;

    margin = args.margin ?? 15;
    steps = args.steps ?? 10;
    updateCb = args.updateCb;
    speed = args.speed ?? 1.0;
  }

  let orignodes = nodes;
  nodes = copyGraph(nodes);

  let decay = 1.0;
  let decayi = 0;


  let min = new Vector2().addScalar(1e17);
  let max = new Vector2().addScalar(-1e17);

  let tmp = new Vector2();
  for (let n of nodes) {
    min.min(n.pos);
    tmp.load(n.pos).add(n.size);
    max.max(tmp);
  }

  let size = new Vector2(max).sub(min);

  for (let n of nodes) {
    n.pos[0] += (Math.random()-0.5)*5.0/size[0]*speed;
    n.pos[1] += (Math.random()-0.5)*5.0/size[1]*speed;
  }

  let nodemap = {};
  for (let n of nodes) {
    n.vel.zero();
    nodemap[n._id] = n;
    for (let v of n.verts) {
      nodemap[v._id] = v;
    }
  }

  let visit = new set$1();
  let verts = new set$1();
  let isect = [];

  let disableEdges = false;

  function edge_c(params) {
    let [v1, v2, restlen] = params;

    if (disableEdges) return 0;

    return Math.abs(v1.absPos.vectorDistance(v2.absPos) - restlen);
  }

  let p1 = new Vector2();
  let p2 = new Vector2();
  let s1 = new Vector2();
  let s2 = new Vector2();

  function loadBoxes(n1, n2, margin1=margin) {
    p1.load(n1.pos);
    p2.load(n2.pos);
    s1.load(n1.size);
    s2.load(n2.size);

    p1.subScalar(margin1);
    p2.subScalar(margin1);
    s1.addScalar(margin1*2.0);
    s2.addScalar(margin1*2.0);
  }

  let disableArea = false;

  function area_c(params) {
    let [n1, n2] = params;

    if (disableArea)
      return 0.0;

    loadBoxes(n1, n2);

    let a1 = n1.size[0]*n1.size[1];
    let a2 = n2.size[0]*n2.size[1];

    return aabb_overlap_area(p1, s1, p2, s2);
    return (aabb_overlap_area(p1, s1, p2, s2) / (a1+a2));
  }

  let lasterr, besterr, best;
  let err;

  let islands = graphGetIslands(nodes);
  let fakeVerts = [];
  for (let island of islands) {
    let n = island[0];
    let fv = new PackNodeVertex(n);
    fakeVerts.push(fv);
  }

  let solveStep1 = (gk=1.0) => {
    let solver = new Solver();

    isect.length = 0;
    visit = new set$1();

    if (fakeVerts.length > 1) {
      for (let i=1; i<fakeVerts.length; i++) {
        let v1 = fakeVerts[0];
        let v2 = fakeVerts[i];

        let rlen = 1.0;

        let con = new Constraint("edge_c", edge_c, [v1.node.pos, v2.node.pos], [v1, v2, rlen]);
        con.k = 0.25;
        solver.add(con);
      }
    }

    for (let n1 of nodes) {
      for (let v of n1.verts) {
        verts.add(v);
        for (let v2 of v.edges) {
          //hueristic to avoid adding same constraint twice
          if (v2._id < v._id) continue;

          let rlen = n1.size.vectorLength()*0.0;

          let con = new Constraint("edge_c", edge_c, [v.node.pos, v2.node.pos], [v, v2, rlen]);
          con.k = 1.0;
          solver.add(con);
        }
      }

      for (let n2 of nodes) {
        if (n1 === n2) continue;
        let key = Math.min(n1._id, n2._id) + ":" + Math.max(n1._id, n2._id);
        if (visit.has(key)) continue;

        loadBoxes(n1, n2);
        let area = aabb_overlap_area(p1, s1, p2, s2);

        if (area > 0.01) {
          let size = decay*(n1.size.vectorLength() + n2.size.vectorLength())*speed;
          //*
          n1.pos[0] += (Math.random() - 0.5)*size;
          n1.pos[1] += (Math.random() - 0.5)*size;
          n2.pos[0] += (Math.random() - 0.5)*size;
          n2.pos[1] += (Math.random() - 0.5)*size;
          //*/

          isect.push([n1, n2]);
          visit.add(key);
        }
      }

      for (let [n1, n2] of isect) {
        let con = new Constraint("area_c", area_c, [n1.pos, n2.pos], [n1, n2]);
        solver.add(con);
        con.k = 1.0;
      }
    }

    return solver;
  };

  let i = 1;
  let solveStep = (gk=0.5) => {
    let solver = solveStep1();

    if (i % 40 === 0.0) {
      let c1 = getCenter(nodes);

      let rfac = 1000.0;

      if (best) loadGraph(nodes, best);

      for (let n of nodes) {
        n.pos[0] += (Math.random() - 0.5) * rfac * speed;
        n.pos[1] += (Math.random() - 0.5) * rfac * speed;
        n.vel.zero();
      }

      let c2 = getCenter(nodes);
      c1.sub(c2);

      for (let n of nodes) {
        n.pos.add(c1);
      }
    }

    let err = 1e17;

    for (let n of nodes) {
      n.oldpos.load(n.pos);
      n.pos.addFac(n.vel, 0.5);
    }

    disableEdges = false;
    disableArea = true;
    solver.solve(1, gk);

    //solve so boxes don't overlap
    disableEdges = true;
    disableArea = false;

    for (let j=0; j<10; j++) {
      solver = solveStep1();
      err = solver.solve(10, gk*speed);
    }

    for (let n of nodes) {
      n.vel.load(n.pos).sub(n.oldpos);
    }

    //get error from edge constraints

    disableEdges = false;
    disableArea = true;

    err = 0.0;
    for (let con of solver.constraints) {
      err += con.evaluate(true);
    }

    disableEdges = false;
    disableArea = false;

    /*
    loadGraph(orignodes, nodes);
    if (updateCb) {
      updateCb();
    }//*/

    lasterr = err;

    let add = Math.random()*besterr*Math.exp(-i*0.1);

    if (besterr === undefined || err < besterr+add) {
      best = copyGraph(nodes);
      besterr = err;
    }

    i++;

    return err;
  };


  for (let j=0; j<steps; j++) {
    solveStep();

    decayi++;
    decay = Math.exp(-decayi*0.1);
  }

  min.zero().addScalar(1e17);
  max.zero().addScalar(-1e17);

  for (let node of (best ? best : nodes)) {
    min.min(node.pos);
    p2.load(node.pos).add(node.size);
    max.max(p2);
  }

  for (let node of (best ? best : nodes)) {
    node.pos.sub(min);
  }

  loadGraph(orignodes, best ? best : nodes);

  if (updateCb) {
    if (nodes._timer !== undefined) {
      window.clearInterval(nodes._timer);
    }

    nodes._timer = window.setInterval(() => {
      let time = time_ms();

      while (time_ms() - time < 50) {
        let err = solveStep();
      }

      if (cconst.DEBUG.boxPacker) {
        console.log("err", (besterr / nodes.length).toFixed(2), (lasterr / nodes.length).toFixed(2), "isects", isect.length);
      }

      if (best) loadGraph(orignodes, best);

      if (updateCb() === false) {
        clearInterval(nodes._timer);
        return;
      }
    }, 100);

    let timer = nodes._timer;

    return {
      stop : () => {
        if (best) loadGraph(nodes, best);

        window.clearInterval(timer);
        nodes._timer = undefined;
      }
    }
  }
}

/**
 see doc_src/context.md
 */

let notifier = undefined;

function setNotifier(cls) {
  notifier = cls;
}

const ContextFlags = {
  IS_VIEW : 1
};

class InheritFlag$1 {
  constructor(data) {
    this.data = data;
  }
}

let __idgen = 1;

if (Symbol.ContextID === undefined) {
  Symbol.ContextID = Symbol("ContextID");
}

if (Symbol.CachedDef === undefined) {
  Symbol.CachedDef = Symbol("CachedDef");
}

const _ret_tmp = [undefined];

const OverlayClasses = [];

class ContextOverlay {
  constructor(appstate) {
    this.ctx = undefined; //owning context
    this._state = appstate;
  }

  get state() {
    return this._state;
  }

  /*
  Ugly hack, ui_lasttool.js saves
  a DataStruct wrapping the most recently executed ToolOp
  in this.state._last_tool.
  */
  get last_tool() {
    return this.state._last_tool;
  }


  onRemove(have_new_file=false) {
  }

  copy() {
    return new this.constructor(this._state);
  }

  validate() {
    throw new Error("Implement me!");
  }


  //base classes override this
  static contextDefine() {
    throw new Error("implement me!");
    return {
      name   :   "",
      flag   :   0
    }
  }

  //don't override this
  static resolveDef() {
    if (this.hasOwnProperty(Symbol.CachedDef)) {
      return this[Symbol.CachedDef];
    }

    let def2 = Symbol.CachedDef = {};

    let def = this.contextDefine();

    if (def === undefined) {
      def = {};
    }

    for (let k in def) {
      def2[k] = def[k];
    }

    if (!("flag") in def) {
      def2.flag = Context.inherit(0);
    }

    let parents = [];
    let p = getClassParent(this);

    while (p && p !== ContextOverlay) {
      parents.push(p);
      p = getClassParent(p);
    }

    if (def2.flag instanceof InheritFlag$1) {
      let flag = def2.flag.data;
      for (let p of parents) {
        let def = p.contextDefine();

        if (!def.flag) {
          continue;
        }else if (def.flag instanceof InheritFlag$1) {
          flag |= def.flag.data;
        } else {
          flag |= def.flag;
          //don't go past non-inheritable parents
          break;
        }
      }

      def2.flag = flag;
    }

    return def2;
  }
}

const excludedKeys = new Set(["onRemove", "reset", "toString", "_fix",
                                     "valueOf", "copy", "next", "save", "load", "clear", "hasOwnProperty",
                                     "toLocaleString", "constructor", "propertyIsEnumerable", "isPrototypeOf",
                                     "state", "saveProperty", "loadProperty", "getOwningOverlay", "_props"]);

class LockedContext {
  constructor(ctx) {
    this.props = {};

    this.state = ctx.state;
    this.api = ctx.api;
    this.toolstack = ctx.toolstack;

    this.load(ctx);
  }

  toLocked() {
    //just return itself
    return this;
  }

  error() {
    return this.ctx.error(...arguments);
  }
  warning() {
    return this.ctx.warning(...arguments);
  }
  message() {
    return this.ctx.message(...arguments);
  }
  progbar() {
    return this.ctx.progbar(...arguments);
  }

  load(ctx) {
    //let keys = util.getAllKeys(ctx);
    let keys = ctx._props;

    function wrapget(name) {
      return function(ctx2, data) {
        return ctx.loadProperty(ctx2, name, data);
      }
    }

    for (let k of keys) {
      let v;
      if (k === "state" || k === "toolstack" || k === "api") {
        continue;
      }

      if (typeof k === "string" && (k.endsWith("_save") || k.endsWith("_load"))) {
        continue;
      }

      try {
        v = ctx[k];
      } catch (error) {
        if (config.DEBUG.contextSystem) {
          console.warn("failed to look up property in context: ", k);
        }
        continue;
      }

      let data, getter;
      let overlay = ctx.getOwningOverlay(k);

      if (overlay === undefined) {
        //property must no longer be used?
        continue;
      }

      try {
        if (typeof k === "string" && (overlay[k + "_save"] && overlay[k + "_load"])) {
          data = overlay[k + "_save"]();
          getter = overlay[k + "_load"];
        } else {
          data = ctx.saveProperty(k);
          getter = wrapget(k);
        }
      } catch (error) {
        //util.print_stack(error);
        console.warn("Failed to save context property", k);
        continue;
      }

      this.props[k] = {
        data : data,
        get  : getter
      };
    }

    let defineProp = (name) => {
      Object.defineProperty(this, name, {
        get : function() {
          let def = this.props[name];
          return def.get(this.ctx, def.data)
        }
      });
    };

    for (let k in this.props) {
      defineProp(k);
    }

    this.ctx = ctx;
  }

  setContext(ctx) {
    this.ctx = ctx;

    this.state = ctx.state;
    this.api = ctx.api;
    this.toolstack = ctx.toolstack;
  }
}

let next_key = {};
let idgen$1 = 1;

class Context {
  constructor(appstate) {
    this.state = appstate;

    this._props = new Set();
    this._stack = [];
    this._inside_map = {};
  }

  /** chrome's debug console corrupts this._inside_map,
   this method fixes it*/
  _fix() {
    this._inside_map = {};
  }

  fix() {
    this._fix();
  }

  error(message, timeout=1500) {
    let state = this.state;

    console.warn(message);

    if (state && state.screen) {
      return notifier.error(state.screen, message, timeout);
    }
  }

  warning(message, timeout=1500) {
    let state = this.state;

    console.warn(message);

    if (state && state.screen) {
      return notifier.warning(state.screen, message, timeout);
    }
  }

  message(msg, timeout=1500) {
    let state = this.state;

    console.warn(msg);

    if (state && state.screen) {
      return notifier.message(state.screen, msg, timeout);
    }
  }

  progbar(msg, perc=0.0, timeout=1500, id=msg) {
    let state = this.state;

    if (state && state.screen) {
      //progbarNote(screen, msg, percent, color, timeout) {
      return notifier.progbarNote(state.screen, msg, perc, "green", timeout, id);
    }
  }

  validateOverlays() {
    let stack = this._stack;
    let stack2 = [];

    for (let i=0; i<stack.length; i++) {
      if (stack[i].validate()) {
        stack2.push(stack[i]);
      }
    }

    this._stack = stack2;
  }

  hasOverlay(cls) {
    return this.getOverlay(cls) !== undefined;
  }

  getOverlay(cls) {
    for (let overlay of this._stack) {
      if (overlay.constructor === cls) {
        return overlay;
      }
    }
  }

  clear(have_new_file=false) {
    for (let overlay of this._stack) {
      overlay.onRemove(have_new_file);
    }

    this._stack = [];
  }

  //this is implemented by child classes
  //it should load the same default overlays as in constructor
  reset(have_new_file=false) {
    this.clear(have_new_file);
  }

  //returns a new context with overriden properties
  //unlike pushOverlay, overrides can be a simple object
  override(overrides) {
    if (overrides.copy === undefined) {
      overrides.copy = function() {
        return Object.assign({}, this);
      };
    }

    let ctx = this.copy();
    ctx.pushOverlay(overrides);
    return ctx;
  }

  copy() {
    let ret = new this.constructor(this.state);

    for (let item of this._stack) {
      ret.pushOverlay(item.copy());
    }

    return ret;
  }

  /**
   Used by overlay property getters.  If returned,
   the next overlay in the struct will have its getter used.

   Example:

   class overlay {
      get scene() {
        if (some_reason) {
          return Context.super();
        }

        return something_else;
      }
    }
   */
  static super() {
    return next_key;
  }

  /**
   *
   * saves a property into some kind of non-object-reference form
   *
   * */
  saveProperty(key) {
    //console.warn("Missing saveProperty implementation in Context; passing through values...", key)
    return this[key];
  }

  /**
   *
   * lookup property based on saved data
   *
   * */
  loadProperty(ctx, key, data) {
    //console.warn("Missing loadProperty implementation in Context; passing through values...", key)
    return data;
  }

  getOwningOverlay(name, _val_out) {
    let inside_map = this._inside_map;
    let stack = this._stack;

    if (config.DEBUG.contextSystem) {
      console.log(name, inside_map);
    }

    for (let i=stack.length-1; i >= 0; i--) {
      let overlay = stack[i];
      let ret = next_key;

      if (overlay[Symbol.ContextID] === undefined) {
        throw new Error("context corruption");
      }

      let ikey = overlay[Symbol.ContextID];

      if (config.DEBUG.contextSystem) {
        console.log(ikey, overlay);
      }

      //prevent infinite recursion
      if (inside_map[ikey]) {
        continue;
      }

      if (overlay.__allKeys.has(name)) {
        if (config.DEBUG.contextSystem) {
          console.log("getting value");
        }

        //Chrome's console messes this up

        inside_map[ikey] = 1;

        try {
          ret = overlay[name];
        } catch (error) {

          inside_map[ikey] = 0;
          throw error;
        }

        inside_map[ikey] = 0;
      }

      if (ret !== next_key) {
        if (_val_out !== undefined) {
          _val_out[0] = ret;
        }
        return overlay;
      }
    }

    if (_val_out !== undefined) {
      _val_out[0] = undefined;
    }

    return undefined;
  }

  ensureProperty(name) {
    if (this.hasOwnProperty(name)) {
      return;
    }

    this._props.add(name);

    Object.defineProperty(this, name, {
      get : function() {
        let ret = _ret_tmp;
        _ret_tmp[0] = undefined;

        this.getOwningOverlay(name, ret);
        return ret[0];
      }, set : function() {
        throw new Error("Cannot set ctx properties")
      }
    });
  }

  /**
   * Returns a new context that doesn't
   * contain any direct object references
   * except for .state .datalib and .api, but
   * instead uses those three to look up references
   * on property access.
   * */
  toLocked() {
    return new LockedContext(this);
  }

  pushOverlay(overlay) {
    if (!overlay.hasOwnProperty(Symbol.ContextID)) {
      overlay[Symbol.ContextID] = idgen$1++;
    }

    let keys = new Set();
    for (let key of getAllKeys(overlay)) {
      if (!excludedKeys.has(key) && !(typeof key === "string" && key[0] === "_")) {
        keys.add(key);
      }
    }

    overlay.ctx = this;

    if (overlay.__allKeys === undefined) {
      overlay.__allKeys = keys;
    }

    for (let k of keys) {
      let bad = typeof k === "symbol" || excludedKeys.has(k);
      bad = bad || (typeof k === "string" && k[0] === "_");
      bad = bad || (typeof k === "string" && k.endsWith("_save"));
      bad = bad || (typeof k === "string" && k.endsWith("_load"));

      if (bad) {
        continue;
      }

      this.ensureProperty(k);
    }

    if (this._stack.indexOf(overlay) >= 0) {
      console.warn("Overlay already added once");
      if (this._stack[this._stack.length-1] === overlay) {
        console.warn("  Definitely an error, overlay is already at top of stack");
        return;
      }
    }

    this._stack.push(overlay);
  }

  popOverlay(overlay) {
    if (overlay !== this._stack[this._stack.length-1]) {
      console.warn("Context.popOverlay called in error", overlay);
      return;
    }

    overlay.onRemove();
    this._stack.pop();
  }

  removeOverlay(overlay) {
    if (this._stack.indexOf(overlay) < 0) {
      console.warn("Context.removeOverlay called in error", overlay);
      return;
    }

    overlay.onRemove();
    this._stack.remove(overlay);
  }

  static inherit(data) {
    return new InheritFlag$1(data);
  }

  static register(cls) {
    if (cls[Symbol.ContextID]) {
      console.warn("Tried to register same class twice:", cls);
      return;
    }

    cls[Symbol.ContextID] = __idgen++;
    OverlayClasses.push(cls);
  }
}

function test() {
  function testInheritance() {
    class Test0 extends ContextOverlay {
      static contextDefine() {
        return {
          flag: 1
        }
      }
    }

    class Test1 extends Test0 {
      static contextDefine() {
        return {
          flag: 2
        }
      }
    }

    class Test2 extends Test1 {
      static contextDefine() {
        return {
          flag: Context.inherit(4)
        }
      }
    }

    class Test3 extends Test2 {
      static contextDefine() {
        return {
          flag: Context.inherit(8)
        }
      }
    }

    class Test4 extends Test3 {
      static contextDefine() {
        return {
          flag: Context.inherit(16)
        }
      }
    }

    return Test4.resolveDef().flag === 30;
  }

  return testInheritance();
}

if (!test()) {
  throw new Error("Context test failed");
}

const solver = solver1;
const util = util1;
const vectormath = vectormath1;
const math = math1;
const toolprop_abstract = toolprop_abstract1;
const html5_fileapi = html5_fileapi1;
const parseutil = parseutil1;
const config$1 = config1;
const nstructjs$1 = nstructjs;

var controller1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  solver: solver,
  util: util,
  vectormath: vectormath,
  math: math,
  toolprop_abstract: toolprop_abstract,
  html5_fileapi: html5_fileapi,
  parseutil: parseutil,
  config: config$1,
  nstructjs: nstructjs$1,
  setNotifier: setNotifier,
  ContextFlags: ContextFlags,
  OverlayClasses: OverlayClasses,
  ContextOverlay: ContextOverlay,
  excludedKeys: excludedKeys,
  LockedContext: LockedContext,
  Context: Context,
  test: test,
  DataPathError: DataPathError,
  DataFlags: DataFlags,
  DataTypes: DataTypes,
  getTempProp: getTempProp,
  getVecClass: getVecClass,
  isVecProperty: isVecProperty,
  DataPath: DataPath,
  StructFlags: StructFlags,
  ListIface: ListIface,
  ToolOpIface: ToolOpIface,
  setImplementationClass: setImplementationClass,
  registerTool: registerTool,
  pathParser: pathParser,
  pushReportName: pushReportName,
  popReportName: popReportName,
  DataList: DataList,
  DataStruct: DataStruct,
  DataAPI: DataAPI,
  initSimpleController: initSimpleController,
  getDataPathToolOp: getDataPathToolOp,
  setDataPathToolOp: setDataPathToolOp,
  ModelInterface: ModelInterface,
  DataPathSetOp: DataPathSetOp,
  ToolClasses: ToolClasses,
  setContextClass: setContextClass,
  ToolFlags: ToolFlags,
  UndoFlags: UndoFlags,
  setDefaultUndoHandlers: setDefaultUndoHandlers,
  ToolPropertyCache: ToolPropertyCache,
  SavedToolDefaults: SavedToolDefaults,
  ToolOp: ToolOp,
  MacroLink: MacroLink,
  MacroClasses: MacroClasses,
  ToolMacro: ToolMacro,
  ToolStack: ToolStack,
  buildToolSysAPI: buildToolSysAPI,
  PropTypes: PropTypes,
  PropFlags: PropFlags,
  isNumber: isNumber,
  NumberConstraintsBase: NumberConstraintsBase,
  IntegerConstraints: IntegerConstraints,
  FloatConstrinats: FloatConstrinats,
  NumberConstraints: NumberConstraints,
  PropSubTypes: PropSubTypes$1,
  setPropTypes: setPropTypes,
  customPropertyTypes: customPropertyTypes,
  PropClasses: PropClasses,
  get defaultRadix () { return defaultRadix; },
  get defaultDecimalPlaces () { return defaultDecimalPlaces; },
  ToolProperty: ToolProperty$1,
  FloatArrayProperty: FloatArrayProperty,
  StringProperty: StringProperty,
  NumProperty: NumProperty,
  _NumberPropertyBase: _NumberPropertyBase,
  IntProperty: IntProperty,
  ReportProperty: ReportProperty,
  BoolProperty: BoolProperty,
  FloatProperty: FloatProperty,
  EnumKeyPair: EnumKeyPair,
  EnumProperty: EnumProperty,
  FlagProperty: FlagProperty,
  VecPropertyBase: VecPropertyBase,
  Vec2Property: Vec2Property,
  Vec3Property: Vec3Property,
  Vec4Property: Vec4Property,
  QuatProperty: QuatProperty,
  Mat4Property: Mat4Property,
  ListProperty: ListProperty,
  StringSetProperty: StringSetProperty,
  Curve1DProperty: Curve1DProperty,
  ToolPaths: ToolPaths,
  buildParser: buildParser,
  Parser: Parser,
  parseToolPath: parseToolPath,
  testToolParser: testToolParser,
  initToolPaths: initToolPaths,
  CurveConstructors: CurveConstructors,
  CURVE_VERSION: CURVE_VERSION,
  CurveFlags: CurveFlags,
  TangentModes: TangentModes,
  getCurve: getCurve,
  CurveTypeData: CurveTypeData,
  evalHermiteTable: evalHermiteTable,
  genHermiteTable: genHermiteTable,
  SplineTemplates: SplineTemplates,
  SplineTemplateIcons: SplineTemplateIcons,
  mySafeJSONStringify: mySafeJSONStringify$1,
  mySafeJSONParse: mySafeJSONParse$1,
  Curve1D: Curve1D,
  EulerOrders: EulerOrders,
  BaseVector: BaseVector,
  F64BaseVector: F64BaseVector,
  F32BaseVector: F32BaseVector,
  Vector4: Vector4,
  Vector3: Vector3,
  Vector2: Vector2,
  Quat: Quat,
  Matrix4: Matrix4,
  quad_bilinear: quad_bilinear,
  ClosestModes: ClosestModes,
  AbstractCurve: AbstractCurve,
  ClosestCurveRets: ClosestCurveRets,
  closestPoint: closestPoint,
  normal_poly: normal_poly,
  dihedral_v3_sqr: dihedral_v3_sqr,
  tet_volume: tet_volume,
  calc_projection_axes: calc_projection_axes,
  aabb_isect_line_3d: aabb_isect_line_3d,
  aabb_isect_cylinder_3d: aabb_isect_cylinder_3d,
  barycentric_v2: barycentric_v2,
  closest_point_on_quad: closest_point_on_quad,
  closest_point_on_tri: closest_point_on_tri,
  dist_to_tri_v3_old: dist_to_tri_v3_old,
  dist_to_tri_v3: dist_to_tri_v3,
  dist_to_tri_v3_sqr: dist_to_tri_v3_sqr,
  tri_area: tri_area,
  aabb_overlap_area: aabb_overlap_area,
  aabb_isect_2d: aabb_isect_2d,
  aabb_isect_3d: aabb_isect_3d,
  aabb_intersect_2d: aabb_intersect_2d,
  aabb_intersect_3d: aabb_intersect_3d,
  aabb_union: aabb_union,
  aabb_union_2d: aabb_union_2d,
  feps: feps,
  COLINEAR: COLINEAR,
  LINECROSS: LINECROSS,
  COLINEAR_ISECT: COLINEAR_ISECT,
  SQRT2: SQRT2,
  FEPS_DATA: FEPS_DATA,
  FEPS: FEPS,
  get FLOAT_MIN () { return FLOAT_MIN; },
  get FLOAT_MAX () { return FLOAT_MAX; },
  Matrix4UI: Matrix4UI,
  get_rect_points: get_rect_points,
  get_rect_lines: get_rect_lines,
  simple_tri_aabb_isect: simple_tri_aabb_isect,
  MinMax: MinMax,
  winding_axis: winding_axis,
  winding: winding,
  inrect_2d: inrect_2d,
  aabb_isect_line_2d: aabb_isect_line_2d,
  expand_rect2d: expand_rect2d,
  expand_line: expand_line,
  colinear: colinear,
  corner_normal: corner_normal,
  line_line_isect: line_line_isect,
  line_line_cross: line_line_cross,
  point_in_aabb_2d: point_in_aabb_2d,
  aabb_sphere_isect_2d: aabb_sphere_isect_2d,
  point_in_aabb: point_in_aabb,
  aabb_sphere_isect: aabb_sphere_isect,
  aabb_sphere_dist: aabb_sphere_dist,
  point_in_tri: point_in_tri,
  convex_quad: convex_quad,
  isNum: isNum,
  normal_tri: normal_tri,
  normal_quad: normal_quad,
  normal_quad_old: normal_quad_old,
  line_isect: line_isect,
  dist_to_line_2d: dist_to_line_2d,
  dist_to_line_sqr: dist_to_line_sqr,
  dist_to_line: dist_to_line,
  clip_line_w: clip_line_w,
  closest_point_on_line: closest_point_on_line,
  circ_from_line_tan: circ_from_line_tan,
  circ_from_line_tan_2d: circ_from_line_tan_2d,
  get_tri_circ: get_tri_circ,
  gen_circle: gen_circle,
  rot2d: rot2d,
  makeCircleMesh: makeCircleMesh,
  minmax_verts: minmax_verts,
  unproject: unproject,
  project: project,
  get_boundary_winding: get_boundary_winding,
  PlaneOps: PlaneOps,
  isect_ray_plane: isect_ray_plane,
  _old_isect_ray_plane: _old_isect_ray_plane,
  mesh_find_tangent: mesh_find_tangent,
  Mat4Stack: Mat4Stack,
  trilinear_v3: trilinear_v3,
  point_in_hex: point_in_hex,
  trilinear_co: trilinear_co,
  trilinear_co2: trilinear_co2,
  tri_angles: tri_angles,
  rgb_to_hsv: rgb_to_hsv,
  hsv_to_rgb: hsv_to_rgb,
  cmyk_to_rgb: cmyk_to_rgb,
  rgb_to_cmyk: rgb_to_cmyk,
  PackNodeVertex: PackNodeVertex,
  PackNode: PackNode,
  graphGetIslands: graphGetIslands,
  graphPack: graphPack,
  Constraint: Constraint,
  Solver: Solver,
  modalstack: modalstack,
  singleMouseEvent: singleMouseEvent,
  isLeftClick: isLeftClick,
  DoubleClickHandler: DoubleClickHandler,
  isMouseDown: isMouseDown,
  pathDebugEvent: pathDebugEvent,
  eventWasTouch: eventWasTouch,
  copyEvent: copyEvent,
  _setScreenClass: _setScreenClass,
  _setModalAreaClass: _setModalAreaClass,
  pushPointerModal: pushPointerModal,
  pushModalLight: pushModalLight,
  popModalLight: popModalLight,
  haveModal: haveModal,
  keymap_latin_1: keymap_latin_1,
  keymap: keymap,
  reverse_keymap: reverse_keymap,
  HotKey: HotKey,
  KeyMap: KeyMap
});

let promise;

if (window.haveElectron) {
  promise = Promise.resolve().then(function () { return electron_api1; });
} else {
  promise = Promise.resolve().then(function () { return web_api; });
}

var platform;

promise.then((module) => {
  platform = module.platform;
  promise = undefined;
});

function getPlatformAsync() {
  if (promise) {
    return promise;
  }

  return new Promise((accept, reject) => {
    accept(platform);
  })
}

var platform1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get platform () { return platform; },
  getPlatformAsync: getPlatformAsync
});

const mimeMap = {
  ".js"  : "application/javascript",
  ".json": "text/json",
  ".html": "text/html",
  ".txt" : "text/plain",
  ".jpg" : "image/jpeg",
  ".png" : "image/png",
  ".tiff": "image/tiff",
  ".gif" : "image/gif",
  ".bmp" : "image/bitmap",
  ".tga" : "image/targa",
  ".svg" : "image/svg+xml",
  ".xml" : "text/xml"
};

var textMimes = new Set([
  "application/javascript", "application/x-javscript",
  "image/svg+xml", "application/xml"
]);

function isMimeText(mime) {
  if (!mime) {
    return false;
  }

  if (mime.startsWith("text")) {
    return true;
  }

  return textMimes.has(mime);
}

function getExtension(path) {
  if (!path) {
    return "";
  }

  let i = path.length;
  while (i > 0 && path[i] !== ".") {
    i--;
  }

  return path.slice(i, path.length).trim().toLowerCase();
}

function getMime(path) {
  let ext = getExtension(path);
  if (ext in mimeMap) {
    return mimeMap[ext];
  }

  return "application/x-octet-stream";
}

class PlatformAPI {
  static writeFile(data, handle, mime) {
    throw new Error("implement me");
    //returns a promise
  }

  static resolveURL(path, base=location.href) {
    base = base.trim();

    if (path.startsWith("./")) {
      path = path.slice(2, path.length).trim();
    }

    while (path.startsWith("/")) {
      path = path.slice(1, path.length).trim();
    }

    while (base.endsWith("/")) {
      base = base.slice(0, base.length-1).trim();
    }

    let exts = ["html", "txt", "js", "php", "cgi"];
    for (let ext of exts) {
      ext = "." + ext;
      if (base.endsWith(ext)) {
        let i = base.length-1;
        while (i > 0 && base[i] !== "/") {
          i--;
        }

        base = base.slice(0, i).trim();
      }
    }

    while (base.endsWith("/")) {
      base = base.slice(0, base.length-1).trim();
    }

    console.log("BASE", base);
    
    path = (base + "/" + path).split("/");
    let path2 = [];

    for (let i=0; i<path.length; i++) {
      if (path[i] === "..") {
        path2.pop();
      } else {
        path2.push(path[i]);
      }
    }

    return path2.join("/");
  }

  //returns a promise that resolves to a FilePath that can be used for re-saving.
  static showOpenDialog(title, args=new FileDialogArgs()) {
    throw new Error("implement me");
  }

  //returns a promise
  static showSaveDialog(title, savedata_cb, args=new FileDialogArgs()) {
    throw new Error("implement me");
  }

  //returns a promise.  if mime is a text type, a string will be fed to the promise,
  //otherwise it will be an ArrayBuffer
  static readFile(path, mime) {
    throw new Error("implement me");
  }
}

class FileDialogArgs {
  constructor() {
    this.multi = false; //allow selecting multiple files
    this.addToRecentList = false; //update recent file list

    /* example for filters:
    [{
      name : "Images",
      mime : "image/png"
      extensions : "["png", "jpg"]
    }]
    * */
    this.filters = [];
  }
}

/*a file path, some platforms may not return real payhs*/
class FilePath {
  constructor(data, filename="unnamed") {
    this.data = data;
    this.filename = filename;
  }
}

"use strict";

function getElectronVersion() {
  let key = navigator.userAgent;
  let i = key.search("Electron");
  key = key.slice(i + 9, key.length);

  i = key.search(/[ \t]/);
  if (i >= 0) {
    key = key.slice(0, i);
  }

  key = key.trim();
  key = key.split(".").map(f => parseInt(f));

  return key;
}

/*
* wrap require to keep angular from auto-importing
* this api in browsers
* */
function getElectron() {
  return require('electron');
}

function myRequire(mod) {
  return globalThis.require(mod);
}

function getFilename(path) {
  let filename = path.replace(/\\/g, "/");
  let i = filename.length - 1;
  while (i >= 0 && filename[i] !== "/") {
    i--;
  }
  if (i > 0) {
    filename = filename.slice(i, filename.length).trim();
  }

  return filename;
}

let _menu_init = false;
let _init = false;

let mimemap = {
  "js"  : "application/javascript",
  "json": "text/json",
  "png" : "image/png",
  "svg" : "image/svg+xml",
  "jpg" : "image/jpeg",
  "txt" : "text/plain",
  "html": "text/html",
  "css" : "text/css",
  "ts"  : "application/typescript",
  "py"  : "application/python",
  "c"   : "application/c",
  "cpp" : "application/cpp",
  "cc"  : "application/cpp",
  "h"   : "application/c",
  "hh"  : "application/cpp",
  "hpp" : "application/cpp",
  "xml" : "text/xml",
  "sh"  : "application/bash",
  "mjs" : "application/javascript",
  "cjs" : "application/javascript",
  "gif" : "image/gif"
};


let electron_menu_idgen = 1;
let ipcRenderer;

class ElectronMenu extends Array {
  constructor(args = {}) {
    super();

    this._ipcId = electron_menu_idgen++;

    for (let k in args) {
      this[k] = args[k];
    }
  }

  insert(i, item) {
    this.length++;

    let j = this.length-1;
    while (j > i) {
      this[j] = this[j-1];
      j--;
    }
    this[i] = item;

    return this;
  }

  static setApplicationMenu(menu) {
    initElectronIpc();

    ipcRenderer.invoke("set-menu-bar", menu);
  }

  closePopup() {
    ipcRenderer.invoke("close-menu", this._ipcId);
  }

  append(item) {
    this.push(item);
  }

  popup(args) {
    let {x, y, callback} = args;

    callback = wrapRemoteCallback("popup_menu_click", callback);

    const {ipcRenderer} = require('electron');
    ipcRenderer.invoke("popup-menu", this, x, y, callback);
  }
}

let callbacks = {};
let keybase = 1;

function wrapRemoteCallback(key, callback) {
  key = "remote_" + key + (keybase++);
  callbacks[key] = callback;

  return key;
}

let ipcInit = false;

function initElectronIpc() {
  if (ipcInit) {
    return;
  }

  ipcInit = true;
  ipcRenderer = require('electron').ipcRenderer;

  ipcRenderer.on('invoke-menu-callback', (event, key, args) => {
    //console.error("Electron menu callback", key, args);
    callbacks[key].apply(undefined, args);
  });
}


class ElectronMenuItem {
  constructor(args) {
    for (let k in args) {
      this[k] = args[k];
    }

    if (this.click) {
      this.click = wrapRemoteCallback("menu_click", this.click);
    }
  }
}

function patchDropBox() {
  initElectronIpc();

  //haveElectron = false;
  //return;
  DropBox.prototype._onpress = function _onpress(e) {
    if (this._menu !== undefined) {
      this._menu.close();
      this._menu = undefined;
      this._pressed = false;
      this._redraw();
      return;
    }

    this._build_menu();

    let emenu = buildElectronMenu(this._menu);

    this._menu.close = () => {
      emenu.closePopup(); //getCurrentWindow);
    };

    //console.log("menu dropbox click", this._menu);

    if (this._menu === undefined) {
      return;
    }

    this._menu._dropbox = this;
    this.dom._background = this.getDefault("BoxDepressed");
    this._background = this.getDefault("BoxDepressed");
    this._redraw();
    this._pressed = true;
    this.setCSS();

    let onclose = this._menu.onclose;
    this._menu.onclose = () => {
      this._pressed = false;
      this._redraw();

      let menu = this._menu;
      if (menu) {
        this._menu = undefined;
        menu._dropbox = undefined;
      }

      if (onclose) {
        onclose.call(menu);
      }
    };

    let menu = this._menu;
    let screen = this.getScreen();

    let dpi = this.getDPI();

    let x = e.x, y = e.y;
    let rects = this.dom.getClientRects();

    x = rects[0].x;
    y = rects[0].y + Math.ceil(rects[0].height);

    x = ~~x;
    y = ~~y;

    emenu.popup({
      x       : x,
      y       : y,
      callback: () => {

        if (this._menu) {
          this._menu.onclose();
        }
      }
    });
  };
}

let on_tick = () => {
  let nativeTheme = getElectron().remote.nativeTheme;

  let mode = nativeTheme.shouldUseDarkColors ? "dark" : "light";

  if (mode !== exports.colorSchemeType) {
    nativeTheme.themeSource = exports.colorSchemeType;
  }
};

function checkInit() {
  if (window.haveElectron && !_init) {
    _init = true;


    patchDropBox();
    setInterval(on_tick, 350);
  }
}

let iconcache = {};

function makeIconKey(icon, iconsheet, invertColors) {
  return "" + icon + ":" + iconsheet + ":" + invertColors;
}

function getNativeIcon(icon, iconsheet = 0, invertColors = false, size = 16) {
  //let key = makeIconKey(icon, iconsheet, invertColors);
  //if (key in iconcache) {
  //  return iconcache[key];
  //}

  let icongen;

  try {
    icongen = myRequire("./icogen.js");
  } catch (error) {
    icongen = myRequire("./icogen.cjs");
  }


  window.icongen = icongen;
  let nativeImage = getElectron().nativeImage;

  let manager = getIconManager();
  let sheet = manager.findSheet(iconsheet);
  let images = [];

  let sizes = icongen.GetRequiredICOImageSizes();

  //for (let size of sizes) {
  if (1) {
    let iconsheet = manager.findClosestSheet(size);
    let tilesize = manager.getTileSize(iconsheet);

    let canvas = document.createElement("canvas");
    let g = canvas.getContext("2d");

    canvas.width = canvas.height = size;

    if (invertColors) {
      g.filter = "invert(100%)";
    }

    let scale = size/tilesize;
    g.scale(scale, scale);

    manager.canvasDraw({getDPI: () => 1.0}, canvas, g, icon, 0, 0, iconsheet);

    let header = "data:image/png;base64,";
    let data = canvas.toDataURL();

    data = data.slice(header.length, data.length);
    data = Buffer.from(data, "base64");

    myRequire("fs").writeFileSync("./myicon2.png", data);

    images.push(data);
  }
  //}

  //let ico = icongen.GenerateICO(images);
  //icon = nativeImage.createFromBuffer(ico);
  //icon = nativeImage.createFromBitmap(ico);
  //myRequire("fs").writeFileSync("myicon2.ico", ico);
  return "myicon2.png"
  return icon;
  return undefined

  window._icon = icon;
  return icon;
}

let map$1 = {
  CTRL   : "Control",
  ALT    : "Alt",
  SHIFT  : "Shift",
  COMMAND: "Command"
};

function buildElectronHotkey(hk) {
  hk = hk.trim().replace(/[ \t-]+/g, "+");
  for (let k in map$1) {
    hk = hk.replace(k, map$1[k]);
  }

  return hk;
}

function buildElectronMenu(menu) {
  let electron = getElectron().remote;

  initElectronIpc();

  //let ElectronMenu = electron.Menu;
  //let ElectronMenuItem = electron.MenuItem;

  let emenu = new ElectronMenu();

  let buildItem = (item) => {
    if (item._isMenu) {
      let menu2 = item._menu;

      return new ElectronMenuItem({
        submenu: buildElectronMenu(item._menu),
        label  : menu2.getAttribute("title")
      });
    }


    let hotkey = item.hotkey;
    let icon = item.icon;
    let label = "" + item.label;

    if (hotkey && typeof hotkey !== "string") {
      hotkey = buildElectronHotkey(hotkey);
    } else {
      hotkey = "" + hotkey;
    }

    if (icon < 0) {
      icon = undefined;
    }

    let args = {
      id                 : "" + item._id,
      label              : label,
      accelerator        : hotkey,
      icon               : icon ? getNativeIcon(icon) : undefined,
      click              : function () {
        menu.onselect(item._id);
      },
      registerAccelerator: false
    };

    return new ElectronMenuItem(args);
  };

  for (let item of menu.items) {
    //buildItem(item);
    emenu.append(buildItem(item));

  }

  return emenu;
}

function initMenuBar(menuEditor, override = false) {
  checkInit();

  if (!window.haveElectron) {
    return;
  }

  if (_menu_init && !override) {
    return;
  }

  _menu_init = true;

  let electron = getElectron().remote;

  //let win = electron.getCurrentWindow();

  let menu = new ElectronMenu();

  let _roles = new Set(["undo", "redo", "cut", "copy", "paste", "delete", "about",
                        "quit", "open", "save", "load", "paste", "cut", "zoom"]);
  let roles = {};
  for (let k of _roles) {
    roles[k] = k;
  }

  roles = Object.assign(roles, {
    "select all": "selectAll",
    "file"      : "fileMenu",
    "edit"      : "editMenu",
    "view"      : "viewMenu",
    "app"       : "appMenu",
    "help"      : "help",
    "zoom in"   : "zoomIn",
    "zoom out"  : "zoomOut"
  });

  /*
  let item = new MenuItem({
    label : "Label",
    tooltip : "Tooltip",
    icon : getNativeIcon(0),
    accelerator : "Control+Z",
    checked : true,
    id : 0,
    role : undefined,
    click : (arg) => {
      console.log("menu click!", arg)
    },
    submenu : undefined,
    role :  undo, redo, cut, copy, paste, pasteAndMatchStyle, delete, selectAll, reload,
            forceReload, toggleDevTools, resetZoom, zoomIn, zoomOut, togglefullscreen, window,
             minimize, close, help, about, services, hide, hideOthers, unhide, quit, startSpeaking,
             stopSpeaking, close, minimize, zoom, front, appMenu, fileMenu, editMenu, viewMenu, recentDocuments,
              toggleTabBar, selectNextTab, selectPreviousTab, mergeAllWindows, clearRecentDocuments, moveTabToNewWindow
               or windowMenu - Define the action of the menu item, when specified the click property will be ignored.
                See roles.

  });//*/


  let header = menuEditor.header;
  for (let dbox of header.traverse(DropBox)) {
    dbox._build_menu();
    dbox.update();

    dbox._build_menu();
    let menu2 = dbox._menu;
    menu2.ctx = dbox.ctx;
    menu2._init();
    menu2.update();

    let title = dbox._genLabel();
    let args = {
      label  : title,
      tooltip: dbox.description,
      submenu: buildElectronMenu(menu2)
    };

    menu.insert(0, new ElectronMenuItem(args));
  }


  ElectronMenu.setApplicationMenu(menu);
  //win.setMenu(menu);
}

class platform$1 extends PlatformAPI {
  static showOpenDialog(title, args = new FileDialogArgs()) {
    const {dialog} = require('electron').remote;

    console.log(args.filters);

    let eargs = {
      defaultPath: args.defaultPath,
      filters    : this._sanitizeFilters(args.filters ?? []),
      properties : [
        "openFile", "showHiddenFiles", "createDirectory"
      ]
    };

    if (args.multi) {
      eargs.properties.push("multiSelections");
    }

    if (!args.addToRecentList) {
      eargs.properties.push("dontAddToRecent");
    }

    initElectronIpc();

    return new Promise((accept, reject) => {
      ipcRenderer.invoke('show-open-dialog', eargs, wrapRemoteCallback("open-dialog", (ret) => {
        if (ret.canceled || ret.cancelled) {
          reject("cancel");
        } else {
          accept(ret.filePaths.map(f => new FilePath(f, getFilename(f))));
        }
      }), wrapRemoteCallback("show-open-dialog", (error) => {
        reject(error);
      }));
    });
  }

  static _sanitizeFilters(filters) {
    let filters2 = [];

    for (let filter of filters) {
      if (Array.isArray(filter)) {
        let ext = filter[0];

        filter = {extensions: filter};

        ext = ext.replace(/\./g, "").trim().toLowerCase();
        if (ext in mimemap) {
          filter.mime = mimemap[ext];
        }

        filter.name = ext;
      }

      console.log(filter.extensions);
      filter.extensions = filter.extensions.map(f => f.startsWith(".") ? f.slice(1, f.length) : f);

      filters2.push(filter);
    }

    return filters2;
  }

  static showSaveDialog(title, filedata_cb, args = new FileDialogArgs()) {
    const {dialog} = require('electron').remote;

    console.log(args.filters);

    let eargs = {
      defaultPath: args.defaultPath,
      filters    : this._sanitizeFilters(args.filters ?? []),
      properties : [
        "openFile", "showHiddenFiles", "createDirectory"
      ]
    };

    if (args.multi) {
      eargs.properties.push("multiSelections");
    }

    if (!args.addToRecentList) {
      eargs.properties.push("dontAddToRecent");
    }

    return new Promise((accept, reject) => {
      initElectronIpc();

      let onthen = (ret) => {
        if (ret.canceled) {
          reject("cancel");
        } else {
          let path = ret.filePath;
          let filedata = filedata_cb();

          if (filedata instanceof ArrayBuffer) {
            filedata = new Uint8Array(filedata);
          }

          require('fs').writeFileSync(path, filedata);
          console.log("saved file", filedata);

          accept(new FilePath(path, getFilename(path)));
        }
      };

      let oncatch = (error) => {
        reject(error);
      };

      ipcRenderer.invoke('show-save-dialog', eargs, wrapRemoteCallback('dialog', onthen), wrapRemoteCallback('dialog', oncatch));

    });
  }

  static readFile(path, mime) {
    return new Promise((accept, reject) => {
      let fs = require('fs');

      if (isMimeText(mime)) {
        accept(fs.readFileSync(path.data, "utf8"));
      } else {
        accept(fs.readFileSync(path.data).buffer);
      }
    });
  }

  static writeFile(data, handle, mime) {
    return new Promise((accept, reject) => {
      let fs = require('fs');

      fs.writeFileSync(handle.data, data);
      accept(handle);
    });
  }
}

var electron_api1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ElectronMenu: ElectronMenu,
  wrapRemoteCallback: wrapRemoteCallback,
  ElectronMenuItem: ElectronMenuItem,
  checkInit: checkInit,
  iconcache: iconcache,
  getNativeIcon: getNativeIcon,
  buildElectronHotkey: buildElectronHotkey,
  buildElectronMenu: buildElectronMenu,
  initMenuBar: initMenuBar,
  platform: platform$1
});

"use strict";
const SVG_URL = 'http://www.w3.org/2000/svg';

const Vector2$b = Vector2;

class CanvasOverdraw extends UIBase$2 {
  constructor() {
    super();

    this.canvas = document.createElement("canvas");
    this.shadow.appendChild(this.canvas);
    this.g = this.canvas.getContext("2d");

    this.screen = undefined;
    this.shapes = [];
    this.otherChildren = []; //non-svg elements
    this.font = undefined;

    let style = document.createElement("style");
    style.textContent = `
      .overdrawx {
        pointer-events : none;
      }
    `;

    this.shadow.appendChild(style);
  }

  static define() {
    return {
      tagname : 'screen-overdraw-canvas-x'
    }
  }

  startNode(node, screen) {
    if (screen) {
      this.screen = screen;
      this.ctx = screen.ctx;
    }

    if (!this.parentNode) {
      node.appendChild(this);
    }

    this.style["display"] = "float";
    this.style["z-index"] = this.zindex_base;

    this.style["position"] = "absolute";
    this.style["left"] = "0px";
    this.style["top"] = "0px";

    this.style["width"] = "100%"; //screen.size[0] + "px";
    this.style["height"] = "100%"; //screen.size[1] + "px";

    this.style["pointer-events"] = "none";

    this.svg = document.createElementNS(SVG_URL, "svg");
    this.svg.style["width"] = "100%";
    this.svg.style["height"] = "100%";

    this.svg.style["pointer-events"] = "none";

    this.shadow.appendChild(this.svg);
    //this.style["background-color"] = "green";
  }

  start(screen) {
    this.screen = screen;
    this.ctx = screen.ctx;

    screen.parentNode.appendChild(this);

    this.style["display"] = "float";
    this.style["z-index"] = this.zindex_base;

    this.style["position"] = "absolute";
    this.style["left"] = "0px";
    this.style["top"] = "0px";

    this.style["width"] = screen.size[0] + "px";
    this.style["height"] = screen.size[1] + "px";

    this.style["pointer-events"] = "none";

    this.svg = document.createElementNS(SVG_URL, "svg");
    this.svg.style["width"] = "100%";
    this.svg.style["height"] = "100%";

    this.shadow.appendChild(this.svg);

    //this.style["background-color"] = "green";
  }
}

class Overdraw extends UIBase$2 {
  constructor() {
    super();

    this.visibleToPick = false;

    this.screen = undefined;
    this.shapes = [];
    this.otherChildren = []; //non-svg elements
    this.font = undefined;

    let style = document.createElement("style");
    style.textContent = `
      .overdrawx {
        pointer-events : none;
      }
    `;

    this.shadow.appendChild(style);

    this.zindex_base = 1000;
  }

  startNode(node, screen) {
    if (screen) {
      this.screen = screen;
      this.ctx = screen.ctx;
    }

    if (!this.parentNode) {
      node.appendChild(this);
    }

    this.style["z-index"] = this.zindex_base;

    this.style["position"] = "relative";
    //this.style["left"] = "0px";
    //this.style["top"] = "0px";
    this.style["margin"] = this.style["padding"] = "0px";

    this.style["width"] = "100%"; //screen.size[0] + "px";
    this.style["height"] = "100%"; //screen.size[1] + "px";

    this.style["pointer-events"] = "none";

    this.svg = document.createElementNS(SVG_URL, "svg");
    this.svg.style["width"] = "100%";
    this.svg.style["height"] = "100%";

    this.svg.style["pointer-events"] = "none";

    this.shadow.appendChild(this.svg);
    //this.style["background-color"] = "green";
  }

  start(screen) {
    this.screen = screen;
    this.ctx = screen.ctx;

    screen.parentNode.appendChild(this);

    this.style["display"] = "float";
    this.style["z-index"] = this.zindex_base;

    this.style["position"] = "absolute";
    this.style["left"] = "0px";
    this.style["top"] = "0px";

    this.style["width"] = screen.size[0] + "px";
    this.style["height"] = screen.size[1] + "px";

    this.style["pointer-events"] = "none";

    this.svg = document.createElementNS(SVG_URL, "svg");
    this.svg.style["width"] = "100%";
    this.svg.style["height"] = "100%";

    this.shadow.appendChild(this.svg);

    //this.style["background-color"] = "green";
  }

  clear() {
    for (let child of list(this.svg.childNodes)) {
      child.remove();
    }

    for (let child of this.otherChildren) {
      child.remove();
    }

    this.otherChildren.length = 0;
  }

  drawTextBubbles(texts, cos, colors) {
    let boxes = [];
    let elems = [];

    let cent = new Vector2$b();

    for (let i=0; i<texts.length; i++) {
      let co = cos[i];
      let text = texts[i];
      let color;

      if (colors !== undefined) {
        color = colors[i];
      }

      cent.add(co);
      let box = this.text(texts[i], co[0], co[1], {color : color});

      boxes.push(box);
      let font = box.style["font"];
      let pat = /[0-9]+px/;
      let size = font.match(pat)[0];

      //console.log("size", size);

      if (size === undefined) {
        size = this.getDefault("DefaultText").size;
      } else {
        size = parsepx$1(size);
      }

      //console.log(size);
      let tsize = measureTextBlock(this, text, undefined, undefined, size, font);

      box.minsize = [
        ~~tsize.width,
        ~~tsize.height
      ];

      let pad = parsepx$1(box.style["padding"]);

      box.minsize[0] += pad*2;
      box.minsize[1] += pad*2;

      let x = parsepx$1(box.style["left"]);
      let y = parsepx$1(box.style["top"]);

      box.grads = new Array(4);
      box.params = [x, y, box.minsize[0], box.minsize[1]];
      box.startpos = new Vector2$b([x, y]);

      box.setCSS = function() {
        this.style["padding"] = "0px";
        this.style["margin"] = "0px";
        this.style["left"] = ~~this.params[0] + "px";
        this.style["top"] = ~~this.params[1] + "px";
        this.style["width"] = ~~this.params[2] + "px";
        this.style["height"] = ~~this.params[3] + "px";
      };

      box.setCSS();
      //console.log(box.params);
      elems.push(box);
    }

    if (boxes.length === 0) {
      return;
    }

    cent.mulScalar(1.0 / boxes.length);

    function error() {
      let p1 = [0, 0], p2 = [0, 0];
      let s1 = [0, 0], s2 = [0, 0];

      let ret = 0.0;

      for (let box1 of boxes) {
        for (let box2 of boxes) {
          if (box2 === box1) {
            continue;
          }

          s1[0] = box1.params[2];
          s1[1] = box1.params[3];
          s2[0] = box2.params[2];
          s2[1] = box2.params[3];

          let overlap = aabb_overlap_area(box1.params, s1, box2.params, s2);
          ret += overlap;
        }

        ret += box1.startpos.vectorDistance(box1.params)*0.25;
      }

      return ret;
    }

    function solve() {
      //console.log("ERROR", error());
      let r1 = error();
      if (r1 === 0.0) {
        return;
      }

      let df = 0.0001;
      let totgs = 0.0;

      for (let box of boxes) {
        for (let i=0; i<box.params.length; i++) {
          let orig = box.params[i];
          box.params[i] += df;
          let r2 = error();
          box.params[i] = orig;

          box.grads[i] = (r2 - r1) / df;
          totgs += box.grads[i]**2;
        }
      }

      if (totgs === 0.0) {
        return;
      }

      r1 /= totgs;
      let k = 0.4;

      for (let box of boxes) {
        for (let i = 0; i < box.params.length; i++) {
          box.params[i] += -r1*box.grads[i]*k;
        }

        box.params[2] = Math.max(box.params[2], box.minsize[0]);
        box.params[3] = Math.max(box.params[3], box.minsize[1]);

        box.setCSS();
      }
    }

    for (let i=0; i<15; i++) {
      solve();
    }

    for (let box of boxes) {
      elems.push(this.line(box.startpos, box.params));
    }

    return elems;
  }

  text(text, x, y, args={}) {
    args = Object.assign({}, args);

    if (args.font === undefined) {
      if (this.font !== undefined)
        args.font = this.font;
      else
        args.font = this.getDefault("DefaultText").genCSS();
    }

    if (!args["background-color"]) {
      args["background-color"] = "rgba(75, 75, 75, 0.75)";
    }

    args.color = args.color ? args.color : "white";
    if (typeof args.color === "object") {
      args.color = color2css$2(args.color);
    }

    args["padding"] = args["padding"] === undefined ? "5px" : args["padding"];
    args["border-color"] = args["border-color"] ? args["border-color"] : "grey";
    args["border-radius"] = args["border-radius"] ? args["border-radius"] : "25px";
    args["border-width"] = args["border-width"] !== undefined ? args["border-width"] : "2px";

    if (typeof args["border-width"] === "number") {
      args["border-width"] = "" + args["border-width"] + "px";
    }
    if (typeof args["border-radius"] === "number") {
      args["border-radius"] = "" + args["border-radius"] + "px";
    }

    //not sure I need SVG for this. . .
    let box = document.createElement("div");

    box.setAttribute("class", "overdrawx");

    box.style["position"] = "fixed";
    box.style["width"] = "min-contents";
    box.style["height"] = "min-contents";
    box.style["border-width"] = args["border-width"];
    box.style["border-radius"] = "25px";
    box.style["pointer-events"] = "none";
    box.style["z-index"] = this.zindex_base + 1;
    box.style["background-color"] = args["background-color"];
    box.style["padding"] = args["padding"];

    box.style["left"] = x + "px";
    box.style["top"] = y + "px";

    box.style["display"] = "flex";
    box.style["justify-content"] = "center";
    box.style["align-items"] = "center";

    box.innerText = text;
    box.style["font"] = args.font;
    box.style["color"] = args.color;

    this.otherChildren.push(box);
    this.shadow.appendChild(box);

    return box;
  }

  circle(p, r, stroke="black", fill="none") {
    let circle = document.createElementNS(SVG_URL, "circle");
    circle.setAttribute("cx", p[0]);
    circle.setAttribute("cy", p[1]);
    circle.setAttribute("r", r);

    if (fill) {
      circle.setAttribute("style", `stroke:${stroke};stroke-width:2;fill:${fill}`);
    } else {
      circle.setAttribute("style", `stroke:${stroke};stroke-width:2`);
    }

    this.svg.appendChild(circle);

    return circle;
  }

  line(v1, v2, color="black") {
    let line = document.createElementNS(SVG_URL, "line");
    line.setAttribute("x1", v1[0]);
    line.setAttribute("y1", v1[1]);
    line.setAttribute("x2", v2[0]);
    line.setAttribute("y2", v2[1]);
    line.setAttribute("style", `stroke:${color};stroke-width:2`);

    this.svg.appendChild(line);
    return line;
  }

  rect(p, size, color="black") {
    let line = document.createElementNS(SVG_URL, "rect");
    line.setAttribute("x", p[0]);
    line.setAttribute("y", p[1]);
    line.setAttribute("width", size[0]);
    line.setAttribute("height", size[1]);
    line.setAttribute("style", `fill:${color};stroke-width:2`);

    line.setColor = (color) => {
      line.setAttribute("style", `fill:${color};stroke-width:2`);
    };

    this.svg.appendChild(line);
    return line;
  }

  end() {
    this.clear();
    this.remove();
  }

  static define() {return {
    tagname : "overdraw-x",
    style   : "overdraw"
  };}
}

UIBase$2.internalRegister(Overdraw);

class TreeItem extends Container {
  constructor() {
    super();

    this.treeParent = undefined;
    this.treeChildren = [];
    this.treeView = undefined;
    this.treeDepth = 0;

    this.header = this.row();

    this._icon1 = this.header.iconbutton(Icons.TREE_COLLAPSE);
    this._icon1.iconsheet = 0;
    this._icon1.drawButtonBG = false;

    this._icon2 = undefined;

    this._icon1.onclick = () => {
      if (this.opened) {
        this.close();
      }  else {
        this.open();
      }
    };

    this.opened = true;

    this._label = this.header.label("unlabeled");
    this._labelText = "unlabeled";
  }

  set icon(id) {
    if (this._icon2) {
      this._icon2 = id;
    } else {
      this._icon2 = UIBase$2.createElement("icon-label-x");
      this._icon2.icon = id;
      this._icon2.iconsheet = 0;


      this.header.insert(1, this._icon2);
    }
  }

  get icon() {
    if (this._icon2)
      return this._icon2.icon;
    else
      return -1;
  }

  open() {
    this._icon1.icon = Icons.TREE_COLLAPSE;
    this.opened = true;
    this.treeView._open(this);
  }

  close() {
    this._icon1.icon = Icons.TREE_EXPAND;
    this.opened = false;
    this.treeView._close(this);
  }

  set text(b) {
    if (typeof b === "string") {
      this._label.text = b;
      this._labelText = b;
    } else if (b instanceof HTMLElement) {
      this._label.remove();
      this.header.add(b);

      this._label = b;
      this._labelText = b;
    }
  }

  get text() {
    return this._labelText;
  }


  item(name, args={}) {
    args.treeParent = this;
    return this.parentWidget.item(name, args);
  }

  init() {
    super.init();
  }

  static define() {return {
    tagname : "tree-item-x",
    style   : "treeview"
  }}
}
UIBase$2.internalRegister(TreeItem);

class TreeView extends Container {
  constructor() {
    super();

    this.items = [];
    this.strokes = [];
  }

  init() {
    super.init();

    this.style["display"] = "flex";
    this.style["flex-direction"] = "column";

    //this.shadow.appendChild(this.overdraw);

    this.overdraw = UIBase$2.createElement("overdraw-x");
    console.log(this.overdraw.startNode);
    this.overdraw.startNode(this);

    this.style["margin"] = this.style["padding"] = "0px";

    this.updateOverdraw();
  }

  _forAllChildren(item, cb) {
    let visit = (n) => {
      cb(n);

      for (let c of n.treeChildren) {
        visit(c);
      }
    };

    for (let c of item.treeChildren) {
      visit(c);
    }
  }

  _open(item) {
    this._forAllChildren(item, (c) => {
      if (c.opened) {
        c.unhide();
      }
    });

    this._makeStrokes();
  }

  _close(item) {
    this._forAllChildren(item, (c) => {
      c.hide();
    });

    this._makeStrokes();
  }

  _makeStrokes() {
    if (!this.overdraw) {
      //this.doOnce(this._makeStrokes);
      return;
    }

    for (let elem of this.strokes) {
      elem.remove();
    }
    this.strokes.length = 0;

    let hidden = (item) => {
      return item.hidden;
      let p = item;

      while (p) {
        if (!p.opened)
          return true;
        p = p.treeParent;
      }

      return false;
    };

    let items = this.items;
    if (items.length == 0) {
      return;
    }

    this.overdraw.clear();

    let next = (i) => {
      i++;

      while (i < items.length && hidden(items[i])) {
        i++;
        continue;
      }

      return i;
    };

    let i = 0;
    if (hidden(items[i]))
      i = next(i);

    let origin = this.overdraw.getBoundingClientRect();
    let overdraw = this.overdraw;

    let line = function(x1, y1, x2, y2) {
      let ox = origin.x, oy = origin.y;

      x1 -= ox; y1 -= oy;
      x2 -= ox; y2 -= oy;

      overdraw.line([x1, y1], [x2, y2]);
    };

    console.log("making lines", i);

    let indent = this.getDefault("itemIndent");
    let rowh = this.getDefault("rowHeight");

    let getx = (depth) => {
      return (depth+2.2)*indent + origin.x;
    };

    this.overdraw.style["z-index"] = "0";

    let prev = undefined;

    for (; i<items.length; i = next(i)) {
      let item = this.items[i];
      let item2 = next(i);
      item2 = item2 < items.length ? items[item2] : undefined;

      let r = item._icon1.getBoundingClientRect();

      if (!r) continue;

      let x1 = getx(item.treeDepth);
      let y1 = origin.y + (i+1)*rowh - rowh*0.25;


      if (item2 && item2.treeDepth > item.treeDepth) {//} && (!prev || prev.treeDepth !== item.treeDepth)) {
        let y2 = y1 + rowh*0.75;

        line(x1, y1, x1, y2);
        line(x1, y2, getx(item2.treeDepth)-3, y2);

      } else if (item2 && item2.treeDepth === item.treeDepth) {
        line(x1, y1, x1, y1+rowh*0.5);
      }

      prev = item;
    }
  }

  updateOverdraw() {
    let mm = new MinMax(2);
    let ok = false;

    for (let item of this.items) {
      if (item.hidden) {
        //continue;
      }

      for (let r of item.getClientRects()) {
        //console.log(r.y);
        mm.minmax([r.x, r.y]);
        mm.minmax([r.x+r.width, r.y+r.height]);
        ok = true;
      }
    }

    if (!ok) {
      return;
    }

    let r = this.getClientRects()[0];
    if (!r) return;

    let x = r.left;
    let y = r.top;// - r.y;

    let od = this.overdraw;
    let w = mm.max[0] - mm.min[0];
    let h = mm.max[1] - mm.min[1];

    od.style["margin"] = "0px";
    od.style["padding"] = "0px";
    od.svg.style["margin"] = "0px";

    od.style["position"] = UIBase$2.PositionKey;

    od.style["width"] = (r.width-1) + "px";
    od.style["height"] = (r.height-1) + "px";

    od.style["left"] = x + "px";
    od.style["top"] =  y + "px";

    //od.style["background-color"] = "rgba(50, 50, 50, 0.25)";
    //od.svg.style["background-color"] = "rgba(50, 50, 50, 0.25)";

  }

  update() {
    super.update();

    this.updateOverdraw();
  }

  item(name, args={icon : undefined}) {
    let ret = UIBase$2.createElement("tree-item-x");
    this.add(ret);
    ret._init();

    ret.text = name;

    if (args.icon) {
      ret.icon = args.icon;
    }

    ret.treeParent = args.treeParent;
    ret.treeView = this;

    //ret.style["margin-bottom"] = ret.style["margin-top"] = "0px";
    //ret.style["padding-bottom"] = ret.style["padding-top"] = "0px";
    ret.style["max-height"] = this.getDefault("rowHeight") + "px";

    if (ret.treeParent) {
      ret.treeParent.treeChildren.push(ret);
      ret.treeDepth = ret.treeParent.treeDepth + 1;
    }

    let p = ret.treeParent;
    let i = 1;
    while (p) {
      p = p.treeParent;
      i++;
    }

    ret.style["margin-left"] = (i*this.getDefault("itemIndent")) + "px";
    this.items.push(ret);

    this.doOnce(() => {
      this._makeStrokes();
    });

    return ret;
  }

  static define() {return {
    tagname : "tree-view-x",
    style   : "treeview"
  }}
}
UIBase$2.internalRegister(TreeView);

function startDrag(box) {
  if (box._modal) {
    popModalLight(box._modal);
    box._modal = undefined;
    return;
  }

  let first = true;
  let lastx = 0;
  let lasty = 0;

  let handlers = {
    on_mousemove(e) {
      let x = e.x, y = e.y;

      if (first) {
        lastx = x;
        lasty = y;
        first = false;

        return;
      }

      let dx = x - lastx;
      let dy = y - lasty;

      let hx = parsepx$1(box.style["left"]);
      let hy = parsepx$1(box.style["top"]);

      hx += dx;
      hy += dy;

      console.log(hx, hy);

      box.style["left"] = hx + "px";
      box.style["top"] = hy + "px";

      lastx = x;
      lasty = y;
    },

    end() {
      if (box._modal) {
        popModalLight(box._modal);
        box._modal = undefined;
      }
    },

    on_mouseup(e) {
      this.end();
    },

    on_keydown(e) {
      switch (e.keyCode) {
        case keymap["Escape"]:
        case keymap["Return"]:
          this.end();
          break;
      }
    }

  };

  box._modal = pushModalLight(handlers);
}

class DragBox extends Container {
  constructor() {
    super();

    this._done = false;
    this.header = UIBase$2.createElement("rowframe-x");
    this.contents = UIBase$2.createElement("container-x");

    this.header.style["border-radius"] = "20px";

    this.header.parentWidget = this;
    this.contents.parentWidget = this;

    this.shadow.appendChild(this.header);
    this.shadow.appendChild(this.contents);
  }

  init() {
    super.init();

    let header = this.header;

    header.ctx = this.ctx;
    this.contents.ctx = this.ctx;
    header._init();
    this.contents._init();

    this.style["min-width"] = "350px";
    header.style["height"] = "35px";

    let icon = header.iconbutton(Icons.DELETE, "Hide", () => {
      this.end();
    });
    icon.iconsheet = 0; //use small icons

    this.addEventListener("mousedown", (e) => {
      console.log("start drag");
      startDrag(this);

      /* ensure browser doesn't spawn its own (incompatible)
         touch->mouse emulation events}; */
      e.preventDefault();

    }, {capture : false});

    header.background = this.getDefault("background-color");

    this.setCSS();
  }

  add() {
    return this.contents.add(...arguments);
  }

  prepend(n) {
    return this.contents.prepend(n);
  }

  appendChild(n) {
    return this.contents.appendChild(n);
  }
  col() {
    return this.contents.col(...arguments);
  }

  row() {
    return this.contents.row(...arguments);
  }

  strip() {
    return this.contents.strip(...arguments);
  }
  button() {
    return this.contents.button(...arguments);
  }
  iconbutton() {
    return this.contents.iconbutton(...arguments);
  }
  iconcheck() {
    return this.contents.iconcheck(...arguments);
  }
  tool() {
    return this.contents.tool(...arguments);
  }
  menu() {
    return this.contents.menu(...arguments);
  }
  prop() {
    return this.contents.prop(...arguments);
  }
  listenum() {
    return this.contents.listenum(...arguments);
  }
  check() {
    return this.contents.check(...arguments);
  }
  iconenum() {
    return this.contents.iconenum(...arguments);
  }
  slider() {
    return this.contents.slider(...arguments);
  }
  simpleslider() {
    return this.contents.simpleslider(...arguments);
  }
  curve() {
    return this.contents.curve(...arguments);
  }
  textbox() {
    return this.contents.textbox(...arguments);
  }
  textarea() {
    return this.contents.textarea(...arguments);
  }
  viewer() {
    return this.contents.viewer(...arguments);
  }
  panel() {
    return this.contents.panel(...arguments);
  }
  tabs() {
    return this.contents.tabs(...arguments);
  }
  table() {
    return this.contents.table(...arguments);
  }


  end() {
    if (this._done) {
      return;
    }
    this.remove();

    if (this._onend) {
      this._onend();
    }

    if (this.onend) {
      this.onend();
    }
  }

  setCSS() {
    super.setCSS();

    this.background = this.getDefault("background-color");
  }

  static define() {return {
    tagname : "drag-box-x",
    style   : "panel"
  }}
}
UIBase$2.internalRegister(DragBox);

let ignore = 0;

function dockerdebug() {
  if (exports.DEBUG.areadocker) {
    console.warn(...arguments);
  }
}

window.testSnapScreenVerts = function (arg) {
  let screen = CTX.screen;

  screen.unlisten();
  screen.on_resize([screen.size[0] - 75, screen.size[1]], screen.size);
  screen.on_resize = screen.updateSize = () => {
  };

  let p = CTX.propsbar;
  p.pos[0] += 50;
  p.owning_sarea.loadFromPosSize();
  screen.regenBorders();

  screen.size[0] = window.innerWidth - 5;

  screen.snapScreenVerts(arg);
};

class AreaDocker extends Container {
  constructor() {
    super();

    this._last_update_key = undefined;
    this.mpos = new Vector2();
    this.needsRebuild = true;
    this.ignoreChange = 0;
  }

  static define() {
    return {
      tagname: "area-docker-x",
      style  : "areadocker"
    }
  }

  rebuild() {
    if (!this.parentWidget) {
      return;
    }

    let sarea = this.getArea().parentWidget;
    if (!sarea) {
      this.needsRebuild = true;
      return;
    }

    this.needsRebuild = false;
    this.ignoreChange++;

    dockerdebug("Rebuild", this.getArea());

    let uidata = sarea.switcherData = saveUIData(this, "switcherTabs");

    this.clear();

    let tabs = this.tbar = this.tabs();
    tabs.onchange = this.tab_onchange.bind(this);

    let tab;

    dockerdebug(sarea._id, sarea.area ? sarea.area._id : "(no active area)", sarea.editors);

    sarea.switcherData = uidata;

    for (let editor of sarea.editors) {
      let def = editor.constructor.define();
      let name = def.uiname;

      if (!name) {
        name = def.areaname || def.tagname.replace(/-x/, '');
        name = ToolProperty.makeUIName(name);
      }

      let tab = tabs.tab(name, editor._id);

      let start_mpos = new Vector2();
      let mpos = new Vector2();

      tab._tab.addEventListener("tabdragstart", (e) => {
        if (e.x !== 0 && e.y !== 0) {
          start_mpos.loadXY(e.x, e.y);
          this.mpos.loadXY(e.x, e.y);
        } else {
          start_mpos.load(this.mpos);
        }

        dockerdebug("tab drag start!", start_mpos, e);
      });
      tab._tab.addEventListener("tabdragmove", (e) => {
        this.mpos.loadXY(e.x, e.y);

        let rect = this.tbar.tbar.canvas.getBoundingClientRect();

        let x = e.x, y = e.y;

        let m = 8;
        if (x < rect.x - m || x > rect.x + rect.width + m || y < rect.y - m || y >= rect.y + rect.height + m) {
          dockerdebug("tab detach!");
          e.preventDefault(); //end dragging
          this.detach(e);
        }
      });
      tab._tab.addEventListener("tabdragend", (e) => {

        this.mpos.loadXY(e.x, e.y);
        dockerdebug("tab drag end!", e);
      });
    }

    tab = this.tbar.icontab(Icons.SMALL_PLUS, "add", "Add Editor", false).noSwitch();
    dockerdebug("Add Menu Tab", tab);

    let icon = this.addicon = tab._tab;

    icon.ontabclick = e => this.on_addclick(e);
    icon.setAttribute("menu-button", "true");
    icon.setAttribute("simple", "true");

    this.loadTabData(uidata);

    this.ignoreChange--;
  }

  detach(event) {
    this.tbar._ensureNoModal();

    let area = this.getArea();
    let sarea = this.ctx.screen.floatArea(area);

    sarea.size.min([300, 300]);
    sarea.loadFromPosSize();

    let mpos = event ? new Vector2([event.x, event.y]) : this.mpos;

    dockerdebug("EVENT", event);

    if (event && event instanceof PointerEvent) {
      this.ctx.screen.moveAttachTool(sarea, mpos, document.body, event.pointerId);
    } else {
      this.ctx.screen.moveAttachTool(sarea, mpos);
    }
  }

  loadTabData(uidata) {
    this.ignoreChange++;
    loadUIData(this, uidata);
    this.ignoreChange--;
  }

  on_addclick(e) {
    let mpos = new Vector2([e.x, e.y]);

    if (this.addicon.menu && !this.addicon.menu.closed) {
      this.addicon.menu.close();
    } else {
      this.addTabMenu(e.target, mpos);
    }
  }

  tab_onchange(tab, event) {
    if (this.ignoreChange) {
      return;
    }

    dockerdebug("EVENT", event);

    if (event && (!(event instanceof PointerEvent) || event.pointerType === "mouse")) {
      //event.preventDefault(); //prevent tab dragging
    }

    this.select(tab.id, event);
  }

  init() {
    super.init();

    this.style["touch-action"] = "none";

    this.addEventListener("pointermove", (e) => {
      this.mpos.loadXY(e.x, e.y);
    });

    this.rebuild();
  }

  setCSS() {
    super.setCSS();
  }

  getArea() {
    let p = this.parentWidget;
    let lastp = p;

    let name = UIBase$2.getInternalName("screenarea-x");
    while (p && p.tagName.toLowerCase() !== name) {
      lastp = p;
      p = p.parentWidget;
    }

    return lastp
  }

  flagUpdate() {
    this.needsRebuild = true;
    return this;
  }

  update() {
    super.update();

    let active = this.tbar.getActive();
    let area = this.getArea();

    let key = this.parentWidget._id;
    for (let area2 of area.parentWidget.editors) {
      key += area2._id + ":";
    }

    if (key !== this._last_update_key) {
      this._last_update_key = key;
      this.needsRebuild = true;
    }

    if (this.needsRebuild) {
      this.rebuild();
      return;
    }

    if (this.addicon) {
      let tabs = this.tbar.tbar.tabs;
      let idx = tabs.indexOf(this.addicon);
      if (idx !== tabs.length - 1) {
        this.tbar.tbar.swapTabs(this.addicon, tabs[tabs.length - 1]);

      }
    }

    if (!active || active._id !== area._id) {
      this.ignoreChange++;

      try {
        this.tbar.setActive(area._id);
      } catch (error) {
        print_stack$1(error);
        this.needsRebuild = true;
      }

      this.ignoreChange--;
    }

    window.tabs = this.tbar;

    this.ignoreChange = 0;
  }

  select(areaId, event) {
    dockerdebug("Tab Select!", areaId);

    this.ignoreChange++;

    let area = this.getArea();
    let sarea = area.parentWidget;

    let uidata = saveUIData(this.tbar, "switcherTabs");
    let newarea;

    for (let area2 of sarea.editors) {
      if (area2._id === areaId) {
        newarea = area2;
        sarea.switchEditor(area2.constructor);
        break;
      }
    }

    if (newarea === area || !newarea.switcher) {
      return;
    }

    //this.ctx.screen.completeSetCSS();
    //this.ctx.screen.completeUpdate();
    sarea.flushSetCSS();
    sarea.flushUpdate();

    newarea = sarea.area;

    /* unswap switchers to avoid a bug in Chrome where
    *  touch-action appears to not be respected due to our
    *  swapping elements */

    let parentw = area.switcher.parentWidget;
    let newparentw = newarea.switcher.parentWidget;

    let parent = area.switcher.parentNode;
    let newparent = newarea.switcher.parentNode;

    area.switcher = newarea.switcher;
    newarea.switcher = this;

    HTMLElement.prototype.remove.call(area.switcher);
    HTMLElement.prototype.remove.call(newarea.switcher);

    if (parent instanceof UIBase$2) {
      parent.shadow.appendChild(area.switcher);
    } else {
      parent.appendChild(area.switcher);
    }

    if (newparent instanceof UIBase$2) {
      newparent.shadow.prepend(newarea.switcher);
    } else {
      newparent.prepend(newarea.switcher);
    }

    area.switcher.parentWidget = parentw;
    newarea.switcher.parentWidget = newparentw;

    area.switcher.tbar._ensureNoModal();
    newarea.switcher.tbar._ensureNoModal();

    newarea.switcher.loadTabData(uidata);
    area.switcher.loadTabData(uidata);

    newarea.switcher.setCSS();
    newarea.switcher.update();

    if (event && (event instanceof PointerEvent || event instanceof MouseEvent || event instanceof TouchEvent)) {
      event.preventDefault();
      event.stopPropagation();
      newarea.switcher.tbar._startMove(undefined, event);
    }

    //console.log(this._id);

    sarea.switcherData = uidata;
    this.ignoreChange--;
  }

  addTabMenu(tab, mpos) {
    let rect = tab.getClientRects()[0];

    dockerdebug(tab, tab.getClientRects());

    if (!mpos) {
      mpos = this.ctx.screen.mpos;
    }

    let menu = UIBase$2.createElement("menu-x");

    menu.closeOnMouseUp = false;
    menu.ctx = this.ctx;
    menu._init();

    let prop = Area$1.makeAreasEnum();
    let sarea = this.getArea().parentWidget;

    if (!sarea) {
      return;
    }

    for (let k in Object.assign({}, prop.values)) {
      let ok = true;
      for (let area of sarea.editors) {
        if (area.constructor.define().uiname === k) {
          ok = false;
        }
      }

      if (!ok) {
        continue;
      }

      let icon = prop.iconmap[k];
      menu.addItemExtra(k, prop.values[k], undefined, icon);
    }

    if (!rect) {
      console.warn("no rect!");
      return;
    }

    dockerdebug(mpos[0], mpos[1], rect.x, rect.y);

    menu.onselect = (val) => {
      dockerdebug("menu select", val, this.getArea().parentWidget);

      this.addicon.menu = undefined;

      let sarea = this.getArea().parentWidget;
      if (sarea) {
        let cls = areaclasses[val];

        this.ignoreChange++;
        let area, ud;

        try {
          let uidata = saveUIData(this.tbar, "switcherTabs");
          sarea.switchEditor(cls);

          dockerdebug("switching", cls);
          area = sarea.area;
          area._init();

          if (area.switcher) {
            area.switcher.rebuild();
            area.switcher.loadTabData(uidata);
            sarea.switcherData = uidata;
          }
        } catch (error) {
          print_stack$1(error);
          throw error;
        } finally {
          this.ignoreChange = Math.max(this.ignoreChange - 1, 0);
        }

        dockerdebug("AREA", area.switcher, area);

        if (area.switcher) {
          this.ignoreChange++;

          try {
            area.parentWidget = sarea;
            area.owning_sarea = sarea;
            area.switcher.parentWidget = area;
            area.switcher.ctx = area.ctx;
            area.switcher._init();
            area.switcher.update();

            dockerdebug("loading data", ud);
            area.switcher.loadTabData(ud);

            area.switcher.rebuild(); //make sure plus tab is at end
            area.flushUpdate();
          } catch (error) {
            throw error;
          } finally {
            this.ignoreChange = Math.max(this.ignoreChange - 1, 0);
          }
        }
      }
    };

    this.addicon.menu = menu;

    startMenu(menu, mpos[0] - 35, rect.y + rect.height, false, 0);
    return menu;
  }
}

UIBase$2.internalRegister(AreaDocker);

function makePopupArea(area_class, screen, args={}) {
  let sarea = UIBase.createElement("screenarea-x");

  let width = args.width || (screen.size[0]*0.7);
  let height = args.height || (screen.size[1]*0.7);
  let addEscapeKeyHandler = args.addEscapeKeyHandler !== undefined ? args.addEscapeKeyHandler : true;

  sarea.ctx = screen.ctx;
  sarea.size[0] = width;
  sarea.size[1] = height;
  sarea.pos[0] = 100;
  sarea.pos[1] = 100;

  sarea.pos[0] = Math.min(sarea.pos[0], screen.size[0] - sarea.size[0] - 2);
  sarea.pos[1] = Math.min(sarea.pos[1], screen.size[1] - sarea.size[1] - 2);

  sarea.switch_editor(area_class);

  sarea.overrideClass("popup");
  sarea.style["background-color"] = sarea.getDefault("background-color");
  sarea.style["border-radius"] = sarea.getDefault("border-radius") + "px";
  sarea.style["border-color"] = sarea.getDefault("border-color");
  sarea.style["border-style"] = sarea.getDefault("border-style");
  sarea.style["border-width"] = sarea.getDefault("border-width") + "px";

  sarea.flag |= AreaFlags.FLOATING | AreaFlags.INDEPENDENT;

  screen.appendChild(sarea);
  sarea.setCSS();

  if (addEscapeKeyHandler) {
    sarea.on_keydown = (e) => {
      if (e.keyCode === keymap.Escape) {
        screen.removeArea(sarea);
      }
    };
  }

  sarea.bringToFront();

  return sarea;
}

let _FrameManager = undefined;

let Area$2 = Area$1;

function list$2(iter) {
  let ret = [];

  for (let item of iter) {
    ret.push(item);
  }

  return ret;
}

startMenuEventWrangling();

let _events_started = false;

function registerToolStackGetter$1(func) {
  registerToolStackGetter(func);
}

let Vector2$c         = Vector2,
    UIBase$g          = UIBase$2,
    styleScrollBars$1 = styleScrollBars;

let update_stack = new Array(8192);
update_stack.cur = 0;

let screen_idgen = 0;

function purgeUpdateStack() {
  for (let i = 0; i < update_stack.length; i++) {
    update_stack[i] = undefined;
  }
}

/**
 * Base class for app workspaces
 *
 attributes:

 inherit-scale : don't resize to fit whole screen, use cssbox scaling

 */
class Screen$2 extends UIBase$2 {
  constructor() {
    super();

    this.snapLimit = 1;
    this.fullScreen = true;

    //all widget shadow DOMs reference this style tag,
    //or rather they copy it
    this.globalCSS = document.createElement("style");
    this.shadow.prepend(this.globalCSS);

    this._do_updateSize = true;
    this._resize_callbacks = [];

    this.allBordersMovable = exports.DEBUG.allBordersMovable;
    this.needsBorderRegen = true;

    this._popup_safe = 0;

    //if true, will test all areas for keymaps on keypress,
    //not just the active one
    this.testAllKeyMaps = false;

    this.needsTabRecalc = true;
    this._screen_id = screen_idgen++;

    this._popups = [];

    this._ctx = undefined;

    this.keymap = new KeyMap();

    this.size = new Vector2$c([window.innerWidth, window.innerHeight]);
    this.pos = new Vector2$c();
    this.oldpos = new Vector2$c();

    this.idgen = 0;
    this.sareas = [];
    this.sareas.active = undefined;
    this.mpos = [0, 0];

    this.screenborders = [];
    this.screenverts = [];
    this._vertmap = {};
    this._edgemap = {};
    this._idmap = {};

    //effective bounds of screen
    this._aabb = [new Vector2$c(), new Vector2$c()];

    let on_mousemove = (e, x, y) => {
      //let elem = this.pickElement(x, y, 1, 1, ScreenArea.ScreenArea);
      let dragging = e.type === "mousemove" || e.type === "touchmove" || e.type === "pointermove";
      dragging = dragging && (e.buttons || (e.touches && e.touches.length > 0));

      /*
      make sure active area is up to date.
      but don't call pickElement too often as it's slow
      */
      if (!dragging && Math.random() > 0.9) {
        let elem = this.pickElement(x, y, {
          sx        : 1,
          sy        : 1,
          nodeclass : ScreenArea,
          mouseEvent: e
        });

        if (0) {
          let elem2 = this.pickElement(x, y, 1, 1);
          console.log("" + this.sareas.active, elem2 ? elem2.tagName : undefined, elem !== undefined);
        }

        if (elem !== undefined) {
          if (elem.area) {
            //make sure context area stacks are up to date
            elem.area.push_ctx_active();
            elem.area.pop_ctx_active();
          }

          this.sareas.active = elem;
        }
      }

      this.mpos[0] = x;
      this.mpos[1] = y;
    };
    this.shadow.addEventListener("mousemove", (e) => {
      return on_mousemove(e, e.x, e.y);
    }, {passive: true});

    /*UIBase forwards touch events already
    this.shadow.addEventListener("touchmove", (e) => {
      if (e.touches.length === 0) {
        return;
      }

      return on_mousemove(e, e.touches[0].pageX, e.touches[0].pagesY);
    }, {passive : true});
    */
  }

  get borders() {
    let this2 = this;

    return (function* () {
      for (let k in this2._edgemap) {
        yield this2._edgemap[k];
      }
    })();
  }

  get listening() {
    return this.listen_timer !== undefined;
  }

  get ctx() {
    return this._ctx;
  }

  set ctx(val) {
    this._ctx = val;

    //fully recurse tree
    let rec = (n) => {
      if (n instanceof UIBase$g) {
        n.ctx = val;
      }

      for (let n2 of n.childNodes) {
        rec(n2);
      }

      if (n.shadow) {
        for (let n2 of n.shadow.childNodes) {
          rec(n2);
        }
      }
    };

    for (let n of this.childNodes) {
      rec(n);
    }

    for (let n of this.shadow.childNodes) {
      rec(n);
    }
  }

  static fromJSON(obj, schedule_resize = false) {
    let ret = UIBase$g.createElement(this.define().tagname);
    return ret.loadJSON(obj, schedule_resize);
  }

  static define() {
    return {
      tagname: "pathux-screen-x"
    };
  }

  static newSTRUCT() {
    return UIBase$g.createElement(this.define().tagname);
  }

  setPosSize(x, y, w, h) {
    this.pos[0] = x;
    this.pos[1] = y;
    this.size[0] = w;
    this.size[1] = h;

    this.setCSS();
    this._internalRegenAll();
  }

  setSize(w, h) {
    this.size[0] = w;
    this.size[1] = h;

    this.setCSS();
    this._internalRegenAll();
  }

  setPos(x, y) {
    this.pos[0] = x;
    this.pos[1] = y;

    this.setCSS();
    this._internalRegenAll();
  }

  init() {
    super.init();

    if (this.hasAttribute("listen")) {
      this.listen();
    }
  }

  /**
   *
   * @param {*} style May be a string, a CSSStyleSheet instance, or a style tag
   * @returns Promise fulfilled when style has been merged
   */
  mergeGlobalCSS(style) {
    return new Promise((accept, reject) => {
      let sheet;

      let finish = () => {
        let sheet2 = this.globalCSS.sheet;
        if (!sheet2) {
          this.doOnce(finish);
          return;
        }

        let map = {};
        for (let rule of sheet2.rules) {
          map[rule.selectorText] = rule;
        }

        for (let rule of sheet.rules) {
          let k = rule.selectorText;
          if (k in map) {
            let rule2 = map[k];

            if (!rule.styleMap) { //handle firefox
              for (let k in rule.style) {
                let desc = Object.getOwnPropertyDescriptor(rule.style, k);

                if (!desc || !desc.writable) {
                  continue;
                }
                let v = rule.style[k];

                if (v) {
                  rule2.style[k] = rule.style[k];
                }
              }
              continue;
            }
            for (let [key, val] of list$2(rule.styleMap.entries())) {
              if (1 || rule2.styleMap.has(key)) {
                //rule2.styleMap.delete(key);
                let sval = "";

                if (Array.isArray(val)) {
                  for (let item of val) {
                    sval += " " + val;
                  }
                  sval = sval.trim();
                } else {
                  sval = ("" + val).trim();
                }

                rule2.style[key] = sval;
                rule2.styleMap.set(key, val);
              } else {
                rule2.styleMap.append(key, val);
              }
            }
          } else {
            sheet2.insertRule(rule.cssText);
          }
        }
      };

      if (typeof style === "string") {
        try { //stupid firefox
          sheet = new CSSStyleSheet();
        } catch (error) {
          sheet = undefined;
        }

        if (sheet && sheet.replaceSync) {
          sheet.replaceSync(style);
          finish();
        } else {
          let tag = document.createElement("style");
          tag.textContent = style;
          document.body.appendChild(tag);

          let cb = () => {
            if (!tag.sheet) {
              this.doOnce(cb);
              return;
            }

            sheet = tag.sheet;
            finish();
            tag.remove();
          };

          this.doOnce(cb);
        }
      } else if (!(style instanceof CSSStyleSheet)) {
        sheet = style.sheet;
        finish();
      } else {
        sheet = style;
        finish();
      }
    });
  }

  newScreenArea() {
    let ret = UIBase$g.createElement("screenarea-x");
    ret.ctx = this.ctx;

    if (ret.ctx) {
      ret.init();
    }

    return ret;
  }

  copy() {
    let ret = UIBase$g.createElement(this.constructor.define().tagname);
    ret.ctx = this.ctx;
    ret._init();

    for (let sarea of this.sareas) {
      let sarea2 = sarea.copy(ret);

      sarea2._ctx = this.ctx;
      sarea2.screen = ret;
      sarea2.parentWidget = ret;

      ret.appendChild(sarea2);
    }

    for (let sarea of ret.sareas) {
      sarea.ctx = this.ctx;
      sarea.area.ctx = this.ctx;

      sarea.area.push_ctx_active();
      sarea._init();
      sarea.area._init();
      sarea.area.pop_ctx_active();

      for (let area of sarea.editors) {
        area.ctx = this.ctx;

        area.push_ctx_active();
        area._init();
        area.pop_ctx_active();
      }
    }

    ret.update();
    ret.regenBorders();
    ret.setCSS();

    return ret;
  }

  findScreenArea(x, y) {
    for (let i = this.sareas.length - 1; i >= 0; i--) {
      let sarea = this.sareas[i];

      let ok = x >= sarea.pos[0] && x <= sarea.pos[0] + sarea.size[0];
      ok = ok && (y >= sarea.pos[1] && y <= sarea.pos[1] + sarea.size[1]);

      if (ok) {
        return sarea;
      }
    }
  }

  /**
   * @param x
   * @param y
   * @param args arguments : {sx, sy, nodeclass, excluded_classes}
   */
  pickElement(x, y, args, sy, nodeclass, excluded_classes) {
    let sx;
    let clip;

    if (typeof args === "object") {
      sx = args.sx;
      sy = args.sy;
      nodeclass = args.nodeclass;
      excluded_classes = args.excluded_classes;
      clip = args.clip;
    } else {
      sx = args;

      args = {
        sx              : sx,
        sy              : sy,
        nodeclass       : nodeclass,
        excluded_classes: excluded_classes
      };
    }

    if (!this.ctx) {
      console.warn("no ctx in screen");
      return;
    }

    let ret;

    for (let i = this._popups.length - 1; i >= 0; i--) {
      let popup = this._popups[i];

      ret = ret || popup.pickElement(x, y, args);
    }

    ret = ret || super.pickElement(x, y, args);

    return ret;
  }

  _enterPopupSafe() {
    if (this._popup_safe === undefined) {
      this._popup_safe = 0;
    }

    this._popup_safe++;
  }

  * _allAreas() {
    for (let sarea of this.sareas) {
      for (let area of sarea.editors) {
        yield [area, area._area_id, sarea];
      }
    }
  }

  _exitPopupSafe() {
    this._popup_safe = Math.max(this._popup_safe - 1, 0);
  }

  popupMenu(menu, x, y) {
    startMenu(menu, x, y);

    for (let i = 0; i < 3; i++) {
      menu.flushSetCSS();
      menu.flushUpdate();
    }

    return menu;
  }

  /**
   *
   * @param popupDelay : if non-zero, wait for popup to layout for popupDelay miliseconds,
   *                     then move the popup so it's fully inside the window (if it's outsize).
   *
   * */
  popup(owning_node, elem_or_x, y, closeOnMouseOut = true, popupDelay = 5) {
    let ret = this._popup(...arguments);

    for (let i = 0; i < 2; i++) {
      ret.flushUpdate();
      ret.flushSetCSS();
    }

    if (popupDelay === 0) {
      return ret;
    }

    let z = ret.style["z-index"];

    ret.style["z-index"] = "-10";

    let cb = () => {
      let rect = ret.getClientRects()[0];
      let size = this.size;

      if (!rect) {
        this.doOnce(cb);
        return;
      }

      //console.log("rect", rect);

      if (rect.bottom > size[1]) {
        ret.style["top"] = (size[1] - rect.height - 10) + "px";
      } else if (rect.top < 0) {
        ret.style["top"] = "10px";
      }
      if (rect.right > size[0]) {
        ret.style["left"] = (size[0] - rect.width - 10) + "px";
      } else if (rect.left < 0) {
        ret.style["left"] = "10px";
      }


      ret.style["z-index"] = z;

      ret.flushUpdate();
      ret.flushSetCSS();
    };

    setTimeout(cb, popupDelay);
    //this.doOnce(cb);

    return ret;
  }

  draggablePopup(x, y) {
    let ret = UIBase$g.createElement("drag-box-x");
    ret.ctx = this.ctx;
    ret.parentWidget = this;
    ret._init();

    this._popups.push(ret);

    ret._onend = () => {
      if (this._popups.indexOf(ret) >= 0) {
        this._popups.remove(ret);
      }
    };

    ret.style["z-index"] = 205;
    ret.style["position"] = UIBase$g.PositionKey;
    ret.style["left"] = x + "px";
    ret.style["top"] = y + "px";

    document.body.appendChild(ret);

    return ret;
  }

  /** makes a popup at x,y and returns a new container-x for it */
  _popup(owning_node, elem_or_x, y, closeOnMouseOut = true) {
    let x;

    let sarea = this.sareas.active;

    let w = owning_node;
    while (w) {
      if (w instanceof ScreenArea) {
        sarea = w;
        break;
      }
      w = w.parentWidget;
    }

    if (typeof elem_or_x === "object") {
      let r = elem_or_x.getClientRects()[0];

      x = r.x;
      y = r.y;
    } else {
      x = elem_or_x;
    }

    x += window.scrollX;
    y += window.scrollY;

    let container = UIBase$g.createElement("container-x");

    container.ctx = this.ctx;
    container._init();

    let remove = container.remove;
    container.remove = () => {
      if (this._popups.indexOf(container) >= 0) {
        this._popups.remove(container);
      }

      return remove.apply(container, arguments);
    };

    container.overrideClass("popup");

    container.background = container.getDefault("background-color");
    container.style["border-radius"] = container.getDefault("border-radius") + "px";
    container.style["border-color"] = container.getDefault("border-color");
    container.style["border-style"] = container.getDefault("border-style");
    container.style["border-width"] = container.getDefault("border-width") + "px";
    container.style["box-shadow"] = container.getDefault("box-shadow");

    container.style["position"] = UIBase$g.PositionKey;
    container.style["z-index"] = "2205";
    container.style["left"] = x + "px";
    container.style["top"] = y + "px";
    container.style["margin"] = "0px";

    container.parentWidget = this;

    let mm = new MinMax(2);
    let p = new Vector2$c();

    let _update = container.update;
    container.update.after(() => {
      container.style["z-index"] = "2205";
    });

    /*causes weird bugs
    container.update = () => {
      _update.call(container);

      let rects = container.getClientRects();
      mm.reset();

      for (let r of rects) {
        p[0] = r.x;
        p[1] = r.y;
        mm.minmax(p);

        p[0] += r.width;
        p[1] += r.height;
        mm.minmax(p);
      }

      let x = mm.min[0], y = mm.min[1];

      x = Math.min(x, this.size[0]-(mm.max[0]-mm.min[0]));
      y = Math.min(y, this.size[1]-(mm.max[1]-mm.min[1]));

      container.style["left"] = x + "px";
      container.style["top"] = y + "px";
    }//*/

    document.body.appendChild(container);
    //this.shadow.appendChild(container);
    this.setCSS();

    this._popups.push(container);

    let touchpick, mousepick, keydown;

    let done = false;
    let end = () => {
      if (this._popup_safe) {
        return;
      }

      if (done) return;

      //this.ctx.screen.removeEventListener("touchstart", touchpick, true);
      //this.ctx.screen.removeEventListener("touchmove", touchpick, true);
      this.ctx.screen.removeEventListener("mousedown", mousepick, true);
      this.ctx.screen.removeEventListener("mousemove", mousepick, {passive: true});
      this.ctx.screen.removeEventListener("mouseup", mousepick, true);
      window.removeEventListener("keydown", keydown);

      done = true;
      container.remove();
    };

    container.end = end;

    let _remove = container.remove;
    container.remove = function () {
      if (arguments.length == 0) {
        end();
      }
      _remove.apply(this, arguments);
    };

    container._ondestroy = () => {
      end();
    };

    let bad_time = time_ms();
    let last_pick_time = time_ms();

    mousepick = (e, x, y, do_timeout = true) => {
      if (!container.isConnected) {
        end();
        return;
      }

      if (sarea && sarea.area) {
        sarea.area.push_ctx_active();
        sarea.area.pop_ctx_active();
      }
      //console.log("=======================================================popup touch start");
      //console.log(e);

      if (time_ms() - last_pick_time < 350) {
        return;
      }
      last_pick_time = time_ms();

      x = x === undefined ? e.x : x;
      y = y === undefined ? e.y : y;

      //let elem = this.pickElement(x, y, 2, 2, undefined, [ScreenBorder]);
      let elem = this.pickElement(x, y, {
        sx              : 2,
        sy              : 2,
        excluded_classes: [ScreenBorder],
        mouseEvent      : e
      });

      let startelem = elem;

      if (elem === undefined) {
        if (closeOnMouseOut) {
          end();
        }
        return;
      }

      let ok = false;
      let elem2 = elem;

      while (elem) {
        if (elem === container) {
          ok = true;
          break;
        }
        elem = elem.parentWidget;
      }

      if (!ok) {
        do_timeout = !do_timeout || (time_ms() - bad_time > 100);

        if (closeOnMouseOut && do_timeout) {
          end();
        }
      } else {
        bad_time = time_ms();
      }
    };

    touchpick = (e) => {
      let x = e.touches[0].pageX, y = e.touches[0].pageY;

      return mousepick(e, x, y, false);
    };

    keydown = (e) => {
      if (!container.isConnected) {
        window.removeEventListener("keydown", keydown);
        return;
      }

      switch (e.keyCode) {
        case keymap["Escape"]:
          end();
          break;
      }
    };

    //this.ctx.screen.addEventListener("touchstart", touchpick, true);
    //this.ctx.screen.addEventListener("touchmove", touchpick, true);
    this.ctx.screen.addEventListener("mousedown", mousepick, true);
    this.ctx.screen.addEventListener("mousemove", mousepick, {passive: true});
    this.ctx.screen.addEventListener("mouseup", mousepick, true);
    window.addEventListener("keydown", keydown);

    /*
    container.addEventListener("mouseleave", (e) => {
      console.log("popup mouse leave");
      if (closeOnMouseOut)
        end();
    });
    container.addEventListener("mouseout", (e) => {
      console.log("popup mouse out");
      if (closeOnMouseOut)
        end();
    });
    //*/

    this.calcTabOrder();

    return container;
  }

  _recalcAABB(save = true) {
    let mm = new MinMax(2);

    for (let v of this.screenverts) {
      mm.minmax(v);
    }

    if (save) {
      this._aabb[0].load(mm.min);
      this._aabb[1].load(mm.max);
    }

    return [new Vector2$c(mm.min), new Vector2$c(mm.max)];
  }

  //XXX look at if this is referenced anywhere
  load() {
  }

  //XXX look at if this is referenced anywhere
  save() {
  }

  popupArea(area_class) {
    return makePopupArea(area_class, this);
  }

  remove(trigger_destroy = true) {
    this.unlisten();

    if (trigger_destroy) {
      return super.remove();
    } else {
      HTMLElement.prototype.remove.call(this);
    }
  }

  unlisten() {
    if (this.listen_timer !== undefined) {
      window.clearInterval(this.listen_timer);
      this.listen_timer = undefined;
    }
  }

  checkCSSSize() {
    let w = this.style.width.toLowerCase().trim();
    let h = this.style.height.toLowerCase().trim();

    if (w.endsWith("px") && h.endsWith("px")) {
      w = parseFloat(w.slice(0, w.length - 2).trim());
      h = parseFloat(h.slice(0, h.length - 2).trim());

      if (w !== this.size[0] || h !== this.size[1]) {
        this.on_resize([this.size[0], this.size[1]], [w, h]);
        this.size[0] = w;
        this.size[1] = h;
      }
    }
  }

  getBoolAttribute(attr, defaultval = false) {
    if (!this.hasAttribute(attr)) {
      return defaultval;
    }

    let ret = this.getAttribute(attr);

    if (typeof ret === "number") {
      return !!ret;
    } else if (typeof ret === "string") {
      ret = ret.toLowerCase().trim();
      ret = ret === "true" || ret === "1" || ret === "yes";
    }

    return !!ret;
  }

  updateSize() {
    if (this.getBoolAttribute("inherit-scale") || !this.fullScreen || !exports.autoSizeUpdate) {
      this.checkCSSSize();
      return;
    }

    let width = window.innerWidth;
    let height = window.innerHeight;

    let ratio = window.outerHeight/window.innerHeight;
    let scale = visualViewport.scale;

    let pad = 4;
    width = visualViewport.width*scale - pad;
    height = visualViewport.height*scale - pad;

    let ox = visualViewport.offsetLeft;
    let oy = visualViewport.offsetTop;

    if (exports.DEBUG.customWindowSize) {
      let s = exports.DEBUG.customWindowSize;
      width = s.width;
      height = s.height;
      ox = 0;
      oy = 0;
      window._DEBUG = exports.DEBUG;
    }

    let key = this._calcSizeKey(width, height, ox, oy, devicePixelRatio, scale);

    /* CSS IS EVIL! WHY DOES BODY HAVE A MARGIN? */
    document.body.style.margin = document.body.style.padding = "0px";
    document.body.style["transform-origin"] = "top left";
    document.body.style["transform"] = `translate(${ox}px,${oy}px) scale(${1.0/scale})`;

    //document.body.style["transform"] = `scale(${1.0 / scale}, ${1.0 / scale})`; // translate(${ox*scale2}px, ${oy*scale2}px)`;

    if (key !== this._last_ckey1) {
      //console.log("resizing", key, this._last_ckey1);
      this._last_ckey1 = key;

      this.on_resize(this.size, [width, height], false);
      this.on_resize(this.size, this.size, false);

      let scale = visualViewport.scale;


      this.regenBorders();

      this.setCSS();
      this.completeUpdate();
    }
  }

  listen(args = {updateSize: true}) {
    setWranglerScreen(this);

    let ctx = this.ctx;
    startEvents(() => ctx.screen);

    if (this.listen_timer !== undefined) {
      return; //already listening
    }

    this._do_updateSize = args.updateSize !== undefined ? args.updateSize : true;

    this.listen_timer = window.setInterval(() => {
      if (this.isDead()) {
        console.log("dead screen");
        this.unlisten();
        return;
      }

      this.update();
    }, 150);
  }

  _calcSizeKey(w, h, x, y, dpi, scale) {
    if (arguments.length !== 6) {
      throw new Error("eek");
    }

    let s = "";
    for (let i = 0; i < arguments.length; i++) {
      s += arguments[i].toFixed(0) + ":";
    }

    return s;
  }

  _ondestroy() {
    if (getWranglerScreen() === this) {
      //ui_menu.setWranglerScreen(undefined);
    }

    this.unlisten();

    //unlike other ondestroy functions, this one physically dismantles the DOM tree
    let recurse = (n, second_pass, parent) => {
      if (n.__pass === second_pass) {
        console.warn("CYCLE IN DOM TREE!", n, parent);
        return;
      }

      n.__pass = second_pass;

      n._forEachChildWidget(n2 => {
        if (n === n2)
          return;
        recurse(n2, second_pass, n);

        try {
          if (!second_pass && !n2.__destroyed) {
            n2.__destroyed = true;
            n2._ondestroy();
          }
        } catch (error) {
          print_stack(error);
          console.log("failed to exectue an ondestroy callback");
        }

        n2.__destroyed = true;

        try {
          if (second_pass) {
            n2.remove();
          }
        } catch (error) {
          print_stack(error);
          console.log("failed to remove element after ondestroy callback");
        }
      });
    };

    let id = ~~(Math.random()*1024*1024);

    recurse(this, id);
    recurse(this, id + 1);
  }

  destroy() {
    this._ondestroy();
  }

  clear() {
    this._ondestroy();

    this.sareas = [];
    this.sareas.active = undefined;

    for (let child of list$2(this.childNodes)) {
      child.remove();
    }
    for (let child of list$2(this.shadow.childNodes)) {
      child.remove();
    }
  }

  _test_save() {
    let obj = JSON.parse(JSON.stringify(this));
    console.log(JSON.stringify(this));

    this.loadJSON(obj);
  }

  loadJSON(obj, schedule_resize = false) {
    this.clear();
    super.loadJSON();

    for (let sarea of obj.sareas) {
      let sarea2 = UIBase$g.createElement("screenarea-x");

      sarea2.ctx = this.ctx;
      sarea2.screen = this;

      this.appendChild(sarea2);

      sarea2.loadJSON(sarea);
    }

    this.regenBorders();
    this.setCSS();

    if (schedule_resize) {
      window.setTimeout(() => {
        this.on_resize(this.size, [window.innerWidth, window.innerHeight]);
      }, 50);
    }
  }

  toJSON() {
    let ret = {
      sareas: this.sareas
    };

    ret.size = this.size;
    ret.idgen = this.idgen;

    return Object.assign(super.toJSON(), ret);
  }

  getHotKey(toolpath) {
    let test = (keymap) => {
      for (let hk of keymap) {
        if (typeof hk.action != "string")
          continue;

        if (hk.action.trim().startsWith(toolpath.trim())) {
          return hk;
        }
      }
    };

    let ret = test(this.keymap);
    if (ret)
      return ret;

    if (this.sareas.active && this.sareas.active.keymap) {
      let area = this.sareas.active.area;

      for (let keymap of area.getKeyMaps()) {
        ret = test(keymap);

        if (ret)
          return ret;
      }
    }

    if (ret === undefined) {
      //just to be safe, check all areas in case the
      //context is confused as to which area is currently "active"

      for (let sarea of this.sareas) {
        let area = sarea.area;

        for (let keymap of area.getKeyMaps()) {
          ret = test(keymap);

          if (ret) {
            return ret;
          }
        }
      }
    }

    return undefined;
  }

  addEventListener(type, cb, options) {
    if (type === "resize") {
      this._resize_callbacks.push(cb);
    } else {
      return super.addEventListener(type, cb, options);
    }
  }

  removeEventListener(type, cb, options) {
    if (type === "resize") {
      if (this._resize_callbacks.indexOf(cb) >= 0)
        this._resize_callbacks.remove(cb);
    } else {
      return super.removeEventListener(type, cb, options);
    }
  }

  execKeyMap(e) {
    let handled = false;

    if (window.DEBUG && window.DEBUG.keymap) {
      console.warn("execKeyMap called", e.keyCode, document.activeElement.tagName);
    }

    if (this.sareas.active) {
      let area = this.sareas.active.area;

      if (!area) {
        return;
      }

      area.push_ctx_active();

      for (let keymap of area.getKeyMaps()) {
        if (keymap === undefined) {
          continue;
        }

        if (keymap.handle(this.ctx, e)) {
          handled = true;
          break;
        }
      }

      area.pop_ctx_active();
    }

    handled = handled || this.keymap.handle(this.ctx, e);

    if (!handled && this.testAllKeyMaps) {
      for (let sarea of this.sareas) {
        if (handled) {
          break;
        }

        sarea.area.push_ctx_active();

        for (let keymap of sarea.area.getKeyMaps()) {
          if (keymap.handle(this.ctx, e)) {
            handled = true;
            break;
          }
        }

        sarea.area.pop_ctx_active();
      }
    }

    return handled;
  }

  calcTabOrder() {
    let nodes = [];
    let visit = {};

    let rec = (n) => {
      let bad = n.tabIndex < 0 || n.tabIndex === undefined || n.tabIndex === null;
      bad = bad || !(n instanceof UIBase$g);

      if (n._id in visit || n.hidden) {
        return;
      }

      visit[n._id] = 1;

      if (!bad) {
        n.__pos = n.getClientRects()[0];
        if (n.__pos) {
          nodes.push(n);
        }
      }

      n._forEachChildWidget((n2) => {
        rec(n2);
      });
    };

    for (let sarea of this.sareas) {
      rec(sarea);
    }

    for (let popup of this._popups) {
      rec(popup);
    }

    //console.log("nodes2", nodes2);
    for (let i = 0; i < nodes.length; i++) {
      let n = nodes[i];

      n.tabIndex = i + 1;
      //console.log(n.tabIndex);
    }
  }

  drawUpdate() {
    if (window.redraw_all !== undefined) {
      window.redraw_all();
    }
  }

  update() {
    let move = [];
    for (let child of this.childNodes) {
      if (child instanceof ScreenArea$1) {
        move.push(child);
      }
    }

    for (let child of move) {
      console.warn("moved screen area to shadow");

      HTMLElement.prototype.remove.call(child);
      this.shadow.appendChild(child);
    }

    if (this._do_updateSize) {
      this.updateSize();
    }

    if (this.needsTabRecalc) {
      this.needsTabRecalc = false;
      this.calcTabOrder();
    }

    outer: for (let sarea of this.sareas) {
      for (let b of sarea._borders) {
        let movable = this.isBorderMovable(b);

        if (movable !== b.movable) {
          console.log("detected change in movable borders");
          this.regenBorders();
          break outer;
        }
      }
    }

    if (this._update_gen) {
      let ret;

      /*
      if (cconst.DEBUG.debugUIUpdatePerf) {
          for (ret = this._update_gen.next(); !ret.done; ret = this._update_gen.next()) {}

        this._update_gen = this.update_intern();
        return;
      }
      //*/

      try {
        ret = this._update_gen.next();
      } catch (error) {
        if (!(error instanceof DataPathError)) {
          print_stack$1(error);
          console.log("error in update_intern tasklet");
        }
        return;
      }

      if (ret !== undefined && ret.done) {
        this._update_gen = undefined;
      }
    } else {
      this._update_gen = this.update_intern();
    }
  }

  purgeUpdateStack() {
    this._update_gen = undefined;
    purgeUpdateStack();
  }

  completeSetCSS() {
    let rec = (n) => {
      n.setCSS();

      if (n.packflag & PackFlags.NO_UPDATE) {
        return;
      }

      n._forEachChildWidget((c) => {
        rec(c);
      });
    };

    rec(this);
  }

  completeUpdate() {
    for (let step of this.update_intern()) {
    }
  }

  updateScrollStyling() {
    let s = theme.scrollbars;

    if (!s || !s.color) return;

    let key = "" + s.color + ":" + s.color2 + ":" + s.border + ":" + s.contrast + ":" + s.width;

    if (key !== this._last_scrollstyle_key) {
      this._last_scrollstyle_key = key;

      //console.log("updating scrollbar styling");

      this.mergeGlobalCSS(styleScrollBars$1(s.color, s.color2, s.contrast, s.width, s.border, "*"));
    }
  }

  //XXX race condition warning
  update_intern() {
    this.updateScrollStyling();

    let popups = this._popups;

    let cssText = "";
    let sheet = this.globalCSS.sheet;
    if (sheet) {
      for (let rule of sheet.rules) {
        cssText += rule.cssText + "\n";
      }

      window.cssText = cssText;
    }
    let cssTextHash = strhash(cssText);

    if (this.needsBorderRegen) {
      this.needsBorderRegen = false;
      this.regenBorders();
    }

    super.update();
    let this2 = this;

    //ensure each area has proper ctx set
    for (let sarea of this.sareas) {
      sarea.ctx = this.ctx;
    }

    return (function* () {
      let stack = update_stack;
      stack.cur = 0;

      let lastn = this2;

      function push(n) {
        stack[stack.cur++] = n;
      }

      function pop(n) {
        if (stack.cur < 0) {
          throw new Error("Screen.update(): stack overflow!");
        }

        return stack[--stack.cur];
      }

      let ctx = this2.ctx;

      let SCOPE_POP = Symbol("pop");
      let AREA_CTX_POP = Symbol("pop2");

      let scopestack = [];
      let areastack = [];

      let t = time_ms();
      push(this2);

      for (let p of popups) {
        push(p);
      }

      while (stack.cur > 0) {
        let n = pop();

        if (n === undefined) {
          //console.log("eek!", stack.length);
          continue;
        } else if (n === SCOPE_POP) {
          scopestack.pop();
          continue;
        } else if (n === AREA_CTX_POP) {
          //console.log("POP", areastack[areastack.length-1].constructor.name);
          areastack.pop().pop_ctx_active(ctx, true);
          continue;
        }

        if (n instanceof Area$2) {
          //console.log("PUSH", n.constructor.name);
          areastack.push(n);
          n.push_ctx_active(ctx, true);
          push(AREA_CTX_POP);
        }

        if (!n.hidden && n !== this2 && n instanceof UIBase$g) {
          if (!n._ctx) {
            n._ctx = ctx;
          }

          if (n._screenStyleUpdateHash !== cssTextHash) {
            n._screenStyleTag.textContent = cssText;
            n._screenStyleUpdateHash = cssTextHash;
          }

          if (scopestack.length > 0 && scopestack[scopestack.length - 1]) {
            n.parentWidget = scopestack[scopestack.length - 1];

            //if (n.parentWidget && n._useDataPathUndo === undefined && n.parentWidget._useDataPathUndo !== undefined) {
            //  n._useDataPathUndo = n.parentWidget._useDataPathUndo;
            //}
          }

          n.update();
        }

        if (time_ms() - t > 20) {
          yield;
          t = time_ms();
        }

        for (let n2 of n.childNodes) {
          if (!(n2 instanceof UIBase$g) || !(n2.packflag & PackFlags.NO_UPDATE)) {
            push(n2);
          }
        }

        if (n.shadow === undefined) {
          continue;
        }

        for (let n2 of n.shadow.childNodes) {
          if (!(n2 instanceof UIBase$g) || !(n2.packflag & PackFlags.NO_UPDATE)) {
            push(n2);
          }
        }

        if (n instanceof UIBase$g) {
          if (!(n.packflag & PackFlags.NO_UPDATE)) {
            scopestack.push(n);
            push(SCOPE_POP);
          }
        }
      }
    })();
  }

  //load pos/size from screenverts
  loadFromVerts() {
    let old = [0, 0];
    for (let sarea of this.sareas) {
      old[0] = sarea.size[0];
      old[1] = sarea.size[1];

      sarea.loadFromVerts();
      sarea.on_resize(old);
      sarea.setCSS();
    }

    this.setCSS();
  }

  /** merges sarea into the screen area opposite to sarea*/
  collapseArea(sarea, border) {
    let sarea2;

    if (!border) {
      for (let b of sarea._borders) {
        let sarea2 = b.getOtherSarea(sarea);

        if (sarea2 && !b.locked) {
          border = b;
          break;
        }
      }
    } else if (border.locked) {
      console.warn("Cannot remove screen border");
    }

    console.warn("SAREA2", border, sarea2, sarea2 !== sarea);

    if (border) {
      sarea2 = border.getOtherSarea(sarea);

      if (!sarea2) {
        console.error("Error merging sarea");
        return;
      }

      let size1 = new Vector2$c(sarea.pos).add(sarea.size);
      let size2 = new Vector2$c(sarea2.pos).add(sarea2.size);

      sarea2.pos.min(sarea.pos);
      sarea2.size.load(size1).max(size2).sub(sarea2.pos);

      sarea2.loadFromPosSize();
    }

    this.sareas.remove(sarea);
    sarea.remove();

    this.regenScreenMesh();
    this._internalRegenAll();

    return this;
  }

  splitArea(sarea, t = 0.5, horiz = true) {
    let w = sarea.size[0], h = sarea.size[1];
    let x = sarea.pos[0], y = sarea.size[1];
    let s1, s2;

    if (!horiz) {
      s1 = sarea;
      if (s1.ctx === undefined) {
        s1.ctx = this.ctx;
      }
      s2 = s1.copy(this);

      s1.size[0] *= t;
      s2.size[0] *= (1.0 - t);

      s2.pos[0] += w*t;
    } else {
      s1 = sarea;
      if (s1.ctx === undefined) {
        s1.ctx = this.ctx;
      }
      s2 = s1.copy(this);

      s1.size[1] *= t;
      s2.size[1] *= (1.0 - t);

      s2.pos[1] += h*t;
    }

    s2.ctx = this.ctx;
    this.appendChild(s2);

    s1.on_resize(s1.size);
    s2.on_resize(s2.size);

    this.regenBorders();
    this.solveAreaConstraints();

    s1.setCSS();
    s2.setCSS();

    this.setCSS();

    //XXX not sure if this is right place to do this or really necassary
    if (s2.area !== undefined)
      s2.area.onadd();

    return s2;
  }

  setCSS() {
    if (!this.getBoolAttribute("inherit-scale")) {
      this.style["width"] = this.size[0] + "px";
      this.style["height"] = this.size[1] + "px";
    }

    this.style["overflow"] = "hidden";

    //call setCSS on borders
    for (let key in this._edgemap) {
      let b = this._edgemap[key];

      b.setCSS();
    }
  }

  regenScreenMesh(snapLimit = SnapLimit) {
    this.snapLimit = snapLimit;

    this.regenBorders();
  }

  regenBorders_stage2() {
    for (let b of this.screenborders) {
      b.halfedges = [];
    }

    function hashHalfEdge(border, sarea) {
      return border._id + ":" + sarea._id;
    }

    function has_he(border, border2, sarea) {
      for (let he of border.halfedges) {
        if (border2 === he.border && sarea === he.sarea) {
          return true;
        }
      }

      return false;
    }

    for (let b1 of this.screenborders) {
      for (let sarea of b1.sareas) {
        let he = new ScreenHalfEdge(b1, sarea);
        b1.halfedges.push(he);
      }

      let axis = b1.horiz ? 1 : 0;

      let min = Math.min(b1.v1[axis], b1.v2[axis]);
      let max = Math.max(b1.v1[axis], b1.v2[axis]);

      for (let b2 of this.walkBorderLine(b1)) {
        if (b1 === b2) {
          continue;
        }

        let ok = b2.v1[axis] >= min && b2.v1[axis] <= max;
        ok = ok || (b2.v2[axis] >= min && b2.v2[axis] <= max);

        for (let sarea of b2.sareas) {
          let ok2 = ok && !has_he(b2, b1, sarea);
          if (ok2) {
            let he2 = new ScreenHalfEdge(b2, sarea);
            b1.halfedges.push(he2);
          }
        }

      }
    }


    for (let b of this.screenborders) {
      let movable = true;

      for (let sarea of b.sareas) {
        movable = movable && this.isBorderMovable(b);
      }

      b.movable = movable;
    }
  }

  hasBorder(b) {
    return b._id in this._idmap;
  }

  killScreenVertex(v) {
    this.screenverts.remove(v);

    delete this._edgemap[ScreenVert.hash(v, undefined, this.snapLimit)];
    delete this._idmap[v._id];

    return this;
  }

  freeBorder(b, sarea) {
    if (b.sareas.indexOf(sarea) >= 0) {
      b.sareas.remove(sarea);
    }

    let dels = [];

    for (let he of b.halfedges) {
      if (he.sarea === sarea) {
        dels.push([b, he]);
      }

      for (let he2 of he.border.halfedges) {
        if (he2 === he)
          continue;

        if (he2.sarea === sarea) {
          dels.push([he.border, he2]);
        }
      }
    }

    for (let d of dels) {
      if (d[0].halfedges.indexOf(d[1]) < 0) {
        console.warn("Double remove detected; use util.set?");
        continue;
      }

      d[0].halfedges.remove(d[1]);
    }

    if (b.sareas.length === 0) {
      this.killBorder(b);
    }
  }

  killBorder(b) {
    console.log("killing border", b._id, b);

    if (this.screenborders.indexOf(b) < 0) {
      console.log("unknown border", b);
      b.remove();
      return;
    }

    this.screenborders.remove(b);

    let del = [];

    for (let he of b.halfedges) {
      if (he === he2)
        continue;

      for (let he2 of he.border.halfedges) {
        if (he2.border === b) {
          del.push([he.border, he2]);
        }
      }
    }

    for (let d of del) {
      d[0].halfedges.remove(d[1]);
    }

    delete this._edgemap[ScreenBorder.hash(b.v1, b.v2)];
    delete this._idmap[b._id];

    b.v1.borders.remove(b);
    b.v2.borders.remove(b);

    if (b.v1.borders.length === 0) {
      this.killScreenVertex(b.v1);
    }
    if (b.v2.borders.length === 0) {
      this.killScreenVertex(b.v2);
    }

    b.remove();

    return this;
  }

  //XXX rename to regenScreenMesh
  regenBorders() {

    for (let b of this.screenborders) {
      b.remove();
      HTMLElement.prototype.remove.call(b);
    }

    this._idmap = {};
    this.screenborders = [];
    this._edgemap = {};
    this._vertmap = {};
    this.screenverts = [];

    for (let sarea of this.sareas) {
      if (sarea.hidden) continue;

      sarea.makeBorders(this);
    }

    for (let key in this._edgemap) {
      let b = this._edgemap[key];

      b.setCSS();
    }

    this.regenBorders_stage2();
    this._recalcAABB();

    for (let b of this.screenborders) {
      b.outer = this.isBorderOuter(b);
      b.movable = this.isBorderMovable(b);
      b.setCSS();
    }

    this.updateDebugBoxes();
  }

  _get_debug_overlay() {
    if (!this._debug_overlay) {
      this._debug_overlay = UIBase$g.createElement("overdraw-x");
      let s = this._debug_overlay;

      s.startNode(this, this);
    }

    return this._debug_overlay;
  }

  updateDebugBoxes() {
    if (exports.DEBUG.screenborders) {
      let overlay = this._get_debug_overlay();
      overlay.clear();

      for (let b of this.screenborders) {
        overlay.line(b.v1, b.v2, "red");
      }
      let del = [];
      for (let child of document.body.childNodes) {
        if (child.getAttribute && child.getAttribute("class") === "__debug") {
          del.push(child);
        }
      }
      for (let n of del) {
        n.remove();
      }

      let box = (x, y, s, text, color = "red") => {
        x -= s*0.5;
        y -= s*0.5;

        x = Math.min(Math.max(x, 0.0), this.size[0] - s);
        y = Math.min(Math.max(y, 0.0), this.size[1] - s);

        let ret = UIBase$g.createElement("div");
        ret.setAttribute("class", "__debug");


        ret.style["position"] = UIBase$g.PositionKey;
        ret.style["left"] = x + "px";
        ret.style["top"] = y + "px";
        ret.style["height"] = s + "px";
        ret.style["width"] = s + "px";//"200px";
        ret.style["z-index"] = "1000";
        ret.style["pointer-events"] = "none";
        ret.style["padding"] = ret.style["margin"] = "0px";
        ret.style['display'] = "float";
        ret.style["background-color"] = color;
        document.body.appendChild(ret);

        let colors = [
          "orange",
          "black",
          "white",
        ];

        for (let i = 2; i >= 0; i--) {
          ret = UIBase$g.createElement("div");

          ret.setAttribute("class", "__debug");

          ret.style["position"] = UIBase$g.PositionKey;
          ret.style["left"] = x + "px";
          ret.style["top"] = y + "px";
          ret.style["height"] = s + "px";
          ret.style["width"] = "250px";//"200px";
          ret.style["z-index"] = "" + (1005 - i - 1);
          ret.style["pointer-events"] = "none";
          ret.style["color"] = colors[i];

          let w = (i)*2;
          ret.style["-webkit-text-stroke-width"] = w + "px";
          ret.style["-webkit-text-stroke-color"] = colors[i];
          ret.style["text-stroke-width"] = w + "px";
          ret.style["text-stroke-color"] = colors[i];

          ret.style["padding"] = ret.style["margin"] = "0px";
          ret.style['display'] = "float";
          ret.style["background-color"] = "rgba(0,0,0,0)";
          ret.innerText = "" + text;
          document.body.appendChild(ret);
        }

      };

      for (let v of this.screenverts) {
        box(v[0], v[1], 10*v.borders.length, "" + v.borders.length, "rgba(255,0,0,0.5)");
      }

      for (let b of this.screenborders) {
        for (let he of b.halfedges) {
          let txt = `${he.side}, ${b.sareas.length}, ${b.halfedges.length}`;
          let p = new Vector2$c(b.v1).add(b.v2).mulScalar(0.5);
          let size = 10*b.halfedges.length;

          let wadd = 25 + size*0.5;
          let axis = b.horiz & 1;

          if (p[axis] > he.sarea.pos[axis]) {
            p[axis] -= wadd;
          } else {
            p[axis] += wadd;
          }
          box(p[0], p[1], size, txt, "rgba(155,255,75,0.5)");
        }
      }
    }
  }

  checkAreaConstraint(sarea, checkOnly = false) {
    let min = sarea.minSize, max = sarea.maxSize;
    let vs = sarea._verts;
    let chg = 0.0;
    let mask = 0;

    let moveBorder = (sidea, sideb, dh) => {
      let b1 = sarea._borders[sidea];
      let b2 = sarea._borders[sideb];
      let bad = 0;

      for (let i = 0; i < 2; i++) {
        let b = i ? b2 : b1;
        let bad2 = sarea.borderLock & (1<<sidea);

        bad2 = bad2 || !b.movable;
        bad2 = bad2 || this.isBorderOuter(b);

        if (bad2)
          bad |= 1<<i;
      }

      if (bad === 0) {
        this.moveBorder(b1, dh*0.5);
        this.moveBorder(b2, -dh*0.5);
      } else if (bad === 1) {
        this.moveBorder(b2, -dh);
      } else if (bad === 2) {
        this.moveBorder(b1, dh);
      } else if (bad === 3) {
        //both borders are bad, yet we need to move anyway. . .
        //console.warn("got case of two borders being bad");

        if (!this.isBorderOuter(b1)) {
          this.moveBorder(b1, dh);
        } else if (!this.isBorderOuter(b2)) {
          this.moveBorder(b2, -dh);
        } else {
          this.moveBorder(b1, dh*0.5);
          this.moveBorder(b2, -dh*0.5);
        }
      }
    };

    if (max[0] !== undefined && sarea.size[0] > max[0]) {
      let dh = (sarea.size[0] - max[0]);
      chg += Math.abs(dh);
      mask |= 1;

      moveBorder(0, 2, dh);
    }

    if (min[0] !== undefined && sarea.size[0] < min[0]) {
      let dh = (min[0] - sarea.size[0]);
      chg += Math.abs(dh);
      mask |= 2;

      moveBorder(2, 0, dh);
    }


    if (max[1] !== undefined && sarea.size[1] > max[1]) {
      let dh = (sarea.size[1] - max[1]);
      chg += Math.abs(dh);
      mask |= 4;

      moveBorder(3, 1, dh);
    }

    if (min[1] !== undefined && sarea.size[1] < min[1]) {
      let dh = (min[1] - sarea.size[1]);
      chg += Math.abs(dh);
      mask |= 8;

      moveBorder(1, 3, dh);
    }

    if (sarea.pos[0] + sarea.size[0] > this.size[0]) {
      mask |= 16;
      let dh = ((this.size[0] - sarea.size[0]) - sarea.pos[0]);

      chg += Math.abs(dh);

      if (sarea.floating) {
        sarea.pos[0] = this.size[0] - sarea.size[0];
        sarea.loadFromPosSize();
      } else {
        this.moveBorder(sarea._borders[0], dh);
        this.moveBorder(sarea._borders[2], dh);
      }
    }

    if (chg === 0.0) {
      return false;
    }

    return mask;
  }

  walkBorderLine(b) {
    let visit = new set$1();
    let ret = [b];
    visit.add(b);

    let rec = (b, v) => {
      for (let b2 of v.borders) {
        if (b2 === b) {
          continue;
        }

        if (b2.horiz === b.horiz && !visit.has(b2)) {
          visit.add(b2);
          ret.push(b2);
          rec(b2, b2.otherVertex(v));
        }
      }
    };

    rec(b, b.v1);
    let ret2 = ret;
    ret = [];

    rec(b, b.v2);
    ret2.reverse();

    return ret2.concat(ret);
  }

  moveBorderWithoutVerts(halfedge, df) {
    let side = halfedge.side;
    let sarea = halfedge.sarea;

    switch (side) {
      case 0:
        sarea.pos[0] += df;
        sarea.size[0] -= df;
        break;
      case 1:
        sarea.size[1] += df;
        break;
      case 2:
        sarea.size[0] += df;
        break;
      case 3:
        sarea.pos[1] += df;
        sarea.size[1] -= df;
        break;
    }
  }

  moveBorder(b, df, strict = true) {
    return this.moveBorderSimple(b, df, strict);
  }

  moveBorderSimple(b, df, strict = true) {
    let axis = b.horiz & 1;
    let axis2 = axis ^ 1;

    let min = Math.min(b.v1[axis2], b.v2[axis2]);
    let max = Math.max(b.v1[axis2], b.v2[axis2]);

    let test = (v) => {
      return v[axis2] >= min && v[axis2] <= max;
    };

    let vs = new set$1();

    for (let b2 of this.walkBorderLine(b)) {
      if (strict && !test(b2.v1) && !test(b2.v2)) {
        return false;
      }

      vs.add(b2.v1);
      vs.add(b2.v2);
    }

    for (let v of vs) {
      v[axis] += df;
    }

    for (let v of vs) {
      for (let b of v.borders) {
        for (let sarea of b.sareas) {
          sarea.loadFromVerts();
        }
      }
    }
    return true;
  }

  moveBorderUnused(b, df, strict = true) {
    if (!b) {
      console.warn("missing border");
      return false;
    }

    let axis = b.horiz & 1;

    let vs = new set$1();

    let visit = new set$1();

    let axis2 = axis ^ 1;

    let min = Math.min(b.v1[axis2], b.v2[axis2]);
    let max = Math.max(b.v1[axis2], b.v2[axis2]);

    let test = (v) => {
      return v[axis2] >= min && v[axis2] <= max;
    };

    let first = true;
    let found = false;
    let halfedges = new set$1();
    let borders = new set$1();

    for (let b2 of this.walkBorderLine(b)) {
      /*
      if (first) {
        first = false;
        df = Math.max(Math.abs(df), FrameManager_mesh.SnapLimit) * Math.sign(df);
      }
      found = true;
      for (let sarea of b2.sareas) {
        halfedges.add(new ScreenHalfEdge(b2, sarea))
      }
      vs.add(b2.v1);
      vs.add(b2.v2);
      continue;
      //*/

      if (!strict) {
        vs.add(b2.v1);
        vs.add(b2.v2);
        continue;
      }


      let t1 = test(b2.v1), t2 = test(b2.v2);

      if (!t1 || !t2) {
        found = true;

        if (first) {
          first = false;
          df = Math.max(Math.abs(df), SnapLimit)*Math.sign(df);
        }
      }
      if (!t1 && !t2) {
        continue;
      }

      borders.add(b2);

      //make dummy half edges to keep track of border/sarea pairs
      //and especailly what the border side is
      for (let sarea of b2.sareas) {
        halfedges.add(new ScreenHalfEdge(b2, sarea));
      }

      vs.add(b2.v1);
      vs.add(b2.v2);
    }

    for (let b2 of this.walkBorderLine(b)) {
      if (borders.has(b2)) {
        continue;
      }

      for (let he of b2.halfedges) {
        borders.remove(he.border);
        if (halfedges.has(he)) {
          halfedges.remove(he);
        }
      }
    }

    for (let v of vs) {
      let ok = v[axis2] >= min && v[axis2] <= max;

      if (!ok && strict) {
        //   return false;
      }
    }

    if (!found || !strict) {
      for (let v of vs) {
        v[axis] += df;
      }
    } else {
      let borders = new set$1();

      for (let he of halfedges) {
        borders.add(he.border);
        this.moveBorderWithoutVerts(he, df);
      }

      for (let he of halfedges) {
        he.sarea.loadFromPosSize();
      }

      for (let b of borders) {
        let sareas = b.sareas.slice(0, b.sareas.length);

        this.killBorder(b);
        for (let sarea of sareas) {
          sarea.loadFromPosSize();
        }
      }

      return halfedges.length > 0;
    }


    for (let sarea of b.sareas) {
      sarea.loadFromVerts();
    }

    for (let he of b.halfedges) {
      he.sarea.loadFromVerts();

      for (let sarea of he.border.sareas) {
        sarea.loadFromVerts();
        for (let b2 of sarea._borders) {
          b2.setCSS();
        }
      }
    }

    b.setCSS();

    return true;
  }

  solveAreaConstraints(snapArgument = true) {
    let repeat = false;
    let found = false;

    let time = time_ms();

    for (let i = 0; i < 10; i++) {
      repeat = false;

      for (let sarea of this.sareas) {
        if (sarea.hidden) continue;

        repeat = repeat || this.checkAreaConstraint(sarea);
      }

      found = found || repeat;

      if (repeat) {
        for (let sarea of this.sareas) {
          sarea.loadFromVerts();
        }

        this.snapScreenVerts(snapArgument);
      } else {
        break;
      }
    }

    if (found) {
      this.snapScreenVerts(snapArgument);
      if (exports.DEBUG.areaConstraintSolver) {
        time = time_ms() - time;

        console.log(`enforced area constraint ${time.toFixed(2)}ms`);
      }
      this._recalcAABB();
      this.setCSS();
    }
  }

  snapScreenVerts(fitToSize = true) {
    let this2 = this;

    function* screenverts() {
      for (let v of this2.screenverts) {
        let ok = 0;

        for (let sarea of v.sareas) {
          if (!(sarea.flag & AreaFlags.INDEPENDENT)) {
            ok = 1;
          }
        }

        if (ok) {
          yield v;
        }
      }
    }

    let mm = new MinMax(2);
    for (let v of screenverts()) {
      mm.minmax(v);
    }

    let min = mm.min, max = mm.max;

    //snap(min);
    //snapi(max);

    if (fitToSize) {
      //fit entire screen to, well, the entire screen (size)
      let vec = new Vector2$c(max).sub(min);
      let sz = new Vector2$c(this.size);

      sz.div(vec);

      for (let v of screenverts()) {
        v.sub(min).mul(sz);
        //snap(v.sub(min).mul(sz));//.add(this.pos);
      }

      for (let v of screenverts()) {
        v[0] += this.pos[0];
        v[1] += this.pos[1];
      }

      //this.pos.zero();
    } else {
      for (let v of screenverts()) {
        //snap(v);
      }

      [min, max] = this._recalcAABB();

      //snap(min);
      //snapi(max);

      this.size.load(max).sub(min);
      //this.pos.zero();
      //this.pos.load(min);
    }

    let found = 1;

    for (let sarea of this.sareas) {
      if (sarea.hidden) continue;

      let old = new Vector2$c(sarea.size);
      let oldpos = new Vector2$c(sarea.pos);

      sarea.loadFromVerts();

      found = found || old.vectorDistance(sarea.size) > 1;
      found = found || oldpos.vectorDistance(sarea.pos) > 1;

      sarea.on_resize(old);
    }

    if (found) {
      //this.regenBorders();
      this._recalcAABB();
      this.setCSS();
    }
  }

  on_resize(oldsize, newsize = this.size, _set_key = true) {
    //console.warn("resizing");

    if (_set_key) {
      this._last_ckey1 = this._calcSizeKey(newsize[0], newsize[1], this.pos[0], this.pos[1], devicePixelRatio, visualViewport.scale);
    }

    let ratio = [newsize[0]/oldsize[0], newsize[1]/oldsize[1]];

    let offx = this.pos[0] - this.oldpos[0];
    let offy = this.pos[1] - this.oldpos[1];

    this.oldpos.load(this.pos);

    //console.log("resize!", ratio);

    for (let v of this.screenverts) {
      v[0] *= ratio[0];
      v[1] *= ratio[1];
      v[0] += offx;
      v[1] += offy;
    }

    let min = [1e17, 1e17], max = [-1e17, -1e17];
    let olds = [];

    for (let sarea of this.sareas) {
      olds.push([sarea.size[0], sarea.size[1]]);

      sarea.loadFromVerts();
    }

    this.size[0] = newsize[0];
    this.size[1] = newsize[1];

    this.snapScreenVerts();
    this.solveAreaConstraints();
    this._recalcAABB();


    let i = 0;
    for (let sarea of this.sareas) {
      sarea.on_resize(sarea.size, olds[i]);
      sarea.setCSS();
      i++;
    }

    this.regenBorders();
    this.setCSS();
    this.calcTabOrder();

    this._fireResizeCB(oldsize);
  }

  _fireResizeCB(oldsize = this.size) {
    for (let cb of this._resize_callbacks) {
      cb(oldsize);
    }
  }

  getScreenVert(pos, added_id = "", floating = false) {
    let key = ScreenVert.hash(pos, added_id, this.snapLimit);

    if (floating || !(key in this._vertmap)) {
      let v = new ScreenVert(pos, this.idgen++, added_id);

      this._vertmap[key] = v;
      this._idmap[v._id] = v;

      this.screenverts.push(v);
    }

    return this._vertmap[key];
  }

  isBorderOuter(border) {
    let sides = 0;

    for (let he of border.halfedges) {
      sides |= 1<<he.side;
    }

    let bits = 0;
    for (let i = 0; i < 4; i++) {
      bits += (sides & (1<<i)) ? 1 : 0;
    }

    let ret = bits < 2;
    let floating = false;

    for (let sarea of border.sareas) {
      floating = floating || sarea.floating;
    }

    if (floating) {
      //check if border is on screen limits
      let axis = border.horiz ? 1 : 0;

      ret = Math.abs(border.v1[axis] - this.pos[axis]) < 4;
      ret = ret || Math.abs(border.v1[axis] - this.pos[axis] - this.size[axis]) < 4;
    }

    border.outer = ret;
    return ret;
  }

  isBorderMovable(b, limit = 5) {
    if (this.allBordersMovable)
      return true;

    for (let he of b.halfedges) {
      if (he.sarea.borderLock & (1<<he.side)) {
        return false;
      }
    }

    let ok = !this.isBorderOuter(b);

    for (let sarea of b.sareas) {
      if (sarea.floating) {
        ok = true;
        break;
      }
    }

    return ok;
  }

  getScreenBorder(sarea, v1, v2, side) {
    let suffix = sarea._get_v_suffix();

    if (!(v1 instanceof ScreenVert)) {
      v1 = this.getScreenVert(v1, suffix);
    }

    if (!(v2 instanceof ScreenVert)) {
      v2 = this.getScreenVert(v2, suffix);
    }

    let hash = ScreenBorder.hash(v1, v2);

    if (!(hash in this._edgemap)) {
      let sb = this._edgemap[hash] = UIBase$g.createElement("screenborder-x");

      sb._hash = hash;
      sb.screen = this;
      sb.v1 = v1;
      sb.v2 = v2;
      sb._id = this.idgen++;

      v1.borders.push(sb);
      v2.borders.push(sb);

      sb.ctx = this.ctx;

      this.screenborders.push(sb);
      this.appendChild(sb);

      sb.setCSS();

      this._edgemap[hash] = sb;
      this._idmap[sb._id] = sb;
    }

    return this._edgemap[hash];
  }

  minmaxArea(sarea, mm = undefined) {
    if (mm === undefined) {
      mm = new MinMax(2);
    }

    for (let b of sarea._borders) {
      mm.minmax(b.v1);
      mm.minmax(b.v2);
    }

    return mm;
  }

  //does sarea1 border sarea2?
  areasBorder(sarea1, sarea2) {
    for (let b of sarea1._borders) {
      for (let sa of b.sareas) {
        if (sa === sarea2)
          return true;
      }
    }

    return false;
  }

  //regenerates borders, sets css and calls this.update

  replaceArea(dst, src) {
    if (dst === src)
      return;

    src.pos[0] = dst.pos[0];
    src.pos[1] = dst.pos[1];
    src.size[0] = dst.size[0];
    src.size[1] = dst.size[1];

    src.floating = dst.floating;
    src._borders = dst._borders;
    src._verts = dst._verts;

    if (this.sareas.indexOf(src) < 0) {
      this.sareas.push(src);
      this.shadow.appendChild(src);
    }

    if (this.sareas.active === dst) {
      this.sareas.active = src;
    }

    //this.sareas.remove(dst);
    //dst.remove();

    this.sareas.remove(dst);
    dst.remove();

    this.regenScreenMesh();
    this.snapScreenVerts();
    this._updateAll();
  }

  _internalRegenAll() {
    this.snapScreenVerts();
    this._recalcAABB();
    this.calcTabOrder();
    this.setCSS();

    this.completeUpdate();
    this.completeSetCSS();
    this.completeUpdate();
  }

  _updateAll() {
    for (let sarea of this.sareas) {
      sarea.setCSS();
    }
    this.setCSS();
    this.update();
  }

  removeArea(sarea) {
    if (this.sareas.indexOf(sarea) < 0) {
      console.warn(sarea, "<- Warning: tried to remove unknown area");
      return;
    }

    this.sareas.remove(sarea);
    sarea.remove();

    for (let i = 0; i < 2; i++) {
      this.snapScreenVerts();
      this.regenScreenMesh();
    }

    this._updateAll();
    this.drawUpdate();
  }

  appendChild(child) {
    /*
    if (child instanceof UIBase) {
      if (child._useDataPathUndo === undefined) {
        child.useDataPathUndo = this.useDataPathUndo;
      }
    }*/

    if (child instanceof ScreenArea) {
      child.screen = this;
      child.ctx = this.ctx;
      child.parentWidget = this;

      this.sareas.push(child);

      if (child.size.dot(child.size) === 0) {
        child.size[0] = this.size[0];
        child.size[1] = this.size[1];
      }

      if (!child._has_evts) {
        child._has_evts = true;

        let onfocus = (e) => {
          this.sareas.active = child;
        };

        let onblur = (e) => {
          //XXX this is causing bugs

          //if (this.sareas.active === child) {
          //  this.sareas.active = undefined;
          //}
        };

        child.addEventListener("focus", onfocus);
        child.addEventListener("mouseenter", onfocus);
        child.addEventListener("blur", onblur);
        child.addEventListener("mouseleave", onblur);
      }

      this.regenBorders();
      child.setCSS();
      this.drawUpdate();
      child._init();
    }

    return this.shadow.appendChild(child);
    //return super.appendChild(child);
  }

  add(child) {
    return this.appendChild(child);
  }

  hintPickerTool() {
    (new ToolTipViewer(this)).start();
  }

  removeAreaTool(border) {
    let tool = new RemoveAreaTool(this, border);
    //let tool = new FrameManager_ops.AreaDragTool(this, undefined, this.mpos);
    tool.start();
  }

  moveAttachTool(sarea, mpos = this.mpos, elem, pointerId) {
    let tool = new AreaMoveAttachTool(this, sarea, mpos);
    tool.start(elem, pointerId);
  }

  splitTool() {
    let tool = new SplitTool(this);
    //let tool = new FrameManager_ops.AreaDragTool(this, undefined, this.mpos);
    tool.start();
  }

  areaDragTool(sarea = this.sareas.active) {
    if (sarea === undefined) {
      console.warn("no active screen area");
      return;
    }

    let mpos = this.mpos;
    let tool = new AreaDragTool(this, this.sareas.active, mpos);

    tool.start();
  }

  makeBorders() {
    for (let sarea of this.sareas) {
      sarea.makeBorders(this);
    }
  }

  cleanupBorders() {
    let del = new Set();

    for (let b of this.screenborders) {
      if (b.halfedges.length === 0) {
        del.add(b);
      }
    }

    for (let b of del) {
      delete this._edgemap[b._hash];
      HTMLElement.prototype.remove.call(b);
    }
  }

  mergeBlankAreas() {
    for (let b of this.screenborders) {
      if (b.locked) {
        continue;
      }

      let blank, sarea;

      for (let he of b.halfedges) {
        if (!he.sarea.area) {
          blank = he.sarea;
          sarea = b.getOtherSarea(blank);

          let axis = b.horiz ^ 1;

          if (blank && sarea && blank.size[axis] !== sarea.size[axis]) {
            blank = sarea = undefined;
          }

          if (blank && sarea) {
            break;
          } else {
            blank = undefined;
            sarea = undefined;
          }
        }
      }

      if (blank && sarea && blank !== sarea) {
        this.collapseArea(blank, b);
      }
    }

    this.cleanupBorders();
  }

  floatArea(area) {
    let sarea = area.parentWidget;

    /* already floating? */
    if (sarea.floating) {
      return sarea;
    }

    sarea.editors.remove(area);
    delete sarea.editormap[area.constructor.define().areaname];
    sarea.area = undefined;

    HTMLElement.prototype.remove.call(area);

    let sarea2 = UIBase$g.createElement("screenarea-x", true);
    sarea2.floating = true;

    sarea2.pos = new Vector2$c(sarea.pos);
    sarea2.pos.addScalar(5);

    sarea2.size = new Vector2$c(sarea.size);

    sarea2.editors.push(area);
    sarea2.editormap[area.constructor.define().areaname] = area;

    sarea2.shadow.appendChild(area);
    sarea2.area = area;

    area.push_ctx_active();
    area.pop_ctx_active();

    area.pos = sarea2.pos;
    area.size = sarea2.size;
    area.parentWidget = sarea2;
    area.owning_sarea = sarea2;

    sarea.flushSetCSS();
    sarea.flushUpdate();

    sarea2.flushSetCSS();
    sarea2.flushUpdate();

    this.appendChild(sarea2);

    if (sarea.editors.length > 0) {
      let area2 = sarea.editors[0];
      sarea.switch_editor(area2.constructor);

      sarea.flushSetCSS();
      sarea.flushUpdate();
    }

    sarea2.loadFromPosSize();
    sarea2.bringToFront();

    this.mergeBlankAreas();
    this.cleanupBorders();

    return sarea2;
  }

  on_keydown(e) {
    if (checkForTextBox(this, this.mpos[0], this.mpos[1])) {
      console.log("textbox detected");
      return;
    }

    if (!haveModal() && this.execKeyMap(e)) {
      e.preventDefault();
      return;
    }

    if (!haveModal() && this.sareas.active !== undefined && this.sareas.active.on_keydown) {
      let area = this.sareas.active;
      return this.sareas.active.on_keydown(e);
    }
  }

  on_keyup(e) {
    if (!haveModal() && this.sareas.active !== undefined && this.sareas.active.on_keyup) {
      return this.sareas.active.on_keyup(e);
    }
  }

  on_keypress(e) {
    if (!haveModal() && this.sareas.active !== undefined && this.sareas.active.on_keypress) {
      return this.sareas.active.on_keypress(e);
    }
  }

  draw() {
    for (let sarea of this.sareas) {
      sarea.draw();
    }
  }

  afterSTRUCT() {
    for (let sarea of this.sareas) {
      sarea._ctx = this.ctx;
      sarea.afterSTRUCT();
    }
  }

  loadSTRUCT(reader) {
    this.clear();

    reader(this);

    //handle old files that might have saved as simple arrays
    this.size = new Vector2$c(this.size);

    let sareas = this.sareas;
    this.sareas = [];

    /*
    let push = this.sareas.push;

    this.sareas.push = function(item) {
      console.error("this.sareas.push", item);
      push.call(this, item);
    }
    */

    for (let sarea of sareas) {
      sarea.screen = this;
      sarea.parentWidget = this;

      this.appendChild(sarea);
    }

    this.regenBorders();
    this.setCSS();

    this.doOnce(() => {
      this.loadUIData(this.uidata);
      this.uidata = undefined;
    });

    return this;
  }

  test_struct(appstate = _appstate) {
    let data = [];
    //let scripts = nstructjs.write_scripts();
    nstructjs$1.manager.write_object(data, this);
    data = new DataView(new Uint8Array(data).buffer);

    let screen2 = nstructjs$1.manager.read_object(data, this.constructor);
    screen2.ctx = this.ctx;

    for (let sarea of screen2.sareas) {
      sarea.screen = screen2;
      sarea.ctx = this.ctx;
      sarea.area.ctx = this.ctx;
    }

    let parent = this.parentElement;
    this.remove();

    appstate.screen = screen2;

    parent.appendChild(screen2);

    //for (let 
    screen2.regenBorders();
    screen2.update();
    screen2.listen();

    screen2.doOnce(() => {
      screen2.on_resize(screen2.size, [window.innerWidth, window.innerHeight]);
    });

    console.log(data);
    return screen2;
  }

  saveUIData() {
    try {
      return saveUIData(this, "screen");
    } catch (error) {
      print_stack$1(error);
      console.log("Failed to save UI state data");
    }
  }

  loadUIData(str) {
    try {
      loadUIData(this, str);
    } catch (error) {
      print_stack$1(error);
      console.log("Failed to load UI state data");
    }
  }
}

Screen$2.STRUCT = `
pathux.Screen { 
  size  : vec2;
  pos   : vec2;
  sareas : array(pathux.ScreenArea);
  idgen : int;
  uidata : string | obj.saveUIData();
}
`;

nstructjs$1.register(Screen$2);
UIBase$2.internalRegister(Screen$2);

setScreenClass$1(Screen$2);
_setScreenClass(Screen$2);

let get_screen_cb;
let _on_keydown;

let start_cbs = [];
let stop_cbs = [];
let keyboardDom = window;

let key_event_opts = undefined;

function startEvents(getScreenFunc) {
  get_screen_cb = getScreenFunc;

  if (_events_started) {
    return;
  }

  _events_started = true;

  _on_keydown = (e) => {
    let screen = get_screen_cb();

    return screen.on_keydown(e);
  };

  window.addEventListener("keydown", _on_keydown, key_event_opts);

  for (let cb of start_cbs) {
    cb();
  }
}

function stopEvents() {
  window.removeEventListener("keydown", _on_keydown, key_event_opts);
  _on_keydown = undefined;
  _events_started = false;

  for (let cb of stop_cbs) {
    try {
      cb();
    } catch (error) {
      print_stack$1(error);
    }
  }

  return get_screen_cb;
}

function setKeyboardDom(dom) {
  let started = _events_started;
  if (started) {
    stopEvents();
  }

  keyboardDom = dom;

  if (started) {
    startEvents(get_screen_cb);
  }
}

/** Sets options passed to addEventListener() for on_keydown hotkey handler */
function setKeyboardOpts(opts) {
  key_event_opts = opts;
}

function _onEventsStart(cb) {
  start_cbs.push(cb);
}

function _onEventsStop(cb) {
  stop_cbs.push(cb);
}

/*
document.addEventListener("touchstart", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("touchmove", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("scroll", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("resize", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("pointerdown", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("pointerstart", (e) => {
  e.preventDefault();
}, {capture : true});
document.addEventListener("pointermove", (e) => {
  e.preventDefault();
}, {capture : true});
*/

let sidebar_hash = new HashDigest();

class SideBar extends Container {
  constructor() {
    super();

    this.header = this.row();
    this.header.style["height"] = "45px";

    this._last_resize_key = undefined;

    this._closed = false;

    this.closeIcon = this.header.iconbutton(Icons.RIGHT_ARROW, "Close/Open sidebar", () => {
      console.log("click!");
      this.closed = !this._closed;
    });

    this._openWidth = undefined;
    this.needsSetCSS = true;
    this.tabbar = this.tabs("left");
    //this.tabbar.style["flex-grow"] = "8";
  }

  saveData() {
    return {
      closed : this.closed
    }
  }

  loadData(obj) {
    this.closed = obj.closed;
  }

  set closed(val) {
    if (!!this._closed === !!val) {
      return;
    }

    if (this._openWidth === undefined && !this._closed && val) {
      this._openWidth = this.width;
    }

    console.log("animate!");
    let w = val ? 50 : this._openWidth;
    this.animate().goto("width", w, 500);


    if (val) {
      this.closeIcon.icon = Icons.LEFT_ARROW;
    } else {
      this.closeIcon.icon = Icons.RIGHT_ARROW;
    }

    this._closed = val;
  }

  get closed() {
    return this._closed;
  }

  get width() {
    return parsepx$1("" + this.getAttribute("width"));
  }

  set width(val) {
    this.setAttribute("width", "" + val + "px");
    this.update();
  }

  get height() {
    return parsepx$1("" + this.getAttribute("height"));
  }

  set height(val) {
    this.setAttribute("height", "" + val + "px");
    this.update();
  }

  static define() {
    return {
      tagname: "sidebar-base-x",
      style  : "sidebar"
    }
  }

  tab(name) {
    return this.tabbar.tab(name);
  }

  init() {
    super.init();

    let closed = this._closed;
    this._closed = false;

    if (!this.getAttribute("width")) {
      this.width = 300;
    }
    if (!this.getAttribute("height")) {
      this.height = 700;
    }

    this.setCSS();

    if (closed) {
      this.closed = true;
    }
  }

  setCSS() {
    if (!this.parentWidget) {
      return;
    }

    let editor = this.parentWidget;

    //happens when editors are inactive
    if (!editor.pos || !editor.size) {
      return;
    }

    this.needsSetCSS = false;

    let w = this.width, h = this.height;

    w = isNaN(w) ? 500 : w;
    h = isNaN(h) ? 500 : h;

    h = Math.min(h, editor.size[1]-25);

    this.style["position"] = UIBase$2.PositionKey;
    this.style["width"] = w + "px";
    this.style["height"] = h + "px";
    this.style["z-index"] = "100";
    this.style["overflow"] = "scroll";

    this.style["background-color"] = this.getDefault("AreaHeaderBG");

    this.tabbar.style["height"] = (h - 45) + "px";
    this.style["left"] = (editor.pos[0] + editor.size[0] - w) + "px";
  }

  update() {
    sidebar_hash.reset();
    sidebar_hash.add(this.width);
    sidebar_hash.add(this.height);

    let key = sidebar_hash.get();
    if (key !== this._last_resize_key) {
      this._last_resize_key = key;
      this.needsSetCSS = true;
    }

    if (this.needsSetCSS) {
      this.setCSS();
    }
  }
}

UIBase$2.register(SideBar);

class Editor extends Area$1 {
  constructor() {
    super();

    this.container = UIBase$2.createElement("container-x");
    this.container.parentWidget = this;
    this.shadow.appendChild(this.container);
  }

  static define() {
    return {
      areaname: "areaname",
      tagname : "tagname-x"
    }
  }

  static defineAPI(api, strct) {
    return strct;
  }

  /** \param makeMenuBar function(ctx, container, menuBarEditor)
   *
   * example:
   *
   * function makeMenuBar(ctx, container, menuBarEditor) {
   *
   *  container.menu("File", [
   *    "app.new()",
   *    simple.Menu.SEP,
   *    "app.save()",
   *    "app.save(forceDialog=true)|Save As",
   *    "app.open"
   *  ]);
   * }
   * */
  static registerAppMenu(makeMenuBar) {
    if (this !== Editor) {
      throw new Error("must call registerAppMenu from simple.Editor base class");
    }

    this.makeMenuBar = makeMenuBar;
  }

  static register(cls) {
    if (!cls.hasOwnProperty("define")) {
      throw new Error("missing define() method");
    }

    if (!cls.hasOwnProperty("STRUCT")) {
      cls.STRUCT = nstructjs$1.inherit(cls, this) + `\n}`;
    }

    super.register(cls);
    nstructjs$1.register(cls);
  }

  makeSideBar() {
    if (this.sidebar) {
      this.sidebar.remove();
    }

    let sidebar = this.sidebar = UIBase$2.createElement("sidebar-base-x");
    sidebar.parentWidget = this;
    sidebar.ctx = this.ctx;
    this.shadow.appendChild(sidebar);

    if (this.ctx) {
      sidebar._init();

      this.sidebar.flushSetCSS();
      this.sidebar.flushUpdate();
    }


    return this.sidebar;
  }

  on_resize(size, oldsize) {
    super.on_resize(size, oldsize);

    if (this.sidebar) {
      if (this.ctx && this.pos) {
        this.sidebar.setCSS();
      } else {
        this.sidebar.needsSetCSS = true;
      }
    }
  }

  static findEditor(cls) {
    return contextWrangler.getLastArea(cls);
  }
  
  getScreen() {
    return this.ctx.screen;
  }

  init() {
    super.init();

    this.makeHeader(this.container);
  }

  /** creates default header and puts it in this.header */
  makeHeader(container, add_note_area = true, make_draggable = true) {
    return super.makeHeader(container, add_note_area, make_draggable);
  }

  /** called regularly */
  update() {
    super.update();
  }

  /** */
  setCSS() {
    super.setCSS();
  }
}

let text = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="512"
   height="512"
   id="svg16099"
   version="1.1"
   inkscape:version="1.0 (4035a4fb49, 2020-05-01)"
   sodipodi:docname="iconsheet.svg"
   inkscape:export-filename="C:\dev\allshape\src\datafiles\iconsheet16.png"
   inkscape:export-xdpi="45"
   inkscape:export-ydpi="45">
  <defs
     id="defs16101">
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1587"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1307"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1303"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1299"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1295"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1291"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1231"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1186"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1182"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4974"
       is_visible="true" />
    <linearGradient
       id="linearGradient5481">
      <stop
         id="stop4865"
         offset="0"
         style="stop-color:#e66700;stop-opacity:1;" />
      <stop
         style="stop-color:#f47712;stop-opacity:1;"
         offset="0.52777779"
         id="stop4867" />
      <stop
         id="stop4869"
         offset="1"
         style="stop-color:#f8bb8a;stop-opacity:1;" />
    </linearGradient>
    <linearGradient
       id="linearGradient17116-6">
      <stop
         id="stop4860"
         offset="0"
         style="stop-color:#b3a500;stop-opacity:1;" />
      <stop
         id="stop4862"
         offset="1"
         style="stop-color:#eaa500;stop-opacity:1;" />
    </linearGradient>
    <linearGradient
       id="linearGradient17116">
      <stop
         id="stop4853"
         offset="0"
         style="stop-color:#b3a500;stop-opacity:1;" />
      <stop
         id="stop4855"
         offset="1"
         style="stop-color:#eaa500;stop-opacity:1;" />
    </linearGradient>
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4290"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4286"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4122"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4118"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4194"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect3225"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect5012"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect5008"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4108"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect3264"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect5465"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4613"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4609"
       is_visible="true" />
    <linearGradient
       id="linearGradient5609">
      <stop
         id="stop5611"
         offset="0"
         style="stop-color:#0089e6;stop-opacity:1;" />
      <stop
         style="stop-color:#1280f4;stop-opacity:1;"
         offset="0.52777779"
         id="stop5613" />
      <stop
         id="stop5615"
         offset="1"
         style="stop-color:#d4eefc;stop-opacity:1;" />
    </linearGradient>
    <linearGradient
       id="linearGradient5481-8">
      <stop
         style="stop-color:#ffc700;stop-opacity:1"
         offset="0"
         id="stop5483" />
      <stop
         id="stop5491"
         offset="0.52777779"
         style="stop-color:#ffc700;stop-opacity:1" />
      <stop
         style="stop-color:#ffa41c;stop-opacity:1"
         offset="1"
         id="stop5485" />
    </linearGradient>
    <inkscape:perspective
       sodipodi:type="inkscape:persp3d"
       inkscape:vp_x="-108.10967 : 516.24314 : 1"
       inkscape:vp_y="0 : 323.31882 : 0"
       inkscape:vp_z="57.429562 : 516.24314 : 1"
       inkscape:persp3d-origin="-25.340056 : 488.65327 : 1"
       id="perspective18342" />
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="Arrow2Send"
       style="overflow:visible;">
      <path
         id="path17173"
         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
         transform="scale(0.3) rotate(180) translate(-2.3,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Mend"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="Arrow2Mend"
       style="overflow:visible;">
      <path
         id="path17167"
         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
         transform="scale(0.6) rotate(180) translate(0,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow1Send"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="Arrow1Send"
       style="overflow:visible;">
      <path
         id="path17155"
         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1.0pt;"
         transform="scale(0.2) rotate(180) translate(6,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Lend"
       orient="auto"
       refY="0.0"
       refX="0.0"
       id="Arrow2Lend"
       style="overflow:visible;">
      <path
         id="path17161"
         style="fill-rule:evenodd;stroke-width:0.62500000;stroke-linejoin:round;"
         d="M 8.7185878,4.0337352 L -2.2072895,0.016013256 L 8.7185884,-4.0017078 C 6.9730900,-1.6296469 6.9831476,1.6157441 8.7185878,4.0337352 z "
         transform="scale(1.1) rotate(180) translate(1,0)" />
    </marker>
    <linearGradient
       id="linearGradient17126">
      <stop
         style="stop-color:#008080;stop-opacity:1;"
         offset="0"
         id="stop17128" />
      <stop
         style="stop-color:#00b3b3;stop-opacity:1;"
         offset="1"
         id="stop17130" />
    </linearGradient>
    <linearGradient
       id="linearGradient17116-6-9">
      <stop
         style="stop-color:#b3a500;stop-opacity:1;"
         offset="0"
         id="stop17118" />
      <stop
         style="stop-color:#eaa500;stop-opacity:1;"
         offset="1"
         id="stop17120" />
    </linearGradient>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-2"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-2"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-6"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-8"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-7"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-6"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-8"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-9"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-79"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-5"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-3"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-1"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-33"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-4"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <marker
       inkscape:stockid="Arrow2Send"
       orient="auto"
       refY="0"
       refX="0"
       id="Arrow2Send-1"
       style="overflow:visible">
      <path
         inkscape:connector-curvature="0"
         id="path17173-3"
         style="fill-rule:evenodd;stroke-width:0.625;stroke-linejoin:round"
         d="M 8.7185878,4.0337352 -2.2072895,0.01601326 8.7185884,-4.0017078 c -1.7454984,2.3720609 -1.7354408,5.6174519 -6e-7,8.035443 z"
         transform="matrix(-0.3,0,0,-0.3,0.69,0)" />
    </marker>
    <linearGradient
       inkscape:collect="always"
       xlink:href="#linearGradient5481-5"
       id="linearGradient5489-4"
       x1="355.89935"
       y1="17.125025"
       x2="380.47559"
       y2="17.125025"
       gradientUnits="userSpaceOnUse" />
    <linearGradient
       id="linearGradient5481-5">
      <stop
         style="stop-color:#e66700;stop-opacity:1;"
         offset="0"
         id="stop5483-2" />
      <stop
         id="stop5491-9"
         offset="0.52777779"
         style="stop-color:#f47712;stop-opacity:1;" />
      <stop
         style="stop-color:#f8bb8a;stop-opacity:1;"
         offset="1"
         id="stop5485-9" />
    </linearGradient>
    <linearGradient
       y2="17.125025"
       x2="380.47559"
       y1="17.125025"
       x1="355.89935"
       gradientUnits="userSpaceOnUse"
       id="linearGradient5588"
       xlink:href="#linearGradient5609"
       inkscape:collect="always"
       gradientTransform="matrix(1.2151103,0,0,1.1804992,-207.06775,536.98221)" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4108-1"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4108-4"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4108-9"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect3225-1"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect3225-4"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4122-2"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4122-7"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect1587-6"
       is_visible="true" />
    <inkscape:path-effect
       effect="spiro"
       id="path-effect4194-5"
       is_visible="true" />
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#9c9c9c"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0"
     inkscape:pageshadow="2"
     inkscape:zoom="3.8325453"
     inkscape:cx="144.17961"
     inkscape:cy="49.96269"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="true"
     inkscape:window-width="1606"
     inkscape:window-height="962"
     inkscape:window-x="177"
     inkscape:window-y="71"
     inkscape:window-maximized="0"
     inkscape:snap-global="false"
     inkscape:pagecheckerboard="true"
     inkscape:document-rotation="0">
    <inkscape:grid
       type="xygrid"
       id="grid16107"
       empspacing="1"
       visible="true"
       enabled="true"
       snapvisiblegridlinesonly="false"
       spacingx="32"
       spacingy="32"
       dotted="false"
       originx="0"
       originy="0" />
  </sodipodi:namedview>
  <metadata
     id="metadata16104">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-540.36218)">
    <ellipse
       style="opacity:0.79203539;fill:url(#linearGradient5588);fill-opacity:1;stroke:#3c3c3c;stroke-width:1.1393038;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="path3171-8"
       cx="240.32063"
       cy="557.19836"
       rx="14.353489"
       ry="14.165989" />
    <flowRoot
       xml:space="preserve"
       id="flowRoot5564"
       style="font-style:normal;font-weight:normal;line-height:0.01%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none"
       transform="matrix(0.64571833,0,0,0.61432912,8.6966653,558.72048)"><flowRegion
         id="flowRegion5566"
         style="font-family:sans-serif"><rect
           id="rect5568"
           width="78.749992"
           height="72.5"
           x="346.24997"
           y="-21.999973"
           style="font-family:sans-serif" /></flowRegion><flowPara
         id="flowPara5570"
         style="font-weight:bold;font-size:40px;line-height:1.25;font-family:sans-serif;-inkscape-font-specification:'Sans Bold'">?</flowPara></flowRoot>
    <path
       style="fill:none;stroke:#ec6900;stroke-width:4.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-mid:none;marker-end:none"
       d="m 187.1235,559.26606 c -3.71166,-5.87882 -12.04056,-10.0009 -18.86169,0.34701"
       id="path4144-1"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:#ec6900;fill-opacity:1;stroke:none;stroke-width:0.001;stroke-miterlimit:4;stroke-dasharray:none"
       d="m 170.01417,560.40163 2.05175,2.63036 -9.89352,4.33226 2.83717,-13.08504 z"
       id="path5370-7"
       inkscape:connector-curvature="0" />
    <path
       style="fill:none;stroke:#1f9000;stroke-width:4.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1;marker-mid:none;marker-end:none"
       d="m 197.1805,559.70121 c 3.69186,-5.88365 11.97631,-10.00911 18.76103,0.3473"
       id="path4144-1-9"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:#1f9000;fill-opacity:1;stroke:none"
       d="m 213.95021,560.59037 -2.0408,2.63252 9.84072,4.33582 -2.82203,-13.09579 z"
       id="path5370-7-4"
       inkscape:connector-curvature="0" />
    <rect
       style="fill:#000000;fill-opacity:1;stroke:none"
       id="rect3224"
       width="23.641272"
       height="8.4057856"
       x="487.73776"
       y="552.41565" />
    <path
       style="fill:none;stroke:#000000;stroke-width:5;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="M 498.18023,567.81152 484.7754,556.20378 498.93081,545.77569"
       id="path4074"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccc" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:none"
       d="m 17.866009,585.82436 -0.09,-4.53232 -14.5167501,7.49748 14.5683701,7.84238 z"
       id="path5370-5-0-6-5"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:none"
       d="m 46.366429,592.31275 0.0109,4.6129 14.90287,-7.37024 -14.68289,-8.23782 z"
       id="path5370-5-1-2"
       inkscape:connector-curvature="0" />
    <rect
       style="opacity:0.94690265;fill:#000000;fill-opacity:1;stroke:none"
       id="rect5558-3-3"
       width="10.726034"
       height="5.6689787"
       x="-3.0812507"
       y="587.85645"
       transform="matrix(1,0,0.06880209,0.99763033,0,0)" />
    <rect
       style="opacity:0.94690265;fill:#000000;fill-opacity:1;stroke:none"
       id="rect5558-1"
       width="10.540748"
       height="5.5710502"
       x="-22.93788"
       y="587.9295"
       transform="matrix(1,0,0.06880209,0.99763033,0,0)" />
    <path
       style="fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.685581"
       d="m 71.46269,592.27473 0.01481,6.27371 20.268436,-10.02379 -19.969263,-11.20374 z"
       id="path5370-5-1-2-1"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.685581"
       d="m 108.87703,578.56977 -6.27262,0.11779 10.35514,20.10117 10.87444,-20.15049 z"
       id="path5370-5-1-2-1-7"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:#363636;stroke-width:2.23946524;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 69.769603,567.95981 5.60449,-5.39601"
       id="path5452-5-5-1-7"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc"
       inkscape:transform-center-x="3.061478"
       inkscape:transform-center-y="-0.63275351" />
    <path
       style="fill:#000000;fill-opacity:1;stroke:#363636;stroke-width:2.23946524;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 75.172083,567.8747 -5.47097,-5.53134"
       id="path5452-5-5-1-7-4"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc"
       inkscape:transform-center-x="3.196728"
       inkscape:transform-center-y="-0.78552851" />
    <path
       style="fill:#ffe87e;fill-opacity:1;stroke:#a58000;stroke-width:1.02573335px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 36.512525,599.08328 -0.0847,-15.30469 14.76623,-0.079 1.13455,-5.3121 h 6.7663 l 0.52197,5.56549 h 2.38874 l -0.0349,15.41642 z"
       id="path4607"
       inkscape:path-effect="#path-effect4609"
       inkscape:original-d="m 36.512525,599.08328 -0.0847,-15.30469 14.76623,-0.079 1.13455,-5.3121 h 6.7663 l 0.52197,5.56549 h 2.38874 l -0.0349,15.41642 z"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccccc"
       transform="translate(-33.065965,-31.819347)" />
    <path
       style="fill:#dfc449;fill-opacity:1;stroke:#a58000;stroke-width:1.04236829px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 38.651325,583.64804 2.27904,-5.34039 8.11475,0.19058 1.53729,4.93611 z"
       id="path5463"
       inkscape:path-effect="#path-effect5465"
       inkscape:original-d="m 38.651325,583.64804 2.27904,-5.34039 8.11475,0.19058 1.53729,4.93611 z"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccc"
       transform="translate(-33.065965,-31.819347)" />
    <path
       style="fill:#d7f0fb;fill-opacity:1;stroke:#4f4f4f;stroke-width:1.5;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
       d="m 71.789265,599.90744 0.17512,-24.69199 h 15.41061 l 4.378,4.90337 0.17513,19.96374 z"
       id="path3262"
       inkscape:path-effect="#path-effect3264"
       inkscape:original-d="m 71.789265,599.90744 0.17512,-24.69199 h 15.41061 l 4.378,4.90337 0.17513,19.96374 z"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccc"
       transform="translate(-33.561281,-31.819347)" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.190225,596.58015 16.81157,-0.35024"
       id="path4106"
       inkscape:path-effect="#path-effect4108"
       inkscape:original-d="m 73.190225,596.58015 16.81157,-0.35024"
       inkscape:connector-curvature="0"
       transform="translate(-33.561281,-31.819347)" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.540465,591.50166 16.81157,-0.35024"
       id="path4106-7"
       inkscape:path-effect="#path-effect4108-1"
       inkscape:original-d="m 73.540465,591.50166 16.81157,-0.35024"
       inkscape:connector-curvature="0"
       transform="translate(-33.561281,-31.819347)" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.365345,586.59829 16.81157,-0.35024"
       id="path4106-0"
       inkscape:path-effect="#path-effect4108-4"
       inkscape:original-d="m 73.365345,586.59829 16.81157,-0.35024"
       inkscape:connector-curvature="0"
       transform="translate(-33.561281,-31.819347)" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 73.365345,582.22027 16.81157,-0.35024"
       id="path4106-4"
       inkscape:path-effect="#path-effect4108-9"
       inkscape:original-d="m 73.365345,582.22027 16.81157,-0.35024"
       inkscape:connector-curvature="0"
       transform="translate(-33.561281,-31.819347)" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#f1f1f1;stroke-width:4.65793133;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 103.19489,558.19446 16.18158,0.0627"
       id="path5452-5-5-1-7-7"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc"
       inkscape:transform-center-x="3.6534509"
       inkscape:transform-center-y="-5.3788766" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#f4f4f4;stroke-width:4.65793133;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 111.38254,565.89244 -0.15492,-16.18101"
       id="path5452-5-5-1-7-4-4"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc"
       inkscape:transform-center-x="3.6340509"
       inkscape:transform-center-y="-5.8027516" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#f1f1f1;stroke-width:4.54087734;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 135.53124,558.66024 15.77493,0.0612"
       id="path5452-5-5-1-7-7-1"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc"
       inkscape:transform-center-x="3.561639"
       inkscape:transform-center-y="-5.2436726" />
    <path
       style="fill:#bfbfbf;fill-opacity:1;stroke:#ffffff;stroke-width:1.39999998;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 273.79736,565.92624 4.84986,4.15066 7.44379,-12.0346 -3.26109,-1.20718 -4.82074,8.91974 -2.46038,-2.39761 z"
       id="path1157"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccc" />
    <path
       style="fill:#ff9d00;fill-opacity:1;stroke:#808080;stroke-width:0.78749156px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 306.19903,566.65065 4.84985,4.15066 7.4438,-12.0346 -3.26109,-1.20718 -4.82075,8.91974 -2.46037,-2.39761 z"
       id="path1157-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccc" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:4.85740042;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 419.41366,537.85807 12.87326,7.64338 12.79438,-7.33068"
       id="path1585"
       inkscape:connector-curvature="0"
       inkscape:path-effect="#path-effect1587"
       inkscape:original-d="m 419.41366,537.85807 12.87326,7.64338 c 4.40656,-2.37267 3.01422,-8.5404 12.79438,-7.33068"
       sodipodi:nodetypes="ccc"
       transform="matrix(0.82348572,0,0,0.82348572,75.604975,111.95505)" />
    <path
       style="fill:none;stroke:#ffffff;stroke-width:4.85740042;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 419.41366,537.85807 12.87326,7.64338 12.79438,-7.33068"
       id="path1585-6"
       inkscape:connector-curvature="0"
       inkscape:path-effect="#path-effect1587-6"
       inkscape:original-d="m 419.41366,537.85807 12.87326,7.64338 c 4.40656,-2.37267 3.01422,-8.5404 12.79438,-7.33068"
       sodipodi:nodetypes="ccc"
       transform="matrix(-0.82326686,0.01898429,-0.01898429,-0.82326686,829.82733,995.45395)" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:1.4972775px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 325.7796,560.88703 9.22114,7.89176 14.15308,-22.88169 -6.20039,-2.29524 -9.16581,16.95932 -4.67796,-4.55863 z"
       id="path1157-6-7"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="ccccccc" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:none"
       d="m 338.27455,603.35315 -4.55847,-12.13972 -4.42325,4.14941 0.29119,-21.42993 14.0532,13.84869 -5.29334,1.40046 4.98485,11.66133 z"
       id="path4192-0"
       inkscape:path-effect="#path-effect4194-5"
       inkscape:original-d="m 338.27455,603.35315 -4.55847,-12.13972 -4.42325,4.14941 0.29119,-21.42993 14.0532,13.84869 -5.29334,1.40046 c 11.73953,18.68506 2.52594,6.89719 4.98485,11.66133 z"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cccccccc"
       transform="rotate(-9.319008,159.52768,371.93318)" />
    <text
       xml:space="preserve"
       style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:17.712px;line-height:0%;font-family:'MV Boli';-inkscape-font-specification:'MV Boli';letter-spacing:0px;word-spacing:0px;fill:#ffdc00;fill-opacity:1;stroke:none;stroke-width:1.476"
       x="179.14906"
       y="751.84772"
       id="text3255-0"
       transform="matrix(1.2141217,-0.1513943,0.23126622,0.79480305,0,0)"><tspan
         sodipodi:role="line"
         id="tspan3257-0"
         x="179.14906"
         y="751.84772"
         style="font-size:44.4154px;line-height:1.25;stroke-width:1.476">!</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:32.4516px;line-height:1.25;font-family:sans-serif;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.81129"
       x="131.62856"
       y="599.63672"
       id="text1309"><tspan
         sodipodi:role="line"
         id="tspan1307"
         x="131.62856"
         y="599.63672"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:sans-serif;-inkscape-font-specification:'sans-serif Bold';stroke-width:0.81129">B</tspan></text>
    <text
       id="text1309-2"
       y="658.43152"
       x="153.61592"
       style="font-style:normal;font-weight:normal;font-size:41.6588px;line-height:1.25;font-family:sans-serif;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:1.04147"
       xml:space="preserve"
       transform="scale(1.0962314,0.91221617)"><tspan
         style="font-style:italic;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:serif;-inkscape-font-specification:'serif Bold Italic';stroke-width:1.04147"
         y="658.43152"
         x="153.61592"
         id="tspan1307-4"
         sodipodi:role="line">i</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:38.431px;line-height:1.25;font-family:sans-serif;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.960773"
       x="264.23669"
       y="522.23657"
       id="text1309-0-9"
       transform="scale(0.87011438,1.1492742)"><tspan
         sodipodi:role="line"
         id="tspan1307-3-4"
         x="264.23669"
         y="522.23657"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:sans-serif;-inkscape-font-specification:'sans-serif Bold';stroke-width:0.960773"><tspan
           style="font-weight:normal;stroke-width:0.960773"
           id="tspan1365">s</tspan></tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:31.7797px;line-height:1.25;font-family:sans-serif;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.794494"
       x="195.07664"
       y="596.5979"
       id="text1309-0-2"
       transform="scale(0.99519471,1.0048285)"><tspan
         sodipodi:role="line"
         id="tspan1307-3-1"
         x="195.07664"
         y="596.5979"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:sans-serif;-inkscape-font-specification:'sans-serif Bold';stroke-width:0.794494">U</tspan></text>
    <path
       style="fill:none;stroke:#ffffff;stroke-width:3.47724;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 194.05959,600.03363 25.702,0.14808"
       id="path1375" />
    <path
       id="path1375-2"
       d="m 227.04774,587.38832 25.63991,0.14772"
       style="fill:none;stroke:#ffffff;stroke-width:3.46884;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       inkscape:transform-center-x="1.1856386"
       inkscape:transform-center-y="-0.33875464" />
    <path
       style="fill:#ffffff;fill-opacity:1;stroke:#484848;stroke-width:1.623;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 262.93706,592.38036 0.0134,5.70131 18.41916,-9.10923 -18.14729,-10.18151 z"
       id="path5370-5-1-2-1-4"
       inkscape:connector-curvature="0" />
    <path
       inkscape:connector-curvature="0"
       id="path5370-5-1-2-1-4-0"
       d="m 301.44451,581.20782 -5.70129,0.0197 9.12976,18.40899 10.16128,-18.15862 z"
       style="fill:#ffffff;fill-opacity:1;stroke:#484848;stroke-width:1.623;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
    <ellipse
       style="fill:none;stroke:#242424;stroke-width:2.80047;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:20;stroke-opacity:1"
       id="path1040"
       ry="8.7032747"
       rx="8.4312963"
       cy="583.49023"
       cx="331.71524" />
    <path
       style="fill:none;stroke:#242424;stroke-width:6;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 336.4644,589.47097 10.10632,10.66173"
       id="path1042"
       sodipodi:nodetypes="cc" />
    <path
       style="fill:none;stroke:#242424;stroke-width:2.17621;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 325.36075,583.26941 12.63506,0.34484"
       id="path1044" />
    <ellipse
       cx="364.00839"
       cy="584.36328"
       rx="9.6165609"
       ry="9.9267731"
       id="path1040-0"
       style="fill:none;stroke:#242424;stroke-width:3.19416;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:20;stroke-opacity:1" />
    <path
       sodipodi:nodetypes="cc"
       id="path1042-6"
       d="m 369.73697,590.7899 10.89694,10.89694"
       style="fill:none;stroke:#242424;stroke-width:6;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
    <path
       id="path1044-4"
       d="m 357.64269,584.09303 12.63506,0.34484"
       style="fill:none;stroke:#242424;stroke-width:2.17621;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" />
    <path
       style="fill:none;stroke:#242424;stroke-width:2.17621;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 363.94156,590.78154 0.20796,-12.63806"
       id="path1044-4-9" />
  </g>
</svg>
`.trim();

text = btoa(text);
let iconSvg = `data:image/svg+xml;base64,` + text;

"use strict";

const Icons$2 = {
  FOLDER        : 0, //file folder
  FILE          : 1,
  TINY_X        : 2, //'x' in bottom left corner
  SMALL_PLUS    : 3,
  SMALL_MINUS   : 4,
  UNDO          : 5,
  REDO          : 6,
  HELP          : 7,
  ENUM_UNCHECKED: 8, //overlaid on icon checkboxes when unchecked
  ENUM_CHECKED  : 9, //overlaid on icon checkboxes when checked
  LARGE_CHECK   : 10, //default check mark for non-icon checkboxes
  CURSOR_ARROW  : 11,
  NOTE_EXCL     : 12, //notification exclamation mark
  SCROLL_DOWN   : 13,
  SCROLL_UP     : 14,
  BACKSPACE     : 15,
  LEFT_ARROW    : 16,
  RIGHT_ARROW   : 17,
  UI_EXPAND     : 18, //triangle
  UI_COLLAPSE   : 19, //triangle
  BOLD          : 20,
  ITALIC        : 21,
  UNDERLINE     : 22,
  STRIKETHRU    : 23,
  TREE_EXPAND   : 24,
  TREE_COLLAPSE : 25,
  ZOOM_OUT      : 26,
  ZOOM_IN       : 27
};

function loadDefaultIconSheet() {
  let iconSheet = document.createElement("img");
  iconSheet.src = iconSvg;

  return iconSheet;
}

class FileHeader {
  constructor(version, magic, flags) {
    this.magic = magic;
    this.flags = flags;
    this.version_major = version ? version[0] : 0;
    this.version_minor = version ? version[1] : 0;
    this.version_micro = version ? version[2] : 0;
    this.schema = nstructjs.write_scripts();
  }
}

FileHeader.STRUCT = `
simple.FileHeader {
  magic         : static_string[4];
  version_major : short;
  version_minor : short;
  version_micro : short;
  flags         : short;
  schema        : string; 
}
`;
nstructjs.register(FileHeader);

class FileFull extends FileHeader {
  constructor(version, magic, flags) {
    super(version, magic, flags);
    this.objects = [];
  }
}

FileFull.STRUCT = nstructjs.inherit(FileFull, FileHeader) + `
  objects : array(abstract(Object));
  screen  : abstract(Object);
}
`;
nstructjs.register(FileFull);


class FileArgs {
  constructor(args = {}) {
    this.ext = args.ext || ".data";
    this.magic = args.magic || "STRT";
    this.doScreen = args.doScreen !== undefined ? args.doScreen : true;
    this.resetOnLoad = args.resetOnLoad !== undefined ? args.resetOnLoad : true;
    this.useJSON = args.useJSON !== undefined ? args.useJSON : false;
    this.version = args.version !== undefined ? args.version : 0;
    this.fileFlags = args.fileFlags !== undefined ? args.fileFlags : 0;
    this.fromFileOp = false; /* SimpleSaveOp and SimpleOpenOp set this to true */
  }
}

class EmptyStruct {

}
EmptyStruct.STRUCT = `
EmptyStruct {
}
`;
nstructjs.register(EmptyStruct);

function saveFile$1(appstate, args, objects) {
  if (args.useJSON === undefined) {
    args.useJSON = appstate.saveFilesInJSON;
  }

  args = new FileArgs(args);

  let version = args.version;
  if (typeof version === "number") {
    if (version === Math.floor(version)) {
      version = [version, 0, 0];
    } else {
      let major = ~~version;
      let minor = ~~(Math.fract(version)*10.0);
      let micro = (Math.fract(version) - minor) * 100.0;

      version = [major, minor, micro];
    }
  }

  let file = new FileFull(version, args.magic, args.fileFlags);

  if (args.doScreen) {
    file.screen = appstate.screen;
  } else {
    file.screen = new EmptyStruct();
  }

  for (let ob of objects) {
    file.objects.push(ob);
  }

  if (args.useJSON) {
    return nstructjs.writeJSON(file);
  } else {
    let data = [];
    nstructjs.writeObject(data, file);
    return (new Uint8Array(data)).buffer;
  }
}

function loadFile$1(appstate, args, data) {
  let header;

  if (args.useJSON === undefined) {
    args.useJSON = appstate.saveFilesInJSON;
  }

  args = new FileArgs(args);

  if (!args.useJSON) {
    if (data instanceof Array) {
      data = (new Uint8Array(data)).buffer;
    }

    if (data instanceof Uint8Array) {
      data = data.buffer;
    }

    if (data instanceof ArrayBuffer) {
      data = new DataView(data);
    }

    header = nstructjs.readObject(data, FileHeader);
  } else {
    if (typeof data === "string") {
      data = JSON.parse(data);
    }

    header = nstructjs.readJSON(data, FileHeader);
  }

  if (header.magic !== args.magic) {
    throw new Error("invalid file");
  }

  let istruct = new nstructjs.STRUCT();
  istruct.parse_structs(header.schema);

  let ret;

  if (!args.useJSON) {
    ret = istruct.readObject(data, FileFull);
  } else {
    ret = istruct.readJSON(data, FileFull);
  }

  if (args.resetOnLoad) {
    appstate.reset();
  }

  if (args.doScreen) {
    if (appstate.screen) {
      appstate.screen.unlisten();
      appstate.screen.remove();
    }

    ret.screen.ctx = appstate.ctx;

    if (!(ret.screen instanceof appstate.screenClass)) {
      let screen = UIBase$2.createElement(appstate.screenClass.define().tagname);
      screen.ctx = appstate.ctx;

      for (let sarea of ret.screen.sareas) {
        screen.appendChild(sarea);

        sarea.area.afterSTRUCT();
        sarea.area.on_fileload();
      }

      ret.screen = screen;
    }

    appstate.screen = ret.screen;

    document.body.appendChild(appstate.screen);
    appstate.screen.listen();
  }

  return ret;
}

/** see ./editor.js:Editor.registerAppMenu */

class MenuBarEditor extends Editor {
  constructor() {
    super();

    this.updateHeight();
    this.borderLock = 1 | 2 | 4 | 8;
    this.areaDragToolEnabled = false;

    this._height = 25;

    this.needsRebuild = false;
  }

  get height() {
    return this._height;
  }

  set height(v) {
    this._height = v;
    this.updateHeight();
  }

  static define() {
    return {
      tagname : "simple-menu-editor-x",
      areaname: "menu",
      uiname  : "Menu Bar",
      icon    : -1,
      //hide in editor list
      flag    : AreaFlags.HIDDEN | AreaFlags.NO_HEADER_CONTEXT_MENU | AreaFlags.NO_COLLAPSE | AreaFlags.NO_SWITCHER
    }
  }

  updateHeight(force = false) {
    if (!this.header)
      return;

    if (window.haveElectron) {
      this.maxSize[1] = this.minSize[1] = 1;
      electron_api.initMenuBar(this);
      return;
    }

    if (this._height === undefined) {
      let rect = this.header.getClientRects()[0];

      if (rect) {
        this._height = rect.height;
      }
    }

    let update = force || this._height !== this.minSize[1];
    this.minSize[1] = this.maxSize[1] = this._height;

    if (update && this.ctx && this.getScreen()) {
      this.getScreen().solveAreaConstraints();
    }
  }

  makeMenuBar(container) {
    if (Editor.makeMenuBar) {
      Editor.makeMenuBar(this.ctx, container, this);
    }
  }

  flagRebuild() {
    this.needsRebuild = true;
  }

  init() {
    super.init();

    this.background = this.getDefault("AreaHeaderBG");

    this.menuRow = this.header.row();
    this.makeMenuBar(this.menuRow);

    this.doOnce(() => {
      if (window.haveElectron) {
        this.height = 1;
        electron_api.initMenuBar(this);
      }
    });

    this.updateHeight(true);
    this.flushUpdate();
  }

  rebuild() {
    this.needsRebuild = false;

    this.menuRow.clear();
    this.makeMenuBar(this.menuRow);
    this.flushUpdate();
  }

  update() {
    if (this.needsRebuild) {
      this.rebuild();
    }
  }
}

MenuBarEditor.STRUCT = nstructjs$1.inherit(MenuBarEditor, Editor, "MenuBarEditor") + `
}
`;

function registerMenuBarEditor() {
  Editor.register(MenuBarEditor);
}

class SimpleAppNewOp extends ToolOp {
  static tooldef() {
    return {
      uiname  : "New",
      toolpath: "app.new",
      inputs  : {},
      undoflag: UndoFlags.NO_UNDO
    }
  }

  exec(ctx) {
    _appstate.createNewFile();
  }
}

class SimpleAppSaveOp extends ToolOp {
  static tooldef() {
    return {
      uiname  : "Save",
      toolpath: "app.save",
      inputs  : {
        forceDialog: new BoolProperty()
      },
      undoflag: UndoFlags.NO_UNDO
    }
  }

  exec(ctx) {
    let ext = _appstate.fileExt;
    let useJSON = _appstate.startArgs.saveFilesInJSON;

    _appstate.saveFile({
      doScreen  : true,
      useJSON,
      fromFileOp: true
    }).then(data => {

      function save() {
        return data;
      }

      platform.showSaveDialog("Save As", save, {
        multi          : false,
        addToRecentList: true,
        filters        : [{
          name      : "File",
          mime      : useJSON ? "text/json" : "application/x-octet-stream",
          extensions: ["." + ext.toLowerCase()]
        }]
      }).then(path => {
        _appstate.currentFileRef = path;
        message("File saved");
      }).catch(err => {
        if (typeof err === "object" && err.message) {
          err = err.message;
        }

        error("Failed to save file " + err);
      });
    });
  }
}

class SimpleAppOpenOp extends ToolOp {
  static tooldef() {
    return {
      uiname  : "Open",
      toolpath: "app.open",
      inputs  : {
        forceDialog: new BoolProperty()
      },
      undoflag: UndoFlags.NO_UNDO
    }
  }

  exec(ctx) {
    let ext = _appstate.fileExt;
    let useJSON = _appstate.startArgs.saveFilesInJSON;
    let mime = useJSON ? "text/json" : "application/x-octet-stream";

    platform.showOpenDialog("Open File", {
      multi          : false,
      addToRecentList: true,
      filters        : [{
        name      : "File",
        mime,
        extensions: ["." + ext.toLowerCase()]
      }]
    }).then(paths => {
      for (let path of paths) {
        platform.readFile(path, mime).then(data => {
          console.log("got data!", data);

          _appstate.loadFile(data, {useJSON, doScreen: true, fromFileOp: true})
            .catch(err => {
              error("File error: " + err.message);
            });
        });
      }
    }).catch(error => {
      ctx.error(error.message);
    });
  }
}

function register$1() {
  ToolOp.register(SimpleAppSaveOp);
  ToolOp.register(SimpleAppOpenOp);
  ToolOp.register(SimpleAppNewOp);
}

const DataModelClasses = [];

class DataModel {
  static defineAPI(api, strct) {
    return strct;
  }

  static register(cls) {
    DataModelClasses.push(cls);

    if (cls.hasOwnProperty("STRUCT")) {
      nstructjs.register(cls);
    }
  }
}

class EmptyContextClass extends Context {
  static defineAPI(api, strct) {
  }
}

/**
 * Extend the client-provided context class
 * with a few standard methods and properties
 *
 * */
function GetContextClass(ctxClass) {
  let StateSymbol = Symbol("AppState ref");

  return class ContextDerived extends ctxClass {
    constructor(state) {
      super(...arguments);

      this[StateSymbol] = state;
    }

    get screen() {
      return this[StateSymbol].screen;
    }

    set state(v) {
      this[StateSymbol] = v;
    }

    get state() {
      return this[StateSymbol];
    }

    get api() {
      return this[StateSymbol].api;
    }

    get toolstack() {
      return this[StateSymbol].toolstack;
    }

    toLocked() {
      //for now, don't support context locking
      return this;
    }

    message(msg, timeout=2500) {
      return message(this.screen, msg, timeout);
    }

    error(msg, timeout=2500) {
      return error(this.screen, msg, timeout);
    }

    warning(msg, timeout=2500) {
      return warning(this.screen, msg, timeout);
    }

    progressBar(msg, percent, color, timeout=1000) {
      return progbarNote(this.screen, msg, percent, color, timeout);
    }
  }
}

function makeAPI(ctxClass) {
  let api = new DataAPI();

  for (let cls of DataModelClasses) {
    cls.defineAPI(api, api.mapStruct(cls, true));
  }

  for (let k in areaclasses) {
    areaclasses[k].defineAPI(api, api.mapStruct(areaclasses[k], true));
  }

  if (ctxClass.defineAPI) {
    ctxClass.defineAPI(api, api.mapStruct(ctxClass, true));
  } else {
    throw new Error("Context class should have a defineAPI static method");
  }

  api.rootContextStruct = api.mapStruct(ctxClass, api.mapStruct(ctxClass, true));

  return api;
}

class StartArgs {
  constructor() {
    this.singlePage = true;

    this.icons = Icons$2;
    this.iconsheet = undefined; //will default to loadDefaultIconSheet();
    this.iconSizes = [16, 24, 32, 48];
    this.iconTileSize = 32;
    this.iconsPerRow = 16;
    this.theme = undefined; //see scripts/core/theme.js

    this.registerSaveOpenOps = true;

    this.autoLoadSplineTemplates = true;
    this.showPathsInToolTips = true;
    this.enableThemeAutoUpdate = false;
    this.addHelpPickers = false;
    this.useNumSliderTextboxes = true;
    this.numSliderArrowLimit = exports.numSliderArrowLimit;
    this.simpleNumSliders = exports.simpleNumSliders;
  }
}

class SimpleScreen extends Screen$2 {
  constructor() {
    super();

    this.keymap = new KeyMap([
      new HotKey("Z", ["CTRL"], () => {
        this.ctx.toolstack.undo(this.ctx);
      }),
      new HotKey("Z", ["CTRL", "SHIFT"], () => {
        this.ctx.toolstack.redo(this.ctx);
      }),
    ]);
  }

  init() {
    if (this.ctx.state.startArgs.registerSaveOpenOps) {
      this.keymap.add(new HotKey("S", ["CTRL"], "app.save()"));
      this.keymap.add(new HotKey("O", ["CTRL"], "app.open()"));
    }
  }

  static define() {
    return {
      tagname: "simple-screen-x"
    }
  }

  setCSS() {
    super.setCSS();

    this.style["position"] = UIBase$2.PositionKey;
    this.style["left"] = this.pos[0] + "px";
    this.style["top"] = this.pos[1] + "px";
  }
}

UIBase$2.register(SimpleScreen);

class AppState {
  /** ctxClass is the context class.  It can be either a simple class
   *  or a subclass of the more complex path.ux Context class.  Note that
   *  using Context will avoid subtle undo stack errors caused by the context
   *  changing after a tool is run (this is why Context has a serialization
   *  mechanism).
   *
   *  Path.ux will actually subclass ctxClass and add a few standard methods
   *  and properties, see GetContextClass.*/
  constructor(ctxClass, screenClass = SimpleScreen) {
    this._ctxClass = ctxClass;

    ctxClass = GetContextClass(ctxClass);

    this.startArgs = undefined;
    this.currentFileRef = undefined; //current file path/ref

    this.ctx = new ctxClass(this);
    this.ctx._state = this;
    this.toolstack = new ToolStack();
    this.api = makeAPI(ctxClass);
    this.screenClass = screenClass;
    this.screen = undefined;

    this.fileMagic = "STRT";
    this.fileVersion = [0, 0, 1];
    this._fileExt = "data";
    this._fileExtSet = false;
    this.saveFilesInJSON = false; /* save files in nstructjs-json */

    this.defaultEditorClass = undefined; //if undefined, the first non-menubar editor will be used
  }


  get fileExt() {
    return this._fileExt;
  }

  set fileExt(ext) {
    this._fileExt = ext;
    this._fileExtSet = true;
  }

  /** resets the undo stack */
  reset() {
    this.toolstack.reset();
  }

  /** Create a new file. See this.makeScreen() if you wish
   *  to create a new screen at this time, and this.reset()
   *  if you wish to reset the undo stack*/
  createNewFile() {
    console.warn("appstate.createNewFile: implement me, using default hack");
    let state = new this.constructor(this.ctx._ctxClass);

    state.api = this.api;
    state.ctx = this.ctx;
    state.startArgs = this.startArgs;
    state.saveFilesInJSON = this.saveFilesInJSON;

    state.toolstack = this.toolstack;
    state.toolstack.reset();

    this.screen.unlisten();
    this.screen.remove();

    for (let k in state) {
      this[k] = state[k];
    }

    this.makeScreen();
  }

  /** Serialize the application state. Takes
   *  a list of objects to save (with nstructjs);
   *  Subclasses should override this, like so:
   *
   *  saveFile(args={}) {
   *    let objects = app state;
   *    return super.saveFile(objects, args);
   *  }
   **/
  saveFile(objects, args = {}) {
    args = new FileArgs(Object.assign({
      magic  : this.fileMagic,
      version: this.fileVersion,
      ext    : this.fileExt
    }, args));

    return new Promise((accept, reject) => {
      accept(saveFile$1(this, args, objects));
    });
  }

  /**
   *  Loads a new file. The default behavior is a
   *  complete state reset (you can control this
   *  with args.reset_toolstack, args.reset_context
   *  and args.doScreen).
   *
   *  As the base class cannot know just what to do
   *  with the loaded data (the objects parameter
   *  passed to saveFile) it is recommended you
   *  override this function like so:
   *
   *  loadFile(data, args) {
   *    return super.loadFile(data, args).then(fileData) => {
   *      // load fileData.objects into appropriate properties
   *      // this is the same objects array originally passed
   *      // to this.saveFile
   *      this.data = fileData.objects;
   *    });
   *  }
   *
   *  @param {ArrayBuffer|JSON|DataView} data
   *  @param {FileArgs} args
   *  */
  loadFile(data, args = {}) {
    return new Promise((accept, reject) => {
      args = new FileArgs(Object.assign({
        magic  : this.fileMagic,
        version: this.fileVersion,
        ext    : this.fileExt
      }, args));

      let ret = loadFile$1(this, args, data);

      if (args.doScreen) {
        try {
          this.ensureMenuBar();
        } catch (error) {
          console.error(error.stack);
          console.error(error.message);
          console.error("Failed to add menu bar");
        }

        this.screen.completeSetCSS();
        this.screen.completeUpdate();
      }

      accept(ret);
    });
  }

  ensureMenuBar() {
    let screen = this.screen;
    let ok = false;

    for (let sarea of screen.sareas) {
      if (sarea.area instanceof MenuBarEditor) {
        ok = true;
        break;
      }
    }

    if (ok) {
      return;
    }

    if (!Editor.makeMenuBar) {
      /* don't make menu bar if Editor.registerAppMenu hasn't been called */
      return;
    }

    /* ensure screen size is up to date */
    screen.update();

    let sarea = UIBase$2.createElement("screenarea-x");

    screen.appendChild(sarea);

    let h = 55;
    let min = new Vector2().addScalar(1e17);
    let max = new Vector2().addScalar(-1e17);
    let tmp = new Vector2();

    for (let sarea2 of screen.sareas) {
      if (sarea2 === sarea) {
        continue;
      }

      min.min(sarea2.pos);
      tmp.load(sarea2.pos).add(sarea2.size);
      max.max(tmp);
    }

    let scale = (max[1] - min[1] - h)/(max[1] - min[1]);

    for (let sarea2 of screen.sareas) {
      if (sarea2 === sarea) {
        continue;
      }

      sarea2.pos[1] *= scale;
      sarea2.size[1] *= scale;
      sarea2.pos[1] += h;
    }

    sarea.pos.zero();
    sarea.size[0] = screen.size[0];
    sarea.size[1] = h;

    screen.regenScreenMesh();
    screen.snapScreenVerts();

    sarea.switch_editor(MenuBarEditor);

    screen.solveAreaConstraints();

    screen.completeSetCSS();
    screen.completeUpdate();
  }

  makeScreen() {
    if (this.screen) {
      this.screen.unlisten();
      this.screen.remove();
    }

    let screen = this.screen = UIBase$2.createElement(this.screenClass.define().tagname);
    let sarea = UIBase$2.createElement("screenarea-x");

    screen.ctx = this.ctx;
    sarea.ctx = this.ctx;

    document.body.appendChild(screen);

    let cls = this.defaultEditorClass;

    if (!cls) {
      for (let k in areaclasses) {
        cls = areaclasses[k];

        if (cls !== MenuBarEditor) {
          break;
        }
      }
    }

    sarea.switch_editor(cls);
    screen.appendChild(sarea);

    screen._init();
    screen.listen();
    screen.update();
    screen.completeSetCSS();
    screen.completeUpdate();

    if (Editor.makeMenuBar) {
      this.ensureMenuBar();
    }
  }

  start(args = new StartArgs()) {
    let args2 = new StartArgs();

    let methodsCheck = [
      "saveFile", "createFile", "loadFile"
    ];

    for (let method of methodsCheck) {
      let m1 = AppState.prototype[method];
      let m2 = this[method];

      if (m1 === m2) {
        console.warn(`Warning: it is recommended to override .${method} when subclassing simple.AppState`);
      }
    }

    document.body.style["touch-action"] = "none";

    registerMenuBarEditor();

    for (let k in args2) {
      if (args[k] === undefined) {
        args[k] = args2[k];
      }
    }

    if (args.registerSaveOpenOps) {
      register$1();
    }

    if (!args.iconsheet) {
      args.iconsheet = loadDefaultIconSheet();
    }

    this.startArgs = args;

    exports.loadConstants(args);

    if (args.autoLoadSplineTemplates) {
      initSplineTemplates();
    }

    let sizes = [];
    let images = [];

    for (let size of args.iconSizes) {
      sizes.push([args.iconTileSize, size]);
      images.push(args.iconsheet);
    }

    window.iconsheet = args.iconsheet;


    let iconManager = new IconManager(images, sizes, args.iconsPerRow);
    setIconManager(iconManager);
    setIconMap(args.icons);

    if (args.theme) {
      setTheme(args.theme);
    }

    document.body.style["margin"] = "0px";
    document.body.style["padding"] = "0px";

    if (args.singlePage) {
      document.body.style["overflow"] = "hidden";
    }

    this.makeScreen();

    Object.defineProperty(window, "C", {
      get() {
        return this._appstate.ctx;
      }
    });

    nstructjs.validateStructs();

    if (this.saveFilesInJSON && !this._fileExtSet) {
      this._fileExt = "json";
    }

    if (this._fileExt.startsWith(".")) {
      this._fileExt = this._fileExt.slice(1, this._fileExt.length).trim();
    }
  }
}

class SimpleContext {
  constructor() {

  }

  static getContextClass() {
    let props = {};

    let rec = (cls) => {
      let prototype = cls.prototype;

      if (cls.__proto__ !== Object.__proto__) {
        rec(cls);
      }

      for (let k in cls) {
        let descr = Object.getOwnPropertyDescriptor(prototype, k);

        if (descr) {
          props[k] = descr;
        }
      }
    };

    console.log(props);

    for (let k in props) {
      if (k.search("_save") >= 0 || k.search("_load") >= 0) {
        continue;
      }

    }
  }
}

var simple1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Menu: Menu,
  DataModelClasses: DataModelClasses,
  DataModel: DataModel,
  makeAPI: makeAPI,
  StartArgs: StartArgs,
  SimpleScreen: SimpleScreen,
  AppState: AppState,
  SideBar: SideBar,
  Editor: Editor,
  Icons: Icons$2,
  loadDefaultIconSheet: loadDefaultIconSheet,
  iconSvg: iconSvg,
  FileHeader: FileHeader,
  FileFull: FileFull,
  FileArgs: FileArgs,
  EmptyStruct: EmptyStruct,
  saveFile: saveFile$1,
  loadFile: loadFile$1,
  SimpleContext: SimpleContext,
  MenuBarEditor: MenuBarEditor,
  registerMenuBarEditor: registerMenuBarEditor
});

const controller = controller1;
setNotifier(ui_noteframe);
const platform$2 = platform1;
const electron_api$1 = electron_api1;
const cconst$1 = exports;
const simple = simple1;

function getWebFilters(filters=[]) {
  let types = [];

  for (let item of filters) {
    let mime = item.mime;
    let exts = [];

    for (let ext of item.extensions) {
      ext = "." + ext;
      if (ext.toLowerCase() in mimeMap) {
        mime = mime !== undefined ? mime : mimeMap[ext.toLowerCase()];
      }

      exts.push(ext);
    }

    if (!mime) {
      mime = "application/x-octet-stream";
    }

    types.push({
      description: item.name,
      accept     : {
        [mime]: exts
      }
    });
  }

  return types;
}

class platform$3 extends PlatformAPI {
  //returns a promise
  static showOpenDialog(title, args = new FileDialogArgs()) {
    let types = getWebFilters(args.filters);

    return new Promise((accept, reject) => {
      try {
        window.showOpenFilePicker({
          multiple: args.multi,
          types
        }).then(arg => {
          let paths = [];

          for (let file of arg) {
            paths.push(new FilePath(file, file.name));
          }

          accept(paths);
        });
      } catch (error) {
        reject(error);
      }
    });
    /*
    let exts = [];

    for (let list of args.filters) {
      for (let ext of list.extensions) {
        exts.push(ext);
      }
    }

    return new Promise((accept, reject) => {
      loadFile(args.defaultPath, exts).then((file) => {
        accept([new FilePath(file)]);
      });
    });*/
  }

  static writeFile(data, handle, mime) {
    handle = handle.data;

    return handle.createWritable().then((file) => {
      file.write(data);
      file.close();
    });
  }

  static showSaveDialog(title, savedata_cb, args = new FileDialogArgs()) {
    if (!window.showSaveFilePicker) {
      return this.showSaveDialog_old(...arguments);
    }

    let types = getWebFilters(args.filters);

    return new Promise((accept, reject) => {
      let fname;
      let saveHandle;

      try {
        saveHandle = window.showSaveFilePicker({types});
      } catch (error) {
        reject(error);
      }

      let handle;

      saveHandle.then((handle1) => {
        handle = handle1;

        fname = handle.name;
        console.log("saveHandle", handle);
        return handle.createWritable();
      }).then((file) => {
        let savedata = savedata_cb();

        if (savedata instanceof Uint8Array || savedata instanceof DataView) {
          savedata = savedata.buffer;
        }

        file.write(savedata);
        file.close();

        let path = new FilePath(handle, fname);
        accept(path);
      });
    });
  }

  //returns a promise
  static showSaveDialog_old(title, savedata, args = new FileDialogArgs()) {

    let exts = [];

    for (let list of args.filters) {
      if (!Array.isArray(list) && list.filters) {
        list = list.filters;
      }

      for (let ext of list) {
        exts.push(ext);
      }
    }

    return new Promise((accept, reject) => {
      saveFile(savedata);

      window.setTimeout(() => {
        accept("undefined");
      });
    });
  }

  //path is a FilePath instance, for web this is the actual file data
  static readFile(path, mime = "") {
    if (mime === "") {
      mime = path.filename;
      let i = mime.length-1;

      while (i > 0 && mime[i] !== ".") {
        i--;
      }

      mime = mime.slice(i, mime.length).trim().toLowerCase();
      if (mime in mimeMap) {
        mime = mimeMap[mime];
      }
    }

    return new Promise((accept, reject) => {
      path.data.getFile().then((file) => {
        console.log("file!", file);

        let promise;

        if (isMimeText(mime)) {
          promise = file.text();
        } else {
          promise = file.arrayBuffer();
        }

        promise.then(data => {
          accept(data);
        });
      });
    });

    return new Promise((accept, reject) => {
      let data = path.data;

      if (isMimeText(mime)) {
        let s = '';
        data = new Uint8Array(data);

        for (let i = 0; i < data.length; i++) {
          s += String.fromCharCode(data[i]);
        }

        data = s;
      }

      accept(data);
    });
  }
}

var web_api = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getWebFilters: getWebFilters,
  platform: platform$3
});

export { AbstractCurve, Area$1 as Area, AreaFlags, AreaTypes, AreaWrangler, BaseVector, BoolProperty, BorderMask, BorderSides, Button, ButtonEventBase, COLINEAR, COLINEAR_ISECT, CSSFont, CURVE_VERSION, CanvasOverdraw, Check, Check1, ClassIdSymbol, ClosestCurveRets, ClosestModes, ColorField, ColorPicker, ColorPickerButton, ColorSchemeTypes, ColumnFrame, Constraint, Container, Context, ContextFlags, ContextOverlay, Curve1D, Curve1DProperty, Curve1DWidget, CurveConstructors, CurveFlags, CurveTypeData, CustomIcon, DataAPI, DataFlags, DataList, DataPath, DataPathError, DataPathSetOp, DataStruct, DataTypes, DegreeUnit, DoubleClickHandler, DropBox, ElementClasses, EnumKeyPair, EnumProperty, ErrorColors, EulerOrders, F32BaseVector, F64BaseVector, FEPS, FEPS_DATA, FLOAT_MAX, FLOAT_MIN, FlagProperty, FloatArrayProperty, FloatConstrinats, FloatProperty, FootUnit, HotKey, HueField, IconButton, IconCheck, IconLabel, IconManager, IconSheets, Icons, InchUnit, IntProperty, IntegerConstraints, IsMobile, KeyMap, LINECROSS, Label, LastToolPanel, ListIface, ListProperty, LockedContext, MacroClasses, MacroLink, Mat4Property, Mat4Stack, Matrix4, Matrix4UI, Menu, MenuWrangler, MeterUnit, MileUnit, MinMax, ModalTabMove, ModelInterface, Note, NoteFrame, NumProperty, NumSlider, NumSliderSimple, NumSliderSimpleBase, NumSliderWithTextBox, NumberConstraints, NumberConstraintsBase, NumberSliderBase, OldButton, Overdraw, OverlayClasses, PackFlags, PackNode, PackNodeVertex, PanelFrame, Parser, PixelUnit, PlaneOps, ProgBarNote, ProgressCircle, PropClasses, PropFlags, PropSubTypes$1 as PropSubTypes, PropTypes, Quat, QuatProperty, RadianUnit, ReportProperty, RichEditor, RichViewer, RowFrame, SQRT2, SVG_URL, SatValField, SavedToolDefaults, Screen$2 as Screen, ScreenArea, ScreenBorder, ScreenHalfEdge, ScreenVert, SimpleBox, SliderDefaults, SliderWithTextbox, Solver, SplineTemplateIcons, SplineTemplates, SquareFootUnit, StringProperty, StringSetProperty, StructFlags, TabBar, TabContainer, TabItem, TableFrame, TableRow, TangentModes, TextBox$1 as TextBox, TextBoxBase, ThemeEditor, ToolClasses, ToolFlags, ToolMacro, ToolOp, ToolOpIface, ToolPaths, ToolProperty$1 as ToolProperty, ToolPropertyCache, ToolStack, ToolTip, TreeItem, TreeView, TwoColumnFrame, UIBase$2 as UIBase, UIFlags, UndoFlags, Unit, Units, ValueButtonBase, Vec2Property, Vec3Property, Vec4Property, VecPropertyBase, Vector2, Vector3, Vector4, VectorPanel, VectorPopupButton, _NumberPropertyBase, _ensureFont, _getFont, _getFont_new, _old_isect_ray_plane, _onEventsStart, _onEventsStop, _setAreaClass, _setModalAreaClass, _setScreenClass, _setTextboxClass, _themeUpdateKey, aabb_intersect_2d, aabb_intersect_3d, aabb_isect_2d, aabb_isect_3d, aabb_isect_cylinder_3d, aabb_isect_line_2d, aabb_isect_line_3d, aabb_overlap_area, aabb_sphere_dist, aabb_sphere_isect, aabb_sphere_isect_2d, aabb_union, aabb_union_2d, areaclasses, barycentric_v2, buildParser, buildString, buildToolSysAPI, calcThemeKey, calc_projection_axes, cconst$1 as cconst, checkForTextBox, circ_from_line_tan, circ_from_line_tan_2d, clip_line_w, closestPoint, closest_point_on_line, closest_point_on_quad, closest_point_on_tri, cmyk_to_rgb, colinear, color2css$2 as color2css, color2web, compatMap, config$1 as config, contextWrangler, controller, convert, convex_quad, copyEvent, corner_normal, createMenu, css2color$1 as css2color, customHandlers, customPropertyTypes, defaultDecimalPlaces, defaultRadix, dihedral_v3_sqr, dist_to_line, dist_to_line_2d, dist_to_line_sqr, dist_to_tri_v3, dist_to_tri_v3_old, dist_to_tri_v3_sqr, domEventAttrs, domTransferAttrs, dpistack, drawRoundBox, drawRoundBox2, drawText, electron_api$1 as electron_api, error, evalHermiteTable, eventWasTouch, excludedKeys, expand_line, expand_rect2d, exportTheme, feps, flagThemeUpdate, genHermiteTable, gen_circle, getAreaIntName, getCurve, getDataPathToolOp, getDefault, getFieldImage, getFont, getHueField, getIconManager, getLastToolStruct, getNoteFrames, getPlatformAsync, getTagPrefix, getTempProp, getVecClass, getWranglerScreen, get_boundary_winding, get_rect_lines, get_rect_points, get_tri_circ, graphGetIslands, graphPack, haveModal, hsv_to_rgb, html5_fileapi, iconSheetFromPackFlag, iconmanager, initPage, initSimpleController, initToolPaths, inrect_2d, inv_sample, invertTheme, isLeftClick, isMouseDown, isNum, isNumber, isVecProperty, isect_ray_plane, keymap, keymap_latin_1, line_isect, line_line_cross, line_line_isect, loadFile, loadPage, loadUIData, makeCircleMesh, makeIconDiv, marginPaddingCSSKeys, math, measureText, measureTextBlock, menuWrangler, mesh_find_tangent, message, minmax_verts, modalstack, mySafeJSONParse$1 as mySafeJSONParse, mySafeJSONStringify$1 as mySafeJSONStringify, normal_poly, normal_quad, normal_quad_old, normal_tri, noteframes, nstructjs$1 as nstructjs, parseToolPath, parseValue, parseValueIntern, parseXML, parsepx$1 as parsepx, parseutil, pathDebugEvent, pathParser, platform$2 as platform, point_in_aabb, point_in_aabb_2d, point_in_hex, point_in_tri, popModalLight, popReportName, progbarNote, project, purgeUpdateStack, pushModalLight, pushPointerModal, pushReportName, quad_bilinear, registerTool, registerToolStackGetter$1 as registerToolStackGetter, report$1 as report, reverse_keymap, rgb_to_cmyk, rgb_to_hsv, rot2d, sample, saveFile, saveUIData, sendNote, setAreaTypes, setBaseUnit, setColorSchemeType, setContextClass, setDataPathToolOp, setDefaultUndoHandlers, setIconManager, setIconMap, setImplementationClass, setKeyboardDom, setKeyboardOpts, setMetric, setNotifier, setPropTypes, setScreenClass$1 as setScreenClass, setTagPrefix, setTheme, setWranglerScreen, simple, simple_tri_aabb_isect, singleMouseEvent, sliderDomAttributes, solver, startEvents, startMenu, startMenuEventWrangling, stopEvents, styleScrollBars, tab_idgen, test, testToolParser, tet_volume, theme, toolprop_abstract, tri_angles, tri_area, trilinear_co, trilinear_co2, trilinear_v3, unproject, util, validateCSSColor$1 as validateCSSColor, validateWebColor, vectormath, warning, web2color, winding, winding_axis };
//# sourceMappingURL=pathux.js.map
