<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../../">
  <title data-ice="title">scripts/lib/tinymce/themes/silver/theme.js | path.ux</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="this is awesome library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="path.ux"><meta property="twitter:description" content="this is awesome library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/joeedh/path.ux.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setIconMap">setIconMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Icons">Icons</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cconst">cconst</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-electron_api">electron_api</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-html5_fileapi">html5_fileapi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-math">math</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-parseutil">parseutil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-solver">solver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-toolprop_abstract">toolprop_abstract</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-util">util</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-vectormath">vectormath</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#config">config</a><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-exports">exports</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#controller">controller</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/context.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/context.js~ContextOverlay.html">ContextOverlay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/context.js~LockedContext.html">LockedContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/controller.js~DataPathError.html">DataPathError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/controller.js~ListIface.html">ListIface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/controller.js~ModelInterface.html">ModelInterface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/controller.js~ToolOpIface.html">ToolOpIface</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/controller_ops.js~DataPathSetOp.html">DataPathSetOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/simple_controller.js~DataAPI.html">DataAPI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/simple_controller.js~DataList.html">DataList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/simple_controller.js~DataPath.html">DataPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/controller/simple_controller.js~DataStruct.html">DataStruct</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-test">test</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getVecClass">getVecClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isVecProperty">isVecProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registerTool">registerTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setImplementationClass">setImplementationClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getDataPathToolOp">getDataPathToolOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initSimpleController">initSimpleController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-popReportName">popReportName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pushReportName">pushReportName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registerTool">registerTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setDataPathToolOp">setDataPathToolOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ContextFlags">ContextFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OverlayClasses">OverlayClasses</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-excludedKeys">excludedKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataFlags">DataFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataTypes">DataTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-StructFlags">StructFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pathParser">pathParser</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~AbstractCommand.html">AbstractCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~AnimManager.html">AnimManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~Animator.html">Animator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~Command.html">Command</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~GoToCommand.html">GoToCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~SetCommand.html">SetCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/anim.js~WaitCommand.html">WaitCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/aspect.js~AfterAspect.html">AfterAspect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/safeobservable.js~AbstractObservable.html">AbstractObservable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/safeobservable.js~Observable.html">Observable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/safeobservable.js~ObserveManger.html">ObserveManger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui.js~ColumnFrame.html">ColumnFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui.js~Container.html">Container</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui.js~Label.html">Label</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui.js~RowFrame.html">RowFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui_base.js~IconManager.html">IconManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui_base.js~UIBase.html">UIBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/ui_theme.js~CSSFont.html">CSSFont</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~DegreeUnit.html">DegreeUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~FootUnit.html">FootUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~InchUnit.html">InchUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~MeterUnit.html">MeterUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~MileUnit.html">MileUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~RadianUnit.html">RadianUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/core/units.js~Unit.html">Unit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_setUIBase">_setUIBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initAspectClass">initAspectClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-IsMobile">IsMobile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_ensureFont">_ensureFont</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_getFont">_getFont</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_getFont_new">_getFont_new</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_setAreaClass">_setAreaClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-drawRoundBox">drawRoundBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-drawRoundBox2">drawRoundBox2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-drawText">drawText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getDefault">getDefault</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFont">getFont</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getIconManager">getIconManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadUIData">loadUIData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeIconDiv">makeIconDiv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-measureText">measureText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-measureTextBlock">measureTextBlock</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-report">report</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-saveUIData">saveUIData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setIconManager">setIconManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setTheme">setTheme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-styleScrollBars">styleScrollBars</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-color2css">color2css</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-color2web">color2web</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-css2color">css2color</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-exportTheme">exportTheme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-invertTheme">invertTheme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parsepx">parsepx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setColorSchemeType">setColorSchemeType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateWebColor">validateWebColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-web2color">web2color</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildString">buildString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convert">convert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseValue">parseValue</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setBaseUnit">setBaseUnit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setMetric">setMetric</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-manager">manager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UIBase">UIBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-manager">manager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DefaultTheme">DefaultTheme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataPathError">DataPathError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EnumProperty">EnumProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Vector2">Vector2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ErrorColors">ErrorColors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IconSheets">IconSheets</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PackFlags">PackFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UIFlags">UIFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Vector4">Vector4</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dpistack">dpistack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-iconmanager">iconmanager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-marginPaddingCSSKeys">marginPaddingCSSKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ColorSchemeTypes">ColorSchemeTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-theme">theme</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Units">Units</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#curve">curve</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d.js~Curve1D.html">Curve1D</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~BounceCurve.html">BounceCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~EaseCurve.html">EaseCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~ElasticCurve.html">ElasticCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~ParamKey.html">ParamKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~RandCurve.html">RandCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_anim.js~SimpleCurveBase.html">SimpleCurveBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_base.js~CurveTypeData.html">CurveTypeData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/curve/curve1d_bspline.js~Curve1DPoint.html">Curve1DPoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mySafeJSONParse">mySafeJSONParse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mySafeJSONStringify">mySafeJSONStringify</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getCurve">getCurve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-binomial">binomial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mySafeJSONParse">mySafeJSONParse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mySafeJSONStringify">mySafeJSONStringify</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeGenEnum">makeGenEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Ease">Ease</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CURVE_VERSION">CURVE_VERSION</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CurveConstructors">CurveConstructors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CurveFlags">CurveFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TangentModes">TangentModes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#docbrowser">docbrowser</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~DocHistory.html">DocHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~DocHistoryItem.html">DocHistoryItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~DocsAPI.html">DocsAPI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~DocsBrowser.html">DocsBrowser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~ElectronAPI.html">ElectronAPI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~SavedDocument.html">SavedDocument</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/docbrowser/docbrowser.js~ServerAPI.html">ServerAPI</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#platforms-electron">platforms/electron</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildElectronHotkey">buildElectronHotkey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildElectronMenu">buildElectronMenu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-checkInit">checkInit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getNativeIcon">getNativeIcon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initMenuBar">initMenuBar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-iconcache">iconcache</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#screen">screen</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/AreaDocker.js~AreaDocker.html">AreaDocker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager.js~Screen.html">Screen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_mesh.js~ScreenBorder.html">ScreenBorder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_mesh.js~ScreenHalfEdge.html">ScreenHalfEdge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_mesh.js~ScreenVert.html">ScreenVert</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_ops.js~AreaDragTool.html">AreaDragTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_ops.js~AreaResizeTool.html">AreaResizeTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_ops.js~SplitTool.html">SplitTool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_ops.js~ToolBase.html">ToolBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/FrameManager_ops.js~ToolTipViewer.html">ToolTipViewer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/ScreenArea.js~Area.html">Area</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/ScreenArea.js~ScreenArea.html">ScreenArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/screen/area_wrangler.js~AreaWrangler.html">AreaWrangler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registerToolStackGetter">registerToolStackGetter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-startEvents">startEvents</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-snap">snap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-snapi">snapi</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registerToolStackGetter">registerToolStackGetter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAreaIntName">getAreaIntName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setAreaTypes">setAreaTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setScreenClass">setScreenClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SnapLimit">SnapLimit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AreaFlags">AreaFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BorderMask">BorderMask</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BorderSides">BorderSides</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AreaTypes">AreaTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-areaclasses">areaclasses</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#toolsys">toolsys</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/simple_toolsys.js~ToolMacro.html">ToolMacro</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/simple_toolsys.js~ToolOp.html">ToolOp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/simple_toolsys.js~ToolStack.html">ToolStack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~BoolProperty.html">BoolProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~Curve1DProperty.html">Curve1DProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~EnumProperty.html">EnumProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~FlagProperty.html">FlagProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~FloatProperty.html">FloatProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~IntProperty.html">IntProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~ListProperty.html">ListProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~Mat4Property.html">Mat4Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~NumProperty.html">NumProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~QuatProperty.html">QuatProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~StringProperty.html">StringProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~StringSetProperty.html">StringSetProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~ToolProperty.html">ToolProperty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~Vec2Property.html">Vec2Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~Vec3Property.html">Vec3Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~Vec4Property.html">Vec4Property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~VecPropertyBase.html">VecPropertyBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop.js~_NumberPropertyBase.html">_NumberPropertyBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~Curve1DPropertyIF.html">Curve1DPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~EnumPropertyIF.html">EnumPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~FlagPropertyIF.html">FlagPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~FloatPropertyIF.html">FloatPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~IntPropertyIF.html">IntPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~ListPropertyIF.html">ListPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~NumPropertyIF.html">NumPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~StringPropertyIF.html">StringPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~StringSetPropertyIF.html">StringSetPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~ToolPropertyIF.html">ToolPropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~Vec2PropertyIF.html">Vec2PropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~Vec3PropertyIF.html">Vec3PropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/toolsys/toolprop_abstract.js~Vec4PropertyIF.html">Vec4PropertyIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setContextClass">setContextClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildParser">buildParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-initToolPaths">initToolPaths</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseToolPath">parseToolPath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-testToolParser">testToolParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNumber">isNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setPropTypes">setPropTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ToolClasses">ToolClasses</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ToolFlags">ToolFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-UndoFlags">UndoFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Parser">Parser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ToolPaths">ToolPaths</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropClasses">PropClasses</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropSubTypes">PropSubTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-customPropertyTypes">customPropertyTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropFlags">PropFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropSubTypes">PropSubTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PropTypes">PropTypes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#util">util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/ScreenOverdraw.js~Overdraw.html">Overdraw</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/events.js~EventDispatcher.html">EventDispatcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/events.js~EventHandler.html">EventHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/expr.js~Node.html">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/graphpack.js~PackNode.html">PackNode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/graphpack.js~PackNodeVertex.html">PackNodeVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/math.js~Mat4Stack.html">Mat4Stack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/math.js~MinMax.html">MinMax</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/math.js~PlaneOps.html">PlaneOps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/parseutil.js~PUTLParseError.html">PUTLParseError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/parseutil.js~lexer.html">lexer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/parseutil.js~parser.html">parser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/parseutil.js~tokdef.html">tokdef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/parseutil.js~token.html">token</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/simple_events.js~DoubleClickHandler.html">DoubleClickHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/simple_events.js~HotKey.html">HotKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/simple_events.js~KeyMap.html">KeyMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/solver.js~Constraint.html">Constraint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/solver.js~Solver.html">Solver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~FastHash.html">FastHash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~HashDigest.html">HashDigest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~HashIter.html">HashIter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~IDGen.html">IDGen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~ImageReader.html">ImageReader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~MersenneRandom.html">MersenneRandom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~MovingAvg.html">MovingAvg</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~SetIter.html">SetIter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~SmartConsole.html">SmartConsole</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~SmartConsoleContext.html">SmartConsoleContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~cachering.html">cachering</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~hashtable.html">hashtable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/util.js~set.html">set</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~BaseVector.html">BaseVector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~Matrix4.html">Matrix4</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~Quat.html">Quat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~Vector2.html">Vector2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~Vector3.html">Vector3</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/util/vectormath.js~Vector4.html">Vector4</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hsv_to_rgb">hsv_to_rgb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rgb_to_hsv">rgb_to_hsv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-css2matrix">css2matrix</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-matrix2css">matrix2css</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-copyMouseEvent">copyMouseEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isModalHead">isModalHead</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pushModal">pushModal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseExpr">parseExpr</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-graphGetIslands">graphGetIslands</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-graphPack">graphPack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadFile">loadFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-saveFile">saveFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getImageData">getImageData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadImageFile">loadImageFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_old_isect_ray_plane">_old_isect_ray_plane</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_intersect_2d">aabb_intersect_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_isect_2d">aabb_isect_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_isect_line_2d">aabb_isect_line_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_overlap_area">aabb_overlap_area</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_sphere_isect">aabb_sphere_isect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_sphere_isect_2d">aabb_sphere_isect_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-aabb_union_2d">aabb_union_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-circ_from_line_tan">circ_from_line_tan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-clip_line_w">clip_line_w</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-closest_point_on_line">closest_point_on_line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-colinear">colinear</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convex_quad">convex_quad</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-corner_normal">corner_normal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dist_to_line">dist_to_line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dist_to_line_2d">dist_to_line_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-expand_line">expand_line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-expand_rect2d">expand_rect2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-gen_circle">gen_circle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_boundary_winding">get_boundary_winding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_rect_lines">get_rect_lines</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_rect_points">get_rect_points</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get_tri_circ">get_tri_circ</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inrect_2d">inrect_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isect_ray_plane">isect_ray_plane</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-line_isect">line_isect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-line_line_cross">line_line_cross</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-line_line_isect">line_line_isect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makeCircleMesh">makeCircleMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-mesh_find_tangent">mesh_find_tangent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-minmax_verts">minmax_verts</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-normal_quad">normal_quad</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-normal_tri">normal_tri</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-point_in_aabb">point_in_aabb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-point_in_aabb_2d">point_in_aabb_2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-point_in_tri">point_in_tri</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-project">project</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rot2d">rot2d</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-simple_tri_aabb_isect">simple_tri_aabb_isect</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unproject">unproject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-winding">winding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_setScreenClass">_setScreenClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-copyEvent">copyEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-eventWasTouch">eventWasTouch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-haveModal">haveModal</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isLeftClick">isLeftClick</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isMouseDown">isMouseDown</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pathDebugEvent">pathDebugEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-popModalLight">popModalLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pushModalLight">pushModalLight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-singleMouseEvent">singleMouseEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-register">register</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-atob">atob</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-btoa">btoa</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-color2css">color2css</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fetch_file">fetch_file</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-formatNumberUI">formatNumberUI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAllKeys">getAllKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getClassParent">getClassParent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hashjoin">hashjoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isMobile">isMobile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-list">list</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-merge">merge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-pollTimer">pollTimer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-print_stack">print_stack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-random">random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-seed">seed</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-strhash">strhash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-termColor">termColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-test_fasthash">test_fasthash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-time_ms">time_ms</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DomEventTypes">DomEventTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-modalStack">modalStack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-COLINEAR">COLINEAR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-COLINEAR_ISECT">COLINEAR_ISECT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FEPS">FEPS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FEPS_DATA">FEPS_DATA</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FLOAT_MAX">FLOAT_MAX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-FLOAT_MIN">FLOAT_MIN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LINECROSS">LINECROSS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Matrix4UI">Matrix4UI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SQRT2">SQRT2</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-feps">feps</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-keymap">keymap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-keymap_latin_1">keymap_latin_1</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-modalstack">modalstack</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-reverse_keymap">reverse_keymap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-STRUCT">STRUCT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-inherit">inherit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-manager">manager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-nstructjs">nstructjs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-setDebugMode">setDebugMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-write_scripts">write_scripts</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-console">console</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-termColorMap">termColorMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-timers">timers</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#widgets">widgets</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/dragbox.js~DragBox.html">DragBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/theme_editor.js~ThemeEditor.html">ThemeEditor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_button.js~Button.html">Button</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker.js~ColorField.html">ColorField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker.js~ColorPicker.html">ColorPicker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker.js~SimpleBox.html">SimpleBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~ColorField.html">ColorField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~ColorPicker.html">ColorPicker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~ColorPickerButton.html">ColorPickerButton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~HueField.html">HueField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~SatValField.html">SatValField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_colorpicker2.js~SimpleBox.html">SimpleBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_container.js~BuilderContainer.html">BuilderContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_container.js~BuilderRow.html">BuilderRow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_container.js~ContainerIF.html">ContainerIF</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_curvewidget.js~Curve1DWidget.html">Curve1DWidget</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_curvewidget_old.js~Curve.html">Curve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_curvewidget_old.js~CurvePoint.html">CurvePoint</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_curvewidget_old.js~CurveWidget.html">CurveWidget</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_lasttool.js~LastToolPanel.html">LastToolPanel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_menu.js~DropBox.html">DropBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_menu.js~Menu.html">Menu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_menu.js~MenuWrangler.html">MenuWrangler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_noteframe.js~Note.html">Note</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_noteframe.js~NoteFrame.html">NoteFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_noteframe.js~ProgBarNote.html">ProgBarNote</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_numsliders.js~NumSlider.html">NumSlider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_numsliders.js~NumSliderSimple.html">NumSliderSimple</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_numsliders.js~NumSliderSimpleBase.html">NumSliderSimpleBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_numsliders.js~NumSliderWithTextBox.html">NumSliderWithTextBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_numsliders.js~SliderWithTextbox.html">SliderWithTextbox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_panel.js~PanelFrame.html">PanelFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_richedit.js~RichEditor.html">RichEditor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_richedit.js~RichViewer.html">RichViewer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_table.js~TableFrame.html">TableFrame</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_table.js~TableRow.html">TableRow</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_tabs.js~ModalTabMove.html">ModalTabMove</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_tabs.js~TabBar.html">TabBar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_tabs.js~TabContainer.html">TabContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_tabs.js~TabItem.html">TabItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_textbox.js~TextBox.html">TextBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_textbox.js~TextBoxBase.html">TextBoxBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_treeview.js~TreeItem.html">TreeItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_treeview.js~TreeView.html">TreeView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~Check.html">Check</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~Check1.html">Check1</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~IconButton.html">IconButton</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~IconCheck.html">IconCheck</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~IconLabel.html">IconLabel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets.js~ValueButtonBase.html">ValueButtonBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets2.js~ToolTip.html">ToolTip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/scripts/widgets/ui_widgets2.js~VectorPanel.html">VectorPanel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFieldImage">getFieldImage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hsv_to_rgb">hsv_to_rgb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inv_sample">inv_sample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-rgb_to_hsv">rgb_to_hsv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sample">sample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFieldImage">getFieldImage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getHueField">getHueField</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inv_sample">inv_sample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sample">sample</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setRootStruct">setRootStruct</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-binomial">binomial</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-makePopupArea">makePopupArea</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createMenu">createMenu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getWranglerScreen">getWranglerScreen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setWranglerScreen">setWranglerScreen</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-startMenu">startMenu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-startMenuEventWrangling">startMenuEventWrangling</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-error">error</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getNoteFrames">getNoteFrames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-message">message</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-progbarNote">progbarNote</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sendNote">sendNote</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-warning">warning</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-checkForTextBox">checkForTextBox</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-api">api</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CurveConstructors">CurveConstructors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CurveFlags">CurveFlags</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CurveTypes">CurveTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TangentModes">TangentModes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-menuWrangler">menuWrangler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-noteframes">noteframes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DataPathError">DataPathError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-tab_idgen">tab_idgen</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">scripts/lib/tinymce/themes/silver/theme.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.3.1 (2020-05-27)
 */
(function (domGlobals) {
    &apos;use strict&apos;;

    var noop = function () {
    };
    var noarg = function (f) {
      return function () {
        return f();
      };
    };
    var compose = function (fa, fb) {
      return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fa(fb.apply(null, args));
      };
    };
    var constant = function (value) {
      return function () {
        return value;
      };
    };
    var identity = function (x) {
      return x;
    };
    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i &lt; arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }
    var not = function (f) {
      return function (t) {
        return !f(t);
      };
    };
    var die = function (msg) {
      return function () {
        throw new Error(msg);
      };
    };
    var never = constant(false);
    var always = constant(true);

    var global$1 = tinymce.util.Tools.resolve(&apos;tinymce.ThemeManager&apos;);

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i &lt; n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
          t[p] = s[p];
      if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &apos;function&apos;)
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++) {
          if (e.indexOf(p[i]) &lt; 0 &amp;&amp; Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i &lt; il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i &lt; il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j &lt; jl; j++, k++)
          r[k] = a[j];
      return r;
    }

    var none = function () {
      return NONE;
    };
    var NONE = function () {
      var eq = function (o) {
        return o.isNone();
      };
      var call = function (thunk) {
        return thunk();
      };
      var id = function (n) {
        return n;
      };
      var me = {
        fold: function (n, _s) {
          return n();
        },
        is: never,
        isSome: never,
        isNone: always,
        getOr: id,
        getOrThunk: call,
        getOrDie: function (msg) {
          throw new Error(msg || &apos;error: getOrDie called on none.&apos;);
        },
        getOrNull: constant(null),
        getOrUndefined: constant(undefined),
        or: id,
        orThunk: call,
        map: none,
        each: noop,
        bind: none,
        exists: never,
        forall: always,
        filter: none,
        equals: eq,
        equals_: eq,
        toArray: function () {
          return [];
        },
        toString: constant(&apos;none()&apos;)
      };
      return me;
    }();
    var some = function (a) {
      var constant_a = constant(a);
      var self = function () {
        return me;
      };
      var bind = function (f) {
        return f(a);
      };
      var me = {
        fold: function (n, s) {
          return s(a);
        },
        is: function (v) {
          return a === v;
        },
        isSome: always,
        isNone: never,
        getOr: constant_a,
        getOrThunk: constant_a,
        getOrDie: constant_a,
        getOrNull: constant_a,
        getOrUndefined: constant_a,
        or: self,
        orThunk: self,
        map: function (f) {
          return some(f(a));
        },
        each: function (f) {
          f(a);
        },
        bind: bind,
        exists: bind,
        forall: bind,
        filter: function (f) {
          return f(a) ? me : NONE;
        },
        toArray: function () {
          return [a];
        },
        toString: function () {
          return &apos;some(&apos; + a + &apos;)&apos;;
        },
        equals: function (o) {
          return o.is(a);
        },
        equals_: function (o, elementEq) {
          return o.fold(never, function (b) {
            return elementEq(a, b);
          });
        }
      };
      return me;
    };
    var from = function (value) {
      return value === null || value === undefined ? NONE : some(value);
    };
    var Option = {
      some: some,
      none: none,
      from: from
    };

    var value = function (o) {
      var is = function (v) {
        return o === v;
      };
      var or = function (_opt) {
        return value(o);
      };
      var orThunk = function (_f) {
        return value(o);
      };
      var map = function (f) {
        return value(f(o));
      };
      var mapError = function (_f) {
        return value(o);
      };
      var each = function (f) {
        f(o);
      };
      var bind = function (f) {
        return f(o);
      };
      var fold = function (_, onValue) {
        return onValue(o);
      };
      var exists = function (f) {
        return f(o);
      };
      var forall = function (f) {
        return f(o);
      };
      var toOption = function () {
        return Option.some(o);
      };
      return {
        is: is,
        isValue: always,
        isError: never,
        getOr: constant(o),
        getOrThunk: constant(o),
        getOrDie: constant(o),
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: each,
        bind: bind,
        exists: exists,
        forall: forall,
        toOption: toOption
      };
    };
    var error = function (message) {
      var getOrThunk = function (f) {
        return f();
      };
      var getOrDie = function () {
        return die(String(message))();
      };
      var or = function (opt) {
        return opt;
      };
      var orThunk = function (f) {
        return f();
      };
      var map = function (_f) {
        return error(message);
      };
      var mapError = function (f) {
        return error(f(message));
      };
      var bind = function (_f) {
        return error(message);
      };
      var fold = function (onError, _) {
        return onError(message);
      };
      return {
        is: never,
        isValue: never,
        isError: always,
        getOr: identity,
        getOrThunk: getOrThunk,
        getOrDie: getOrDie,
        or: or,
        orThunk: orThunk,
        fold: fold,
        map: map,
        mapError: mapError,
        each: noop,
        bind: bind,
        exists: never,
        forall: always,
        toOption: Option.none
      };
    };
    var fromOption = function (opt, err) {
      return opt.fold(function () {
        return error(err);
      }, value);
    };
    var Result = {
      value: value,
      error: error,
      fromOption: fromOption
    };

    var typeOf = function (x) {
      var t = typeof x;
      if (x === null) {
        return &apos;null&apos;;
      } else if (t === &apos;object&apos; &amp;&amp; (Array.prototype.isPrototypeOf(x) || x.constructor &amp;&amp; x.constructor.name === &apos;Array&apos;)) {
        return &apos;array&apos;;
      } else if (t === &apos;object&apos; &amp;&amp; (String.prototype.isPrototypeOf(x) || x.constructor &amp;&amp; x.constructor.name === &apos;String&apos;)) {
        return &apos;string&apos;;
      } else {
        return t;
      }
    };
    var isType = function (type) {
      return function (value) {
        return typeOf(value) === type;
      };
    };
    var isSimpleType = function (type) {
      return function (value) {
        return typeof value === type;
      };
    };
    var eq = function (t) {
      return function (a) {
        return t === a;
      };
    };
    var isString = isType(&apos;string&apos;);
    var isObject = isType(&apos;object&apos;);
    var isArray = isType(&apos;array&apos;);
    var isBoolean = isSimpleType(&apos;boolean&apos;);
    var isUndefined = eq(undefined);
    var isFunction = isSimpleType(&apos;function&apos;);
    var isNumber = isSimpleType(&apos;number&apos;);
    var isArrayOf = function (value, pred) {
      if (isArray(value)) {
        for (var i = 0, len = value.length; i &lt; len; ++i) {
          if (!pred(value[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };

    var nativeSlice = Array.prototype.slice;
    var nativeIndexOf = Array.prototype.indexOf;
    var nativePush = Array.prototype.push;
    var rawIndexOf = function (ts, t) {
      return nativeIndexOf.call(ts, t);
    };
    var indexOf = function (xs, x) {
      var r = rawIndexOf(xs, x);
      return r === -1 ? Option.none() : Option.some(r);
    };
    var contains = function (xs, x) {
      return rawIndexOf(xs, x) &gt; -1;
    };
    var exists = function (xs, pred) {
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    var range = function (num, f) {
      var r = [];
      for (var i = 0; i &lt; num; i++) {
        r.push(f(i));
      }
      return r;
    };
    var chunk = function (array, size) {
      var r = [];
      for (var i = 0; i &lt; array.length; i += size) {
        var s = nativeSlice.call(array, i, i + size);
        r.push(s);
      }
      return r;
    };
    var map = function (xs, f) {
      var len = xs.length;
      var r = new Array(len);
      for (var i = 0; i &lt; len; i++) {
        var x = xs[i];
        r[i] = f(x, i);
      }
      return r;
    };
    var each = function (xs, f) {
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        f(x, i);
      }
    };
    var eachr = function (xs, f) {
      for (var i = xs.length - 1; i &gt;= 0; i--) {
        var x = xs[i];
        f(x, i);
      }
    };
    var partition = function (xs, pred) {
      var pass = [];
      var fail = [];
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        var arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass: pass,
        fail: fail
      };
    };
    var filter = function (xs, pred) {
      var r = [];
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          r.push(x);
        }
      }
      return r;
    };
    var foldr = function (xs, f, acc) {
      eachr(xs, function (x) {
        acc = f(acc, x);
      });
      return acc;
    };
    var foldl = function (xs, f, acc) {
      each(xs, function (x) {
        acc = f(acc, x);
      });
      return acc;
    };
    var findUntil = function (xs, pred, until) {
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Option.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Option.none();
    };
    var find = function (xs, pred) {
      return findUntil(xs, pred, never);
    };
    var findIndex = function (xs, pred) {
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        if (pred(x, i)) {
          return Option.some(i);
        }
      }
      return Option.none();
    };
    var flatten = function (xs) {
      var r = [];
      for (var i = 0, len = xs.length; i &lt; len; ++i) {
        if (!isArray(xs[i])) {
          throw new Error(&apos;Arr.flatten item &apos; + i + &apos; was not an array, input: &apos; + xs);
        }
        nativePush.apply(r, xs[i]);
      }
      return r;
    };
    var bind = function (xs, f) {
      return flatten(map(xs, f));
    };
    var forall = function (xs, pred) {
      for (var i = 0, len = xs.length; i &lt; len; ++i) {
        var x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    var reverse = function (xs) {
      var r = nativeSlice.call(xs, 0);
      r.reverse();
      return r;
    };
    var difference = function (a1, a2) {
      return filter(a1, function (x) {
        return !contains(a2, x);
      });
    };
    var mapToObject = function (xs, f) {
      var r = {};
      for (var i = 0, len = xs.length; i &lt; len; i++) {
        var x = xs[i];
        r[String(x)] = f(x, i);
      }
      return r;
    };
    var pure = function (x) {
      return [x];
    };
    var sort = function (xs, comparator) {
      var copy = nativeSlice.call(xs, 0);
      copy.sort(comparator);
      return copy;
    };
    var head = function (xs) {
      return xs.length === 0 ? Option.none() : Option.some(xs[0]);
    };
    var last = function (xs) {
      return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
    };
    var from$1 = isFunction(Array.from) ? Array.from : function (x) {
      return nativeSlice.call(x);
    };
    var findMap = function (arr, f) {
      for (var i = 0; i &lt; arr.length; i++) {
        var r = f(arr[i], i);
        if (r.isSome()) {
          return r;
        }
      }
      return Option.none();
    };

    var keys = Object.keys;
    var hasOwnProperty = Object.hasOwnProperty;
    var each$1 = function (obj, f) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k &lt; len; k++) {
        var i = props[k];
        var x = obj[i];
        f(x, i);
      }
    };
    var map$1 = function (obj, f) {
      return tupleMap(obj, function (x, i) {
        return {
          k: i,
          v: f(x, i)
        };
      });
    };
    var tupleMap = function (obj, f) {
      var r = {};
      each$1(obj, function (x, i) {
        var tuple = f(x, i);
        r[tuple.k] = tuple.v;
      });
      return r;
    };
    var objAcc = function (r) {
      return function (x, i) {
        r[i] = x;
      };
    };
    var internalFilter = function (obj, pred, onTrue, onFalse) {
      var r = {};
      each$1(obj, function (x, i) {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
      return r;
    };
    var filter$1 = function (obj, pred) {
      var t = {};
      internalFilter(obj, pred, objAcc(t), noop);
      return t;
    };
    var mapToArray = function (obj, f) {
      var r = [];
      each$1(obj, function (value, name) {
        r.push(f(value, name));
      });
      return r;
    };
    var find$1 = function (obj, pred) {
      var props = keys(obj);
      for (var k = 0, len = props.length; k &lt; len; k++) {
        var i = props[k];
        var x = obj[i];
        if (pred(x, i, obj)) {
          return Option.some(x);
        }
      }
      return Option.none();
    };
    var values = function (obj) {
      return mapToArray(obj, function (v) {
        return v;
      });
    };
    var get = function (obj, key) {
      return has(obj, key) ? Option.from(obj[key]) : Option.none();
    };
    var has = function (obj, key) {
      return hasOwnProperty.call(obj, key);
    };
    var hasNonNullableKey = function (obj, key) {
      return has(obj, key) &amp;&amp; obj[key] !== undefined &amp;&amp; obj[key] !== null;
    };

    var generate = function (cases) {
      if (!isArray(cases)) {
        throw new Error(&apos;cases must be an array&apos;);
      }
      if (cases.length === 0) {
        throw new Error(&apos;there must be at least one case&apos;);
      }
      var constructors = [];
      var adt = {};
      each(cases, function (acase, count) {
        var keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error(&apos;one and only one name per case&apos;);
        }
        var key = keys$1[0];
        var value = acase[key];
        if (adt[key] !== undefined) {
          throw new Error(&apos;duplicate key detected:&apos; + key);
        } else if (key === &apos;cata&apos;) {
          throw new Error(&apos;cannot have a case named cata (sorry)&apos;);
        } else if (!isArray(value)) {
          throw new Error(&apos;case arguments must be an array&apos;);
        }
        constructors.push(key);
        adt[key] = function () {
          var argLength = arguments.length;
          if (argLength !== value.length) {
            throw new Error(&apos;Wrong number of arguments to case &apos; + key + &apos;. Expected &apos; + value.length + &apos; (&apos; + value + &apos;), got &apos; + argLength);
          }
          var args = new Array(argLength);
          for (var i = 0; i &lt; args.length; i++) {
            args[i] = arguments[i];
          }
          var match = function (branches) {
            var branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error(&apos;Wrong number of arguments to match. Expected: &apos; + constructors.join(&apos;,&apos;) + &apos;\nActual: &apos; + branchKeys.join(&apos;,&apos;));
            }
            var allReqd = forall(constructors, function (reqKey) {
              return contains(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error(&apos;Not all branches were specified when using match. Specified: &apos; + branchKeys.join(&apos;, &apos;) + &apos;\nRequired: &apos; + constructors.join(&apos;, &apos;));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: function () {
              if (arguments.length !== cases.length) {
                throw new Error(&apos;Wrong number of arguments to fold. Expected &apos; + cases.length + &apos;, got &apos; + arguments.length);
              }
              var target = arguments[count];
              return target.apply(null, args);
            },
            match: match,
            log: function (label) {
              domGlobals.console.log(label, {
                constructors: constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt;
    };
    var Adt = { generate: generate };

    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var shallow = function (old, nu) {
      return nu;
    };
    var deep = function (old, nu) {
      var bothObjects = isObject(old) &amp;&amp; isObject(nu);
      return bothObjects ? deepMerge(old, nu) : nu;
    };
    var baseMerge = function (merger) {
      return function () {
        var objects = new Array(arguments.length);
        for (var i = 0; i &lt; objects.length; i++) {
          objects[i] = arguments[i];
        }
        if (objects.length === 0) {
          throw new Error(&apos;Can\&apos;t merge zero objects&apos;);
        }
        var ret = {};
        for (var j = 0; j &lt; objects.length; j++) {
          var curObject = objects[j];
          for (var key in curObject) {
            if (hasOwnProperty$1.call(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    var deepMerge = baseMerge(deep);
    var merge = baseMerge(shallow);

    var cached = function (f) {
      var called = false;
      var r;
      return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!called) {
          called = true;
          r = f.apply(null, args);
        }
        return r;
      };
    };

    var SimpleResultType;
    (function (SimpleResultType) {
      SimpleResultType[SimpleResultType[&apos;Error&apos;] = 0] = &apos;Error&apos;;
      SimpleResultType[SimpleResultType[&apos;Value&apos;] = 1] = &apos;Value&apos;;
    }(SimpleResultType || (SimpleResultType = {})));
    var fold = function (res, onError, onValue) {
      return res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
    };
    var partition$1 = function (results) {
      var values = [];
      var errors = [];
      each(results, function (obj) {
        fold(obj, function (err) {
          return errors.push(err);
        }, function (val) {
          return values.push(val);
        });
      });
      return {
        values: values,
        errors: errors
      };
    };
    var mapError = function (res, f) {
      if (res.stype === SimpleResultType.Error) {
        return {
          stype: SimpleResultType.Error,
          serror: f(res.serror)
        };
      } else {
        return res;
      }
    };
    var map$2 = function (res, f) {
      if (res.stype === SimpleResultType.Value) {
        return {
          stype: SimpleResultType.Value,
          svalue: f(res.svalue)
        };
      } else {
        return res;
      }
    };
    var bind$1 = function (res, f) {
      if (res.stype === SimpleResultType.Value) {
        return f(res.svalue);
      } else {
        return res;
      }
    };
    var bindError = function (res, f) {
      if (res.stype === SimpleResultType.Error) {
        return f(res.serror);
      } else {
        return res;
      }
    };
    var svalue = function (v) {
      return {
        stype: SimpleResultType.Value,
        svalue: v
      };
    };
    var serror = function (e) {
      return {
        stype: SimpleResultType.Error,
        serror: e
      };
    };
    var toResult = function (res) {
      return fold(res, Result.error, Result.value);
    };
    var fromResult = function (res) {
      return res.fold(serror, svalue);
    };
    var SimpleResult = {
      fromResult: fromResult,
      toResult: toResult,
      svalue: svalue,
      partition: partition$1,
      serror: serror,
      bind: bind$1,
      bindError: bindError,
      map: map$2,
      mapError: mapError,
      fold: fold
    };

    var adt = Adt.generate([
      { strict: [] },
      { defaultedThunk: [&apos;fallbackThunk&apos;] },
      { asOption: [] },
      { asDefaultedOptionThunk: [&apos;fallbackThunk&apos;] },
      { mergeWithThunk: [&apos;baseThunk&apos;] }
    ]);
    var defaulted = function (fallback) {
      return adt.defaultedThunk(constant(fallback));
    };
    var mergeWith = function (base) {
      return adt.mergeWithThunk(constant(base));
    };
    var strict = adt.strict;
    var asOption = adt.asOption;
    var defaultedThunk = adt.defaultedThunk;
    var asDefaultedOptionThunk = adt.asDefaultedOptionThunk;
    var mergeWithThunk = adt.mergeWithThunk;

    var exclude = function (obj, fields) {
      var r = {};
      each$1(obj, function (v, k) {
        if (!contains(fields, k)) {
          r[k] = v;
        }
      });
      return r;
    };

    var wrap = function (key, value) {
      var _a;
      return _a = {}, _a[key] = value, _a;
    };
    var wrapAll = function (keyvalues) {
      var r = {};
      each(keyvalues, function (kv) {
        r[kv.key] = kv.value;
      });
      return r;
    };

    var comparison = Adt.generate([
      {
        bothErrors: [
          &apos;error1&apos;,
          &apos;error2&apos;
        ]
      },
      {
        firstError: [
          &apos;error1&apos;,
          &apos;value2&apos;
        ]
      },
      {
        secondError: [
          &apos;value1&apos;,
          &apos;error2&apos;
        ]
      },
      {
        bothValues: [
          &apos;value1&apos;,
          &apos;value2&apos;
        ]
      }
    ]);
    var partition$2 = function (results) {
      var errors = [];
      var values = [];
      each(results, function (result) {
        result.fold(function (err) {
          errors.push(err);
        }, function (value) {
          values.push(value);
        });
      });
      return {
        errors: errors,
        values: values
      };
    };

    var exclude$1 = function (obj, fields) {
      return exclude(obj, fields);
    };
    var wrap$1 = function (key, value) {
      return wrap(key, value);
    };
    var wrapAll$1 = function (keyvalues) {
      return wrapAll(keyvalues);
    };
    var mergeValues = function (values, base) {
      return values.length === 0 ? Result.value(base) : Result.value(deepMerge(base, merge.apply(undefined, values)));
    };
    var mergeErrors = function (errors) {
      return Result.error(flatten(errors));
    };
    var consolidate = function (objs, base) {
      var partitions = partition$2(objs);
      return partitions.errors.length &gt; 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base);
    };

    var mergeValues$1 = function (values, base) {
      return values.length &gt; 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);
    };
    var mergeErrors$1 = function (errors) {
      return compose(SimpleResult.serror, flatten)(errors);
    };
    var consolidateObj = function (objects, base) {
      var partition = SimpleResult.partition(objects);
      return partition.errors.length &gt; 0 ? mergeErrors$1(partition.errors) : mergeValues$1(partition.values, base);
    };
    var consolidateArr = function (objects) {
      var partitions = SimpleResult.partition(objects);
      return partitions.errors.length &gt; 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    var ResultCombine = {
      consolidateObj: consolidateObj,
      consolidateArr: consolidateArr
    };

    var formatObj = function (input) {
      return isObject(input) &amp;&amp; keys(input).length &gt; 100 ? &apos; removed due to size&apos; : JSON.stringify(input, null, 2);
    };
    var formatErrors = function (errors) {
      var es = errors.length &gt; 10 ? errors.slice(0, 10).concat([{
          path: [],
          getErrorInfo: function () {
            return &apos;... (only showing first ten failures)&apos;;
          }
        }]) : errors;
      return map(es, function (e) {
        return &apos;Failed path: (&apos; + e.path.join(&apos; &gt; &apos;) + &apos;)\n&apos; + e.getErrorInfo();
      });
    };

    var nu = function (path, getErrorInfo) {
      return SimpleResult.serror([{
          path: path,
          getErrorInfo: getErrorInfo
        }]);
    };
    var missingStrict = function (path, key, obj) {
      return nu(path, function () {
        return &apos;Could not find valid *strict* value for &quot;&apos; + key + &apos;&quot; in &apos; + formatObj(obj);
      });
    };
    var missingKey = function (path, key) {
      return nu(path, function () {
        return &apos;Choice schema did not contain choice key: &quot;&apos; + key + &apos;&quot;&apos;;
      });
    };
    var missingBranch = function (path, branches, branch) {
      return nu(path, function () {
        return &apos;The chosen schema: &quot;&apos; + branch + &apos;&quot; did not exist in branches: &apos; + formatObj(branches);
      });
    };
    var unsupportedFields = function (path, unsupported) {
      return nu(path, function () {
        return &apos;There are unsupported fields: [&apos; + unsupported.join(&apos;, &apos;) + &apos;] specified&apos;;
      });
    };
    var custom = function (path, err) {
      return nu(path, function () {
        return err;
      });
    };

    var adt$1 = Adt.generate([
      {
        field: [
          &apos;key&apos;,
          &apos;okey&apos;,
          &apos;presence&apos;,
          &apos;prop&apos;
        ]
      },
      {
        state: [
          &apos;okey&apos;,
          &apos;instantiator&apos;
        ]
      }
    ]);
    var strictAccess = function (path, obj, key) {
      return get(obj, key).fold(function () {
        return missingStrict(path, key, obj);
      }, SimpleResult.svalue);
    };
    var fallbackAccess = function (obj, key, fallbackThunk) {
      var v = get(obj, key).fold(function () {
        return fallbackThunk(obj);
      }, identity);
      return SimpleResult.svalue(v);
    };
    var optionAccess = function (obj, key) {
      return SimpleResult.svalue(get(obj, key));
    };
    var optionDefaultedAccess = function (obj, key, fallback) {
      var opt = get(obj, key).map(function (val) {
        return val === true ? fallback(obj) : val;
      });
      return SimpleResult.svalue(opt);
    };
    var cExtractOne = function (path, obj, field, strength) {
      return field.fold(function (key, okey, presence, prop) {
        var bundle = function (av) {
          var result = prop.extract(path.concat([key]), strength, av);
          return SimpleResult.map(result, function (res) {
            return wrap(okey, strength(res));
          });
        };
        var bundleAsOption = function (optValue) {
          return optValue.fold(function () {
            var outcome = wrap(okey, strength(Option.none()));
            return SimpleResult.svalue(outcome);
          }, function (ov) {
            var result = prop.extract(path.concat([key]), strength, ov);
            return SimpleResult.map(result, function (res) {
              return wrap(okey, strength(Option.some(res)));
            });
          });
        };
        return function () {
          return presence.fold(function () {
            return SimpleResult.bind(strictAccess(path, obj, key), bundle);
          }, function (fallbackThunk) {
            return SimpleResult.bind(fallbackAccess(obj, key, fallbackThunk), bundle);
          }, function () {
            return SimpleResult.bind(optionAccess(obj, key), bundleAsOption);
          }, function (fallbackThunk) {
            return SimpleResult.bind(optionDefaultedAccess(obj, key, fallbackThunk), bundleAsOption);
          }, function (baseThunk) {
            var base = baseThunk(obj);
            var result = SimpleResult.map(fallbackAccess(obj, key, constant({})), function (v) {
              return deepMerge(base, v);
            });
            return SimpleResult.bind(result, bundle);
          });
        }();
      }, function (okey, instantiator) {
        var state = instantiator(obj);
        return SimpleResult.svalue(wrap(okey, strength(state)));
      });
    };
    var cExtract = function (path, obj, fields, strength) {
      var results = map(fields, function (field) {
        return cExtractOne(path, obj, field, strength);
      });
      return ResultCombine.consolidateObj(results, {});
    };
    var valueThunk = function (getDelegate) {
      var extract = function (path, strength, val) {
        return getDelegate().extract(path, strength, val);
      };
      var toString = function () {
        return getDelegate().toString();
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var value$1 = function (validator) {
      var extract = function (path, strength, val) {
        return SimpleResult.bindError(validator(val, strength), function (err) {
          return custom(path, err);
        });
      };
      var toString = function () {
        return &apos;val&apos;;
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var getSetKeys = function (obj) {
      return keys(filter$1(obj, function (value) {
        return value !== undefined &amp;&amp; value !== null;
      }));
    };
    var objOfOnly = function (fields) {
      var delegate = objOf(fields);
      var fieldNames = foldr(fields, function (acc, f) {
        return f.fold(function (key) {
          return deepMerge(acc, wrap$1(key, true));
        }, constant(acc));
      }, {});
      var extract = function (path, strength, o) {
        var keys = isBoolean(o) ? [] : getSetKeys(o);
        var extra = filter(keys, function (k) {
          return !hasNonNullableKey(fieldNames, k);
        });
        return extra.length === 0 ? delegate.extract(path, strength, o) : unsupportedFields(path, extra);
      };
      return {
        extract: extract,
        toString: delegate.toString
      };
    };
    var objOf = function (fields) {
      var extract = function (path, strength, o) {
        return cExtract(path, o, fields, strength);
      };
      var toString = function () {
        var fieldStrings = map(fields, function (field) {
          return field.fold(function (key, okey, presence, prop) {
            return key + &apos; -&gt; &apos; + prop.toString();
          }, function (okey, _instantiator) {
            return &apos;state(&apos; + okey + &apos;)&apos;;
          });
        });
        return &apos;obj{\n&apos; + fieldStrings.join(&apos;\n&apos;) + &apos;}&apos;;
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var arrOf = function (prop) {
      var extract = function (path, strength, array) {
        var results = map(array, function (a, i) {
          return prop.extract(path.concat([&apos;[&apos; + i + &apos;]&apos;]), strength, a);
        });
        return ResultCombine.consolidateArr(results);
      };
      var toString = function () {
        return &apos;array(&apos; + prop.toString() + &apos;)&apos;;
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var oneOf = function (props) {
      var extract = function (path, strength, val) {
        var errors = [];
        for (var _i = 0, props_1 = props; _i &lt; props_1.length; _i++) {
          var prop = props_1[_i];
          var res = prop.extract(path, strength, val);
          if (res.stype === SimpleResultType.Value) {
            return res;
          }
          errors.push(res);
        }
        return ResultCombine.consolidateArr(errors);
      };
      var toString = function () {
        return &apos;oneOf(&apos; + map(props, function (prop) {
          return prop.toString();
        }).join(&apos;, &apos;) + &apos;)&apos;;
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var setOf = function (validator, prop) {
      var validateKeys = function (path, keys) {
        return arrOf(value$1(validator)).extract(path, identity, keys);
      };
      var extract = function (path, strength, o) {
        var keys$1 = keys(o);
        var validatedKeys = validateKeys(path, keys$1);
        return SimpleResult.bind(validatedKeys, function (validKeys) {
          var schema = map(validKeys, function (vk) {
            return adt$1.field(vk, vk, strict(), prop);
          });
          return objOf(schema).extract(path, strength, o);
        });
      };
      var toString = function () {
        return &apos;setOf(&apos; + prop.toString() + &apos;)&apos;;
      };
      return {
        extract: extract,
        toString: toString
      };
    };
    var anyValue = constant(value$1(SimpleResult.svalue));
    var arrOfObj = compose(arrOf, objOf);
    var state = adt$1.state;
    var field = adt$1.field;

    var chooseFrom = function (path, strength, input, branches, ch) {
      var fields = get(branches, ch);
      return fields.fold(function () {
        return missingBranch(path, branches, ch);
      }, function (vp) {
        return vp.extract(path.concat([&apos;branch: &apos; + ch]), strength, input);
      });
    };
    var choose = function (key, branches) {
      var extract = function (path, strength, input) {
        var choice = get(input, key);
        return choice.fold(function () {
          return missingKey(path, key);
        }, function (chosen) {
          return chooseFrom(path, strength, input, branches, chosen);
        });
      };
      var toString = function () {
        return &apos;chooseOn(&apos; + key + &apos;). Possible values: &apos; + keys(branches);
      };
      return {
        extract: extract,
        toString: toString
      };
    };

    var _anyValue = value$1(SimpleResult.svalue);
    var arrOfObj$1 = function (objFields) {
      return arrOfObj(objFields);
    };
    var arrOfVal = function () {
      return arrOf(_anyValue);
    };
    var valueThunkOf = valueThunk;
    var valueOf = function (validator) {
      return value$1(function (v) {
        return validator(v).fold(SimpleResult.serror, SimpleResult.svalue);
      });
    };
    var setOf$1 = function (validator, prop) {
      return setOf(function (v) {
        return SimpleResult.fromResult(validator(v));
      }, prop);
    };
    var extract = function (label, prop, strength, obj) {
      var res = prop.extract([label], strength, obj);
      return SimpleResult.mapError(res, function (errs) {
        return {
          input: obj,
          errors: errs
        };
      });
    };
    var asRaw = function (label, prop, obj) {
      return SimpleResult.toResult(extract(label, prop, identity, obj));
    };
    var getOrDie = function (extraction) {
      return extraction.fold(function (errInfo) {
        throw new Error(formatError(errInfo));
      }, identity);
    };
    var asRawOrDie = function (label, prop, obj) {
      return getOrDie(asRaw(label, prop, obj));
    };
    var formatError = function (errInfo) {
      return &apos;Errors: \n&apos; + formatErrors(errInfo.errors).join(&apos;\n&apos;) + &apos;\n\nInput object: &apos; + formatObj(errInfo.input);
    };
    var chooseProcessor = function (key, branches) {
      return choose(key, branches);
    };
    var choose$1 = function (key, branches) {
      return choose(key, map$1(branches, objOf));
    };
    var anyValue$1 = constant(_anyValue);
    var typedValue = function (validator, expectedType) {
      return value$1(function (a) {
        var actualType = typeof a;
        return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(&apos;Expected type: &apos; + expectedType + &apos; but got: &apos; + actualType);
      });
    };
    var number = typedValue(isNumber, &apos;number&apos;);
    var string = typedValue(isString, &apos;string&apos;);
    var boolean = typedValue(isBoolean, &apos;boolean&apos;);
    var functionProcessor = typedValue(isFunction, &apos;function&apos;);
    var isPostMessageable = function (val) {
      var every = function (iter, callbackFn) {
        var result = iter.next();
        while (!result.done) {
          if (!callbackFn(result.value)) {
            return false;
          }
          result = iter.next();
        }
        return true;
      };
      if (Object(val) !== val) {
        return true;
      }
      switch ({}.toString.call(val).slice(8, -1)) {
      case &apos;Boolean&apos;:
      case &apos;Number&apos;:
      case &apos;String&apos;:
      case &apos;Date&apos;:
      case &apos;RegExp&apos;:
      case &apos;Blob&apos;:
      case &apos;FileList&apos;:
      case &apos;ImageData&apos;:
      case &apos;ImageBitmap&apos;:
      case &apos;ArrayBuffer&apos;:
        return true;
      case &apos;Array&apos;:
      case &apos;Object&apos;:
        return Object.keys(val).every(function (prop) {
          return isPostMessageable(val[prop]);
        });
      case &apos;Map&apos;:
        return every(val.keys(), isPostMessageable) &amp;&amp; every(val.values(), isPostMessageable);
      case &apos;Set&apos;:
        return every(val.keys(), isPostMessageable);
      default:
        return false;
      }
    };
    var postMessageable = value$1(function (a) {
      return isPostMessageable(a) ? SimpleResult.svalue(a) : SimpleResult.serror(&apos;Expected value to be acceptable for sending via postMessage&apos;);
    });

    var validateEnum = function (values) {
      return valueOf(function (value) {
        return contains(values, value) ? Result.value(value) : Result.error(&apos;Unsupported value: &quot;&apos; + value + &apos;&quot;, choose one of &quot;&apos; + values.join(&apos;, &apos;) + &apos;&quot;.&apos;);
      });
    };
    var strict$1 = function (key) {
      return field(key, key, strict(), anyValue());
    };
    var strictOf = function (key, schema) {
      return field(key, key, strict(), schema);
    };
    var strictNumber = function (key) {
      return strictOf(key, number);
    };
    var strictString = function (key) {
      return strictOf(key, string);
    };
    var strictStringEnum = function (key, values) {
      return field(key, key, strict(), validateEnum(values));
    };
    var strictBoolean = function (key) {
      return strictOf(key, boolean);
    };
    var strictFunction = function (key) {
      return strictOf(key, functionProcessor);
    };
    var forbid = function (key, message) {
      return field(key, key, asOption(), value$1(function (_v) {
        return SimpleResult.serror(&apos;The field: &apos; + key + &apos; is forbidden. &apos; + message);
      }));
    };
    var strictObjOf = function (key, objSchema) {
      return field(key, key, strict(), objOf(objSchema));
    };
    var strictArrayOfObj = function (key, objFields) {
      return field(key, key, strict(), arrOfObj(objFields));
    };
    var strictArrayOf = function (key, schema) {
      return field(key, key, strict(), arrOf(schema));
    };
    var option = function (key) {
      return field(key, key, asOption(), anyValue());
    };
    var optionOf = function (key, schema) {
      return field(key, key, asOption(), schema);
    };
    var optionNumber = function (key) {
      return optionOf(key, number);
    };
    var optionString = function (key) {
      return optionOf(key, string);
    };
    var optionFunction = function (key) {
      return optionOf(key, functionProcessor);
    };
    var optionArrayOf = function (key, schema) {
      return optionOf(key, arrOf(schema));
    };
    var optionObjOf = function (key, objSchema) {
      return optionOf(key, objOf(objSchema));
    };
    var optionObjOfOnly = function (key, objSchema) {
      return optionOf(key, objOfOnly(objSchema));
    };
    var defaulted$1 = function (key, fallback) {
      return field(key, key, defaulted(fallback), anyValue());
    };
    var defaultedOf = function (key, fallback, schema) {
      return field(key, key, defaulted(fallback), schema);
    };
    var defaultedNumber = function (key, fallback) {
      return defaultedOf(key, fallback, number);
    };
    var defaultedString = function (key, fallback) {
      return defaultedOf(key, fallback, string);
    };
    var defaultedStringEnum = function (key, fallback, values) {
      return defaultedOf(key, fallback, validateEnum(values));
    };
    var defaultedBoolean = function (key, fallback) {
      return defaultedOf(key, fallback, boolean);
    };
    var defaultedFunction = function (key, fallback) {
      return defaultedOf(key, fallback, functionProcessor);
    };
    var defaultedPostMsg = function (key, fallback) {
      return defaultedOf(key, fallback, postMessageable);
    };
    var defaultedArrayOf = function (key, fallback, schema) {
      return defaultedOf(key, fallback, arrOf(schema));
    };
    var defaultedObjOf = function (key, fallback, objSchema) {
      return defaultedOf(key, fallback, objOf(objSchema));
    };
    var state$1 = function (okey, instantiator) {
      return state(okey, instantiator);
    };

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };

    var fromHtml = function (html, scope) {
      var doc = scope || domGlobals.document;
      var div = doc.createElement(&apos;div&apos;);
      div.innerHTML = html;
      if (!div.hasChildNodes() || div.childNodes.length &gt; 1) {
        domGlobals.console.error(&apos;HTML does not have a single root node&apos;, html);
        throw new Error(&apos;HTML must have a single root node&apos;);
      }
      return fromDom(div.childNodes[0]);
    };
    var fromTag = function (tag, scope) {
      var doc = scope || domGlobals.document;
      var node = doc.createElement(tag);
      return fromDom(node);
    };
    var fromText = function (text, scope) {
      var doc = scope || domGlobals.document;
      var node = doc.createTextNode(text);
      return fromDom(node);
    };
    var fromDom = function (node) {
      if (node === null || node === undefined) {
        throw new Error(&apos;Node cannot be null or undefined&apos;);
      }
      return { dom: constant(node) };
    };
    var fromPoint = function (docElm, x, y) {
      var doc = docElm.dom();
      return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
    };
    var Element = {
      fromHtml: fromHtml,
      fromTag: fromTag,
      fromText: fromText,
      fromDom: fromDom,
      fromPoint: fromPoint
    };

    var compareDocumentPosition = function (a, b, match) {
      return (a.compareDocumentPosition(b) &amp; match) !== 0;
    };
    var documentPositionContainedBy = function (a, b) {
      return compareDocumentPosition(a, b, domGlobals.Node.DOCUMENT_POSITION_CONTAINED_BY);
    };

    var firstMatch = function (regexes, s) {
      for (var i = 0; i &lt; regexes.length; i++) {
        var x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return undefined;
    };
    var find$2 = function (regexes, agent) {
      var r = firstMatch(regexes, agent);
      if (!r) {
        return {
          major: 0,
          minor: 0
        };
      }
      var group = function (i) {
        return Number(agent.replace(r, &apos;$&apos; + i));
      };
      return nu$1(group(1), group(2));
    };
    var detect = function (versionRegexes, agent) {
      var cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown();
      }
      return find$2(versionRegexes, cleanedAgent);
    };
    var unknown = function () {
      return nu$1(0, 0);
    };
    var nu$1 = function (major, minor) {
      return {
        major: major,
        minor: minor
      };
    };
    var Version = {
      nu: nu$1,
      detect: detect,
      unknown: unknown
    };

    var edge = &apos;Edge&apos;;
    var chrome = &apos;Chrome&apos;;
    var ie = &apos;IE&apos;;
    var opera = &apos;Opera&apos;;
    var firefox = &apos;Firefox&apos;;
    var safari = &apos;Safari&apos;;
    var unknown$1 = function () {
      return nu$2({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$2 = function (info) {
      var current = info.current;
      var version = info.version;
      var isBrowser = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isEdge: isBrowser(edge),
        isChrome: isBrowser(chrome),
        isIE: isBrowser(ie),
        isOpera: isBrowser(opera),
        isFirefox: isBrowser(firefox),
        isSafari: isBrowser(safari)
      };
    };
    var Browser = {
      unknown: unknown$1,
      nu: nu$2,
      edge: constant(edge),
      chrome: constant(chrome),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };

    var windows = &apos;Windows&apos;;
    var ios = &apos;iOS&apos;;
    var android = &apos;Android&apos;;
    var linux = &apos;Linux&apos;;
    var osx = &apos;OSX&apos;;
    var solaris = &apos;Solaris&apos;;
    var freebsd = &apos;FreeBSD&apos;;
    var chromeos = &apos;ChromeOS&apos;;
    var unknown$2 = function () {
      return nu$3({
        current: undefined,
        version: Version.unknown()
      });
    };
    var nu$3 = function (info) {
      var current = info.current;
      var version = info.version;
      var isOS = function (name) {
        return function () {
          return current === name;
        };
      };
      return {
        current: current,
        version: version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isOSX: isOS(osx),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    var OperatingSystem = {
      unknown: unknown$2,
      nu: nu$3,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      osx: constant(osx),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };

    var DeviceType = function (os, browser, userAgent, mediaMatch) {
      var isiPad = os.isiOS() &amp;&amp; /ipad/i.test(userAgent) === true;
      var isiPhone = os.isiOS() &amp;&amp; !isiPad;
      var isMobile = os.isiOS() || os.isAndroid();
      var isTouch = isMobile || mediaMatch(&apos;(pointer:coarse)&apos;);
      var isTablet = isiPad || !isiPhone &amp;&amp; isMobile &amp;&amp; mediaMatch(&apos;(min-device-width:768px)&apos;);
      var isPhone = isiPhone || isMobile &amp;&amp; !isTablet;
      var iOSwebview = browser.isSafari() &amp;&amp; os.isiOS() &amp;&amp; /safari/i.test(userAgent) === false;
      var isDesktop = !isPhone &amp;&amp; !isTablet &amp;&amp; !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet),
        isPhone: constant(isPhone),
        isTouch: constant(isTouch),
        isAndroid: os.isAndroid,
        isiOS: os.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };

    var detect$1 = function (candidates, userAgent) {
      var agent = String(userAgent).toLowerCase();
      return find(candidates, function (candidate) {
        return candidate.search(agent);
      });
    };
    var detectBrowser = function (browsers, userAgent) {
      return detect$1(browsers, userAgent).map(function (browser) {
        var version = Version.detect(browser.versionRegexes, userAgent);
        return {
          current: browser.name,
          version: version
        };
      });
    };
    var detectOs = function (oses, userAgent) {
      return detect$1(oses, userAgent).map(function (os) {
        var version = Version.detect(os.versionRegexes, userAgent);
        return {
          current: os.name,
          version: version
        };
      });
    };
    var UaString = {
      detectBrowser: detectBrowser,
      detectOs: detectOs
    };

    var checkRange = function (str, substr, start) {
      return substr === &apos;&apos; || str.length &gt;= substr.length &amp;&amp; str.substr(start, start + substr.length) === substr;
    };
    var contains$1 = function (str, substr) {
      return str.indexOf(substr) !== -1;
    };
    var endsWith = function (str, suffix) {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    var blank = function (r) {
      return function (s) {
        return s.replace(r, &apos;&apos;);
      };
    };
    var trim = blank(/^\s+|\s+$/g);

    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    var checkContains = function (target) {
      return function (uastring) {
        return contains$1(uastring, target);
      };
    };
    var browsers = [
      {
        name: &apos;Edge&apos;,
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: function (uastring) {
          return contains$1(uastring, &apos;edge/&apos;) &amp;&amp; contains$1(uastring, &apos;chrome&apos;) &amp;&amp; contains$1(uastring, &apos;safari&apos;) &amp;&amp; contains$1(uastring, &apos;applewebkit&apos;);
        }
      },
      {
        name: &apos;Chrome&apos;,
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: function (uastring) {
          return contains$1(uastring, &apos;chrome&apos;) &amp;&amp; !contains$1(uastring, &apos;chromeframe&apos;);
        }
      },
      {
        name: &apos;IE&apos;,
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: function (uastring) {
          return contains$1(uastring, &apos;msie&apos;) || contains$1(uastring, &apos;trident&apos;);
        }
      },
      {
        name: &apos;Opera&apos;,
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains(&apos;opera&apos;)
      },
      {
        name: &apos;Firefox&apos;,
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains(&apos;firefox&apos;)
      },
      {
        name: &apos;Safari&apos;,
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: function (uastring) {
          return (contains$1(uastring, &apos;safari&apos;) || contains$1(uastring, &apos;mobile/&apos;)) &amp;&amp; contains$1(uastring, &apos;applewebkit&apos;);
        }
      }
    ];
    var oses = [
      {
        name: &apos;Windows&apos;,
        search: checkContains(&apos;win&apos;),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: &apos;iOS&apos;,
        search: function (uastring) {
          return contains$1(uastring, &apos;iphone&apos;) || contains$1(uastring, &apos;ipad&apos;);
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: &apos;Android&apos;,
        search: checkContains(&apos;android&apos;),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: &apos;OSX&apos;,
        search: checkContains(&apos;mac os x&apos;),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: &apos;Linux&apos;,
        search: checkContains(&apos;linux&apos;),
        versionRegexes: []
      },
      {
        name: &apos;Solaris&apos;,
        search: checkContains(&apos;sunos&apos;),
        versionRegexes: []
      },
      {
        name: &apos;FreeBSD&apos;,
        search: checkContains(&apos;freebsd&apos;),
        versionRegexes: []
      },
      {
        name: &apos;ChromeOS&apos;,
        search: checkContains(&apos;cros&apos;),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    var PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };

    var detect$2 = function (userAgent, mediaMatch) {
      var browsers = PlatformInfo.browsers();
      var oses = PlatformInfo.oses();
      var browser = UaString.detectBrowser(browsers, userAgent).fold(Browser.unknown, Browser.nu);
      var os = UaString.detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
      return {
        browser: browser,
        os: os,
        deviceType: deviceType
      };
    };
    var PlatformDetection = { detect: detect$2 };

    var mediaMatch = function (query) {
      return domGlobals.window.matchMedia(query).matches;
    };
    var platform = cached(function () {
      return PlatformDetection.detect(domGlobals.navigator.userAgent, mediaMatch);
    });
    var detect$3 = function () {
      return platform();
    };

    var DOCUMENT = 9;
    var ELEMENT = 1;
    var TEXT = 3;

    var ELEMENT$1 = ELEMENT;
    var DOCUMENT$1 = DOCUMENT;
    var is = function (element, selector) {
      var dom = element.dom();
      if (dom.nodeType !== ELEMENT$1) {
        return false;
      } else {
        var elem = dom;
        if (elem.matches !== undefined) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error(&apos;Browser lacks native selectors&apos;);
        }
      }
    };
    var bypassSelector = function (dom) {
      return dom.nodeType !== ELEMENT$1 &amp;&amp; dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
    };
    var all = function (selector, scope) {
      var base = scope === undefined ? domGlobals.document : scope.dom();
      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), Element.fromDom);
    };
    var one = function (selector, scope) {
      var base = scope === undefined ? domGlobals.document : scope.dom();
      return bypassSelector(base) ? Option.none() : Option.from(base.querySelector(selector)).map(Element.fromDom);
    };

    var eq$1 = function (e1, e2) {
      return e1.dom() === e2.dom();
    };
    var regularContains = function (e1, e2) {
      var d1 = e1.dom();
      var d2 = e2.dom();
      return d1 === d2 ? false : d1.contains(d2);
    };
    var ieContains = function (e1, e2) {
      return documentPositionContainedBy(e1.dom(), e2.dom());
    };
    var contains$2 = function (e1, e2) {
      return detect$3().browser.isIE() ? ieContains(e1, e2) : regularContains(e1, e2);
    };

    var ensureIsRoot = function (isRoot) {
      return isFunction(isRoot) ? isRoot : constant(false);
    };
    var ancestor = function (scope, transform, isRoot) {
      var element = scope.dom();
      var stop = ensureIsRoot(isRoot);
      while (element.parentNode) {
        element = element.parentNode;
        var el = Element.fromDom(element);
        var transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop(el)) {
          break;
        }
      }
      return Option.none();
    };
    var closest = function (scope, transform, isRoot) {
      var current = transform(scope);
      var stop = ensureIsRoot(isRoot);
      return current.orThunk(function () {
        return stop(scope) ? Option.none() : ancestor(scope, transform, stop);
      });
    };

    var isSource = function (component, simulatedEvent) {
      return eq$1(component.element(), simulatedEvent.event().target());
    };

    var nu$4 = function (parts) {
      if (!hasNonNullableKey(parts, &apos;can&apos;) &amp;&amp; !hasNonNullableKey(parts, &apos;abort&apos;) &amp;&amp; !hasNonNullableKey(parts, &apos;run&apos;)) {
        throw new Error(&apos;EventHandler defined by: &apos; + JSON.stringify(parts, null, 2) + &apos; does not have can, abort, or run!&apos;);
      }
      return asRawOrDie(&apos;Extracting event.handler&apos;, objOfOnly([
        defaulted$1(&apos;can&apos;, constant(true)),
        defaulted$1(&apos;abort&apos;, constant(false)),
        defaulted$1(&apos;run&apos;, noop)
      ]), parts);
    };
    var all$1 = function (handlers, f) {
      return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return foldl(handlers, function (acc, handler) {
          return acc &amp;&amp; f(handler).apply(undefined, args);
        }, true);
      };
    };
    var any = function (handlers, f) {
      return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return foldl(handlers, function (acc, handler) {
          return acc || f(handler).apply(undefined, args);
        }, false);
      };
    };
    var read = function (handler) {
      return isFunction(handler) ? {
        can: constant(true),
        abort: constant(false),
        run: handler
      } : handler;
    };
    var fuse = function (handlers) {
      var can = all$1(handlers, function (handler) {
        return handler.can;
      });
      var abort = any(handlers, function (handler) {
        return handler.abort;
      });
      var run = function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        each(handlers, function (handler) {
          handler.run.apply(undefined, args);
        });
      };
      return nu$4({
        can: can,
        abort: abort,
        run: run
      });
    };

    var touchstart = constant(&apos;touchstart&apos;);
    var touchmove = constant(&apos;touchmove&apos;);
    var touchend = constant(&apos;touchend&apos;);
    var touchcancel = constant(&apos;touchcancel&apos;);
    var mousedown = constant(&apos;mousedown&apos;);
    var mousemove = constant(&apos;mousemove&apos;);
    var mouseout = constant(&apos;mouseout&apos;);
    var mouseup = constant(&apos;mouseup&apos;);
    var mouseover = constant(&apos;mouseover&apos;);
    var focusin = constant(&apos;focusin&apos;);
    var focusout = constant(&apos;focusout&apos;);
    var keydown = constant(&apos;keydown&apos;);
    var keyup = constant(&apos;keyup&apos;);
    var input = constant(&apos;input&apos;);
    var change = constant(&apos;change&apos;);
    var click = constant(&apos;click&apos;);
    var transitionend = constant(&apos;transitionend&apos;);
    var selectstart = constant(&apos;selectstart&apos;);

    var alloy = { tap: constant(&apos;alloy.tap&apos;) };
    var focus = constant(&apos;alloy.focus&apos;);
    var postBlur = constant(&apos;alloy.blur.post&apos;);
    var postPaste = constant(&apos;alloy.paste.post&apos;);
    var receive = constant(&apos;alloy.receive&apos;);
    var execute = constant(&apos;alloy.execute&apos;);
    var focusItem = constant(&apos;alloy.focus.item&apos;);
    var tap = alloy.tap;
    var longpress = constant(&apos;alloy.longpress&apos;);
    var sandboxClose = constant(&apos;alloy.sandbox.close&apos;);
    var typeaheadCancel = constant(&apos;alloy.typeahead.cancel&apos;);
    var systemInit = constant(&apos;alloy.system.init&apos;);
    var documentTouchmove = constant(&apos;alloy.system.touchmove&apos;);
    var documentTouchend = constant(&apos;alloy.system.touchend&apos;);
    var windowScroll = constant(&apos;alloy.system.scroll&apos;);
    var windowResize = constant(&apos;alloy.system.resize&apos;);
    var attachedToDom = constant(&apos;alloy.system.attached&apos;);
    var detachedFromDom = constant(&apos;alloy.system.detached&apos;);
    var dismissRequested = constant(&apos;alloy.system.dismissRequested&apos;);
    var repositionRequested = constant(&apos;alloy.system.repositionRequested&apos;);
    var focusShifted = constant(&apos;alloy.focusmanager.shifted&apos;);
    var slotVisibility = constant(&apos;alloy.slotcontainer.visibility&apos;);
    var changeTab = constant(&apos;alloy.change.tab&apos;);
    var dismissTab = constant(&apos;alloy.dismiss.tab&apos;);
    var highlight = constant(&apos;alloy.highlight&apos;);
    var dehighlight = constant(&apos;alloy.dehighlight&apos;);

    var emit = function (component, event) {
      dispatchWith(component, component.element(), event, {});
    };
    var emitWith = function (component, event, properties) {
      dispatchWith(component, component.element(), event, properties);
    };
    var emitExecute = function (component) {
      emit(component, execute());
    };
    var dispatch = function (component, target, event) {
      dispatchWith(component, target, event, {});
    };
    var dispatchWith = function (component, target, event, properties) {
      var data = __assign({ target: target }, properties);
      component.getSystem().triggerEvent(event, target, map$1(data, constant));
    };
    var dispatchEvent = function (component, target, event, simulatedEvent) {
      component.getSystem().triggerEvent(event, target, simulatedEvent.event());
    };

    var derive = function (configs) {
      return wrapAll$1(configs);
    };
    var abort = function (name, predicate) {
      return {
        key: name,
        value: nu$4({ abort: predicate })
      };
    };
    var can = function (name, predicate) {
      return {
        key: name,
        value: nu$4({ can: predicate })
      };
    };
    var preventDefault = function (name) {
      return {
        key: name,
        value: nu$4({
          run: function (component, simulatedEvent) {
            simulatedEvent.event().prevent();
          }
        })
      };
    };
    var run = function (name, handler) {
      return {
        key: name,
        value: nu$4({ run: handler })
      };
    };
    var runActionExtra = function (name, action, extra) {
      return {
        key: name,
        value: nu$4({
          run: function (component, simulatedEvent) {
            action.apply(undefined, [
              component,
              simulatedEvent
            ].concat(extra));
          }
        })
      };
    };
    var runOnName = function (name) {
      return function (handler) {
        return run(name, handler);
      };
    };
    var runOnSourceName = function (name) {
      return function (handler) {
        return {
          key: name,
          value: nu$4({
            run: function (component, simulatedEvent) {
              if (isSource(component, simulatedEvent)) {
                handler(component, simulatedEvent);
              }
            }
          })
        };
      };
    };
    var redirectToUid = function (name, uid) {
      return run(name, function (component, simulatedEvent) {
        component.getSystem().getByUid(uid).each(function (redirectee) {
          dispatchEvent(redirectee, redirectee.element(), name, simulatedEvent);
        });
      });
    };
    var redirectToPart = function (name, detail, partName) {
      var uid = detail.partUids[partName];
      return redirectToUid(name, uid);
    };
    var runWithTarget = function (name, f) {
      return run(name, function (component, simulatedEvent) {
        var ev = simulatedEvent.event();
        var target = component.getSystem().getByDom(ev.target()).fold(function () {
          var closest$1 = closest(ev.target(), function (el) {
            return component.getSystem().getByDom(el).toOption();
          }, constant(false));
          return closest$1.getOr(component);
        }, function (c) {
          return c;
        });
        f(component, target, simulatedEvent);
      });
    };
    var cutter = function (name) {
      return run(name, function (component, simulatedEvent) {
        simulatedEvent.cut();
      });
    };
    var stopper = function (name) {
      return run(name, function (component, simulatedEvent) {
        simulatedEvent.stop();
      });
    };
    var runOnSource = function (name, f) {
      return runOnSourceName(name)(f);
    };
    var runOnAttached = runOnSourceName(attachedToDom());
    var runOnDetached = runOnSourceName(detachedFromDom());
    var runOnInit = runOnSourceName(systemInit());
    var runOnExecute = runOnName(execute());

    var owner = function (element) {
      return Element.fromDom(element.dom().ownerDocument);
    };
    var documentElement = function (element) {
      return Element.fromDom(element.dom().ownerDocument.documentElement);
    };
    var defaultView = function (element) {
      return Element.fromDom(element.dom().ownerDocument.defaultView);
    };
    var parent = function (element) {
      return Option.from(element.dom().parentNode).map(Element.fromDom);
    };
    var offsetParent = function (element) {
      return Option.from(element.dom().offsetParent).map(Element.fromDom);
    };
    var nextSibling = function (element) {
      return Option.from(element.dom().nextSibling).map(Element.fromDom);
    };
    var children = function (element) {
      return map(element.dom().childNodes, Element.fromDom);
    };
    var child = function (element, index) {
      var cs = element.dom().childNodes;
      return Option.from(cs[index]).map(Element.fromDom);
    };
    var firstChild = function (element) {
      return child(element, 0);
    };

    var before = function (marker, element) {
      var parent$1 = parent(marker);
      parent$1.each(function (v) {
        v.dom().insertBefore(element.dom(), marker.dom());
      });
    };
    var after = function (marker, element) {
      var sibling = nextSibling(marker);
      sibling.fold(function () {
        var parent$1 = parent(marker);
        parent$1.each(function (v) {
          append(v, element);
        });
      }, function (v) {
        before(v, element);
      });
    };
    var prepend = function (parent, element) {
      var firstChild$1 = firstChild(parent);
      firstChild$1.fold(function () {
        append(parent, element);
      }, function (v) {
        parent.dom().insertBefore(element.dom(), v.dom());
      });
    };
    var append = function (parent, element) {
      parent.dom().appendChild(element.dom());
    };
    var appendAt = function (parent, element, index) {
      child(parent, index).fold(function () {
        append(parent, element);
      }, function (v) {
        before(v, element);
      });
    };

    var before$1 = function (marker, elements) {
      each(elements, function (x) {
        before(marker, x);
      });
    };
    var append$1 = function (parent, elements) {
      each(elements, function (x) {
        append(parent, x);
      });
    };

    var empty = function (element) {
      element.dom().textContent = &apos;&apos;;
      each(children(element), function (rogue) {
        remove(rogue);
      });
    };
    var remove = function (element) {
      var dom = element.dom();
      if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
      }
    };
    var unwrap = function (wrapper) {
      var children$1 = children(wrapper);
      if (children$1.length &gt; 0) {
        before$1(wrapper, children$1);
      }
      remove(wrapper);
    };

    var fromHtml$1 = function (html, scope) {
      var doc = scope || domGlobals.document;
      var div = doc.createElement(&apos;div&apos;);
      div.innerHTML = html;
      return children(Element.fromDom(div));
    };

    var get$1 = function (element) {
      return element.dom().innerHTML;
    };
    var set = function (element, content) {
      var owner$1 = owner(element);
      var docDom = owner$1.dom();
      var fragment = Element.fromDom(docDom.createDocumentFragment());
      var contentElements = fromHtml$1(content, docDom);
      append$1(fragment, contentElements);
      empty(element);
      append(element, fragment);
    };
    var getOuter = function (element) {
      var container = Element.fromTag(&apos;div&apos;);
      var clone = Element.fromDom(element.dom().cloneNode(true));
      append(container, clone);
      return get$1(container);
    };

    var Global = typeof domGlobals.window !== &apos;undefined&apos; ? domGlobals.window : Function(&apos;return this;&apos;)();

    var name = function (element) {
      var r = element.dom().nodeName;
      return r.toLowerCase();
    };
    var type = function (element) {
      return element.dom().nodeType;
    };
    var isType$1 = function (t) {
      return function (element) {
        return type(element) === t;
      };
    };
    var isElement = isType$1(ELEMENT);
    var isText = isType$1(TEXT);

    var rawSet = function (dom, key, value) {
      if (isString(value) || isBoolean(value) || isNumber(value)) {
        dom.setAttribute(key, value + &apos;&apos;);
      } else {
        domGlobals.console.error(&apos;Invalid call to Attr.set. Key &apos;, key, &apos;:: Value &apos;, value, &apos;:: Element &apos;, dom);
        throw new Error(&apos;Attribute value was not simple&apos;);
      }
    };
    var set$1 = function (element, key, value) {
      rawSet(element.dom(), key, value);
    };
    var setAll = function (element, attrs) {
      var dom = element.dom();
      each$1(attrs, function (v, k) {
        rawSet(dom, k, v);
      });
    };
    var get$2 = function (element, key) {
      var v = element.dom().getAttribute(key);
      return v === null ? undefined : v;
    };
    var getOpt = function (element, key) {
      return Option.from(get$2(element, key));
    };
    var has$1 = function (element, key) {
      var dom = element.dom();
      return dom &amp;&amp; dom.hasAttribute ? dom.hasAttribute(key) : false;
    };
    var remove$1 = function (element, key) {
      element.dom().removeAttribute(key);
    };

    var clone = function (original, isDeep) {
      return Element.fromDom(original.dom().cloneNode(isDeep));
    };
    var shallow$1 = function (original) {
      return clone(original, false);
    };

    var getHtml = function (element) {
      var clone = shallow$1(element);
      return getOuter(clone);
    };

    var element = function (elem) {
      return getHtml(elem);
    };

    var isRecursive = function (component, originator, target) {
      return eq$1(originator, component.element()) &amp;&amp; !eq$1(originator, target);
    };
    var events = derive([can(focus(), function (component, simulatedEvent) {
        var originator = simulatedEvent.event().originator();
        var target = simulatedEvent.event().target();
        if (isRecursive(component, originator, target)) {
          domGlobals.console.warn(focus() + &apos; did not get interpreted by the desired target. &apos; + &apos;\nOriginator: &apos; + element(originator) + &apos;\nTarget: &apos; + element(target) + &apos;\nCheck the &apos; + focus() + &apos; event handlers&apos;);
          return false;
        } else {
          return true;
        }
      })]);

    var DefaultEvents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events
    });

    var unique = 0;
    var generate$1 = function (prefix) {
      var date = new Date();
      var time = date.getTime();
      var random = Math.floor(Math.random() * 1000000000);
      unique++;
      return prefix + &apos;_&apos; + random + unique + String(time);
    };

    var prefix = constant(&apos;alloy-id-&apos;);
    var idAttr = constant(&apos;data-alloy-id&apos;);

    var prefix$1 = prefix();
    var idAttr$1 = idAttr();
    var write = function (label, elem) {
      var id = generate$1(prefix$1 + label);
      writeOnly(elem, id);
      return id;
    };
    var writeOnly = function (elem, uid) {
      Object.defineProperty(elem.dom(), idAttr$1, {
        value: uid,
        writable: true
      });
    };
    var read$1 = function (elem) {
      var id = isElement(elem) ? elem.dom()[idAttr$1] : null;
      return Option.from(id);
    };
    var generate$2 = function (prefix) {
      return generate$1(prefix);
    };

    var make = identity;

    var NoContextApi = function (getComp) {
      var fail = function (event) {
        return function () {
          throw new Error(&apos;The component must be in a context to send: &apos; + event + (getComp ? &apos;\n&apos; + element(getComp().element()) + &apos; is not in context.&apos; : &apos;&apos;));
        };
      };
      return {
        debugInfo: constant(&apos;fake&apos;),
        triggerEvent: fail(&apos;triggerEvent&apos;),
        triggerFocus: fail(&apos;triggerFocus&apos;),
        triggerEscape: fail(&apos;triggerEscape&apos;),
        build: fail(&apos;build&apos;),
        addToWorld: fail(&apos;addToWorld&apos;),
        removeFromWorld: fail(&apos;removeFromWorld&apos;),
        addToGui: fail(&apos;addToGui&apos;),
        removeFromGui: fail(&apos;removeFromGui&apos;),
        getByUid: fail(&apos;getByUid&apos;),
        getByDom: fail(&apos;getByDom&apos;),
        broadcast: fail(&apos;broadcast&apos;),
        broadcastOn: fail(&apos;broadcastOn&apos;),
        broadcastEvent: fail(&apos;broadcastEvent&apos;),
        isConnected: constant(false)
      };
    };
    var singleton = NoContextApi();

    var markAsBehaviourApi = function (f, apiName, apiFunction) {
      var delegate = apiFunction.toString();
      var endIndex = delegate.indexOf(&apos;)&apos;) + 1;
      var openBracketIndex = delegate.indexOf(&apos;(&apos;);
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: apiName,
          parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
        };
      };
      return f;
    };
    var cleanParameters = function (parameters) {
      return map(parameters, function (p) {
        return endsWith(p, &apos;/*&apos;) ? p.substring(0, p.length - &apos;/*&apos;.length) : p;
      });
    };
    var markAsExtraApi = function (f, extraName) {
      var delegate = f.toString();
      var endIndex = delegate.indexOf(&apos;)&apos;) + 1;
      var openBracketIndex = delegate.indexOf(&apos;(&apos;);
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: extraName,
          parameters: cleanParameters(parameters)
        };
      };
      return f;
    };
    var markAsSketchApi = function (f, apiFunction) {
      var delegate = apiFunction.toString();
      var endIndex = delegate.indexOf(&apos;)&apos;) + 1;
      var openBracketIndex = delegate.indexOf(&apos;(&apos;);
      var parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
      f.toFunctionAnnotation = function () {
        return {
          name: &apos;OVERRIDE&apos;,
          parameters: cleanParameters(parameters.slice(1))
        };
      };
      return f;
    };

    var premadeTag = generate$1(&apos;alloy-premade&apos;);
    var premade = function (comp) {
      return wrap$1(premadeTag, comp);
    };
    var getPremade = function (spec) {
      return get(spec, premadeTag);
    };
    var makeApi = function (f) {
      return markAsSketchApi(function (component) {
        var rest = [];
        for (var _i = 1; _i &lt; arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        return f.apply(void 0, __spreadArrays([
          component.getApis(),
          component
        ], rest));
      }, f);
    };

    var NoState = {
      init: function () {
        return nu$5({
          readState: function () {
            return &apos;No State required&apos;;
          }
        });
      }
    };
    var nu$5 = function (spec) {
      return spec;
    };

    var generateFrom = function (spec, all) {
      var schema = map(all, function (a) {
        return optionObjOf(a.name(), [
          strict$1(&apos;config&apos;),
          defaulted$1(&apos;state&apos;, NoState)
        ]);
      });
      var validated = asRaw(&apos;component.behaviours&apos;, objOf(schema), spec.behaviours).fold(function (errInfo) {
        throw new Error(formatError(errInfo) + &apos;\nComplete spec:\n&apos; + JSON.stringify(spec, null, 2));
      }, function (v) {
        return v;
      });
      return {
        list: all,
        data: map$1(validated, function (optBlobThunk) {
          var output = optBlobThunk.map(function (blob) {
            return {
              config: blob.config,
              state: blob.state.init(blob.config)
            };
          });
          return function () {
            return output;
          };
        })
      };
    };
    var getBehaviours = function (bData) {
      return bData.list;
    };
    var getData = function (bData) {
      return bData.data;
    };

    var byInnerKey = function (data, tuple) {
      var r = {};
      each$1(data, function (detail, key) {
        each$1(detail, function (value, indexKey) {
          var chain = get(r, indexKey).getOr([]);
          r[indexKey] = chain.concat([tuple(key, value)]);
        });
      });
      return r;
    };

    var nu$6 = function (s) {
      return {
        classes: s.classes !== undefined ? s.classes : [],
        attributes: s.attributes !== undefined ? s.attributes : {},
        styles: s.styles !== undefined ? s.styles : {}
      };
    };
    var merge$1 = function (defnA, mod) {
      return __assign(__assign({}, defnA), {
        attributes: __assign(__assign({}, defnA.attributes), mod.attributes),
        styles: __assign(__assign({}, defnA.styles), mod.styles),
        classes: defnA.classes.concat(mod.classes)
      });
    };

    var combine = function (info, baseMod, behaviours, base) {
      var modsByBehaviour = __assign({}, baseMod);
      each(behaviours, function (behaviour) {
        modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base);
      });
      var byAspect = byInnerKey(modsByBehaviour, function (name, modification) {
        return {
          name: name,
          modification: modification
        };
      });
      var combineObjects = function (objects) {
        return foldr(objects, function (b, a) {
          return __assign(__assign({}, a.modification), b);
        }, {});
      };
      var combinedClasses = foldr(byAspect.classes, function (b, a) {
        return a.modification.concat(b);
      }, []);
      var combinedAttributes = combineObjects(byAspect.attributes);
      var combinedStyles = combineObjects(byAspect.styles);
      return nu$6({
        classes: combinedClasses,
        attributes: combinedAttributes,
        styles: combinedStyles
      });
    };

    var sortKeys = function (label, keyName, array, order) {
      try {
        var sorted = sort(array, function (a, b) {
          var aKey = a[keyName]();
          var bKey = b[keyName]();
          var aIndex = order.indexOf(aKey);
          var bIndex = order.indexOf(bKey);
          if (aIndex === -1) {
            throw new Error(&apos;The ordering for &apos; + label + &apos; does not have an entry for &apos; + aKey + &apos;.\nOrder specified: &apos; + JSON.stringify(order, null, 2));
          }
          if (bIndex === -1) {
            throw new Error(&apos;The ordering for &apos; + label + &apos; does not have an entry for &apos; + bKey + &apos;.\nOrder specified: &apos; + JSON.stringify(order, null, 2));
          }
          if (aIndex &lt; bIndex) {
            return -1;
          } else if (bIndex &lt; aIndex) {
            return 1;
          } else {
            return 0;
          }
        });
        return Result.value(sorted);
      } catch (err) {
        return Result.error([err]);
      }
    };

    var uncurried = function (handler, purpose) {
      return {
        handler: handler,
        purpose: constant(purpose)
      };
    };
    var curried = function (handler, purpose) {
      return {
        cHandler: handler,
        purpose: constant(purpose)
      };
    };
    var curryArgs = function (descHandler, extraArgs) {
      return curried(curry.apply(undefined, [descHandler.handler].concat(extraArgs)), descHandler.purpose());
    };
    var getCurried = function (descHandler) {
      return descHandler.cHandler;
    };

    var behaviourTuple = function (name, handler) {
      return {
        name: constant(name),
        handler: constant(handler)
      };
    };
    var nameToHandlers = function (behaviours, info) {
      var r = {};
      each(behaviours, function (behaviour) {
        r[behaviour.name()] = behaviour.handlers(info);
      });
      return r;
    };
    var groupByEvents = function (info, behaviours, base) {
      var behaviourEvents = __assign(__assign({}, base), nameToHandlers(behaviours, info));
      return byInnerKey(behaviourEvents, behaviourTuple);
    };
    var combine$1 = function (info, eventOrder, behaviours, base) {
      var byEventName = groupByEvents(info, behaviours, base);
      return combineGroups(byEventName, eventOrder);
    };
    var assemble = function (rawHandler) {
      var handler = read(rawHandler);
      return function (component, simulatedEvent) {
        var rest = [];
        for (var _i = 2; _i &lt; arguments.length; _i++) {
          rest[_i - 2] = arguments[_i];
        }
        var args = [
          component,
          simulatedEvent
        ].concat(rest);
        if (handler.abort.apply(undefined, args)) {
          simulatedEvent.stop();
        } else if (handler.can.apply(undefined, args)) {
          handler.run.apply(undefined, args);
        }
      };
    };
    var missingOrderError = function (eventName, tuples) {
      return Result.error([&apos;The event (&apos; + eventName + &apos;) has more than one behaviour that listens to it.\nWhen this occurs, you must &apos; + &apos;specify an event ordering for the behaviours in your spec (e.g. [ &quot;listing&quot;, &quot;toggling&quot; ]).\nThe behaviours that &apos; + &apos;can trigger it are: &apos; + JSON.stringify(map(tuples, function (c) {
          return c.name();
        }), null, 2)]);
    };
    var fuse$1 = function (tuples, eventOrder, eventName) {
      var order = eventOrder[eventName];
      if (!order) {
        return missingOrderError(eventName, tuples);
      } else {
        return sortKeys(&apos;Event: &apos; + eventName, &apos;name&apos;, tuples, order).map(function (sortedTuples) {
          var handlers = map(sortedTuples, function (tuple) {
            return tuple.handler();
          });
          return fuse(handlers);
        });
      }
    };
    var combineGroups = function (byEventName, eventOrder) {
      var r = mapToArray(byEventName, function (tuples, eventName) {
        var combined = tuples.length === 1 ? Result.value(tuples[0].handler()) : fuse$1(tuples, eventOrder, eventName);
        return combined.map(function (handler) {
          var assembled = assemble(handler);
          var purpose = tuples.length &gt; 1 ? filter(eventOrder[eventName], function (o) {
            return exists(tuples, function (t) {
              return t.name() === o;
            });
          }).join(&apos; &gt; &apos;) : tuples[0].name();
          return wrap$1(eventName, uncurried(assembled, purpose));
        });
      });
      return consolidate(r, {});
    };

    var toInfo = function (spec) {
      return asRaw(&apos;custom.definition&apos;, objOf([
        field(&apos;dom&apos;, &apos;dom&apos;, strict(), objOf([
          strict$1(&apos;tag&apos;),
          defaulted$1(&apos;styles&apos;, {}),
          defaulted$1(&apos;classes&apos;, []),
          defaulted$1(&apos;attributes&apos;, {}),
          option(&apos;value&apos;),
          option(&apos;innerHtml&apos;)
        ])),
        strict$1(&apos;components&apos;),
        strict$1(&apos;uid&apos;),
        defaulted$1(&apos;events&apos;, {}),
        defaulted$1(&apos;apis&apos;, {}),
        field(&apos;eventOrder&apos;, &apos;eventOrder&apos;, mergeWith({
          &apos;alloy.execute&apos;: [
            &apos;disabling&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;toggling&apos;,
            &apos;typeaheadevents&apos;
          ],
          &apos;alloy.focus&apos;: [
            &apos;alloy.base.behaviour&apos;,
            &apos;focusing&apos;,
            &apos;keying&apos;
          ],
          &apos;alloy.system.init&apos;: [
            &apos;alloy.base.behaviour&apos;,
            &apos;disabling&apos;,
            &apos;toggling&apos;,
            &apos;representing&apos;
          ],
          &apos;input&apos;: [
            &apos;alloy.base.behaviour&apos;,
            &apos;representing&apos;,
            &apos;streaming&apos;,
            &apos;invalidating&apos;
          ],
          &apos;alloy.system.detached&apos;: [
            &apos;alloy.base.behaviour&apos;,
            &apos;representing&apos;,
            &apos;item-events&apos;,
            &apos;tooltipping&apos;
          ],
          &apos;mousedown&apos;: [
            &apos;focusing&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;item-type-events&apos;
          ],
          &apos;touchstart&apos;: [
            &apos;focusing&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;item-type-events&apos;
          ],
          &apos;mouseover&apos;: [
            &apos;item-type-events&apos;,
            &apos;tooltipping&apos;
          ],
          &apos;alloy.receive&apos;: [
            &apos;receiving&apos;,
            &apos;reflecting&apos;,
            &apos;tooltipping&apos;
          ]
        }), anyValue$1()),
        option(&apos;domModification&apos;)
      ]), spec);
    };
    var toDefinition = function (detail) {
      return __assign(__assign({}, detail.dom), {
        uid: detail.uid,
        domChildren: map(detail.components, function (comp) {
          return comp.element();
        })
      });
    };
    var toModification = function (detail) {
      return detail.domModification.fold(function () {
        return nu$6({});
      }, nu$6);
    };
    var toEvents = function (info) {
      return info.events;
    };

    var read$2 = function (element, attr) {
      var value = get$2(element, attr);
      return value === undefined || value === &apos;&apos; ? [] : value.split(&apos; &apos;);
    };
    var add = function (element, attr, id) {
      var old = read$2(element, attr);
      var nu = old.concat([id]);
      set$1(element, attr, nu.join(&apos; &apos;));
      return true;
    };
    var remove$2 = function (element, attr, id) {
      var nu = filter(read$2(element, attr), function (v) {
        return v !== id;
      });
      if (nu.length &gt; 0) {
        set$1(element, attr, nu.join(&apos; &apos;));
      } else {
        remove$1(element, attr);
      }
      return false;
    };

    var supports = function (element) {
      return element.dom().classList !== undefined;
    };
    var get$3 = function (element) {
      return read$2(element, &apos;class&apos;);
    };
    var add$1 = function (element, clazz) {
      return add(element, &apos;class&apos;, clazz);
    };
    var remove$3 = function (element, clazz) {
      return remove$2(element, &apos;class&apos;, clazz);
    };

    var add$2 = function (element, clazz) {
      if (supports(element)) {
        element.dom().classList.add(clazz);
      } else {
        add$1(element, clazz);
      }
    };
    var cleanClass = function (element) {
      var classList = supports(element) ? element.dom().classList : get$3(element);
      if (classList.length === 0) {
        remove$1(element, &apos;class&apos;);
      }
    };
    var remove$4 = function (element, clazz) {
      if (supports(element)) {
        var classList = element.dom().classList;
        classList.remove(clazz);
      } else {
        remove$3(element, clazz);
      }
      cleanClass(element);
    };
    var has$2 = function (element, clazz) {
      return supports(element) &amp;&amp; element.dom().classList.contains(clazz);
    };

    var add$3 = function (element, classes) {
      each(classes, function (x) {
        add$2(element, x);
      });
    };
    var remove$5 = function (element, classes) {
      each(classes, function (x) {
        remove$4(element, x);
      });
    };

    var isSupported = function (dom) {
      return dom.style !== undefined &amp;&amp; isFunction(dom.style.getPropertyValue);
    };

    var inBody = function (element) {
      var dom = isText(element) ? element.dom().parentNode : element.dom();
      return dom !== undefined &amp;&amp; dom !== null &amp;&amp; dom.ownerDocument.body.contains(dom);
    };
    var body = function () {
      return getBody(Element.fromDom(domGlobals.document));
    };
    var getBody = function (doc) {
      var b = doc.dom().body;
      if (b === null || b === undefined) {
        throw new Error(&apos;Body is not available yet&apos;);
      }
      return Element.fromDom(b);
    };

    var internalSet = function (dom, property, value) {
      if (!isString(value)) {
        domGlobals.console.error(&apos;Invalid call to CSS.set. Property &apos;, property, &apos;:: Value &apos;, value, &apos;:: Element &apos;, dom);
        throw new Error(&apos;CSS value must be a string: &apos; + value);
      }
      if (isSupported(dom)) {
        dom.style.setProperty(property, value);
      }
    };
    var internalRemove = function (dom, property) {
      if (isSupported(dom)) {
        dom.style.removeProperty(property);
      }
    };
    var set$2 = function (element, property, value) {
      var dom = element.dom();
      internalSet(dom, property, value);
    };
    var setAll$1 = function (element, css) {
      var dom = element.dom();
      each$1(css, function (v, k) {
        internalSet(dom, k, v);
      });
    };
    var setOptions = function (element, css) {
      var dom = element.dom();
      each$1(css, function (v, k) {
        v.fold(function () {
          internalRemove(dom, k);
        }, function (value) {
          internalSet(dom, k, value);
        });
      });
    };
    var get$4 = function (element, property) {
      var dom = element.dom();
      var styles = domGlobals.window.getComputedStyle(dom);
      var r = styles.getPropertyValue(property);
      return r === &apos;&apos; &amp;&amp; !inBody(element) ? getUnsafeProperty(dom, property) : r;
    };
    var getUnsafeProperty = function (dom, property) {
      return isSupported(dom) ? dom.style.getPropertyValue(property) : &apos;&apos;;
    };
    var getRaw = function (element, property) {
      var dom = element.dom();
      var raw = getUnsafeProperty(dom, property);
      return Option.from(raw).filter(function (r) {
        return r.length &gt; 0;
      });
    };
    var getAllRaw = function (element) {
      var css = {};
      var dom = element.dom();
      if (isSupported(dom)) {
        for (var i = 0; i &lt; dom.style.length; i++) {
          var ruleName = dom.style.item(i);
          css[ruleName] = dom.style[ruleName];
        }
      }
      return css;
    };
    var isValidValue = function (tag, property, value) {
      var element = Element.fromTag(tag);
      set$2(element, property, value);
      var style = getRaw(element, property);
      return style.isSome();
    };
    var remove$6 = function (element, property) {
      var dom = element.dom();
      internalRemove(dom, property);
      if (getOpt(element, &apos;style&apos;).map(trim).is(&apos;&apos;)) {
        remove$1(element, &apos;style&apos;);
      }
    };
    var reflow = function (e) {
      return e.dom().offsetWidth;
    };

    var get$5 = function (element) {
      return element.dom().value;
    };
    var set$3 = function (element, value) {
      if (value === undefined) {
        throw new Error(&apos;Value.set was undefined&apos;);
      }
      element.dom().value = value;
    };

    var renderToDom = function (definition) {
      var subject = Element.fromTag(definition.tag);
      setAll(subject, definition.attributes);
      add$3(subject, definition.classes);
      setAll$1(subject, definition.styles);
      definition.innerHtml.each(function (html) {
        return set(subject, html);
      });
      var children = definition.domChildren;
      append$1(subject, children);
      definition.value.each(function (value) {
        set$3(subject, value);
      });
      if (!definition.uid) {
        debugger;
      }
      writeOnly(subject, definition.uid);
      return subject;
    };

    var getBehaviours$1 = function (spec) {
      var behaviours = get(spec, &apos;behaviours&apos;).getOr({});
      var keys$1 = filter(keys(behaviours), function (k) {
        return behaviours[k] !== undefined;
      });
      return map(keys$1, function (k) {
        return behaviours[k].me;
      });
    };
    var generateFrom$1 = function (spec, all) {
      return generateFrom(spec, all);
    };
    var generate$3 = function (spec) {
      var all = getBehaviours$1(spec);
      return generateFrom$1(spec, all);
    };

    var getDomDefinition = function (info, bList, bData) {
      var definition = toDefinition(info);
      var infoModification = toModification(info);
      var baseModification = { &apos;alloy.base.modification&apos;: infoModification };
      var modification = bList.length &gt; 0 ? combine(bData, baseModification, bList, definition) : infoModification;
      return merge$1(definition, modification);
    };
    var getEvents = function (info, bList, bData) {
      var baseEvents = { &apos;alloy.base.behaviour&apos;: toEvents(info) };
      return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
    };
    var build = function (spec) {
      var getMe = function () {
        return me;
      };
      var systemApi = Cell(singleton);
      var info = getOrDie(toInfo(spec));
      var bBlob = generate$3(spec);
      var bList = getBehaviours(bBlob);
      var bData = getData(bBlob);
      var modDefinition = getDomDefinition(info, bList, bData);
      var item = renderToDom(modDefinition);
      var events = getEvents(info, bList, bData);
      var subcomponents = Cell(info.components);
      var connect = function (newApi) {
        systemApi.set(newApi);
      };
      var disconnect = function () {
        systemApi.set(NoContextApi(getMe));
      };
      var syncComponents = function () {
        var children$1 = children(item);
        var subs = bind(children$1, function (child) {
          return systemApi.get().getByDom(child).fold(function () {
            return [];
          }, function (c) {
            return [c];
          });
        });
        subcomponents.set(subs);
      };
      var config = function (behaviour) {
        var b = bData;
        var f = isFunction(b[behaviour.name()]) ? b[behaviour.name()] : function () {
          throw new Error(&apos;Could not find &apos; + behaviour.name() + &apos; in &apos; + JSON.stringify(spec, null, 2));
        };
        return f();
      };
      var hasConfigured = function (behaviour) {
        return isFunction(bData[behaviour.name()]);
      };
      var getApis = function () {
        return info.apis;
      };
      var readState = function (behaviourName) {
        return bData[behaviourName]().map(function (b) {
          return b.state.readState();
        }).getOr(&apos;not enabled&apos;);
      };
      var me = {
        getSystem: systemApi.get,
        config: config,
        hasConfigured: hasConfigured,
        spec: constant(spec),
        readState: readState,
        getApis: getApis,
        connect: connect,
        disconnect: disconnect,
        element: constant(item),
        syncComponents: syncComponents,
        components: subcomponents.get,
        events: constant(events)
      };
      return me;
    };

    var buildSubcomponents = function (spec) {
      var components = get(spec, &apos;components&apos;).getOr([]);
      return map(components, build$1);
    };
    var buildFromSpec = function (userSpec) {
      var _a = make(userSpec), specEvents = _a.events, spec = __rest(_a, [&apos;events&apos;]);
      var components = buildSubcomponents(spec);
      var completeSpec = __assign(__assign({}, spec), {
        events: __assign(__assign({}, DefaultEvents), specEvents),
        components: components
      });
      return Result.value(build(completeSpec));
    };
    var text = function (textContent) {
      var element = Element.fromText(textContent);
      return external({ element: element });
    };
    var external = function (spec) {
      var extSpec = asRawOrDie(&apos;external.component&apos;, objOfOnly([
        strict$1(&apos;element&apos;),
        option(&apos;uid&apos;)
      ]), spec);
      var systemApi = Cell(NoContextApi());
      var connect = function (newApi) {
        systemApi.set(newApi);
      };
      var disconnect = function () {
        systemApi.set(NoContextApi(function () {
          return me;
        }));
      };
      extSpec.uid.each(function (uid) {
        writeOnly(extSpec.element, uid);
      });
      var me = {
        getSystem: systemApi.get,
        config: Option.none,
        hasConfigured: constant(false),
        connect: connect,
        disconnect: disconnect,
        getApis: function () {
          return {};
        },
        element: constant(extSpec.element),
        spec: constant(spec),
        readState: constant(&apos;No state&apos;),
        syncComponents: noop,
        components: constant([]),
        events: constant({})
      };
      return premade(me);
    };
    var uids = generate$2;
    var build$1 = function (spec) {
      return getPremade(spec).fold(function () {
        var userSpecWithUid = spec.hasOwnProperty(&apos;uid&apos;) ? spec : __assign({ uid: uids(&apos;&apos;) }, spec);
        return buildFromSpec(userSpecWithUid).getOrDie();
      }, function (prebuilt) {
        return prebuilt;
      });
    };
    var premade$1 = premade;

    function Dimension (name, getOffset) {
      var set = function (element, h) {
        if (!isNumber(h) &amp;&amp; !h.match(/^[0-9]+$/)) {
          throw new Error(name + &apos;.set accepts only positive integer values. Value was &apos; + h);
        }
        var dom = element.dom();
        if (isSupported(dom)) {
          dom.style[name] = h + &apos;px&apos;;
        }
      };
      var get = function (element) {
        var r = getOffset(element);
        if (r &lt;= 0 || r === null) {
          var css = get$4(element, name);
          return parseFloat(css) || 0;
        }
        return r;
      };
      var getOuter = get;
      var aggregate = function (element, properties) {
        return foldl(properties, function (acc, property) {
          var val = get$4(element, property);
          var value = val === undefined ? 0 : parseInt(val, 10);
          return isNaN(value) ? acc : acc + value;
        }, 0);
      };
      var max = function (element, value, properties) {
        var cumulativeInclusions = aggregate(element, properties);
        var absoluteMax = value &gt; cumulativeInclusions ? value - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set,
        get: get,
        getOuter: getOuter,
        aggregate: aggregate,
        max: max
      };
    }

    var api = Dimension(&apos;height&apos;, function (element) {
      var dom = element.dom();
      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
    });
    var get$6 = function (element) {
      return api.get(element);
    };
    var getOuter$1 = function (element) {
      return api.getOuter(element);
    };
    var setMax = function (element, value) {
      var inclusions = [
        &apos;margin-top&apos;,
        &apos;border-top-width&apos;,
        &apos;padding-top&apos;,
        &apos;padding-bottom&apos;,
        &apos;border-bottom-width&apos;,
        &apos;margin-bottom&apos;
      ];
      var absMax = api.max(element, value, inclusions);
      set$2(element, &apos;max-height&apos;, absMax + &apos;px&apos;);
    };

    var r = function (left, top) {
      var translate = function (x, y) {
        return r(left + x, top + y);
      };
      return {
        left: constant(left),
        top: constant(top),
        translate: translate
      };
    };
    var Position = r;

    var boxPosition = function (dom) {
      var box = dom.getBoundingClientRect();
      return Position(box.left, box.top);
    };
    var firstDefinedOrZero = function (a, b) {
      if (a !== undefined) {
        return a;
      } else {
        return b !== undefined ? b : 0;
      }
    };
    var absolute = function (element) {
      var doc = element.dom().ownerDocument;
      var body = doc.body;
      var win = doc.defaultView;
      var html = doc.documentElement;
      if (body === element.dom()) {
        return Position(body.offsetLeft, body.offsetTop);
      }
      var scrollTop = firstDefinedOrZero(win.pageYOffset, html.scrollTop);
      var scrollLeft = firstDefinedOrZero(win.pageXOffset, html.scrollLeft);
      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
    };
    var viewport = function (element) {
      var dom = element.dom();
      var doc = dom.ownerDocument;
      var body = doc.body;
      if (body === dom) {
        return Position(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return Position(0, 0);
      }
      return boxPosition(dom);
    };

    var api$1 = Dimension(&apos;width&apos;, function (element) {
      return element.dom().offsetWidth;
    });
    var set$4 = function (element, h) {
      return api$1.set(element, h);
    };
    var get$7 = function (element) {
      return api$1.get(element);
    };
    var getOuter$2 = function (element) {
      return api$1.getOuter(element);
    };
    var setMax$1 = function (element, value) {
      var inclusions = [
        &apos;margin-left&apos;,
        &apos;border-left-width&apos;,
        &apos;padding-left&apos;,
        &apos;padding-right&apos;,
        &apos;border-right-width&apos;,
        &apos;margin-right&apos;
      ];
      var absMax = api$1.max(element, value, inclusions);
      set$2(element, &apos;max-width&apos;, absMax + &apos;px&apos;);
    };

    var mkEvent = function (target, x, y, stop, prevent, kill, raw) {
      return {
        target: constant(target),
        x: constant(x),
        y: constant(y),
        stop: stop,
        prevent: prevent,
        kill: kill,
        raw: constant(raw)
      };
    };
    var fromRawEvent = function (rawEvent) {
      var target = Element.fromDom(rawEvent.target);
      var stop = function () {
        return rawEvent.stopPropagation();
      };
      var prevent = function () {
        return rawEvent.preventDefault();
      };
      var kill = compose(prevent, stop);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);
    };
    var handle = function (filter, handler) {
      return function (rawEvent) {
        if (filter(rawEvent)) {
          handler(fromRawEvent(rawEvent));
        }
      };
    };
    var binder = function (element, event, filter, handler, useCapture) {
      var wrapped = handle(filter, handler);
      element.dom().addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    var bind$2 = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, false);
    };
    var capture = function (element, event, filter, handler) {
      return binder(element, event, filter, handler, true);
    };
    var unbind = function (element, event, handler, useCapture) {
      element.dom().removeEventListener(event, handler, useCapture);
    };

    var get$8 = function (_DOC) {
      var doc = _DOC !== undefined ? _DOC.dom() : domGlobals.document;
      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return Position(x, y);
    };
    var to = function (x, y, _DOC) {
      var doc = _DOC !== undefined ? _DOC.dom() : domGlobals.document;
      var win = doc.defaultView;
      win.scrollTo(x, y);
    };

    var get$9 = function (_win) {
      var win = _win === undefined ? domGlobals.window : _win;
      return Option.from(win[&apos;visualViewport&apos;]);
    };
    var bounds = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var getBounds = function (_win) {
      var win = _win === undefined ? domGlobals.window : _win;
      var doc = win.document;
      var scroll = get$8(Element.fromDom(doc));
      return get$9(win).fold(function () {
        var html = win.document.documentElement;
        var width = html.clientWidth;
        var height = html.clientHeight;
        return bounds(scroll.left(), scroll.top(), width, height);
      }, function (visualViewport) {
        return bounds(Math.max(visualViewport.pageLeft, scroll.left()), Math.max(visualViewport.pageTop, scroll.top()), visualViewport.width, visualViewport.height);
      });
    };

    var walkUp = function (navigation, doc) {
      var frame = navigation.view(doc);
      return frame.fold(constant([]), function (f) {
        var parent = navigation.owner(f);
        var rest = walkUp(navigation, parent);
        return [f].concat(rest);
      });
    };
    var pathTo = function (element, navigation) {
      var d = navigation.owner(element);
      var paths = walkUp(navigation, d);
      return Option.some(paths);
    };

    var view = function (doc) {
      var element = doc.dom() === domGlobals.document ? Option.none() : Option.from(doc.dom().defaultView.frameElement);
      return element.map(Element.fromDom);
    };
    var owner$1 = function (element) {
      return owner(element);
    };

    var Navigation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        view: view,
        owner: owner$1
    });

    var find$3 = function (element) {
      var doc = Element.fromDom(domGlobals.document);
      var scroll = get$8(doc);
      var path = pathTo(element, Navigation);
      return path.fold(curry(absolute, element), function (frames) {
        var offset = viewport(element);
        var r = foldr(frames, function (b, a) {
          var loc = viewport(a);
          return {
            left: b.left + loc.left(),
            top: b.top + loc.top()
          };
        }, {
          left: 0,
          top: 0
        });
        return Position(r.left + offset.left() + scroll.left(), r.top + offset.top() + scroll.top());
      });
    };

    var pointed = function (point, width, height) {
      return {
        point: point,
        width: width,
        height: height
      };
    };
    var rect = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };
    var bounds$1 = function (x, y, width, height) {
      return {
        x: x,
        y: y,
        width: width,
        height: height,
        right: x + width,
        bottom: y + height
      };
    };
    var box = function (element) {
      var xy = absolute(element);
      var w = getOuter$2(element);
      var h = getOuter$1(element);
      return bounds$1(xy.left(), xy.top(), w, h);
    };
    var absolute$1 = function (element) {
      var position = find$3(element);
      var width = getOuter$2(element);
      var height = getOuter$1(element);
      return bounds$1(position.left(), position.top(), width, height);
    };
    var win = function () {
      return getBounds(domGlobals.window);
    };

    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
      return is(scope, a) ? Option.some(scope) : isFunction(isRoot) &amp;&amp; isRoot(scope) ? Option.none() : ancestor(scope, a, isRoot);
    }

    var ancestor$1 = function (scope, predicate, isRoot) {
      var element = scope.dom();
      var stop = isFunction(isRoot) ? isRoot : constant(false);
      while (element.parentNode) {
        element = element.parentNode;
        var el = Element.fromDom(element);
        if (predicate(el)) {
          return Option.some(el);
        } else if (stop(el)) {
          break;
        }
      }
      return Option.none();
    };
    var closest$1 = function (scope, predicate, isRoot) {
      var is = function (s, test) {
        return test(s);
      };
      return ClosestOrAncestor(is, ancestor$1, scope, predicate, isRoot);
    };
    var descendant = function (scope, predicate) {
      var descend = function (node) {
        for (var i = 0; i &lt; node.childNodes.length; i++) {
          var child_1 = Element.fromDom(node.childNodes[i]);
          if (predicate(child_1)) {
            return Option.some(child_1);
          }
          var res = descend(node.childNodes[i]);
          if (res.isSome()) {
            return res;
          }
        }
        return Option.none();
      };
      return descend(scope.dom());
    };

    var closest$2 = function (scope, predicate, isRoot) {
      return closest$1(scope, predicate, isRoot).isSome();
    };

    var ancestor$2 = function (scope, selector, isRoot) {
      return ancestor$1(scope, function (e) {
        return is(e, selector);
      }, isRoot);
    };
    var descendant$1 = function (scope, selector) {
      return one(selector, scope);
    };
    var closest$3 = function (scope, selector, isRoot) {
      var is$1 = function (element, selector) {
        return is(element, selector);
      };
      return ClosestOrAncestor(is$1, ancestor$2, scope, selector, isRoot);
    };

    var find$4 = function (queryElem) {
      var dependent = closest$1(queryElem, function (elem) {
        if (!isElement(elem)) {
          return false;
        }
        var id = get$2(elem, &apos;id&apos;);
        return id !== undefined &amp;&amp; id.indexOf(&apos;aria-owns&apos;) &gt; -1;
      });
      return dependent.bind(function (dep) {
        var id = get$2(dep, &apos;id&apos;);
        var doc = owner(dep);
        return descendant$1(doc, &apos;[aria-owns=&quot;&apos; + id + &apos;&quot;]&apos;);
      });
    };
    var manager = function () {
      var ariaId = generate$1(&apos;aria-owns&apos;);
      var link = function (elem) {
        set$1(elem, &apos;aria-owns&apos;, ariaId);
      };
      var unlink = function (elem) {
        remove$1(elem, &apos;aria-owns&apos;);
      };
      return {
        id: ariaId,
        link: link,
        unlink: unlink
      };
    };

    var isAriaPartOf = function (component, queryElem) {
      return find$4(queryElem).exists(function (owner) {
        return isPartOf(component, owner);
      });
    };
    var isPartOf = function (component, queryElem) {
      return closest$2(queryElem, function (el) {
        return eq$1(el, component.element());
      }, constant(false)) || isAriaPartOf(component, queryElem);
    };

    var unknown$3 = &apos;unknown&apos;;
    var EventConfiguration;
    (function (EventConfiguration) {
      EventConfiguration[EventConfiguration[&apos;STOP&apos;] = 0] = &apos;STOP&apos;;
      EventConfiguration[EventConfiguration[&apos;NORMAL&apos;] = 1] = &apos;NORMAL&apos;;
      EventConfiguration[EventConfiguration[&apos;LOGGING&apos;] = 2] = &apos;LOGGING&apos;;
    }(EventConfiguration || (EventConfiguration = {})));
    var eventConfig = Cell({});
    var makeEventLogger = function (eventName, initialTarget) {
      var sequence = [];
      var startTime = new Date().getTime();
      return {
        logEventCut: function (_name, target, purpose) {
          sequence.push({
            outcome: &apos;cut&apos;,
            target: target,
            purpose: purpose
          });
        },
        logEventStopped: function (_name, target, purpose) {
          sequence.push({
            outcome: &apos;stopped&apos;,
            target: target,
            purpose: purpose
          });
        },
        logNoParent: function (_name, target, purpose) {
          sequence.push({
            outcome: &apos;no-parent&apos;,
            target: target,
            purpose: purpose
          });
        },
        logEventNoHandlers: function (_name, target) {
          sequence.push({
            outcome: &apos;no-handlers-left&apos;,
            target: target
          });
        },
        logEventResponse: function (_name, target, purpose) {
          sequence.push({
            outcome: &apos;response&apos;,
            purpose: purpose,
            target: target
          });
        },
        write: function () {
          var finishTime = new Date().getTime();
          if (contains([
              &apos;mousemove&apos;,
              &apos;mouseover&apos;,
              &apos;mouseout&apos;,
              systemInit()
            ], eventName)) {
            return;
          }
          domGlobals.console.log(eventName, {
            event: eventName,
            time: finishTime - startTime,
            target: initialTarget.dom(),
            sequence: map(sequence, function (s) {
              if (!contains([
                  &apos;cut&apos;,
                  &apos;stopped&apos;,
                  &apos;response&apos;
                ], s.outcome)) {
                return s.outcome;
              } else {
                return &apos;{&apos; + s.purpose + &apos;} &apos; + s.outcome + &apos; at (&apos; + element(s.target) + &apos;)&apos;;
              }
            })
          });
        }
      };
    };
    var processEvent = function (eventName, initialTarget, f) {
      var status = get(eventConfig.get(), eventName).orThunk(function () {
        var patterns = keys(eventConfig.get());
        return findMap(patterns, function (p) {
          return eventName.indexOf(p) &gt; -1 ? Option.some(eventConfig.get()[p]) : Option.none();
        });
      }).getOr(EventConfiguration.NORMAL);
      switch (status) {
      case EventConfiguration.NORMAL:
        return f(noLogger());
      case EventConfiguration.LOGGING: {
          var logger = makeEventLogger(eventName, initialTarget);
          var output = f(logger);
          logger.write();
          return output;
        }
      case EventConfiguration.STOP:
        return true;
      }
    };
    var path = [
      &apos;alloy/data/Fields&apos;,
      &apos;alloy/debugging/Debugging&apos;
    ];
    var getTrace = function () {
      var err = new Error();
      if (err.stack !== undefined) {
        var lines = err.stack.split(&apos;\n&apos;);
        return find(lines, function (line) {
          return line.indexOf(&apos;alloy&apos;) &gt; 0 &amp;&amp; !exists(path, function (p) {
            return line.indexOf(p) &gt; -1;
          });
        }).getOr(unknown$3);
      } else {
        return unknown$3;
      }
    };
    var ignoreEvent = {
      logEventCut: noop,
      logEventStopped: noop,
      logNoParent: noop,
      logEventNoHandlers: noop,
      logEventResponse: noop,
      write: noop
    };
    var monitorEvent = function (eventName, initialTarget, f) {
      return processEvent(eventName, initialTarget, f);
    };
    var noLogger = constant(ignoreEvent);

    var menuFields = constant([
      strict$1(&apos;menu&apos;),
      strict$1(&apos;selectedMenu&apos;)
    ]);
    var itemFields = constant([
      strict$1(&apos;item&apos;),
      strict$1(&apos;selectedItem&apos;)
    ]);
    var schema = constant(objOf(itemFields().concat(menuFields())));
    var itemSchema = constant(objOf(itemFields()));

    var _initSize = strictObjOf(&apos;initSize&apos;, [
      strict$1(&apos;numColumns&apos;),
      strict$1(&apos;numRows&apos;)
    ]);
    var itemMarkers = function () {
      return strictOf(&apos;markers&apos;, itemSchema());
    };
    var tieredMenuMarkers = function () {
      return strictObjOf(&apos;markers&apos;, [strict$1(&apos;backgroundMenu&apos;)].concat(menuFields()).concat(itemFields()));
    };
    var markers = function (required) {
      return strictObjOf(&apos;markers&apos;, map(required, strict$1));
    };
    var onPresenceHandler = function (label, fieldName, presence) {
      var trace = getTrace();
      return field(fieldName, fieldName, presence, valueOf(function (f) {
        return Result.value(function () {
          var args = [];
          for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return f.apply(undefined, args);
        });
      }));
    };
    var onHandler = function (fieldName) {
      return onPresenceHandler(&apos;onHandler&apos;, fieldName, defaulted(noop));
    };
    var onKeyboardHandler = function (fieldName) {
      return onPresenceHandler(&apos;onKeyboardHandler&apos;, fieldName, defaulted(Option.none));
    };
    var onStrictHandler = function (fieldName) {
      return onPresenceHandler(&apos;onHandler&apos;, fieldName, strict());
    };
    var onStrictKeyboardHandler = function (fieldName) {
      return onPresenceHandler(&apos;onKeyboardHandler&apos;, fieldName, strict());
    };
    var output = function (name, value) {
      return state$1(name, constant(value));
    };
    var snapshot = function (name) {
      return state$1(name, identity);
    };
    var initSize = constant(_initSize);

    var nu$7 = function (x, y, bubble, direction, boundsRestriction, label) {
      return {
        x: constant(x),
        y: constant(y),
        bubble: constant(bubble),
        direction: constant(direction),
        boundsRestriction: constant(boundsRestriction),
        label: constant(label)
      };
    };

    var adt$2 = Adt.generate([
      { southeast: [] },
      { southwest: [] },
      { northeast: [] },
      { northwest: [] },
      { south: [] },
      { north: [] },
      { east: [] },
      { west: [] }
    ]);
    var cata = function (subject, southeast, southwest, northeast, northwest, south, north, east, west) {
      return subject.fold(southeast, southwest, northeast, northwest, south, north, east, west);
    };
    var cataVertical = function (subject, south, middle, north) {
      return subject.fold(south, south, north, north, south, north, middle, middle);
    };
    var cataHorizontal = function (subject, east, middle, west) {
      return subject.fold(east, west, east, west, middle, middle, east, west);
    };
    var southeast = adt$2.southeast;
    var southwest = adt$2.southwest;
    var northeast = adt$2.northeast;
    var northwest = adt$2.northwest;
    var south = adt$2.south;
    var north = adt$2.north;
    var east = adt$2.east;
    var west = adt$2.west;

    var getRestriction = function (anchor, restriction) {
      switch (restriction) {
      case 1:
        return anchor.x;
      case 0:
        return anchor.x + anchor.width;
      case 2:
        return anchor.y;
      case 3:
        return anchor.y + anchor.height;
      }
    };
    var boundsRestriction = function (anchor, restrictions) {
      return mapToObject([
        &apos;left&apos;,
        &apos;right&apos;,
        &apos;top&apos;,
        &apos;bottom&apos;
      ], function (dir) {
        return get(restrictions, dir).map(function (restriction) {
          return getRestriction(anchor, restriction);
        });
      });
    };
    var adjustBounds = function (bounds, boundsRestrictions, bubbleOffsets) {
      var applyRestriction = function (dir, current) {
        var bubbleOffset = dir === &apos;top&apos; || dir === &apos;bottom&apos; ? bubbleOffsets.top() : bubbleOffsets.left();
        return get(boundsRestrictions, dir).bind(identity).bind(function (restriction) {
          if (dir === &apos;left&apos; || dir === &apos;top&apos;) {
            return restriction &gt;= current ? Option.some(restriction) : Option.none();
          } else {
            return restriction &lt;= current ? Option.some(restriction) : Option.none();
          }
        }).map(function (restriction) {
          return restriction + bubbleOffset;
        }).getOr(current);
      };
      var adjustedLeft = applyRestriction(&apos;left&apos;, bounds.x);
      var adjustedTop = applyRestriction(&apos;top&apos;, bounds.y);
      var adjustedRight = applyRestriction(&apos;right&apos;, bounds.right);
      var adjustedBottom = applyRestriction(&apos;bottom&apos;, bounds.bottom);
      return bounds$1(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
    };

    var eastX = function (anchor) {
      return anchor.x;
    };
    var middleX = function (anchor, element) {
      return anchor.x + anchor.width / 2 - element.width / 2;
    };
    var westX = function (anchor, element) {
      return anchor.x + anchor.width - element.width;
    };
    var northY = function (anchor, element) {
      return anchor.y - element.height;
    };
    var southY = function (anchor) {
      return anchor.y + anchor.height;
    };
    var centreY = function (anchor, element) {
      return anchor.y + anchor.height / 2 - element.height / 2;
    };
    var eastEdgeX = function (anchor) {
      return anchor.x + anchor.width;
    };
    var westEdgeX = function (anchor, element) {
      return anchor.x - element.width;
    };
    var southeast$1 = function (anchor, element, bubbles) {
      return nu$7(eastX(anchor), southY(anchor), bubbles.southeast(), southeast(), boundsRestriction(anchor, {
        left: 1,
        top: 3
      }), &apos;layout-se&apos;);
    };
    var southwest$1 = function (anchor, element, bubbles) {
      return nu$7(westX(anchor, element), southY(anchor), bubbles.southwest(), southwest(), boundsRestriction(anchor, {
        right: 0,
        top: 3
      }), &apos;layout-sw&apos;);
    };
    var northeast$1 = function (anchor, element, bubbles) {
      return nu$7(eastX(anchor), northY(anchor, element), bubbles.northeast(), northeast(), boundsRestriction(anchor, {
        left: 1,
        bottom: 2
      }), &apos;layout-ne&apos;);
    };
    var northwest$1 = function (anchor, element, bubbles) {
      return nu$7(westX(anchor, element), northY(anchor, element), bubbles.northwest(), northwest(), boundsRestriction(anchor, {
        right: 0,
        bottom: 2
      }), &apos;layout-nw&apos;);
    };
    var north$1 = function (anchor, element, bubbles) {
      return nu$7(middleX(anchor, element), northY(anchor, element), bubbles.north(), north(), boundsRestriction(anchor, { bottom: 2 }), &apos;layout-n&apos;);
    };
    var south$1 = function (anchor, element, bubbles) {
      return nu$7(middleX(anchor, element), southY(anchor), bubbles.south(), south(), boundsRestriction(anchor, { top: 3 }), &apos;layout-s&apos;);
    };
    var east$1 = function (anchor, element, bubbles) {
      return nu$7(eastEdgeX(anchor), centreY(anchor, element), bubbles.east(), east(), boundsRestriction(anchor, { left: 0 }), &apos;layout-e&apos;);
    };
    var west$1 = function (anchor, element, bubbles) {
      return nu$7(westEdgeX(anchor, element), centreY(anchor, element), bubbles.west(), west(), boundsRestriction(anchor, { right: 1 }), &apos;layout-w&apos;);
    };
    var all$2 = function () {
      return [
        southeast$1,
        southwest$1,
        northeast$1,
        northwest$1,
        south$1,
        north$1,
        east$1,
        west$1
      ];
    };
    var allRtl = function () {
      return [
        southwest$1,
        southeast$1,
        northwest$1,
        northeast$1,
        south$1,
        north$1,
        east$1,
        west$1
      ];
    };
    var aboveOrBelow = function () {
      return [
        northeast$1,
        northwest$1,
        southeast$1,
        southwest$1,
        north$1,
        south$1
      ];
    };
    var aboveOrBelowRtl = function () {
      return [
        northwest$1,
        northeast$1,
        southwest$1,
        southeast$1,
        north$1,
        south$1
      ];
    };
    var belowOrAbove = function () {
      return [
        southeast$1,
        southwest$1,
        northeast$1,
        northwest$1,
        south$1,
        north$1
      ];
    };
    var belowOrAboveRtl = function () {
      return [
        southwest$1,
        southeast$1,
        northwest$1,
        northeast$1,
        south$1,
        north$1
      ];
    };

    var executeEvent = function (bConfig, bState, executor) {
      return runOnExecute(function (component) {
        executor(component, bConfig, bState);
      });
    };
    var loadEvent = function (bConfig, bState, f) {
      return runOnInit(function (component, _simulatedEvent) {
        f(component, bConfig, bState);
      });
    };
    var create = function (schema, name, active, apis, extra, state) {
      var configSchema = objOfOnly(schema);
      var schemaSchema = optionObjOf(name, [optionObjOfOnly(&apos;config&apos;, schema)]);
      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    var createModes = function (modes, name, active, apis, extra, state) {
      var configSchema = modes;
      var schemaSchema = optionObjOf(name, [optionOf(&apos;config&apos;, modes)]);
      return doCreate(configSchema, schemaSchema, name, active, apis, extra, state);
    };
    var wrapApi = function (bName, apiFunction, apiName) {
      var f = function (component) {
        var rest = [];
        for (var _i = 1; _i &lt; arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        var args = [component].concat(rest);
        return component.config({ name: constant(bName) }).fold(function () {
          throw new Error(&apos;We could not find any behaviour configuration for: &apos; + bName + &apos;. Using API: &apos; + apiName);
        }, function (info) {
          var rest = Array.prototype.slice.call(args, 1);
          return apiFunction.apply(undefined, [
            component,
            info.config,
            info.state
          ].concat(rest));
        });
      };
      return markAsBehaviourApi(f, apiName, apiFunction);
    };
    var revokeBehaviour = function (name) {
      return {
        key: name,
        value: undefined
      };
    };
    var doCreate = function (configSchema, schemaSchema, name, active, apis, extra, state) {
      var getConfig = function (info) {
        return hasNonNullableKey(info, name) ? info[name]() : Option.none();
      };
      var wrappedApis = map$1(apis, function (apiF, apiName) {
        return wrapApi(name, apiF, apiName);
      });
      var wrappedExtra = map$1(extra, function (extraF, extraName) {
        return markAsExtraApi(extraF, extraName);
      });
      var me = __assign(__assign(__assign({}, wrappedExtra), wrappedApis), {
        revoke: curry(revokeBehaviour, name),
        config: function (spec) {
          var prepared = asRawOrDie(name + &apos;-config&apos;, configSchema, spec);
          return {
            key: name,
            value: {
              config: prepared,
              me: me,
              configAsRaw: cached(function () {
                return asRawOrDie(name + &apos;-config&apos;, configSchema, spec);
              }),
              initialConfig: spec,
              state: state
            }
          };
        },
        schema: function () {
          return schemaSchema;
        },
        exhibit: function (info, base) {
          return getConfig(info).bind(function (behaviourInfo) {
            return get(active, &apos;exhibit&apos;).map(function (exhibitor) {
              return exhibitor(base, behaviourInfo.config, behaviourInfo.state);
            });
          }).getOr(nu$6({}));
        },
        name: function () {
          return name;
        },
        handlers: function (info) {
          return getConfig(info).map(function (behaviourInfo) {
            var getEvents = get(active, &apos;events&apos;).getOr(function () {
              return {};
            });
            return getEvents(behaviourInfo.config, behaviourInfo.state);
          }).getOr({});
        }
      });
      return me;
    };

    var derive$1 = function (capabilities) {
      return wrapAll$1(capabilities);
    };
    var simpleSchema = objOfOnly([
      strict$1(&apos;fields&apos;),
      strict$1(&apos;name&apos;),
      defaulted$1(&apos;active&apos;, {}),
      defaulted$1(&apos;apis&apos;, {}),
      defaulted$1(&apos;state&apos;, NoState),
      defaulted$1(&apos;extra&apos;, {})
    ]);
    var create$1 = function (data) {
      var value = asRawOrDie(&apos;Creating behaviour: &apos; + data.name, simpleSchema, data);
      return create(value.fields, value.name, value.active, value.apis, value.extra, value.state);
    };
    var modeSchema = objOfOnly([
      strict$1(&apos;branchKey&apos;),
      strict$1(&apos;branches&apos;),
      strict$1(&apos;name&apos;),
      defaulted$1(&apos;active&apos;, {}),
      defaulted$1(&apos;apis&apos;, {}),
      defaulted$1(&apos;state&apos;, NoState),
      defaulted$1(&apos;extra&apos;, {})
    ]);
    var createModes$1 = function (data) {
      var value = asRawOrDie(&apos;Creating behaviour: &apos; + data.name, modeSchema, data);
      return createModes(choose$1(value.branchKey, value.branches), value.name, value.active, value.apis, value.extra, value.state);
    };
    var revoke = constant(undefined);

    var chooseChannels = function (channels, message) {
      return message.universal() ? channels : filter(channels, function (ch) {
        return contains(message.channels(), ch);
      });
    };
    var events$1 = function (receiveConfig) {
      return derive([run(receive(), function (component, message) {
          var channelMap = receiveConfig.channels;
          var channels = keys(channelMap);
          var receivingData = message;
          var targetChannels = chooseChannels(channels, receivingData);
          each(targetChannels, function (ch) {
            var channelInfo = channelMap[ch];
            var channelSchema = channelInfo.schema;
            var data = asRawOrDie(&apos;channel[&apos; + ch + &apos;] data\nReceiver: &apos; + element(component.element()), channelSchema, receivingData.data());
            channelInfo.onReceive(component, data);
          });
        })]);
    };

    var ActiveReceiving = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$1
    });

    var ReceivingSchema = [strictOf(&apos;channels&apos;, setOf$1(Result.value, objOfOnly([
        onStrictHandler(&apos;onReceive&apos;),
        defaulted$1(&apos;schema&apos;, anyValue$1())
      ])))];

    var Receiving = create$1({
      fields: ReceivingSchema,
      name: &apos;receiving&apos;,
      active: ActiveReceiving
    });

    var exhibit = function (base, posConfig) {
      return nu$6({
        classes: [],
        styles: posConfig.useFixed() ? {} : { position: &apos;relative&apos; }
      });
    };

    var ActivePosition = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit
    });

    var focus$1 = function (element) {
      return element.dom().focus();
    };
    var blur = function (element) {
      return element.dom().blur();
    };
    var hasFocus = function (element) {
      var doc = owner(element).dom();
      return element.dom() === doc.activeElement;
    };
    var active = function (_doc) {
      var doc = _doc !== undefined ? _doc.dom() : domGlobals.document;
      return Option.from(doc.activeElement).map(Element.fromDom);
    };
    var search = function (element) {
      return active(owner(element)).filter(function (e) {
        return element.dom().contains(e.dom());
      });
    };

    var preserve = function (f, container) {
      var ownerDoc = owner(container);
      var refocus = active(ownerDoc).bind(function (focused) {
        var hasFocus = function (elem) {
          return eq$1(focused, elem);
        };
        return hasFocus(container) ? Option.some(container) : descendant(container, hasFocus);
      });
      var result = f(container);
      refocus.each(function (oldFocus) {
        active(ownerDoc).filter(function (newFocus) {
          return eq$1(newFocus, oldFocus);
        }).fold(function () {
          focus$1(oldFocus);
        }, noop);
      });
      return result;
    };

    var NuPositionCss = function (position, left, top, right, bottom) {
      return {
        position: constant(position),
        left: constant(left),
        top: constant(top),
        right: constant(right),
        bottom: constant(bottom)
      };
    };
    var applyPositionCss = function (element, position) {
      var addPx = function (num) {
        return num + &apos;px&apos;;
      };
      setOptions(element, {
        position: Option.some(position.position()),
        left: position.left().map(addPx),
        top: position.top().map(addPx),
        right: position.right().map(addPx),
        bottom: position.bottom().map(addPx)
      });
    };

    var adt$3 = Adt.generate([
      { none: [] },
      {
        relative: [
          &apos;x&apos;,
          &apos;y&apos;,
          &apos;width&apos;,
          &apos;height&apos;
        ]
      },
      {
        fixed: [
          &apos;x&apos;,
          &apos;y&apos;,
          &apos;width&apos;,
          &apos;height&apos;
        ]
      }
    ]);
    var positionWithDirection = function (posName, decision, x, y, width, height) {
      var decisionX = decision.x - x;
      var decisionY = decision.y - y;
      var decisionWidth = decision.width;
      var decisionHeight = decision.height;
      var decisionRight = width - (decisionX + decisionWidth);
      var decisionBottom = height - (decisionY + decisionHeight);
      var left = Option.some(decisionX);
      var top = Option.some(decisionY);
      var right = Option.some(decisionRight);
      var bottom = Option.some(decisionBottom);
      var none = Option.none();
      return cata(decision.direction, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, none, top, right, none);
      }, function () {
        return NuPositionCss(posName, left, none, none, bottom);
      }, function () {
        return NuPositionCss(posName, none, none, right, bottom);
      }, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, left, none, none, bottom);
      }, function () {
        return NuPositionCss(posName, left, top, none, none);
      }, function () {
        return NuPositionCss(posName, none, top, right, none);
      });
    };
    var reposition = function (origin, decision) {
      return origin.fold(function () {
        return NuPositionCss(&apos;absolute&apos;, Option.some(decision.x), Option.some(decision.y), Option.none(), Option.none());
      }, function (x, y, width, height) {
        return positionWithDirection(&apos;absolute&apos;, decision, x, y, width, height);
      }, function (x, y, width, height) {
        return positionWithDirection(&apos;fixed&apos;, decision, x, y, width, height);
      });
    };
    var toBox = function (origin, element) {
      var rel = curry(find$3, element);
      var position = origin.fold(rel, rel, function () {
        var scroll = get$8();
        return find$3(element).translate(-scroll.left(), -scroll.top());
      });
      var width = getOuter$2(element);
      var height = getOuter$1(element);
      return bounds$1(position.left(), position.top(), width, height);
    };
    var viewport$1 = function (origin, getBounds) {
      return getBounds.fold(function () {
        return origin.fold(win, win, bounds$1);
      }, function (b) {
        return origin.fold(b, b, function () {
          var bounds = b();
          var pos = translate(origin, bounds.x, bounds.y);
          return bounds$1(pos.left(), pos.top(), bounds.width, bounds.height);
        });
      });
    };
    var translate = function (origin, x, y) {
      var pos = Position(x, y);
      var removeScroll = function () {
        var outerScroll = get$8();
        return pos.translate(-outerScroll.left(), -outerScroll.top());
      };
      return origin.fold(constant(pos), constant(pos), removeScroll);
    };
    var cata$1 = function (subject, onNone, onRelative, onFixed) {
      return subject.fold(onNone, onRelative, onFixed);
    };
    var none$1 = adt$3.none;
    var relative = adt$3.relative;
    var fixed = adt$3.fixed;

    var anchor = function (anchorBox, origin) {
      return {
        anchorBox: constant(anchorBox),
        origin: constant(origin)
      };
    };
    var box$1 = function (anchorBox, origin) {
      return anchor(anchorBox, origin);
    };

    var cycleBy = function (value, delta, min, max) {
      var r = value + delta;
      return r &gt; max ? min : r &lt; min ? max : r;
    };
    var clamp = function (value, min, max) {
      return Math.min(Math.max(value, min), max);
    };

    var adt$4 = Adt.generate([
      { fit: [&apos;reposition&apos;] },
      {
        nofit: [
          &apos;reposition&apos;,
          &apos;deltaW&apos;,
          &apos;deltaH&apos;
        ]
      }
    ]);
    var calcReposition = function (newX, newY, width, height, bounds) {
      var boundsX = bounds.x;
      var boundsY = bounds.y;
      var boundsWidth = bounds.width;
      var boundsHeight = bounds.height;
      var xInBounds = newX &gt;= boundsX;
      var yInBounds = newY &gt;= boundsY;
      var originInBounds = xInBounds &amp;&amp; yInBounds;
      var xFit = newX + width &lt;= boundsX + boundsWidth;
      var yFit = newY + height &lt;= boundsY + boundsHeight;
      var sizeInBounds = xFit &amp;&amp; yFit;
      var deltaW = Math.abs(Math.min(width, xInBounds ? boundsX + boundsWidth - newX : boundsX - (newX + width)));
      var deltaH = Math.abs(Math.min(height, yInBounds ? boundsY + boundsHeight - newY : boundsY - (newY + height)));
      var maxX = Math.max(bounds.x, bounds.right - width);
      var maxY = Math.max(bounds.y, bounds.bottom - height);
      var limitX = clamp(newX, bounds.x, maxX);
      var limitY = clamp(newY, bounds.y, maxY);
      return {
        originInBounds: originInBounds,
        sizeInBounds: sizeInBounds,
        limitX: limitX,
        limitY: limitY,
        deltaW: deltaW,
        deltaH: deltaH
      };
    };
    var attempt = function (candidate, width, height, bounds) {
      var candidateX = candidate.x();
      var candidateY = candidate.y();
      var bubbleOffsets = candidate.bubble().offset();
      var bubbleLeft = bubbleOffsets.left();
      var bubbleTop = bubbleOffsets.top();
      var adjustedBounds = adjustBounds(bounds, candidate.boundsRestriction(), bubbleOffsets);
      var boundsY = adjustedBounds.y;
      var boundsBottom = adjustedBounds.bottom;
      var boundsX = adjustedBounds.x;
      var boundsRight = adjustedBounds.right;
      var newX = candidateX + bubbleLeft;
      var newY = candidateY + bubbleTop;
      var _a = calcReposition(newX, newY, width, height, adjustedBounds), originInBounds = _a.originInBounds, sizeInBounds = _a.sizeInBounds, limitX = _a.limitX, limitY = _a.limitY, deltaW = _a.deltaW, deltaH = _a.deltaH;
      var upAvailable = constant(limitY + deltaH - boundsY);
      var downAvailable = constant(boundsBottom - limitY);
      var maxHeight = cataVertical(candidate.direction(), downAvailable, downAvailable, upAvailable);
      var westAvailable = constant(limitX + deltaW - boundsX);
      var eastAvailable = constant(boundsRight - limitX);
      var maxWidth = cataHorizontal(candidate.direction(), eastAvailable, eastAvailable, westAvailable);
      var reposition = {
        x: limitX,
        y: limitY,
        width: deltaW,
        height: deltaH,
        maxHeight: maxHeight,
        maxWidth: maxWidth,
        direction: candidate.direction(),
        classes: {
          on: candidate.bubble().classesOn(),
          off: candidate.bubble().classesOff()
        },
        label: candidate.label(),
        candidateYforTest: newY
      };
      return originInBounds &amp;&amp; sizeInBounds ? adt$4.fit(reposition) : adt$4.nofit(reposition, deltaW, deltaH);
    };
    var attempts = function (candidates, anchorBox, elementBox, bubbles, bounds) {
      var panelWidth = elementBox.width;
      var panelHeight = elementBox.height;
      var attemptBestFit = function (layout, reposition, deltaW, deltaH) {
        var next = layout(anchorBox, elementBox, bubbles);
        var attemptLayout = attempt(next, panelWidth, panelHeight, bounds);
        return attemptLayout.fold(adt$4.fit, function (newReposition, newDeltaW, newDeltaH) {
          var improved = newDeltaH &gt; deltaH || newDeltaW &gt; deltaW;
          return improved ? adt$4.nofit(newReposition, newDeltaW, newDeltaH) : adt$4.nofit(reposition, deltaW, deltaH);
        });
      };
      var abc = foldl(candidates, function (b, a) {
        var bestNext = curry(attemptBestFit, a);
        return b.fold(adt$4.fit, bestNext);
      }, adt$4.nofit({
        x: anchorBox.x,
        y: anchorBox.y,
        width: elementBox.width,
        height: elementBox.height,
        maxHeight: elementBox.height,
        maxWidth: elementBox.width,
        direction: southeast(),
        classes: {
          on: [],
          off: []
        },
        label: &apos;none&apos;,
        candidateYforTest: anchorBox.y
      }, -1, -1));
      return abc.fold(identity, identity);
    };

    var elementSize = function (p) {
      return {
        width: getOuter$2(p),
        height: getOuter$1(p)
      };
    };
    var layout = function (anchorBox, element, bubbles, options) {
      remove$6(element, &apos;max-height&apos;);
      remove$6(element, &apos;max-width&apos;);
      var elementBox = elementSize(element);
      return attempts(options.preference, anchorBox, elementBox, bubbles, options.bounds);
    };
    var setClasses = function (element, decision) {
      var classInfo = decision.classes;
      remove$5(element, classInfo.off);
      add$3(element, classInfo.on);
    };
    var setHeight = function (element, decision, options) {
      var maxHeightFunction = options.maxHeightFunction;
      maxHeightFunction(element, decision.maxHeight);
    };
    var setWidth = function (element, decision, options) {
      var maxWidthFunction = options.maxWidthFunction;
      maxWidthFunction(element, decision.maxWidth);
    };
    var position = function (element, decision, options) {
      applyPositionCss(element, reposition(options.origin, decision));
    };

    var setMaxHeight = function (element, maxHeight) {
      setMax(element, Math.floor(maxHeight));
    };
    var anchored = constant(function (element, available) {
      setMaxHeight(element, available);
      setAll$1(element, {
        &apos;overflow-x&apos;: &apos;hidden&apos;,
        &apos;overflow-y&apos;: &apos;auto&apos;
      });
    });
    var expandable = constant(function (element, available) {
      setMaxHeight(element, available);
    });

    var defaultOr = function (options, key, dephault) {
      return options[key] === undefined ? dephault : options[key];
    };
    var simple = function (anchor, element, bubble, layouts, getBounds, overrideOptions) {
      var maxHeightFunction = defaultOr(overrideOptions, &apos;maxHeightFunction&apos;, anchored());
      var maxWidthFunction = defaultOr(overrideOptions, &apos;maxWidthFunction&apos;, noop);
      var anchorBox = anchor.anchorBox();
      var origin = anchor.origin();
      var options = {
        bounds: viewport$1(origin, getBounds),
        origin: origin,
        preference: layouts,
        maxHeightFunction: maxHeightFunction,
        maxWidthFunction: maxWidthFunction
      };
      go(anchorBox, element, bubble, options);
    };
    var go = function (anchorBox, element, bubble, options) {
      var decision = layout(anchorBox, element, bubble, options);
      position(element, decision, options);
      setClasses(element, decision);
      setHeight(element, decision, options);
      setWidth(element, decision, options);
    };

    var allAlignments = [
      &apos;valignCentre&apos;,
      &apos;alignLeft&apos;,
      &apos;alignRight&apos;,
      &apos;alignCentre&apos;,
      &apos;top&apos;,
      &apos;bottom&apos;,
      &apos;left&apos;,
      &apos;right&apos;
    ];
    var nu$8 = function (width, yoffset, classes) {
      var getClasses = function (prop) {
        return get(classes, prop).getOr([]);
      };
      var make = function (xDelta, yDelta, alignmentsOn) {
        var alignmentsOff = difference(allAlignments, alignmentsOn);
        return {
          offset: function () {
            return Position(xDelta, yDelta);
          },
          classesOn: function () {
            return bind(alignmentsOn, getClasses);
          },
          classesOff: function () {
            return bind(alignmentsOff, getClasses);
          }
        };
      };
      return {
        southeast: function () {
          return make(-width, yoffset, [
            &apos;top&apos;,
            &apos;alignLeft&apos;
          ]);
        },
        southwest: function () {
          return make(width, yoffset, [
            &apos;top&apos;,
            &apos;alignRight&apos;
          ]);
        },
        south: function () {
          return make(-width / 2, yoffset, [
            &apos;top&apos;,
            &apos;alignCentre&apos;
          ]);
        },
        northeast: function () {
          return make(-width, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignLeft&apos;
          ]);
        },
        northwest: function () {
          return make(width, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignRight&apos;
          ]);
        },
        north: function () {
          return make(-width / 2, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignCentre&apos;
          ]);
        },
        east: function () {
          return make(width, -yoffset / 2, [
            &apos;valignCentre&apos;,
            &apos;left&apos;
          ]);
        },
        west: function () {
          return make(-width, -yoffset / 2, [
            &apos;valignCentre&apos;,
            &apos;right&apos;
          ]);
        },
        innerNorthwest: function () {
          return make(-width, yoffset, [
            &apos;top&apos;,
            &apos;alignRight&apos;
          ]);
        },
        innerNortheast: function () {
          return make(width, yoffset, [
            &apos;top&apos;,
            &apos;alignLeft&apos;
          ]);
        },
        innerNorth: function () {
          return make(-width / 2, yoffset, [
            &apos;top&apos;,
            &apos;alignCentre&apos;
          ]);
        },
        innerSouthwest: function () {
          return make(-width, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignRight&apos;
          ]);
        },
        innerSoutheast: function () {
          return make(width, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignLeft&apos;
          ]);
        },
        innerSouth: function () {
          return make(-width / 2, -yoffset, [
            &apos;bottom&apos;,
            &apos;alignCentre&apos;
          ]);
        },
        innerWest: function () {
          return make(width, -yoffset / 2, [
            &apos;valignCentre&apos;,
            &apos;right&apos;
          ]);
        },
        innerEast: function () {
          return make(-width, -yoffset / 2, [
            &apos;valignCentre&apos;,
            &apos;left&apos;
          ]);
        }
      };
    };
    var fallback = function () {
      return nu$8(0, 0, {});
    };

    var nu$9 = function (x) {
      return x;
    };

    var onDirection = function (isLtr, isRtl) {
      return function (element) {
        return getDirection(element) === &apos;rtl&apos; ? isRtl : isLtr;
      };
    };
    var getDirection = function (element) {
      return get$4(element, &apos;direction&apos;) === &apos;rtl&apos; ? &apos;rtl&apos; : &apos;ltr&apos;;
    };

    var AttributeValue;
    (function (AttributeValue) {
      AttributeValue[&apos;TopToBottom&apos;] = &apos;toptobottom&apos;;
      AttributeValue[&apos;BottomToTop&apos;] = &apos;bottomtotop&apos;;
    }(AttributeValue || (AttributeValue = {})));
    var Attribute = &apos;data-alloy-vertical-dir&apos;;
    var isBottomToTopDir = function (el) {
      return closest$2(el, function (current) {
        return isElement(current) &amp;&amp; get$2(current, Attribute) === AttributeValue.BottomToTop;
      });
    };

    var schema$1 = function () {
      return optionObjOf(&apos;layouts&apos;, [
        strict$1(&apos;onLtr&apos;),
        strict$1(&apos;onRtl&apos;),
        option(&apos;onBottomLtr&apos;),
        option(&apos;onBottomRtl&apos;)
      ]);
    };
    var get$a = function (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) {
      var isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
      var customLtr = info.layouts.map(function (ls) {
        return ls.onLtr(elem);
      });
      var customRtl = info.layouts.map(function (ls) {
        return ls.onRtl(elem);
      });
      var ltr = isBottomToTop ? info.layouts.bind(function (ls) {
        return ls.onBottomLtr.map(function (f) {
          return f(elem);
        });
      }).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);
      var rtl = isBottomToTop ? info.layouts.bind(function (ls) {
        return ls.onBottomRtl.map(function (f) {
          return f(elem);
        });
      }).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);
      var f = onDirection(ltr, rtl);
      return f(elem);
    };

    var placement = function (component, anchorInfo, origin) {
      var hotspot = anchorInfo.hotspot;
      var anchorBox = toBox(origin, hotspot.element());
      var layouts = get$a(component.element(), anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Option.some(anchorInfo.hotspot.element()));
      return Option.some(nu$9({
        anchorBox: anchorBox,
        bubble: anchorInfo.bubble.getOr(fallback()),
        overrides: anchorInfo.overrides,
        layouts: layouts,
        placer: Option.none()
      }));
    };
    var HotspotAnchor = [
      strict$1(&apos;hotspot&apos;),
      option(&apos;bubble&apos;),
      defaulted$1(&apos;overrides&apos;, {}),
      schema$1(),
      output(&apos;placement&apos;, placement)
    ];

    var placement$1 = function (component, anchorInfo, origin) {
      var pos = translate(origin, anchorInfo.x, anchorInfo.y);
      var anchorBox = bounds$1(pos.left(), pos.top(), anchorInfo.width, anchorInfo.height);
      var layouts = get$a(component.element(), anchorInfo, all$2(), allRtl(), all$2(), allRtl(), Option.none());
      return Option.some(nu$9({
        anchorBox: anchorBox,
        bubble: anchorInfo.bubble,
        overrides: anchorInfo.overrides,
        layouts: layouts,
        placer: Option.none()
      }));
    };
    var MakeshiftAnchor = [
      strict$1(&apos;x&apos;),
      strict$1(&apos;y&apos;),
      defaulted$1(&apos;height&apos;, 0),
      defaulted$1(&apos;width&apos;, 0),
      defaulted$1(&apos;bubble&apos;, fallback()),
      defaulted$1(&apos;overrides&apos;, {}),
      schema$1(),
      output(&apos;placement&apos;, placement$1)
    ];

    var zeroWidth = &apos;\uFEFF&apos;;
    var nbsp = &apos;\xA0&apos;;

    var create$2 = function (start, soffset, finish, foffset) {
      return {
        start: constant(start),
        soffset: constant(soffset),
        finish: constant(finish),
        foffset: constant(foffset)
      };
    };
    var SimRange = { create: create$2 };

    var adt$5 = Adt.generate([
      { before: [&apos;element&apos;] },
      {
        on: [
          &apos;element&apos;,
          &apos;offset&apos;
        ]
      },
      { after: [&apos;element&apos;] }
    ]);
    var cata$2 = function (subject, onBefore, onOn, onAfter) {
      return subject.fold(onBefore, onOn, onAfter);
    };
    var getStart = function (situ) {
      return situ.fold(identity, identity, identity);
    };
    var before$2 = adt$5.before;
    var on = adt$5.on;
    var after$1 = adt$5.after;
    var Situ = {
      before: before$2,
      on: on,
      after: after$1,
      cata: cata$2,
      getStart: getStart
    };

    var adt$6 = Adt.generate([
      { domRange: [&apos;rng&apos;] },
      {
        relative: [
          &apos;startSitu&apos;,
          &apos;finishSitu&apos;
        ]
      },
      {
        exact: [
          &apos;start&apos;,
          &apos;soffset&apos;,
          &apos;finish&apos;,
          &apos;foffset&apos;
        ]
      }
    ]);
    var exactFromRange = function (simRange) {
      return adt$6.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
    };
    var getStart$1 = function (selection) {
      return selection.match({
        domRange: function (rng) {
          return Element.fromDom(rng.startContainer);
        },
        relative: function (startSitu, _finishSitu) {
          return Situ.getStart(startSitu);
        },
        exact: function (start, _soffset, _finish, _foffset) {
          return start;
        }
      });
    };
    var domRange = adt$6.domRange;
    var relative$1 = adt$6.relative;
    var exact = adt$6.exact;
    var getWin = function (selection) {
      var start = getStart$1(selection);
      return defaultView(start);
    };
    var range$1 = SimRange.create;
    var Selection = {
      domRange: domRange,
      relative: relative$1,
      exact: exact,
      exactFromRange: exactFromRange,
      getWin: getWin,
      range: range$1
    };

    var setStart = function (rng, situ) {
      situ.fold(function (e) {
        rng.setStartBefore(e.dom());
      }, function (e, o) {
        rng.setStart(e.dom(), o);
      }, function (e) {
        rng.setStartAfter(e.dom());
      });
    };
    var setFinish = function (rng, situ) {
      situ.fold(function (e) {
        rng.setEndBefore(e.dom());
      }, function (e, o) {
        rng.setEnd(e.dom(), o);
      }, function (e) {
        rng.setEndAfter(e.dom());
      });
    };
    var relativeToNative = function (win, startSitu, finishSitu) {
      var range = win.document.createRange();
      setStart(range, startSitu);
      setFinish(range, finishSitu);
      return range;
    };
    var exactToNative = function (win, start, soffset, finish, foffset) {
      var rng = win.document.createRange();
      rng.setStart(start.dom(), soffset);
      rng.setEnd(finish.dom(), foffset);
      return rng;
    };
    var toRect = function (rect) {
      return {
        left: constant(rect.left),
        top: constant(rect.top),
        right: constant(rect.right),
        bottom: constant(rect.bottom),
        width: constant(rect.width),
        height: constant(rect.height)
      };
    };
    var getFirstRect = function (rng) {
      var rects = rng.getClientRects();
      var rect = rects.length &gt; 0 ? rects[0] : rng.getBoundingClientRect();
      return rect.width &gt; 0 || rect.height &gt; 0 ? Option.some(rect).map(toRect) : Option.none();
    };

    var adt$7 = Adt.generate([
      {
        ltr: [
          &apos;start&apos;,
          &apos;soffset&apos;,
          &apos;finish&apos;,
          &apos;foffset&apos;
        ]
      },
      {
        rtl: [
          &apos;start&apos;,
          &apos;soffset&apos;,
          &apos;finish&apos;,
          &apos;foffset&apos;
        ]
      }
    ]);
    var fromRange = function (win, type, range) {
      return type(Element.fromDom(range.startContainer), range.startOffset, Element.fromDom(range.endContainer), range.endOffset);
    };
    var getRanges = function (win, selection) {
      return selection.match({
        domRange: function (rng) {
          return {
            ltr: constant(rng),
            rtl: Option.none
          };
        },
        relative: function (startSitu, finishSitu) {
          return {
            ltr: cached(function () {
              return relativeToNative(win, startSitu, finishSitu);
            }),
            rtl: cached(function () {
              return Option.some(relativeToNative(win, finishSitu, startSitu));
            })
          };
        },
        exact: function (start, soffset, finish, foffset) {
          return {
            ltr: cached(function () {
              return exactToNative(win, start, soffset, finish, foffset);
            }),
            rtl: cached(function () {
              return Option.some(exactToNative(win, finish, foffset, start, soffset));
            })
          };
        }
      });
    };
    var doDiagnose = function (win, ranges) {
      var rng = ranges.ltr();
      if (rng.collapsed) {
        var reversed = ranges.rtl().filter(function (rev) {
          return rev.collapsed === false;
        });
        return reversed.map(function (rev) {
          return adt$7.rtl(Element.fromDom(rev.endContainer), rev.endOffset, Element.fromDom(rev.startContainer), rev.startOffset);
        }).getOrThunk(function () {
          return fromRange(win, adt$7.ltr, rng);
        });
      } else {
        return fromRange(win, adt$7.ltr, rng);
      }
    };
    var diagnose = function (win, selection) {
      var ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    var asLtrRange = function (win, selection) {
      var diagnosis = diagnose(win, selection);
      return diagnosis.match({
        ltr: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(start.dom(), soffset);
          rng.setEnd(finish.dom(), foffset);
          return rng;
        },
        rtl: function (start, soffset, finish, foffset) {
          var rng = win.document.createRange();
          rng.setStart(finish.dom(), foffset);
          rng.setEnd(start.dom(), soffset);
          return rng;
        }
      });
    };
    var ltr = adt$7.ltr;
    var rtl = adt$7.rtl;

    function NodeValue (is, name) {
      var get = function (element) {
        if (!is(element)) {
          throw new Error(&apos;Can only get &apos; + name + &apos; value of a &apos; + name + &apos; node&apos;);
        }
        return getOption(element).getOr(&apos;&apos;);
      };
      var getOption = function (element) {
        return is(element) ? Option.from(element.dom().nodeValue) : Option.none();
      };
      var set = function (element, value) {
        if (!is(element)) {
          throw new Error(&apos;Can only set raw &apos; + name + &apos; value of a &apos; + name + &apos; node&apos;);
        }
        element.dom().nodeValue = value;
      };
      return {
        get: get,
        getOption: getOption,
        set: set
      };
    }

    var api$2 = NodeValue(isText, &apos;text&apos;);
    var get$b = function (element) {
      return api$2.get(element);
    };
    var getOption = function (element) {
      return api$2.getOption(element);
    };

    var getEnd = function (element) {
      return name(element) === &apos;img&apos; ? 1 : getOption(element).fold(function () {
        return children(element).length;
      }, function (v) {
        return v.length;
      });
    };
    var isTextNodeWithCursorPosition = function (el) {
      return getOption(el).filter(function (text) {
        return text.trim().length !== 0 || text.indexOf(nbsp) &gt; -1;
      }).isSome();
    };
    var elementsWithCursorPosition = [
      &apos;img&apos;,
      &apos;br&apos;
    ];
    var isCursorPosition = function (elem) {
      var hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains(elementsWithCursorPosition, name(elem));
    };

    var last$1 = function (element) {
      return descendantRtl(element, isCursorPosition);
    };
    var descendantRtl = function (scope, predicate) {
      var descend = function (element) {
        var children$1 = children(element);
        for (var i = children$1.length - 1; i &gt;= 0; i--) {
          var child = children$1[i];
          if (predicate(child)) {
            return Option.some(child);
          }
          var res = descend(child);
          if (res.isSome()) {
            return res;
          }
        }
        return Option.none();
      };
      return descend(scope);
    };

    var descendants = function (scope, selector) {
      return all(selector, scope);
    };

    var makeRange = function (start, soffset, finish, foffset) {
      var doc = owner(start);
      var rng = doc.dom().createRange();
      rng.setStart(start.dom(), soffset);
      rng.setEnd(finish.dom(), foffset);
      return rng;
    };
    var after$2 = function (start, soffset, finish, foffset) {
      var r = makeRange(start, soffset, finish, foffset);
      var same = eq$1(start, finish) &amp;&amp; soffset === foffset;
      return r.collapsed &amp;&amp; !same;
    };

    var readRange = function (selection) {
      if (selection.rangeCount &gt; 0) {
        var firstRng = selection.getRangeAt(0);
        var lastRng = selection.getRangeAt(selection.rangeCount - 1);
        return Option.some(SimRange.create(Element.fromDom(firstRng.startContainer), firstRng.startOffset, Element.fromDom(lastRng.endContainer), lastRng.endOffset));
      } else {
        return Option.none();
      }
    };
    var doGetExact = function (selection) {
      var anchor = Element.fromDom(selection.anchorNode);
      var focus = Element.fromDom(selection.focusNode);
      return after$2(anchor, selection.anchorOffset, focus, selection.focusOffset) ? Option.some(SimRange.create(anchor, selection.anchorOffset, focus, selection.focusOffset)) : readRange(selection);
    };
    var getExact = function (win) {
      return Option.from(win.getSelection()).filter(function (sel) {
        return sel.rangeCount &gt; 0;
      }).bind(doGetExact);
    };
    var getFirstRect$1 = function (win, selection) {
      var rng = asLtrRange(win, selection);
      return getFirstRect(rng);
    };

    var point = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };
    var descendOnce = function (element, offset) {
      var children$1 = children(element);
      if (children$1.length === 0) {
        return point(element, offset);
      } else if (offset &lt; children$1.length) {
        return point(children$1[offset], 0);
      } else {
        var last = children$1[children$1.length - 1];
        var len = isText(last) ? get$b(last).length : children(last).length;
        return point(last, len);
      }
    };

    var adt$8 = Adt.generate([
      { screen: [&apos;point&apos;] },
      {
        absolute: [
          &apos;point&apos;,
          &apos;scrollLeft&apos;,
          &apos;scrollTop&apos;
        ]
      }
    ]);
    var toFixed = function (pos) {
      return pos.fold(identity, function (point, scrollLeft, scrollTop) {
        return point.translate(-scrollLeft, -scrollTop);
      });
    };
    var toAbsolute = function (pos) {
      return pos.fold(identity, identity);
    };
    var sum = function (points) {
      return foldl(points, function (b, a) {
        return b.translate(a.left(), a.top());
      }, Position(0, 0));
    };
    var sumAsFixed = function (positions) {
      var points = map(positions, toFixed);
      return sum(points);
    };
    var sumAsAbsolute = function (positions) {
      var points = map(positions, toAbsolute);
      return sum(points);
    };
    var screen = adt$8.screen;
    var absolute$2 = adt$8.absolute;

    var getOffset = function (component, origin, anchorInfo) {
      var win = defaultView(anchorInfo.root).dom();
      var hasSameOwner = function (frame) {
        var frameOwner = owner(frame);
        var compOwner = owner(component.element());
        return eq$1(frameOwner, compOwner);
      };
      return Option.from(win.frameElement).map(Element.fromDom).filter(hasSameOwner).map(absolute);
    };
    var getRootPoint = function (component, origin, anchorInfo) {
      var doc = owner(component.element());
      var outerScroll = get$8(doc);
      var offset = getOffset(component, origin, anchorInfo).getOr(outerScroll);
      return absolute$2(offset, outerScroll.left(), outerScroll.top());
    };

    var capRect = function (left, top, width, height) {
      var newLeft = left, newTop = top, newWidth = width, newHeight = height;
      if (left &lt; 0) {
        newLeft = 0;
        newWidth = width + left;
      }
      if (top &lt; 0) {
        newTop = 0;
        newHeight = height + top;
      }
      var point = screen(Position(newLeft, newTop));
      return Option.some(pointed(point, newWidth, newHeight));
    };
    var calcNewAnchor = function (optBox, rootPoint, anchorInfo, origin, elem) {
      return optBox.map(function (box) {
        var points = [
          rootPoint,
          box.point
        ];
        var topLeft = cata$1(origin, function () {
          return sumAsAbsolute(points);
        }, function () {
          return sumAsAbsolute(points);
        }, function () {
          return sumAsFixed(points);
        });
        var anchorBox = rect(topLeft.left(), topLeft.top(), box.width, box.height);
        var layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();
        var layoutsRtl = anchorInfo.showAbove ? belowOrAboveRtl() : belowOrAboveRtl();
        var layouts = get$a(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Option.none());
        return nu$9({
          anchorBox: anchorBox,
          bubble: anchorInfo.bubble.getOr(fallback()),
          overrides: anchorInfo.overrides,
          layouts: layouts,
          placer: Option.none()
        });
      });
    };

    var point$1 = function (element, offset) {
      return {
        element: element,
        offset: offset
      };
    };
    var descendOnce$1 = function (element, offset) {
      return isText(element) ? point$1(element, offset) : descendOnce(element, offset);
    };
    var getAnchorSelection = function (win, anchorInfo) {
      var getSelection = anchorInfo.getSelection.getOrThunk(function () {
        return function () {
          return getExact(win);
        };
      });
      return getSelection().map(function (sel) {
        var modStart = descendOnce$1(sel.start(), sel.soffset());
        var modFinish = descendOnce$1(sel.finish(), sel.foffset());
        return Selection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
      });
    };
    var placement$2 = function (component, anchorInfo, origin) {
      var win = defaultView(anchorInfo.root).dom();
      var rootPoint = getRootPoint(component, origin, anchorInfo);
      var selectionBox = getAnchorSelection(win, anchorInfo).bind(function (sel) {
        var optRect = getFirstRect$1(win, Selection.exactFromRange(sel)).orThunk(function () {
          var x = Element.fromText(zeroWidth);
          before(sel.start(), x);
          return getFirstRect$1(win, Selection.exact(x, 0, x, 1)).map(function (rect) {
            remove(x);
            return rect;
          });
        });
        return optRect.bind(function (rawRect) {
          return capRect(rawRect.left(), rawRect.top(), rawRect.width(), rawRect.height());
        });
      });
      var targetElement = getAnchorSelection(win, anchorInfo).bind(function (sel) {
        return isElement(sel.start()) ? Option.some(sel.start()) : parent(sel.start());
      });
      var elem = targetElement.getOr(component.element());
      return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
    };
    var SelectionAnchor = [
      option(&apos;getSelection&apos;),
      strict$1(&apos;root&apos;),
      option(&apos;bubble&apos;),
      schema$1(),
      defaulted$1(&apos;overrides&apos;, {}),
      defaulted$1(&apos;showAbove&apos;, false),
      output(&apos;placement&apos;, placement$2)
    ];

    var placement$3 = function (component, anchorInfo, origin) {
      var rootPoint = getRootPoint(component, origin, anchorInfo);
      return anchorInfo.node.bind(function (target) {
        var rect = target.dom().getBoundingClientRect();
        var nodeBox = capRect(rect.left, rect.top, rect.width, rect.height);
        var elem = anchorInfo.node.getOr(component.element());
        return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);
      });
    };
    var NodeAnchor = [
      strict$1(&apos;node&apos;),
      strict$1(&apos;root&apos;),
      option(&apos;bubble&apos;),
      schema$1(),
      defaulted$1(&apos;overrides&apos;, {}),
      defaulted$1(&apos;showAbove&apos;, false),
      output(&apos;placement&apos;, placement$3)
    ];

    var eastX$1 = function (anchor) {
      return anchor.x + anchor.width;
    };
    var westX$1 = function (anchor, element) {
      return anchor.x - element.width;
    };
    var northY$1 = function (anchor, element) {
      return anchor.y - element.height + anchor.height;
    };
    var southY$1 = function (anchor) {
      return anchor.y;
    };
    var southeast$2 = function (anchor, element, bubbles) {
      return nu$7(eastX$1(anchor), southY$1(anchor), bubbles.southeast(), southeast(), boundsRestriction(anchor, {
        left: 0,
        top: 2
      }), &apos;link-layout-se&apos;);
    };
    var southwest$2 = function (anchor, element, bubbles) {
      return nu$7(westX$1(anchor, element), southY$1(anchor), bubbles.southwest(), southwest(), boundsRestriction(anchor, {
        right: 1,
        top: 2
      }), &apos;link-layout-sw&apos;);
    };
    var northeast$2 = function (anchor, element, bubbles) {
      return nu$7(eastX$1(anchor), northY$1(anchor, element), bubbles.northeast(), northeast(), boundsRestriction(anchor, {
        left: 0,
        bottom: 3
      }), &apos;link-layout-ne&apos;);
    };
    var northwest$2 = function (anchor, element, bubbles) {
      return nu$7(westX$1(anchor, element), northY$1(anchor, element), bubbles.northwest(), northwest(), boundsRestriction(anchor, {
        right: 1,
        bottom: 3
      }), &apos;link-layout-nw&apos;);
    };
    var all$3 = function () {
      return [
        southeast$2,
        southwest$2,
        northeast$2,
        northwest$2
      ];
    };
    var allRtl$1 = function () {
      return [
        southwest$2,
        southeast$2,
        northwest$2,
        northeast$2
      ];
    };

    var placement$4 = function (component, submenuInfo, origin) {
      var anchorBox = toBox(origin, submenuInfo.item.element());
      var layouts = get$a(component.element(), submenuInfo, all$3(), allRtl$1(), all$3(), allRtl$1(), Option.none());
      return Option.some(nu$9({
        anchorBox: anchorBox,
        bubble: fallback(),
        overrides: submenuInfo.overrides,
        layouts: layouts,
        placer: Option.none()
      }));
    };
    var SubmenuAnchor = [
      strict$1(&apos;item&apos;),
      schema$1(),
      defaulted$1(&apos;overrides&apos;, {}),
      output(&apos;placement&apos;, placement$4)
    ];

    var AnchorSchema = choose$1(&apos;anchor&apos;, {
      selection: SelectionAnchor,
      node: NodeAnchor,
      hotspot: HotspotAnchor,
      submenu: SubmenuAnchor,
      makeshift: MakeshiftAnchor
    });

    var getFixedOrigin = function () {
      var html = domGlobals.document.documentElement;
      return fixed(0, 0, html.clientWidth, html.clientHeight);
    };
    var getRelativeOrigin = function (component) {
      var position = absolute(component.element());
      var bounds = component.element().dom().getBoundingClientRect();
      return relative(position.left(), position.top(), bounds.width, bounds.height);
    };
    var place = function (component, origin, anchoring, getBounds, placee) {
      var anchor = box$1(anchoring.anchorBox, origin);
      simple(anchor, placee.element(), anchoring.bubble, anchoring.layouts, getBounds, anchoring.overrides);
    };
    var position$1 = function (component, posConfig, posState, anchor, placee) {
      positionWithin(component, posConfig, posState, anchor, placee, Option.none());
    };
    var positionWithin = function (component, posConfig, posState, anchor, placee, boxElement) {
      var boundsBox = boxElement.map(box);
      return positionWithinBounds(component, posConfig, posState, anchor, placee, boundsBox);
    };
    var positionWithinBounds = function (component, posConfig, posState, anchor, placee, bounds) {
      var anchorage = asRawOrDie(&apos;positioning anchor.info&apos;, AnchorSchema, anchor);
      preserve(function () {
        set$2(placee.element(), &apos;position&apos;, &apos;fixed&apos;);
        var oldVisibility = getRaw(placee.element(), &apos;visibility&apos;);
        set$2(placee.element(), &apos;visibility&apos;, &apos;hidden&apos;);
        var origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
        var placer = anchorage.placement;
        var getBounds = bounds.map(constant).or(posConfig.getBounds);
        placer(component, anchorage, origin).each(function (anchoring) {
          var doPlace = anchoring.placer.getOr(place);
          doPlace(component, origin, anchoring, getBounds, placee);
        });
        oldVisibility.fold(function () {
          remove$6(placee.element(), &apos;visibility&apos;);
        }, function (vis) {
          set$2(placee.element(), &apos;visibility&apos;, vis);
        });
        if (getRaw(placee.element(), &apos;left&apos;).isNone() &amp;&amp; getRaw(placee.element(), &apos;top&apos;).isNone() &amp;&amp; getRaw(placee.element(), &apos;right&apos;).isNone() &amp;&amp; getRaw(placee.element(), &apos;bottom&apos;).isNone() &amp;&amp; getRaw(placee.element(), &apos;position&apos;).is(&apos;fixed&apos;)) {
          remove$6(placee.element(), &apos;position&apos;);
        }
      }, placee.element());
    };
    var getMode = function (component, pConfig, _pState) {
      return pConfig.useFixed() ? &apos;fixed&apos; : &apos;absolute&apos;;
    };

    var PositionApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        position: position$1,
        positionWithin: positionWithin,
        positionWithinBounds: positionWithinBounds,
        getMode: getMode
    });

    var PositionSchema = [
      defaulted$1(&apos;useFixed&apos;, never),
      option(&apos;getBounds&apos;)
    ];

    var Positioning = create$1({
      fields: PositionSchema,
      name: &apos;positioning&apos;,
      active: ActivePosition,
      apis: PositionApis
    });

    var fireDetaching = function (component) {
      emit(component, detachedFromDom());
      var children = component.components();
      each(children, fireDetaching);
    };
    var fireAttaching = function (component) {
      var children = component.components();
      each(children, fireAttaching);
      emit(component, attachedToDom());
    };
    var attach = function (parent, child) {
      append(parent.element(), child.element());
    };
    var detachChildren = function (component) {
      each(component.components(), function (childComp) {
        return remove(childComp.element());
      });
      empty(component.element());
      component.syncComponents();
    };
    var replaceChildren = function (component, newChildren) {
      var subs = component.components();
      detachChildren(component);
      var deleted = difference(subs, newChildren);
      each(deleted, function (comp) {
        fireDetaching(comp);
        component.getSystem().removeFromWorld(comp);
      });
      each(newChildren, function (childComp) {
        if (!childComp.getSystem().isConnected()) {
          component.getSystem().addToWorld(childComp);
          attach(component, childComp);
          if (inBody(component.element())) {
            fireAttaching(childComp);
          }
        } else {
          attach(component, childComp);
        }
        component.syncComponents();
      });
    };

    var attach$1 = function (parent, child) {
      attachWith(parent, child, append);
    };
    var attachWith = function (parent, child, insertion) {
      parent.getSystem().addToWorld(child);
      insertion(parent.element(), child.element());
      if (inBody(parent.element())) {
        fireAttaching(child);
      }
      parent.syncComponents();
    };
    var doDetach = function (component) {
      fireDetaching(component);
      remove(component.element());
      component.getSystem().removeFromWorld(component);
    };
    var detach = function (component) {
      var parent$1 = parent(component.element()).bind(function (p) {
        return component.getSystem().getByDom(p).toOption();
      });
      doDetach(component);
      parent$1.each(function (p) {
        p.syncComponents();
      });
    };
    var detachChildren$1 = function (component) {
      var subs = component.components();
      each(subs, doDetach);
      empty(component.element());
      component.syncComponents();
    };
    var attachSystem = function (element, guiSystem) {
      attachSystemWith(element, guiSystem, append);
    };
    var attachSystemAfter = function (element, guiSystem) {
      attachSystemWith(element, guiSystem, after);
    };
    var attachSystemWith = function (element, guiSystem, inserter) {
      inserter(element, guiSystem.element());
      var children$1 = children(guiSystem.element());
      each(children$1, function (child) {
        guiSystem.getByDom(child).each(fireAttaching);
      });
    };
    var detachSystem = function (guiSystem) {
      var children$1 = children(guiSystem.element());
      each(children$1, function (child) {
        guiSystem.getByDom(child).each(fireDetaching);
      });
      remove(guiSystem.element());
    };

    var rebuild = function (sandbox, sConfig, sState, data) {
      sState.get().each(function (_data) {
        detachChildren$1(sandbox);
      });
      var point = sConfig.getAttachPoint(sandbox);
      attach$1(point, sandbox);
      var built = sandbox.getSystem().build(data);
      attach$1(sandbox, built);
      sState.set(built);
      return built;
    };
    var open = function (sandbox, sConfig, sState, data) {
      var newState = rebuild(sandbox, sConfig, sState, data);
      sConfig.onOpen(sandbox, newState);
      return newState;
    };
    var setContent = function (sandbox, sConfig, sState, data) {
      return sState.get().map(function () {
        return rebuild(sandbox, sConfig, sState, data);
      });
    };
    var openWhileCloaked = function (sandbox, sConfig, sState, data, transaction) {
      cloak(sandbox, sConfig);
      open(sandbox, sConfig, sState, data);
      transaction();
      decloak(sandbox, sConfig);
    };
    var close = function (sandbox, sConfig, sState) {
      sState.get().each(function (data) {
        detachChildren$1(sandbox);
        detach(sandbox);
        sConfig.onClose(sandbox, data);
        sState.clear();
      });
    };
    var isOpen = function (_sandbox, _sConfig, sState) {
      return sState.isOpen();
    };
    var isPartOf$1 = function (sandbox, sConfig, sState, queryElem) {
      return isOpen(sandbox, sConfig, sState) &amp;&amp; sState.get().exists(function (data) {
        return sConfig.isPartOf(sandbox, data, queryElem);
      });
    };
    var getState = function (_sandbox, _sConfig, sState) {
      return sState.get();
    };
    var store = function (sandbox, cssKey, attr, newValue) {
      getRaw(sandbox.element(), cssKey).fold(function () {
        remove$1(sandbox.element(), attr);
      }, function (v) {
        set$1(sandbox.element(), attr, v);
      });
      set$2(sandbox.element(), cssKey, newValue);
    };
    var restore = function (sandbox, cssKey, attr) {
      getOpt(sandbox.element(), attr).fold(function () {
        return remove$6(sandbox.element(), cssKey);
      }, function (oldValue) {
        return set$2(sandbox.element(), cssKey, oldValue);
      });
    };
    var cloak = function (sandbox, sConfig, _sState) {
      var sink = sConfig.getAttachPoint(sandbox);
      set$2(sandbox.element(), &apos;position&apos;, Positioning.getMode(sink));
      store(sandbox, &apos;visibility&apos;, sConfig.cloakVisibilityAttr, &apos;hidden&apos;);
    };
    var hasPosition = function (element) {
      return exists([
        &apos;top&apos;,
        &apos;left&apos;,
        &apos;right&apos;,
        &apos;bottom&apos;
      ], function (pos) {
        return getRaw(element, pos).isSome();
      });
    };
    var decloak = function (sandbox, sConfig, _sState) {
      if (!hasPosition(sandbox.element())) {
        remove$6(sandbox.element(), &apos;position&apos;);
      }
      restore(sandbox, &apos;visibility&apos;, sConfig.cloakVisibilityAttr);
    };

    var SandboxApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        cloak: cloak,
        decloak: decloak,
        open: open,
        openWhileCloaked: openWhileCloaked,
        close: close,
        isOpen: isOpen,
        isPartOf: isPartOf$1,
        getState: getState,
        setContent: setContent
    });

    var events$2 = function (sandboxConfig, sandboxState) {
      return derive([run(sandboxClose(), function (sandbox, _simulatedEvent) {
          close(sandbox, sandboxConfig, sandboxState);
        })]);
    };

    var ActiveSandbox = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$2
    });

    var SandboxSchema = [
      onHandler(&apos;onOpen&apos;),
      onHandler(&apos;onClose&apos;),
      strict$1(&apos;isPartOf&apos;),
      strict$1(&apos;getAttachPoint&apos;),
      defaulted$1(&apos;cloakVisibilityAttr&apos;, &apos;data-precloak-visibility&apos;)
    ];

    var init = function () {
      var contents = Cell(Option.none());
      var readState = constant(&apos;not-implemented&apos;);
      var isOpen = function () {
        return contents.get().isSome();
      };
      var set = function (comp) {
        contents.set(Option.some(comp));
      };
      var get = function () {
        return contents.get();
      };
      var clear = function () {
        contents.set(Option.none());
      };
      return nu$5({
        readState: readState,
        isOpen: isOpen,
        clear: clear,
        set: set,
        get: get
      });
    };

    var SandboxState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init
    });

    var Sandboxing = create$1({
      fields: SandboxSchema,
      name: &apos;sandboxing&apos;,
      active: ActiveSandbox,
      apis: SandboxApis,
      state: SandboxState
    });

    var dismissPopups = constant(&apos;dismiss.popups&apos;);
    var repositionPopups = constant(&apos;reposition.popups&apos;);
    var mouseReleased = constant(&apos;mouse.released&apos;);

    var schema$2 = objOfOnly([
      defaulted$1(&apos;isExtraPart&apos;, constant(false)),
      optionObjOf(&apos;fireEventInstead&apos;, [defaulted$1(&apos;event&apos;, dismissRequested())])
    ]);
    var receivingChannel = function (rawSpec) {
      var _a;
      var detail = asRawOrDie(&apos;Dismissal&apos;, schema$2, rawSpec);
      return _a = {}, _a[dismissPopups()] = {
        schema: objOfOnly([strict$1(&apos;target&apos;)]),
        onReceive: function (sandbox, data) {
          if (Sandboxing.isOpen(sandbox)) {
            var isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
            if (!isPart) {
              detail.fireEventInstead.fold(function () {
                return Sandboxing.close(sandbox);
              }, function (fe) {
                return emit(sandbox, fe.event);
              });
            }
          }
        }
      }, _a;
    };

    var schema$3 = objOfOnly([
      optionObjOf(&apos;fireEventInstead&apos;, [defaulted$1(&apos;event&apos;, repositionRequested())]),
      strictFunction(&apos;doReposition&apos;)
    ]);
    var receivingChannel$1 = function (rawSpec) {
      var _a;
      var detail = asRawOrDie(&apos;Reposition&apos;, schema$3, rawSpec);
      return _a = {}, _a[repositionPopups()] = {
        onReceive: function (sandbox) {
          if (Sandboxing.isOpen(sandbox)) {
            detail.fireEventInstead.fold(function () {
              return detail.doReposition(sandbox);
            }, function (fe) {
              return emit(sandbox, fe.event);
            });
          }
        }
      }, _a;
    };

    var onLoad = function (component, repConfig, repState) {
      repConfig.store.manager.onLoad(component, repConfig, repState);
    };
    var onUnload = function (component, repConfig, repState) {
      repConfig.store.manager.onUnload(component, repConfig, repState);
    };
    var setValue = function (component, repConfig, repState, data) {
      repConfig.store.manager.setValue(component, repConfig, repState, data);
    };
    var getValue = function (component, repConfig, repState) {
      return repConfig.store.manager.getValue(component, repConfig, repState);
    };
    var getState$1 = function (component, repConfig, repState) {
      return repState;
    };

    var RepresentApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad,
        onUnload: onUnload,
        setValue: setValue,
        getValue: getValue,
        getState: getState$1
    });

    var events$3 = function (repConfig, repState) {
      var es = repConfig.resetOnDom ? [
        runOnAttached(function (comp, _se) {
          onLoad(comp, repConfig, repState);
        }),
        runOnDetached(function (comp, _se) {
          onUnload(comp, repConfig, repState);
        })
      ] : [loadEvent(repConfig, repState, onLoad)];
      return derive(es);
    };

    var ActiveRepresenting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$3
    });

    var memory = function () {
      var data = Cell(null);
      var readState = function () {
        return {
          mode: &apos;memory&apos;,
          value: data.get()
        };
      };
      var isNotSet = function () {
        return data.get() === null;
      };
      var clear = function () {
        data.set(null);
      };
      return nu$5({
        set: data.set,
        get: data.get,
        isNotSet: isNotSet,
        clear: clear,
        readState: readState
      });
    };
    var manual = function () {
      var readState = function () {
      };
      return nu$5({ readState: readState });
    };
    var dataset = function () {
      var dataByValue = Cell({});
      var dataByText = Cell({});
      var readState = function () {
        return {
          mode: &apos;dataset&apos;,
          dataByValue: dataByValue.get(),
          dataByText: dataByText.get()
        };
      };
      var clear = function () {
        dataByValue.set({});
        dataByText.set({});
      };
      var lookup = function (itemString) {
        return get(dataByValue.get(), itemString).orThunk(function () {
          return get(dataByText.get(), itemString);
        });
      };
      var update = function (items) {
        var currentDataByValue = dataByValue.get();
        var currentDataByText = dataByText.get();
        var newDataByValue = {};
        var newDataByText = {};
        each(items, function (item) {
          newDataByValue[item.value] = item;
          get(item, &apos;meta&apos;).each(function (meta) {
            get(meta, &apos;text&apos;).each(function (text) {
              newDataByText[text] = item;
            });
          });
        });
        dataByValue.set(__assign(__assign({}, currentDataByValue), newDataByValue));
        dataByText.set(__assign(__assign({}, currentDataByText), newDataByText));
      };
      return nu$5({
        readState: readState,
        lookup: lookup,
        update: update,
        clear: clear
      });
    };
    var init$1 = function (spec) {
      return spec.store.manager.state(spec);
    };

    var RepresentState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        memory: memory,
        dataset: dataset,
        manual: manual,
        init: init$1
    });

    var setValue$1 = function (component, repConfig, repState, data) {
      var store = repConfig.store;
      repState.update([data]);
      store.setValue(component, data);
      repConfig.onSetValue(component, data);
    };
    var getValue$1 = function (component, repConfig, repState) {
      var store = repConfig.store;
      var key = store.getDataKey(component);
      return repState.lookup(key).fold(function () {
        return store.getFallbackEntry(key);
      }, function (data) {
        return data;
      });
    };
    var onLoad$1 = function (component, repConfig, repState) {
      var store = repConfig.store;
      store.initialValue.each(function (data) {
        setValue$1(component, repConfig, repState, data);
      });
    };
    var onUnload$1 = function (component, repConfig, repState) {
      repState.clear();
    };
    var DatasetStore = [
      option(&apos;initialValue&apos;),
      strict$1(&apos;getFallbackEntry&apos;),
      strict$1(&apos;getDataKey&apos;),
      strict$1(&apos;setValue&apos;),
      output(&apos;manager&apos;, {
        setValue: setValue$1,
        getValue: getValue$1,
        onLoad: onLoad$1,
        onUnload: onUnload$1,
        state: dataset
      })
    ];

    var getValue$2 = function (component, repConfig, _repState) {
      return repConfig.store.getValue(component);
    };
    var setValue$2 = function (component, repConfig, _repState, data) {
      repConfig.store.setValue(component, data);
      repConfig.onSetValue(component, data);
    };
    var onLoad$2 = function (component, repConfig, _repState) {
      repConfig.store.initialValue.each(function (data) {
        repConfig.store.setValue(component, data);
      });
    };
    var ManualStore = [
      strict$1(&apos;getValue&apos;),
      defaulted$1(&apos;setValue&apos;, noop),
      option(&apos;initialValue&apos;),
      output(&apos;manager&apos;, {
        setValue: setValue$2,
        getValue: getValue$2,
        onLoad: onLoad$2,
        onUnload: noop,
        state: NoState.init
      })
    ];

    var setValue$3 = function (component, repConfig, repState, data) {
      repState.set(data);
      repConfig.onSetValue(component, data);
    };
    var getValue$3 = function (component, repConfig, repState) {
      return repState.get();
    };
    var onLoad$3 = function (component, repConfig, repState) {
      repConfig.store.initialValue.each(function (initVal) {
        if (repState.isNotSet()) {
          repState.set(initVal);
        }
      });
    };
    var onUnload$2 = function (component, repConfig, repState) {
      repState.clear();
    };
    var MemoryStore = [
      option(&apos;initialValue&apos;),
      output(&apos;manager&apos;, {
        setValue: setValue$3,
        getValue: getValue$3,
        onLoad: onLoad$3,
        onUnload: onUnload$2,
        state: memory
      })
    ];

    var RepresentSchema = [
      defaultedOf(&apos;store&apos;, { mode: &apos;memory&apos; }, choose$1(&apos;mode&apos;, {
        memory: MemoryStore,
        manual: ManualStore,
        dataset: DatasetStore
      })),
      onHandler(&apos;onSetValue&apos;),
      defaulted$1(&apos;resetOnDom&apos;, false)
    ];

    var Representing = create$1({
      fields: RepresentSchema,
      name: &apos;representing&apos;,
      active: ActiveRepresenting,
      apis: RepresentApis,
      extra: {
        setValueFrom: function (component, source) {
          var value = Representing.getValue(source);
          Representing.setValue(component, value);
        }
      },
      state: RepresentState
    });

    var field$1 = function (name, forbidden) {
      return defaultedObjOf(name, {}, map(forbidden, function (f) {
        return forbid(f.name(), &apos;Cannot configure &apos; + f.name() + &apos; for &apos; + name);
      }).concat([state$1(&apos;dump&apos;, identity)]));
    };
    var get$c = function (data) {
      return data.dump;
    };
    var augment = function (data, original) {
      return __assign(__assign({}, data.dump), derive$1(original));
    };
    var SketchBehaviours = {
      field: field$1,
      augment: augment,
      get: get$c
    };

    var _placeholder = &apos;placeholder&apos;;
    var adt$9 = Adt.generate([
      {
        single: [
          &apos;required&apos;,
          &apos;valueThunk&apos;
        ]
      },
      {
        multiple: [
          &apos;required&apos;,
          &apos;valueThunks&apos;
        ]
      }
    ]);
    var isSubstituted = function (spec) {
      return has(spec, &apos;uiType&apos;);
    };
    var subPlaceholder = function (owner, detail, compSpec, placeholders) {
      if (owner.exists(function (o) {
          return o !== compSpec.owner;
        })) {
        return adt$9.single(true, constant(compSpec));
      }
      return get(placeholders, compSpec.name).fold(function () {
        throw new Error(&apos;Unknown placeholder component: &apos; + compSpec.name + &apos;\nKnown: [&apos; + keys(placeholders) + &apos;]\nNamespace: &apos; + owner.getOr(&apos;none&apos;) + &apos;\nSpec: &apos; + JSON.stringify(compSpec, null, 2));
      }, function (newSpec) {
        return newSpec.replace();
      });
    };
    var scan = function (owner, detail, compSpec, placeholders) {
      if (isSubstituted(compSpec) &amp;&amp; compSpec.uiType === _placeholder) {
        return subPlaceholder(owner, detail, compSpec, placeholders);
      } else {
        return adt$9.single(false, constant(compSpec));
      }
    };
    var substitute = function (owner, detail, compSpec, placeholders) {
      var base = scan(owner, detail, compSpec, placeholders);
      return base.fold(function (req, valueThunk) {
        var value = isSubstituted(compSpec) ? valueThunk(detail, compSpec.config, compSpec.validated) : valueThunk(detail);
        var childSpecs = get(value, &apos;components&apos;).getOr([]);
        var substituted = bind(childSpecs, function (c) {
          return substitute(owner, detail, c, placeholders);
        });
        return [__assign(__assign({}, value), { components: substituted })];
      }, function (req, valuesThunk) {
        if (isSubstituted(compSpec)) {
          var values = valuesThunk(detail, compSpec.config, compSpec.validated);
          var preprocessor = compSpec.validated.preprocess.getOr(identity);
          return preprocessor(values);
        } else {
          return valuesThunk(detail);
        }
      });
    };
    var substituteAll = function (owner, detail, components, placeholders) {
      return bind(components, function (c) {
        return substitute(owner, detail, c, placeholders);
      });
    };
    var oneReplace = function (label, replacements) {
      var called = false;
      var used = function () {
        return called;
      };
      var replace = function () {
        if (called) {
          throw new Error(&apos;Trying to use the same placeholder more than once: &apos; + label);
        }
        called = true;
        return replacements;
      };
      var required = function () {
        return replacements.fold(function (req, _) {
          return req;
        }, function (req, _) {
          return req;
        });
      };
      return {
        name: constant(label),
        required: required,
        used: used,
        replace: replace
      };
    };
    var substitutePlaces = function (owner, detail, components, placeholders) {
      var ps = map$1(placeholders, function (ph, name) {
        return oneReplace(name, ph);
      });
      var outcome = substituteAll(owner, detail, components, ps);
      each$1(ps, function (p) {
        if (p.used() === false &amp;&amp; p.required()) {
          throw new Error(&apos;Placeholder: &apos; + p.name() + &apos; was not found in components list\nNamespace: &apos; + owner.getOr(&apos;none&apos;) + &apos;\nComponents: &apos; + JSON.stringify(detail.components, null, 2));
        }
      });
      return outcome;
    };
    var single = adt$9.single;
    var multiple = adt$9.multiple;
    var placeholder = constant(_placeholder);

    var adt$a = Adt.generate([
      { required: [&apos;data&apos;] },
      { external: [&apos;data&apos;] },
      { optional: [&apos;data&apos;] },
      { group: [&apos;data&apos;] }
    ]);
    var fFactory = defaulted$1(&apos;factory&apos;, { sketch: identity });
    var fSchema = defaulted$1(&apos;schema&apos;, []);
    var fName = strict$1(&apos;name&apos;);
    var fPname = field(&apos;pname&apos;, &apos;pname&apos;, defaultedThunk(function (typeSpec) {
      return &apos;&lt;alloy.&apos; + generate$1(typeSpec.name) + &apos;&gt;&apos;;
    }), anyValue$1());
    var fGroupSchema = state$1(&apos;schema&apos;, function () {
      return [option(&apos;preprocess&apos;)];
    });
    var fDefaults = defaulted$1(&apos;defaults&apos;, constant({}));
    var fOverrides = defaulted$1(&apos;overrides&apos;, constant({}));
    var requiredSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fPname,
      fDefaults,
      fOverrides
    ]);
    var externalSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fDefaults,
      fOverrides
    ]);
    var optionalSpec = objOf([
      fFactory,
      fSchema,
      fName,
      fPname,
      fDefaults,
      fOverrides
    ]);
    var groupSpec = objOf([
      fFactory,
      fGroupSchema,
      fName,
      strict$1(&apos;unit&apos;),
      fPname,
      fDefaults,
      fOverrides
    ]);
    var asNamedPart = function (part) {
      return part.fold(Option.some, Option.none, Option.some, Option.some);
    };
    var name$1 = function (part) {
      var get = function (data) {
        return data.name;
      };
      return part.fold(get, get, get, get);
    };
    var asCommon = function (part) {
      return part.fold(identity, identity, identity, identity);
    };
    var convert = function (adtConstructor, partSchema) {
      return function (spec) {
        var data = asRawOrDie(&apos;Converting part type&apos;, partSchema, spec);
        return adtConstructor(data);
      };
    };
    var required = convert(adt$a.required, requiredSpec);
    var external$1 = convert(adt$a.external, externalSpec);
    var optional = convert(adt$a.optional, optionalSpec);
    var group = convert(adt$a.group, groupSpec);
    var original = constant(&apos;entirety&apos;);

    var PartType = /*#__PURE__*/Object.freeze({
        __proto__: null,
        required: required,
        external: external$1,
        optional: optional,
        group: group,
        asNamedPart: asNamedPart,
        name: name$1,
        asCommon: asCommon,
        original: original
    });

    var combine$2 = function (detail, data, partSpec, partValidated) {
      return deepMerge(data.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data.name] }, data.overrides(detail, partSpec, partValidated));
    };
    var subs = function (owner, detail, parts) {
      var internals = {};
      var externals = {};
      each(parts, function (part) {
        part.fold(function (data) {
          internals[data.pname] = single(true, function (detail, partSpec, partValidated) {
            return data.factory.sketch(combine$2(detail, data, partSpec, partValidated));
          });
        }, function (data) {
          var partSpec = detail.parts[data.name];
          externals[data.name] = constant(data.factory.sketch(combine$2(detail, data, partSpec[original()]), partSpec));
        }, function (data) {
          internals[data.pname] = single(false, function (detail, partSpec, partValidated) {
            return data.factory.sketch(combine$2(detail, data, partSpec, partValidated));
          });
        }, function (data) {
          internals[data.pname] = multiple(true, function (detail, _partSpec, _partValidated) {
            var units = detail[data.name];
            return map(units, function (u) {
              return data.factory.sketch(deepMerge(data.defaults(detail, u, _partValidated), u, data.overrides(detail, u)));
            });
          });
        });
      });
      return {
        internals: constant(internals),
        externals: constant(externals)
      };
    };

    var generate$4 = function (owner, parts) {
      var r = {};
      each(parts, function (part) {
        asNamedPart(part).each(function (np) {
          var g = doGenerateOne(owner, np.pname);
          r[np.name] = function (config) {
            var validated = asRawOrDie(&apos;Part: &apos; + np.name + &apos; in &apos; + owner, objOf(np.schema), config);
            return __assign(__assign({}, g), {
              config: config,
              validated: validated
            });
          };
        });
      });
      return r;
    };
    var doGenerateOne = function (owner, pname) {
      return {
        uiType: placeholder(),
        owner: owner,
        name: pname
      };
    };
    var generateOne = function (owner, pname, config) {
      return {
        uiType: placeholder(),
        owner: owner,
        name: pname,
        config: config,
        validated: {}
      };
    };
    var schemas = function (parts) {
      return bind(parts, function (part) {
        return part.fold(Option.none, Option.some, Option.none, Option.none).map(function (data) {
          return strictObjOf(data.name, data.schema.concat([snapshot(original())]));
        }).toArray();
      });
    };
    var names = function (parts) {
      return map(parts, name$1);
    };
    var substitutes = function (owner, detail, parts) {
      return subs(owner, detail, parts);
    };
    var components = function (owner, detail, internals) {
      return substitutePlaces(Option.some(owner), detail, detail.components, internals);
    };
    var getPart = function (component, detail, partKey) {
      var uid = detail.partUids[partKey];
      return component.getSystem().getByUid(uid).toOption();
    };
    var getPartOrDie = function (component, detail, partKey) {
      return getPart(component, detail, partKey).getOrDie(&apos;Could not find part: &apos; + partKey);
    };
    var getParts = function (component, detail, partKeys) {
      var r = {};
      var uids = detail.partUids;
      var system = component.getSystem();
      each(partKeys, function (pk) {
        r[pk] = constant(system.getByUid(uids[pk]));
      });
      return r;
    };
    var getAllParts = function (component, detail) {
      var system = component.getSystem();
      return map$1(detail.partUids, function (pUid, _k) {
        return constant(system.getByUid(pUid));
      });
    };
    var getAllPartNames = function (detail) {
      return keys(detail.partUids);
    };
    var getPartsOrDie = function (component, detail, partKeys) {
      var r = {};
      var uids = detail.partUids;
      var system = component.getSystem();
      each(partKeys, function (pk) {
        r[pk] = constant(system.getByUid(uids[pk]).getOrDie());
      });
      return r;
    };
    var defaultUids = function (baseUid, partTypes) {
      var partNames = names(partTypes);
      return wrapAll$1(map(partNames, function (pn) {
        return {
          key: pn,
          value: baseUid + &apos;-&apos; + pn
        };
      }));
    };
    var defaultUidsSchema = function (partTypes) {
      return field(&apos;partUids&apos;, &apos;partUids&apos;, mergeWithThunk(function (spec) {
        return defaultUids(spec.uid, partTypes);
      }), anyValue$1());
    };

    var AlloyParts = /*#__PURE__*/Object.freeze({
        __proto__: null,
        generate: generate$4,
        generateOne: generateOne,
        schemas: schemas,
        names: names,
        substitutes: substitutes,
        components: components,
        defaultUids: defaultUids,
        defaultUidsSchema: defaultUidsSchema,
        getAllParts: getAllParts,
        getAllPartNames: getAllPartNames,
        getPart: getPart,
        getPartOrDie: getPartOrDie,
        getParts: getParts,
        getPartsOrDie: getPartsOrDie
    });

    var base = function (partSchemas, partUidsSchemas) {
      var ps = partSchemas.length &gt; 0 ? [strictObjOf(&apos;parts&apos;, partSchemas)] : [];
      return ps.concat([
        strict$1(&apos;uid&apos;),
        defaulted$1(&apos;dom&apos;, {}),
        defaulted$1(&apos;components&apos;, []),
        snapshot(&apos;originalSpec&apos;),
        defaulted$1(&apos;debug.sketcher&apos;, {})
      ]).concat(partUidsSchemas);
    };
    var asRawOrDie$1 = function (label, schema, spec, partSchemas, partUidsSchemas) {
      var baseS = base(partSchemas, partUidsSchemas);
      return asRawOrDie(label + &apos; [SpecSchema]&apos;, objOfOnly(baseS.concat(schema)), spec);
    };

    var single$1 = function (owner, schema, factory, spec) {
      var specWithUid = supplyUid(spec);
      var detail = asRawOrDie$1(owner, schema, specWithUid, [], []);
      return factory(detail, specWithUid);
    };
    var composite = function (owner, schema, partTypes, factory, spec) {
      var specWithUid = supplyUid(spec);
      var partSchemas = schemas(partTypes);
      var partUidsSchema = defaultUidsSchema(partTypes);
      var detail = asRawOrDie$1(owner, schema, specWithUid, partSchemas, [partUidsSchema]);
      var subs = substitutes(owner, detail, partTypes);
      var components$1 = components(owner, detail, subs.internals());
      return factory(detail, components$1, specWithUid, subs.externals());
    };
    var hasUid = function (spec) {
      return has(spec, &apos;uid&apos;);
    };
    var supplyUid = function (spec) {
      return hasUid(spec) ? spec : __assign(__assign({}, spec), { uid: generate$2(&apos;uid&apos;) });
    };

    function isSketchSpec(spec) {
      return spec.uid !== undefined;
    }
    var singleSchema = objOfOnly([
      strict$1(&apos;name&apos;),
      strict$1(&apos;factory&apos;),
      strict$1(&apos;configFields&apos;),
      defaulted$1(&apos;apis&apos;, {}),
      defaulted$1(&apos;extraApis&apos;, {})
    ]);
    var compositeSchema = objOfOnly([
      strict$1(&apos;name&apos;),
      strict$1(&apos;factory&apos;),
      strict$1(&apos;configFields&apos;),
      strict$1(&apos;partFields&apos;),
      defaulted$1(&apos;apis&apos;, {}),
      defaulted$1(&apos;extraApis&apos;, {})
    ]);
    var single$2 = function (rawConfig) {
      var config = asRawOrDie(&apos;Sketcher for &apos; + rawConfig.name, singleSchema, rawConfig);
      var sketch = function (spec) {
        return single$1(config.name, config.configFields, config.factory, spec);
      };
      var apis = map$1(config.apis, makeApi);
      var extraApis = map$1(config.extraApis, function (f, k) {
        return markAsExtraApi(f, k);
      });
      return __assign(__assign({
        name: constant(config.name),
        configFields: constant(config.configFields),
        sketch: sketch
      }, apis), extraApis);
    };
    var composite$1 = function (rawConfig) {
      var config = asRawOrDie(&apos;Sketcher for &apos; + rawConfig.name, compositeSchema, rawConfig);
      var sketch = function (spec) {
        return composite(config.name, config.configFields, config.partFields, config.factory, spec);
      };
      var parts = generate$4(config.name, config.partFields);
      var apis = map$1(config.apis, makeApi);
      var extraApis = map$1(config.extraApis, function (f, k) {
        return markAsExtraApi(f, k);
      });
      return __assign(__assign({
        name: constant(config.name),
        partFields: constant(config.partFields),
        configFields: constant(config.configFields),
        sketch: sketch,
        parts: constant(parts)
      }, apis), extraApis);
    };

    var cat = function (arr) {
      var r = [];
      var push = function (x) {
        r.push(x);
      };
      for (var i = 0; i &lt; arr.length; i++) {
        arr[i].each(push);
      }
      return r;
    };
    var sequence = function (arr) {
      var r = [];
      for (var i = 0; i &lt; arr.length; i++) {
        var x = arr[i];
        if (x.isSome()) {
          r.push(x.getOrDie());
        } else {
          return Option.none();
        }
      }
      return Option.some(r);
    };
    var lift2 = function (oa, ob, f) {
      return oa.isSome() &amp;&amp; ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
    };
    var lift3 = function (oa, ob, oc, f) {
      return oa.isSome() &amp;&amp; ob.isSome() &amp;&amp; oc.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Option.none();
    };

    var inside = function (target) {
      return name(target) === &apos;input&apos; &amp;&amp; get$2(target, &apos;type&apos;) !== &apos;radio&apos; || name(target) === &apos;textarea&apos;;
    };

    var getCurrent = function (component, composeConfig, _composeState) {
      return composeConfig.find(component);
    };

    var ComposeApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCurrent: getCurrent
    });

    var ComposeSchema = [strict$1(&apos;find&apos;)];

    var Composing = create$1({
      fields: ComposeSchema,
      name: &apos;composing&apos;,
      apis: ComposeApis
    });

    var dehighlightAllExcept = function (component, hConfig, hState, skip) {
      var highlighted = descendants(component.element(), &apos;.&apos; + hConfig.highlightClass);
      each(highlighted, function (h) {
        if (!exists(skip, function (skipComp) {
            return skipComp.element() === h;
          })) {
          remove$4(h, hConfig.highlightClass);
          component.getSystem().getByDom(h).each(function (target) {
            hConfig.onDehighlight(component, target);
            emit(target, dehighlight());
          });
        }
      });
    };
    var dehighlightAll = function (component, hConfig, hState) {
      return dehighlightAllExcept(component, hConfig, hState, []);
    };
    var dehighlight$1 = function (component, hConfig, hState, target) {
      if (isHighlighted(component, hConfig, hState, target)) {
        remove$4(target.element(), hConfig.highlightClass);
        hConfig.onDehighlight(component, target);
        emit(target, dehighlight());
      }
    };
    var highlight$1 = function (component, hConfig, hState, target) {
      dehighlightAllExcept(component, hConfig, hState, [target]);
      if (!isHighlighted(component, hConfig, hState, target)) {
        add$2(target.element(), hConfig.highlightClass);
        hConfig.onHighlight(component, target);
        emit(target, highlight());
      }
    };
    var highlightFirst = function (component, hConfig, hState) {
      getFirst(component, hConfig).each(function (firstComp) {
        highlight$1(component, hConfig, hState, firstComp);
      });
    };
    var highlightLast = function (component, hConfig, hState) {
      getLast(component, hConfig).each(function (lastComp) {
        highlight$1(component, hConfig, hState, lastComp);
      });
    };
    var highlightAt = function (component, hConfig, hState, index) {
      getByIndex(component, hConfig, hState, index).fold(function (err) {
        throw new Error(err);
      }, function (firstComp) {
        highlight$1(component, hConfig, hState, firstComp);
      });
    };
    var highlightBy = function (component, hConfig, hState, predicate) {
      var candidates = getCandidates(component, hConfig);
      var targetComp = find(candidates, predicate);
      targetComp.each(function (c) {
        highlight$1(component, hConfig, hState, c);
      });
    };
    var isHighlighted = function (component, hConfig, hState, queryTarget) {
      return has$2(queryTarget.element(), hConfig.highlightClass);
    };
    var getHighlighted = function (component, hConfig, _hState) {
      return descendant$1(component.element(), &apos;.&apos; + hConfig.highlightClass).bind(function (e) {
        return component.getSystem().getByDom(e).toOption();
      });
    };
    var getByIndex = function (component, hConfig, hState, index) {
      var items = descendants(component.element(), &apos;.&apos; + hConfig.itemClass);
      return Option.from(items[index]).fold(function () {
        return Result.error(&apos;No element found with index &apos; + index);
      }, component.getSystem().getByDom);
    };
    var getFirst = function (component, hConfig, _hState) {
      return descendant$1(component.element(), &apos;.&apos; + hConfig.itemClass).bind(function (e) {
        return component.getSystem().getByDom(e).toOption();
      });
    };
    var getLast = function (component, hConfig, _hState) {
      var items = descendants(component.element(), &apos;.&apos; + hConfig.itemClass);
      var last = items.length &gt; 0 ? Option.some(items[items.length - 1]) : Option.none();
      return last.bind(function (c) {
        return component.getSystem().getByDom(c).toOption();
      });
    };
    var getDelta = function (component, hConfig, hState, delta) {
      var items = descendants(component.element(), &apos;.&apos; + hConfig.itemClass);
      var current = findIndex(items, function (item) {
        return has$2(item, hConfig.highlightClass);
      });
      return current.bind(function (selected) {
        var dest = cycleBy(selected, delta, 0, items.length - 1);
        return component.getSystem().getByDom(items[dest]).toOption();
      });
    };
    var getPrevious = function (component, hConfig, hState) {
      return getDelta(component, hConfig, hState, -1);
    };
    var getNext = function (component, hConfig, hState) {
      return getDelta(component, hConfig, hState, +1);
    };
    var getCandidates = function (component, hConfig, _hState) {
      var items = descendants(component.element(), &apos;.&apos; + hConfig.itemClass);
      return cat(map(items, function (i) {
        return component.getSystem().getByDom(i).toOption();
      }));
    };

    var HighlightApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        dehighlightAll: dehighlightAll,
        dehighlight: dehighlight$1,
        highlight: highlight$1,
        highlightFirst: highlightFirst,
        highlightLast: highlightLast,
        highlightAt: highlightAt,
        highlightBy: highlightBy,
        isHighlighted: isHighlighted,
        getHighlighted: getHighlighted,
        getFirst: getFirst,
        getLast: getLast,
        getPrevious: getPrevious,
        getNext: getNext,
        getCandidates: getCandidates
    });

    var HighlightSchema = [
      strict$1(&apos;highlightClass&apos;),
      strict$1(&apos;itemClass&apos;),
      onHandler(&apos;onHighlight&apos;),
      onHandler(&apos;onDehighlight&apos;)
    ];

    var Highlighting = create$1({
      fields: HighlightSchema,
      name: &apos;highlighting&apos;,
      apis: HighlightApis
    });

    var BACKSPACE = function () {
      return [8];
    };
    var TAB = function () {
      return [9];
    };
    var ENTER = function () {
      return [13];
    };
    var ESCAPE = function () {
      return [27];
    };
    var SPACE = function () {
      return [32];
    };
    var LEFT = function () {
      return [37];
    };
    var UP = function () {
      return [38];
    };
    var RIGHT = function () {
      return [39];
    };
    var DOWN = function () {
      return [40];
    };

    var cyclePrev = function (values, index, predicate) {
      var before = reverse(values.slice(0, index));
      var after = reverse(values.slice(index + 1));
      return find(before.concat(after), predicate);
    };
    var tryPrev = function (values, index, predicate) {
      var before = reverse(values.slice(0, index));
      return find(before, predicate);
    };
    var cycleNext = function (values, index, predicate) {
      var before = values.slice(0, index);
      var after = values.slice(index + 1);
      return find(after.concat(before), predicate);
    };
    var tryNext = function (values, index, predicate) {
      var after = values.slice(index + 1);
      return find(after, predicate);
    };

    var inSet = function (keys) {
      return function (event) {
        var raw = event.raw();
        return contains(keys, raw.which);
      };
    };
    var and = function (preds) {
      return function (event) {
        return forall(preds, function (pred) {
          return pred(event);
        });
      };
    };
    var isShift = function (event) {
      var raw = event.raw();
      return raw.shiftKey === true;
    };
    var isControl = function (event) {
      var raw = event.raw();
      return raw.ctrlKey === true;
    };
    var isNotShift = not(isShift);

    var rule = function (matches, action) {
      return {
        matches: matches,
        classification: action
      };
    };
    var choose$2 = function (transitions, event) {
      var transition = find(transitions, function (t) {
        return t.matches(event);
      });
      return transition.map(function (t) {
        return t.classification;
      });
    };

    var reportFocusShifting = function (component, prevFocus, newFocus) {
      var noChange = prevFocus.exists(function (p) {
        return newFocus.exists(function (n) {
          return eq$1(n, p);
        });
      });
      if (!noChange) {
        emitWith(component, focusShifted(), {
          prevFocus: prevFocus,
          newFocus: newFocus
        });
      }
    };
    var dom = function () {
      var get = function (component) {
        return search(component.element());
      };
      var set = function (component, focusee) {
        var prevFocus = get(component);
        component.getSystem().triggerFocus(focusee, component.element());
        var newFocus = get(component);
        reportFocusShifting(component, prevFocus, newFocus);
      };
      return {
        get: get,
        set: set
      };
    };
    var highlights = function () {
      var get = function (component) {
        return Highlighting.getHighlighted(component).map(function (item) {
          return item.element();
        });
      };
      var set = function (component, element) {
        var prevFocus = get(component);
        component.getSystem().getByDom(element).fold(noop, function (item) {
          Highlighting.highlight(component, item);
        });
        var newFocus = get(component);
        reportFocusShifting(component, prevFocus, newFocus);
      };
      return {
        get: get,
        set: set
      };
    };

    var FocusInsideModes;
    (function (FocusInsideModes) {
      FocusInsideModes[&apos;OnFocusMode&apos;] = &apos;onFocus&apos;;
      FocusInsideModes[&apos;OnEnterOrSpaceMode&apos;] = &apos;onEnterOrSpace&apos;;
      FocusInsideModes[&apos;OnApiMode&apos;] = &apos;onApi&apos;;
    }(FocusInsideModes || (FocusInsideModes = {})));

    var typical = function (infoSchema, stateInit, getKeydownRules, getKeyupRules, optFocusIn) {
      var schema = function () {
        return infoSchema.concat([
          defaulted$1(&apos;focusManager&apos;, dom()),
          defaultedOf(&apos;focusInside&apos;, &apos;onFocus&apos;, valueOf(function (val) {
            return contains([
              &apos;onFocus&apos;,
              &apos;onEnterOrSpace&apos;,
              &apos;onApi&apos;
            ], val) ? Result.value(val) : Result.error(&apos;Invalid value for focusInside&apos;);
          })),
          output(&apos;handler&apos;, me),
          output(&apos;state&apos;, stateInit),
          output(&apos;sendFocusIn&apos;, optFocusIn)
        ]);
      };
      var processKey = function (component, simulatedEvent, getRules, keyingConfig, keyingState) {
        var rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
        return choose$2(rules, simulatedEvent.event()).bind(function (rule) {
          return rule(component, simulatedEvent, keyingConfig, keyingState);
        });
      };
      var toEvents = function (keyingConfig, keyingState) {
        var onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Option.none() : optFocusIn(keyingConfig).map(function (focusIn) {
          return run(focus(), function (component, simulatedEvent) {
            focusIn(component, keyingConfig, keyingState);
            simulatedEvent.stop();
          });
        });
        var tryGoInsideComponent = function (component, simulatedEvent) {
          var isEnterOrSpace = inSet(SPACE().concat(ENTER()))(simulatedEvent.event());
          if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode &amp;&amp; isEnterOrSpace &amp;&amp; isSource(component, simulatedEvent)) {
            optFocusIn(keyingConfig).each(function (focusIn) {
              focusIn(component, keyingConfig, keyingState);
              simulatedEvent.stop();
            });
          }
        };
        var keyboardEvents = [
          run(keydown(), function (component, simulatedEvent) {
            processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(function () {
              tryGoInsideComponent(component, simulatedEvent);
            }, function (_) {
              simulatedEvent.stop();
            });
          }),
          run(keyup(), function (component, simulatedEvent) {
            processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each(function (_) {
              simulatedEvent.stop();
            });
          })
        ];
        return derive(onFocusHandler.toArray().concat(keyboardEvents));
      };
      var me = {
        schema: schema,
        processKey: processKey,
        toEvents: toEvents
      };
      return me;
    };

    var create$3 = function (cyclicField) {
      var schema = [
        option(&apos;onEscape&apos;),
        option(&apos;onEnter&apos;),
        defaulted$1(&apos;selector&apos;, &apos;[data-alloy-tabstop=&quot;true&quot;]:not(:disabled)&apos;),
        defaulted$1(&apos;firstTabstop&apos;, 0),
        defaulted$1(&apos;useTabstopAt&apos;, constant(true)),
        option(&apos;visibilitySelector&apos;)
      ].concat([cyclicField]);
      var isVisible = function (tabbingConfig, element) {
        var target = tabbingConfig.visibilitySelector.bind(function (sel) {
          return closest$3(element, sel);
        }).getOr(element);
        return get$6(target) &gt; 0;
      };
      var findInitial = function (component, tabbingConfig) {
        var tabstops = descendants(component.element(), tabbingConfig.selector);
        var visibles = filter(tabstops, function (elem) {
          return isVisible(tabbingConfig, elem);
        });
        return Option.from(visibles[tabbingConfig.firstTabstop]);
      };
      var findCurrent = function (component, tabbingConfig) {
        return tabbingConfig.focusManager.get(component).bind(function (elem) {
          return closest$3(elem, tabbingConfig.selector);
        });
      };
      var isTabstop = function (tabbingConfig, element) {
        return isVisible(tabbingConfig, element) &amp;&amp; tabbingConfig.useTabstopAt(element);
      };
      var focusIn = function (component, tabbingConfig, _tabbingState) {
        findInitial(component, tabbingConfig).each(function (target) {
          tabbingConfig.focusManager.set(component, target);
        });
      };
      var goFromTabstop = function (component, tabstops, stopIndex, tabbingConfig, cycle) {
        return cycle(tabstops, stopIndex, function (elem) {
          return isTabstop(tabbingConfig, elem);
        }).fold(function () {
          return tabbingConfig.cyclic ? Option.some(true) : Option.none();
        }, function (target) {
          tabbingConfig.focusManager.set(component, target);
          return Option.some(true);
        });
      };
      var go = function (component, _simulatedEvent, tabbingConfig, cycle) {
        var tabstops = descendants(component.element(), tabbingConfig.selector);
        return findCurrent(component, tabbingConfig).bind(function (tabstop) {
          var optStopIndex = findIndex(tabstops, curry(eq$1, tabstop));
          return optStopIndex.bind(function (stopIndex) {
            return goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle);
          });
        });
      };
      var goBackwards = function (component, simulatedEvent, tabbingConfig) {
        var navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
        return go(component, simulatedEvent, tabbingConfig, navigate);
      };
      var goForwards = function (component, simulatedEvent, tabbingConfig) {
        var navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
        return go(component, simulatedEvent, tabbingConfig, navigate);
      };
      var execute = function (component, simulatedEvent, tabbingConfig) {
        return tabbingConfig.onEnter.bind(function (f) {
          return f(component, simulatedEvent);
        });
      };
      var exit = function (component, simulatedEvent, tabbingConfig) {
        return tabbingConfig.onEscape.bind(function (f) {
          return f(component, simulatedEvent);
        });
      };
      var getKeydownRules = constant([
        rule(and([
          isShift,
          inSet(TAB())
        ]), goBackwards),
        rule(inSet(TAB()), goForwards),
        rule(inSet(ESCAPE()), exit),
        rule(and([
          isNotShift,
          inSet(ENTER())
        ]), execute)
      ]);
      var getKeyupRules = constant([]);
      return typical(schema, NoState.init, getKeydownRules, getKeyupRules, function () {
        return Option.some(focusIn);
      });
    };

    var AcyclicType = create$3(state$1(&apos;cyclic&apos;, constant(false)));

    var CyclicType = create$3(state$1(&apos;cyclic&apos;, constant(true)));

    var doDefaultExecute = function (component, _simulatedEvent, focused) {
      dispatch(component, focused, execute());
      return Option.some(true);
    };
    var defaultExecute = function (component, simulatedEvent, focused) {
      var isComplex = inside(focused) &amp;&amp; inSet(SPACE())(simulatedEvent.event());
      return isComplex ? Option.none() : doDefaultExecute(component, simulatedEvent, focused);
    };
    var stopEventForFirefox = function (_component, _simulatedEvent) {
      return Option.some(true);
    };

    var schema$4 = [
      defaulted$1(&apos;execute&apos;, defaultExecute),
      defaulted$1(&apos;useSpace&apos;, false),
      defaulted$1(&apos;useEnter&apos;, true),
      defaulted$1(&apos;useControlEnter&apos;, false),
      defaulted$1(&apos;useDown&apos;, false)
    ];
    var execute$1 = function (component, simulatedEvent, executeConfig) {
      return executeConfig.execute(component, simulatedEvent, component.element());
    };
    var getKeydownRules = function (component, _simulatedEvent, executeConfig, _executeState) {
      var spaceExec = executeConfig.useSpace &amp;&amp; !inside(component.element()) ? SPACE() : [];
      var enterExec = executeConfig.useEnter ? ENTER() : [];
      var downExec = executeConfig.useDown ? DOWN() : [];
      var execKeys = spaceExec.concat(enterExec).concat(downExec);
      return [rule(inSet(execKeys), execute$1)].concat(executeConfig.useControlEnter ? [rule(and([
          isControl,
          inSet(ENTER())
        ]), execute$1)] : []);
    };
    var getKeyupRules = function (component, _simulatedEvent, executeConfig, _executeState) {
      return executeConfig.useSpace &amp;&amp; !inside(component.element()) ? [rule(inSet(SPACE()), stopEventForFirefox)] : [];
    };
    var ExecutionType = typical(schema$4, NoState.init, getKeydownRules, getKeyupRules, function () {
      return Option.none();
    });

    var flatgrid = function () {
      var dimensions = Cell(Option.none());
      var setGridSize = function (numRows, numColumns) {
        dimensions.set(Option.some({
          numRows: numRows,
          numColumns: numColumns
        }));
      };
      var getNumRows = function () {
        return dimensions.get().map(function (d) {
          return d.numRows;
        });
      };
      var getNumColumns = function () {
        return dimensions.get().map(function (d) {
          return d.numColumns;
        });
      };
      return nu$5({
        readState: function () {
          return dimensions.get().map(function (d) {
            return {
              numRows: String(d.numRows),
              numColumns: String(d.numColumns)
            };
          }).getOr({
            numRows: &apos;?&apos;,
            numColumns: &apos;?&apos;
          });
        },
        setGridSize: setGridSize,
        getNumRows: getNumRows,
        getNumColumns: getNumColumns
      });
    };
    var init$2 = function (spec) {
      return spec.state(spec);
    };

    var KeyingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        flatgrid: flatgrid,
        init: init$2
    });

    var useH = function (movement) {
      return function (component, simulatedEvent, config, state) {
        var move = movement(component.element());
        return use(move, component, simulatedEvent, config, state);
      };
    };
    var west$2 = function (moveLeft, moveRight) {
      var movement = onDirection(moveLeft, moveRight);
      return useH(movement);
    };
    var east$2 = function (moveLeft, moveRight) {
      var movement = onDirection(moveRight, moveLeft);
      return useH(movement);
    };
    var useV = function (move) {
      return function (component, simulatedEvent, config, state) {
        return use(move, component, simulatedEvent, config, state);
      };
    };
    var use = function (move, component, simulatedEvent, config, state) {
      var outcome = config.focusManager.get(component).bind(function (focused) {
        return move(component.element(), focused, config, state);
      });
      return outcome.map(function (newFocus) {
        config.focusManager.set(component, newFocus);
        return true;
      });
    };
    var north$2 = useV;
    var south$2 = useV;
    var move = useV;

    var isHidden = function (dom) {
      return dom.offsetWidth &lt;= 0 &amp;&amp; dom.offsetHeight &lt;= 0;
    };
    var isVisible = function (element) {
      return !isHidden(element.dom());
    };

    var locate = function (candidates, predicate) {
      return findIndex(candidates, predicate).map(function (index) {
        return {
          index: constant(index),
          candidates: constant(candidates)
        };
      });
    };

    var locateVisible = function (container, current, selector) {
      var predicate = function (x) {
        return eq$1(x, current);
      };
      var candidates = descendants(container, selector);
      var visible = filter(candidates, isVisible);
      return locate(visible, predicate);
    };
    var findIndex$1 = function (elements, target) {
      return findIndex(elements, function (elem) {
        return eq$1(target, elem);
      });
    };

    var withGrid = function (values, index, numCols, f) {
      var oldRow = Math.floor(index / numCols);
      var oldColumn = index % numCols;
      return f(oldRow, oldColumn).bind(function (address) {
        var newIndex = address.row() * numCols + address.column();
        return newIndex &gt;= 0 &amp;&amp; newIndex &lt; values.length ? Option.some(values[newIndex]) : Option.none();
      });
    };
    var cycleHorizontal = function (values, index, numRows, numCols, delta) {
      return withGrid(values, index, numCols, function (oldRow, oldColumn) {
        var onLastRow = oldRow === numRows - 1;
        var colsInRow = onLastRow ? values.length - oldRow * numCols : numCols;
        var newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
        return Option.some({
          row: constant(oldRow),
          column: constant(newColumn)
        });
      });
    };
    var cycleVertical = function (values, index, numRows, numCols, delta) {
      return withGrid(values, index, numCols, function (oldRow, oldColumn) {
        var newRow = cycleBy(oldRow, delta, 0, numRows - 1);
        var onLastRow = newRow === numRows - 1;
        var colsInRow = onLastRow ? values.length - newRow * numCols : numCols;
        var newCol = clamp(oldColumn, 0, colsInRow - 1);
        return Option.some({
          row: constant(newRow),
          column: constant(newCol)
        });
      });
    };
    var cycleRight = function (values, index, numRows, numCols) {
      return cycleHorizontal(values, index, numRows, numCols, +1);
    };
    var cycleLeft = function (values, index, numRows, numCols) {
      return cycleHorizontal(values, index, numRows, numCols, -1);
    };
    var cycleUp = function (values, index, numRows, numCols) {
      return cycleVertical(values, index, numRows, numCols, -1);
    };
    var cycleDown = function (values, index, numRows, numCols) {
      return cycleVertical(values, index, numRows, numCols, +1);
    };

    var schema$5 = [
      strict$1(&apos;selector&apos;),
      defaulted$1(&apos;execute&apos;, defaultExecute),
      onKeyboardHandler(&apos;onEscape&apos;),
      defaulted$1(&apos;captureTab&apos;, false),
      initSize()
    ];
    var focusIn = function (component, gridConfig, _gridState) {
      descendant$1(component.element(), gridConfig.selector).each(function (first) {
        gridConfig.focusManager.set(component, first);
      });
    };
    var findCurrent = function (component, gridConfig) {
      return gridConfig.focusManager.get(component).bind(function (elem) {
        return closest$3(elem, gridConfig.selector);
      });
    };
    var execute$2 = function (component, simulatedEvent, gridConfig, _gridState) {
      return findCurrent(component, gridConfig).bind(function (focused) {
        return gridConfig.execute(component, simulatedEvent, focused);
      });
    };
    var doMove = function (cycle) {
      return function (element, focused, gridConfig, gridState) {
        return locateVisible(element, focused, gridConfig.selector).bind(function (identified) {
          return cycle(identified.candidates(), identified.index(), gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns));
        });
      };
    };
    var handleTab = function (_component, _simulatedEvent, gridConfig) {
      return gridConfig.captureTab ? Option.some(true) : Option.none();
    };
    var doEscape = function (component, simulatedEvent, gridConfig) {
      return gridConfig.onEscape(component, simulatedEvent);
    };
    var moveLeft = doMove(cycleLeft);
    var moveRight = doMove(cycleRight);
    var moveNorth = doMove(cycleUp);
    var moveSouth = doMove(cycleDown);
    var getKeydownRules$1 = constant([
      rule(inSet(LEFT()), west$2(moveLeft, moveRight)),
      rule(inSet(RIGHT()), east$2(moveLeft, moveRight)),
      rule(inSet(UP()), north$2(moveNorth)),
      rule(inSet(DOWN()), south$2(moveSouth)),
      rule(and([
        isShift,
        inSet(TAB())
      ]), handleTab),
      rule(and([
        isNotShift,
        inSet(TAB())
      ]), handleTab),
      rule(inSet(ESCAPE()), doEscape),
      rule(inSet(SPACE().concat(ENTER())), execute$2)
    ]);
    var getKeyupRules$1 = constant([rule(inSet(SPACE()), stopEventForFirefox)]);
    var FlatgridType = typical(schema$5, flatgrid, getKeydownRules$1, getKeyupRules$1, function () {
      return Option.some(focusIn);
    });

    var horizontal = function (container, selector, current, delta) {
      var isDisabledButton = function (candidate) {
        return name(candidate) === &apos;button&apos; &amp;&amp; get$2(candidate, &apos;disabled&apos;) === &apos;disabled&apos;;
      };
      var tryCycle = function (initial, index, candidates) {
        var newIndex = cycleBy(index, delta, 0, candidates.length - 1);
        if (newIndex === initial) {
          return Option.none();
        } else {
          return isDisabledButton(candidates[newIndex]) ? tryCycle(initial, newIndex, candidates) : Option.from(candidates[newIndex]);
        }
      };
      return locateVisible(container, current, selector).bind(function (identified) {
        var index = identified.index();
        var candidates = identified.candidates();
        return tryCycle(index, index, candidates);
      });
    };

    var schema$6 = [
      strict$1(&apos;selector&apos;),
      defaulted$1(&apos;getInitial&apos;, Option.none),
      defaulted$1(&apos;execute&apos;, defaultExecute),
      onKeyboardHandler(&apos;onEscape&apos;),
      defaulted$1(&apos;executeOnMove&apos;, false),
      defaulted$1(&apos;allowVertical&apos;, true)
    ];
    var findCurrent$1 = function (component, flowConfig) {
      return flowConfig.focusManager.get(component).bind(function (elem) {
        return closest$3(elem, flowConfig.selector);
      });
    };
    var execute$3 = function (component, simulatedEvent, flowConfig) {
      return findCurrent$1(component, flowConfig).bind(function (focused) {
        return flowConfig.execute(component, simulatedEvent, focused);
      });
    };
    var focusIn$1 = function (component, flowConfig, _state) {
      flowConfig.getInitial(component).orThunk(function () {
        return descendant$1(component.element(), flowConfig.selector);
      }).each(function (first) {
        flowConfig.focusManager.set(component, first);
      });
    };
    var moveLeft$1 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, -1);
    };
    var moveRight$1 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, +1);
    };
    var doMove$1 = function (movement) {
      return function (component, simulatedEvent, flowConfig, flowState) {
        return movement(component, simulatedEvent, flowConfig, flowState).bind(function () {
          return flowConfig.executeOnMove ? execute$3(component, simulatedEvent, flowConfig) : Option.some(true);
        });
      };
    };
    var doEscape$1 = function (component, simulatedEvent, flowConfig) {
      return flowConfig.onEscape(component, simulatedEvent);
    };
    var getKeydownRules$2 = function (_component, _se, flowConfig, _flowState) {
      var westMovers = LEFT().concat(flowConfig.allowVertical ? UP() : []);
      var eastMovers = RIGHT().concat(flowConfig.allowVertical ? DOWN() : []);
      return [
        rule(inSet(westMovers), doMove$1(west$2(moveLeft$1, moveRight$1))),
        rule(inSet(eastMovers), doMove$1(east$2(moveLeft$1, moveRight$1))),
        rule(inSet(ENTER()), execute$3),
        rule(inSet(SPACE()), execute$3),
        rule(inSet(ESCAPE()), doEscape$1)
      ];
    };
    var getKeyupRules$2 = constant([rule(inSet(SPACE()), stopEventForFirefox)]);
    var FlowType = typical(schema$6, NoState.init, getKeydownRules$2, getKeyupRules$2, function () {
      return Option.some(focusIn$1);
    });

    var toCell = function (matrix, rowIndex, columnIndex) {
      return Option.from(matrix[rowIndex]).bind(function (row) {
        return Option.from(row[columnIndex]).map(function (cell) {
          return {
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            cell: cell
          };
        });
      });
    };
    var cycleHorizontal$1 = function (matrix, rowIndex, startCol, deltaCol) {
      var row = matrix[rowIndex];
      var colsInRow = row.length;
      var newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
      return toCell(matrix, rowIndex, newColIndex);
    };
    var cycleVertical$1 = function (matrix, colIndex, startRow, deltaRow) {
      var nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix.length - 1);
      var colsInNextRow = matrix[nextRowIndex].length;
      var nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
      return toCell(matrix, nextRowIndex, nextColIndex);
    };
    var moveHorizontal = function (matrix, rowIndex, startCol, deltaCol) {
      var row = matrix[rowIndex];
      var colsInRow = row.length;
      var newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);
      return toCell(matrix, rowIndex, newColIndex);
    };
    var moveVertical = function (matrix, colIndex, startRow, deltaRow) {
      var nextRowIndex = clamp(startRow + deltaRow, 0, matrix.length - 1);
      var colsInNextRow = matrix[nextRowIndex].length;
      var nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
      return toCell(matrix, nextRowIndex, nextColIndex);
    };
    var cycleRight$1 = function (matrix, startRow, startCol) {
      return cycleHorizontal$1(matrix, startRow, startCol, +1);
    };
    var cycleLeft$1 = function (matrix, startRow, startCol) {
      return cycleHorizontal$1(matrix, startRow, startCol, -1);
    };
    var cycleUp$1 = function (matrix, startRow, startCol) {
      return cycleVertical$1(matrix, startCol, startRow, -1);
    };
    var cycleDown$1 = function (matrix, startRow, startCol) {
      return cycleVertical$1(matrix, startCol, startRow, +1);
    };
    var moveLeft$2 = function (matrix, startRow, startCol) {
      return moveHorizontal(matrix, startRow, startCol, -1);
    };
    var moveRight$2 = function (matrix, startRow, startCol) {
      return moveHorizontal(matrix, startRow, startCol, +1);
    };
    var moveUp = function (matrix, startRow, startCol) {
      return moveVertical(matrix, startCol, startRow, -1);
    };
    var moveDown = function (matrix, startRow, startCol) {
      return moveVertical(matrix, startCol, startRow, +1);
    };

    var schema$7 = [
      strictObjOf(&apos;selectors&apos;, [
        strict$1(&apos;row&apos;),
        strict$1(&apos;cell&apos;)
      ]),
      defaulted$1(&apos;cycles&apos;, true),
      defaulted$1(&apos;previousSelector&apos;, Option.none),
      defaulted$1(&apos;execute&apos;, defaultExecute)
    ];
    var focusIn$2 = function (component, matrixConfig, _state) {
      var focused = matrixConfig.previousSelector(component).orThunk(function () {
        var selectors = matrixConfig.selectors;
        return descendant$1(component.element(), selectors.cell);
      });
      focused.each(function (cell) {
        matrixConfig.focusManager.set(component, cell);
      });
    };
    var execute$4 = function (component, simulatedEvent, matrixConfig) {
      return search(component.element()).bind(function (focused) {
        return matrixConfig.execute(component, simulatedEvent, focused);
      });
    };
    var toMatrix = function (rows, matrixConfig) {
      return map(rows, function (row) {
        return descendants(row, matrixConfig.selectors.cell);
      });
    };
    var doMove$2 = function (ifCycle, ifMove) {
      return function (element, focused, matrixConfig) {
        var move = matrixConfig.cycles ? ifCycle : ifMove;
        return closest$3(focused, matrixConfig.selectors.row).bind(function (inRow) {
          var cellsInRow = descendants(inRow, matrixConfig.selectors.cell);
          return findIndex$1(cellsInRow, focused).bind(function (colIndex) {
            var allRows = descendants(element, matrixConfig.selectors.row);
            return findIndex$1(allRows, inRow).bind(function (rowIndex) {
              var matrix = toMatrix(allRows, matrixConfig);
              return move(matrix, rowIndex, colIndex).map(function (next) {
                return next.cell;
              });
            });
          });
        });
      };
    };
    var moveLeft$3 = doMove$2(cycleLeft$1, moveLeft$2);
    var moveRight$3 = doMove$2(cycleRight$1, moveRight$2);
    var moveNorth$1 = doMove$2(cycleUp$1, moveUp);
    var moveSouth$1 = doMove$2(cycleDown$1, moveDown);
    var getKeydownRules$3 = constant([
      rule(inSet(LEFT()), west$2(moveLeft$3, moveRight$3)),
      rule(inSet(RIGHT()), east$2(moveLeft$3, moveRight$3)),
      rule(inSet(UP()), north$2(moveNorth$1)),
      rule(inSet(DOWN()), south$2(moveSouth$1)),
      rule(inSet(SPACE().concat(ENTER())), execute$4)
    ]);
    var getKeyupRules$3 = constant([rule(inSet(SPACE()), stopEventForFirefox)]);
    var MatrixType = typical(schema$7, NoState.init, getKeydownRules$3, getKeyupRules$3, function () {
      return Option.some(focusIn$2);
    });

    var schema$8 = [
      strict$1(&apos;selector&apos;),
      defaulted$1(&apos;execute&apos;, defaultExecute),
      defaulted$1(&apos;moveOnTab&apos;, false)
    ];
    var execute$5 = function (component, simulatedEvent, menuConfig) {
      return menuConfig.focusManager.get(component).bind(function (focused) {
        return menuConfig.execute(component, simulatedEvent, focused);
      });
    };
    var focusIn$3 = function (component, menuConfig, _state) {
      descendant$1(component.element(), menuConfig.selector).each(function (first) {
        menuConfig.focusManager.set(component, first);
      });
    };
    var moveUp$1 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, -1);
    };
    var moveDown$1 = function (element, focused, info) {
      return horizontal(element, info.selector, focused, +1);
    };
    var fireShiftTab = function (component, simulatedEvent, menuConfig, menuState) {
      return menuConfig.moveOnTab ? move(moveUp$1)(component, simulatedEvent, menuConfig, menuState) : Option.none();
    };
    var fireTab = function (component, simulatedEvent, menuConfig, menuState) {
      return menuConfig.moveOnTab ? move(moveDown$1)(component, simulatedEvent, menuConfig, menuState) : Option.none();
    };
    var getKeydownRules$4 = constant([
      rule(inSet(UP()), move(moveUp$1)),
      rule(inSet(DOWN()), move(moveDown$1)),
      rule(and([
        isShift,
        inSet(TAB())
      ]), fireShiftTab),
      rule(and([
        isNotShift,
        inSet(TAB())
      ]), fireTab),
      rule(inSet(ENTER()), execute$5),
      rule(inSet(SPACE()), execute$5)
    ]);
    var getKeyupRules$4 = constant([rule(inSet(SPACE()), stopEventForFirefox)]);
    var MenuType = typical(schema$8, NoState.init, getKeydownRules$4, getKeyupRules$4, function () {
      return Option.some(focusIn$3);
    });

    var schema$9 = [
      onKeyboardHandler(&apos;onSpace&apos;),
      onKeyboardHandler(&apos;onEnter&apos;),
      onKeyboardHandler(&apos;onShiftEnter&apos;),
      onKeyboardHandler(&apos;onLeft&apos;),
      onKeyboardHandler(&apos;onRight&apos;),
      onKeyboardHandler(&apos;onTab&apos;),
      onKeyboardHandler(&apos;onShiftTab&apos;),
      onKeyboardHandler(&apos;onUp&apos;),
      onKeyboardHandler(&apos;onDown&apos;),
      onKeyboardHandler(&apos;onEscape&apos;),
      defaulted$1(&apos;stopSpaceKeyup&apos;, false),
      option(&apos;focusIn&apos;)
    ];
    var getKeydownRules$5 = function (component, simulatedEvent, specialInfo) {
      return [
        rule(inSet(SPACE()), specialInfo.onSpace),
        rule(and([
          isNotShift,
          inSet(ENTER())
        ]), specialInfo.onEnter),
        rule(and([
          isShift,
          inSet(ENTER())
        ]), specialInfo.onShiftEnter),
        rule(and([
          isShift,
          inSet(TAB())
        ]), specialInfo.onShiftTab),
        rule(and([
          isNotShift,
          inSet(TAB())
        ]), specialInfo.onTab),
        rule(inSet(UP()), specialInfo.onUp),
        rule(inSet(DOWN()), specialInfo.onDown),
        rule(inSet(LEFT()), specialInfo.onLeft),
        rule(inSet(RIGHT()), specialInfo.onRight),
        rule(inSet(SPACE()), specialInfo.onSpace),
        rule(inSet(ESCAPE()), specialInfo.onEscape)
      ];
    };
    var getKeyupRules$5 = function (component, simulatedEvent, specialInfo) {
      return specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE()), stopEventForFirefox)] : [];
    };
    var SpecialType = typical(schema$9, NoState.init, getKeydownRules$5, getKeyupRules$5, function (specialInfo) {
      return specialInfo.focusIn;
    });

    var acyclic = AcyclicType.schema();
    var cyclic = CyclicType.schema();
    var flow = FlowType.schema();
    var flatgrid$1 = FlatgridType.schema();
    var matrix = MatrixType.schema();
    var execution = ExecutionType.schema();
    var menu = MenuType.schema();
    var special = SpecialType.schema();

    var KeyboardBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        acyclic: acyclic,
        cyclic: cyclic,
        flow: flow,
        flatgrid: flatgrid$1,
        matrix: matrix,
        execution: execution,
        menu: menu,
        special: special
    });

    var isFlatgridState = function (keyState) {
      return hasNonNullableKey(keyState, &apos;setGridSize&apos;);
    };
    var Keying = createModes$1({
      branchKey: &apos;mode&apos;,
      branches: KeyboardBranches,
      name: &apos;keying&apos;,
      active: {
        events: function (keyingConfig, keyingState) {
          var handler = keyingConfig.handler;
          return handler.toEvents(keyingConfig, keyingState);
        }
      },
      apis: {
        focusIn: function (component, keyConfig, keyState) {
          keyConfig.sendFocusIn(keyConfig).fold(function () {
            component.getSystem().triggerFocus(component.element(), component.element());
          }, function (sendFocusIn) {
            sendFocusIn(component, keyConfig, keyState);
          });
        },
        setGridSize: function (component, keyConfig, keyState, numRows, numColumns) {
          if (!isFlatgridState(keyState)) {
            domGlobals.console.error(&apos;Layout does not support setGridSize&apos;);
          } else {
            keyState.setGridSize(numRows, numColumns);
          }
        }
      },
      state: KeyingState
    });

    var set$5 = function (component, replaceConfig, replaceState, data) {
      preserve(function () {
        var newChildren = map(data, component.getSystem().build);
        replaceChildren(component, newChildren);
      }, component.element());
    };
    var insert = function (component, replaceConfig, insertion, childSpec) {
      var child = component.getSystem().build(childSpec);
      attachWith(component, child, insertion);
    };
    var append$2 = function (component, replaceConfig, replaceState, appendee) {
      insert(component, replaceConfig, append, appendee);
    };
    var prepend$1 = function (component, replaceConfig, replaceState, prependee) {
      insert(component, replaceConfig, prepend, prependee);
    };
    var remove$7 = function (component, replaceConfig, replaceState, removee) {
      var children = contents(component);
      var foundChild = find(children, function (child) {
        return eq$1(removee.element(), child.element());
      });
      foundChild.each(detach);
    };
    var contents = function (component, _replaceConfig) {
      return component.components();
    };
    var replaceAt = function (component, replaceConfig, replaceState, replaceeIndex, replacer) {
      var children = contents(component);
      return Option.from(children[replaceeIndex]).map(function (replacee) {
        remove$7(component, replaceConfig, replaceState, replacee);
        replacer.each(function (r) {
          insert(component, replaceConfig, function (p, c) {
            appendAt(p, c, replaceeIndex);
          }, r);
        });
        return replacee;
      });
    };
    var replaceBy = function (component, replaceConfig, replaceState, replaceePred, replacer) {
      var children = contents(component);
      return findIndex(children, replaceePred).bind(function (replaceeIndex) {
        return replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer);
      });
    };

    var ReplaceApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        append: append$2,
        prepend: prepend$1,
        remove: remove$7,
        replaceAt: replaceAt,
        replaceBy: replaceBy,
        set: set$5,
        contents: contents
    });

    var Replacing = create$1({
      fields: [],
      name: &apos;replacing&apos;,
      apis: ReplaceApis
    });

    var events$4 = function (name, eventHandlers) {
      var events = derive(eventHandlers);
      return create$1({
        fields: [strict$1(&apos;enabled&apos;)],
        name: name,
        active: { events: constant(events) }
      });
    };
    var config = function (name, eventHandlers) {
      var me = events$4(name, eventHandlers);
      return {
        key: name,
        value: {
          config: {},
          me: me,
          configAsRaw: constant({}),
          initialConfig: {},
          state: NoState
        }
      };
    };

    var focus$2 = function (component, focusConfig) {
      if (!focusConfig.ignore) {
        focus$1(component.element());
        focusConfig.onFocus(component);
      }
    };
    var blur$1 = function (component, focusConfig) {
      if (!focusConfig.ignore) {
        blur(component.element());
      }
    };
    var isFocused = function (component) {
      return hasFocus(component.element());
    };

    var FocusApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        focus: focus$2,
        blur: blur$1,
        isFocused: isFocused
    });

    var exhibit$1 = function (base, focusConfig) {
      var mod = focusConfig.ignore ? {} : { attributes: { tabindex: &apos;-1&apos; } };
      return nu$6(mod);
    };
    var events$5 = function (focusConfig) {
      return derive([run(focus(), function (component, simulatedEvent) {
          focus$2(component, focusConfig);
          simulatedEvent.stop();
        })].concat(focusConfig.stopMousedown ? [run(mousedown(), function (_, simulatedEvent) {
          simulatedEvent.event().prevent();
        })] : []));
    };

    var ActiveFocus = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$1,
        events: events$5
    });

    var FocusSchema = [
      onHandler(&apos;onFocus&apos;),
      defaulted$1(&apos;stopMousedown&apos;, false),
      defaulted$1(&apos;ignore&apos;, false)
    ];

    var Focusing = create$1({
      fields: FocusSchema,
      name: &apos;focusing&apos;,
      active: ActiveFocus,
      apis: FocusApis
    });

    var updateAriaState = function (component, toggleConfig, toggleState) {
      var ariaInfo = toggleConfig.aria;
      ariaInfo.update(component, ariaInfo, toggleState.get());
    };
    var updateClass = function (component, toggleConfig, toggleState) {
      toggleConfig.toggleClass.each(function (toggleClass) {
        if (toggleState.get()) {
          add$2(component.element(), toggleClass);
        } else {
          remove$4(component.element(), toggleClass);
        }
      });
    };
    var toggle = function (component, toggleConfig, toggleState) {
      set$6(component, toggleConfig, toggleState, !toggleState.get());
    };
    var on$1 = function (component, toggleConfig, toggleState) {
      toggleState.set(true);
      updateClass(component, toggleConfig, toggleState);
      updateAriaState(component, toggleConfig, toggleState);
    };
    var off = function (component, toggleConfig, toggleState) {
      toggleState.set(false);
      updateClass(component, toggleConfig, toggleState);
      updateAriaState(component, toggleConfig, toggleState);
    };
    var set$6 = function (component, toggleConfig, toggleState, state) {
      var action = state ? on$1 : off;
      action(component, toggleConfig, toggleState);
    };
    var isOn = function (component, toggleConfig, toggleState) {
      return toggleState.get();
    };
    var onLoad$4 = function (component, toggleConfig, toggleState) {
      set$6(component, toggleConfig, toggleState, toggleConfig.selected);
    };

    var ToggleApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        onLoad: onLoad$4,
        toggle: toggle,
        isOn: isOn,
        on: on$1,
        off: off,
        set: set$6
    });

    var exhibit$2 = function () {
      return nu$6({});
    };
    var events$6 = function (toggleConfig, toggleState) {
      var execute = executeEvent(toggleConfig, toggleState, toggle);
      var load = loadEvent(toggleConfig, toggleState, onLoad$4);
      return derive(flatten([
        toggleConfig.toggleOnExecute ? [execute] : [],
        [load]
      ]));
    };

    var ActiveToggle = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$2,
        events: events$6
    });

    var SetupBehaviourCellState = function (initialState) {
      var init = function () {
        var cell = Cell(initialState);
        var get = function () {
          return cell.get();
        };
        var set = function (newState) {
          return cell.set(newState);
        };
        var clear = function () {
          return cell.set(initialState);
        };
        var readState = function () {
          return cell.get();
        };
        return {
          get: get,
          set: set,
          clear: clear,
          readState: readState
        };
      };
      return { init: init };
    };

    var updatePressed = function (component, ariaInfo, status) {
      set$1(component.element(), &apos;aria-pressed&apos;, status);
      if (ariaInfo.syncWithExpanded) {
        updateExpanded(component, ariaInfo, status);
      }
    };
    var updateSelected = function (component, ariaInfo, status) {
      set$1(component.element(), &apos;aria-selected&apos;, status);
    };
    var updateChecked = function (component, ariaInfo, status) {
      set$1(component.element(), &apos;aria-checked&apos;, status);
    };
    var updateExpanded = function (component, ariaInfo, status) {
      set$1(component.element(), &apos;aria-expanded&apos;, status);
    };

    var ToggleSchema = [
      defaulted$1(&apos;selected&apos;, false),
      option(&apos;toggleClass&apos;),
      defaulted$1(&apos;toggleOnExecute&apos;, true),
      defaultedOf(&apos;aria&apos;, { mode: &apos;none&apos; }, choose$1(&apos;mode&apos;, {
        pressed: [
          defaulted$1(&apos;syncWithExpanded&apos;, false),
          output(&apos;update&apos;, updatePressed)
        ],
        checked: [output(&apos;update&apos;, updateChecked)],
        expanded: [output(&apos;update&apos;, updateExpanded)],
        selected: [output(&apos;update&apos;, updateSelected)],
        none: [output(&apos;update&apos;, noop)]
      }))
    ];

    var Toggling = create$1({
      fields: ToggleSchema,
      name: &apos;toggling&apos;,
      active: ActiveToggle,
      apis: ToggleApis,
      state: SetupBehaviourCellState(false)
    });

    var pointerEvents = function () {
      var onClick = function (component, simulatedEvent) {
        simulatedEvent.stop();
        emitExecute(component);
      };
      return [
        run(click(), onClick),
        run(tap(), onClick),
        cutter(touchstart()),
        cutter(mousedown())
      ];
    };
    var events$7 = function (optAction) {
      var executeHandler = function (action) {
        return runOnExecute(function (component, simulatedEvent) {
          action(component);
          simulatedEvent.stop();
        });
      };
      return derive(flatten([
        optAction.map(executeHandler).toArray(),
        pointerEvents()
      ]));
    };

    var hoverEvent = &apos;alloy.item-hover&apos;;
    var focusEvent = &apos;alloy.item-focus&apos;;
    var onHover = function (item) {
      if (search(item.element()).isNone() || Focusing.isFocused(item)) {
        if (!Focusing.isFocused(item)) {
          Focusing.focus(item);
        }
        emitWith(item, hoverEvent, { item: item });
      }
    };
    var onFocus = function (item) {
      emitWith(item, focusEvent, { item: item });
    };
    var hover = constant(hoverEvent);
    var focus$3 = constant(focusEvent);

    var builder = function (detail) {
      return {
        dom: detail.dom,
        domModification: __assign(__assign({}, detail.domModification), { attributes: __assign(__assign(__assign({ &apos;role&apos;: detail.toggling.isSome() ? &apos;menuitemcheckbox&apos; : &apos;menuitem&apos; }, detail.domModification.attributes), { &apos;aria-haspopup&apos;: detail.hasSubmenu }), detail.hasSubmenu ? { &apos;aria-expanded&apos;: false } : {}) }),
        behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
          detail.toggling.fold(Toggling.revoke, function (tConfig) {
            return Toggling.config(__assign({ aria: { mode: &apos;checked&apos; } }, tConfig));
          }),
          Focusing.config({
            ignore: detail.ignoreFocus,
            stopMousedown: detail.ignoreFocus,
            onFocus: function (component) {
              onFocus(component);
            }
          }),
          Keying.config({ mode: &apos;execution&apos; }),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: detail.data
            }
          }),
          config(&apos;item-type-events&apos;, __spreadArrays(pointerEvents(), [
            run(mouseover(), onHover),
            run(focusItem(), Focusing.focus)
          ]))
        ]),
        components: detail.components,
        eventOrder: detail.eventOrder
      };
    };
    var schema$a = [
      strict$1(&apos;data&apos;),
      strict$1(&apos;components&apos;),
      strict$1(&apos;dom&apos;),
      defaulted$1(&apos;hasSubmenu&apos;, false),
      option(&apos;toggling&apos;),
      SketchBehaviours.field(&apos;itemBehaviours&apos;, [
        Toggling,
        Focusing,
        Keying,
        Representing
      ]),
      defaulted$1(&apos;ignoreFocus&apos;, false),
      defaulted$1(&apos;domModification&apos;, {}),
      output(&apos;builder&apos;, builder),
      defaulted$1(&apos;eventOrder&apos;, {})
    ];

    var builder$1 = function (detail) {
      return {
        dom: detail.dom,
        components: detail.components,
        events: derive([stopper(focusItem())])
      };
    };
    var schema$b = [
      strict$1(&apos;dom&apos;),
      strict$1(&apos;components&apos;),
      output(&apos;builder&apos;, builder$1)
    ];

    var owner$2 = function () {
      return &apos;item-widget&apos;;
    };
    var parts = constant([required({
        name: &apos;widget&apos;,
        overrides: function (detail) {
          return {
            behaviours: derive$1([Representing.config({
                store: {
                  mode: &apos;manual&apos;,
                  getValue: function (_component) {
                    return detail.data;
                  },
                  setValue: function () {
                  }
                }
              })])
          };
        }
      })]);

    var builder$2 = function (detail) {
      var subs = substitutes(owner$2(), detail, parts());
      var components$1 = components(owner$2(), detail, subs.internals());
      var focusWidget = function (component) {
        return getPart(component, detail, &apos;widget&apos;).map(function (widget) {
          Keying.focusIn(widget);
          return widget;
        });
      };
      var onHorizontalArrow = function (component, simulatedEvent) {
        return inside(simulatedEvent.event().target()) ? Option.none() : function () {
          if (detail.autofocus) {
            simulatedEvent.setSource(component.element());
            return Option.none();
          } else {
            return Option.none();
          }
        }();
      };
      return {
        dom: detail.dom,
        components: components$1,
        domModification: detail.domModification,
        events: derive([
          runOnExecute(function (component, simulatedEvent) {
            focusWidget(component).each(function (_widget) {
              simulatedEvent.stop();
            });
          }),
          run(mouseover(), onHover),
          run(focusItem(), function (component, _simulatedEvent) {
            if (detail.autofocus) {
              focusWidget(component);
            } else {
              Focusing.focus(component);
            }
          })
        ]),
        behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: detail.data
            }
          }),
          Focusing.config({
            ignore: detail.ignoreFocus,
            onFocus: function (component) {
              onFocus(component);
            }
          }),
          Keying.config({
            mode: &apos;special&apos;,
            focusIn: detail.autofocus ? function (component) {
              focusWidget(component);
            } : revoke(),
            onLeft: onHorizontalArrow,
            onRight: onHorizontalArrow,
            onEscape: function (component, simulatedEvent) {
              if (!Focusing.isFocused(component) &amp;&amp; !detail.autofocus) {
                Focusing.focus(component);
                return Option.some(true);
              } else if (detail.autofocus) {
                simulatedEvent.setSource(component.element());
                return Option.none();
              } else {
                return Option.none();
              }
            }
          })
        ])
      };
    };
    var schema$c = [
      strict$1(&apos;uid&apos;),
      strict$1(&apos;data&apos;),
      strict$1(&apos;components&apos;),
      strict$1(&apos;dom&apos;),
      defaulted$1(&apos;autofocus&apos;, false),
      defaulted$1(&apos;ignoreFocus&apos;, false),
      SketchBehaviours.field(&apos;widgetBehaviours&apos;, [
        Representing,
        Focusing,
        Keying
      ]),
      defaulted$1(&apos;domModification&apos;, {}),
      defaultUidsSchema(parts()),
      output(&apos;builder&apos;, builder$2)
    ];

    var itemSchema$1 = choose$1(&apos;type&apos;, {
      widget: schema$c,
      item: schema$a,
      separator: schema$b
    });
    var configureGrid = function (detail, movementInfo) {
      return {
        mode: &apos;flatgrid&apos;,
        selector: &apos;.&apos; + detail.markers.item,
        initSize: {
          numColumns: movementInfo.initSize.numColumns,
          numRows: movementInfo.initSize.numRows
        },
        focusManager: detail.focusManager
      };
    };
    var configureMatrix = function (detail, movementInfo) {
      return {
        mode: &apos;matrix&apos;,
        selectors: {
          row: movementInfo.rowSelector,
          cell: &apos;.&apos; + detail.markers.item
        },
        focusManager: detail.focusManager
      };
    };
    var configureMenu = function (detail, movementInfo) {
      return {
        mode: &apos;menu&apos;,
        selector: &apos;.&apos; + detail.markers.item,
        moveOnTab: movementInfo.moveOnTab,
        focusManager: detail.focusManager
      };
    };
    var parts$1 = constant([group({
        factory: {
          sketch: function (spec) {
            var itemInfo = asRawOrDie(&apos;menu.spec item&apos;, itemSchema$1, spec);
            return itemInfo.builder(itemInfo);
          }
        },
        name: &apos;items&apos;,
        unit: &apos;item&apos;,
        defaults: function (detail, u) {
          return u.hasOwnProperty(&apos;uid&apos;) ? u : __assign(__assign({}, u), { uid: generate$2(&apos;item&apos;) });
        },
        overrides: function (detail, u) {
          return {
            type: u.type,
            ignoreFocus: detail.fakeFocus,
            domModification: { classes: [detail.markers.item] }
          };
        }
      })]);
    var schema$d = constant([
      strict$1(&apos;value&apos;),
      strict$1(&apos;items&apos;),
      strict$1(&apos;dom&apos;),
      strict$1(&apos;components&apos;),
      defaulted$1(&apos;eventOrder&apos;, {}),
      field$1(&apos;menuBehaviours&apos;, [
        Highlighting,
        Representing,
        Composing,
        Keying
      ]),
      defaultedOf(&apos;movement&apos;, {
        mode: &apos;menu&apos;,
        moveOnTab: true
      }, choose$1(&apos;mode&apos;, {
        grid: [
          initSize(),
          output(&apos;config&apos;, configureGrid)
        ],
        matrix: [
          output(&apos;config&apos;, configureMatrix),
          strict$1(&apos;rowSelector&apos;)
        ],
        menu: [
          defaulted$1(&apos;moveOnTab&apos;, true),
          output(&apos;config&apos;, configureMenu)
        ]
      })),
      itemMarkers(),
      defaulted$1(&apos;fakeFocus&apos;, false),
      defaulted$1(&apos;focusManager&apos;, dom()),
      onHandler(&apos;onHighlight&apos;)
    ]);

    var focus$4 = constant(&apos;alloy.menu-focus&apos;);

    var make$1 = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        markers: detail.markers,
        behaviours: augment(detail.menuBehaviours, [
          Highlighting.config({
            highlightClass: detail.markers.selectedItem,
            itemClass: detail.markers.item,
            onHighlight: detail.onHighlight
          }),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: detail.value
            }
          }),
          Composing.config({ find: Option.some }),
          Keying.config(detail.movement.config(detail, detail.movement))
        ]),
        events: derive([
          run(focus$3(), function (menu, simulatedEvent) {
            var event = simulatedEvent.event();
            menu.getSystem().getByDom(event.target()).each(function (item) {
              Highlighting.highlight(menu, item);
              simulatedEvent.stop();
              emitWith(menu, focus$4(), {
                menu: menu,
                item: item
              });
            });
          }),
          run(hover(), function (menu, simulatedEvent) {
            var item = simulatedEvent.event().item();
            Highlighting.highlight(menu, item);
          })
        ]),
        components: components,
        eventOrder: detail.eventOrder,
        domModification: { attributes: { role: &apos;menu&apos; } }
      };
    };

    var Menu = composite$1({
      name: &apos;Menu&apos;,
      configFields: schema$d(),
      partFields: parts$1(),
      factory: make$1
    });

    var transpose = function (obj) {
      return tupleMap(obj, function (v, k) {
        return {
          k: v,
          v: k
        };
      });
    };
    var trace = function (items, byItem, byMenu, finish) {
      return get(byMenu, finish).bind(function (triggerItem) {
        return get(items, triggerItem).bind(function (triggerMenu) {
          var rest = trace(items, byItem, byMenu, triggerMenu);
          return Option.some([triggerMenu].concat(rest));
        });
      }).getOr([]);
    };
    var generate$5 = function (menus, expansions) {
      var items = {};
      each$1(menus, function (menuItems, menu) {
        each(menuItems, function (item) {
          items[item] = menu;
        });
      });
      var byItem = expansions;
      var byMenu = transpose(expansions);
      var menuPaths = map$1(byMenu, function (_triggerItem, submenu) {
        return [submenu].concat(trace(items, byItem, byMenu, submenu));
      });
      return map$1(items, function (menu) {
        return get(menuPaths, menu).getOr([menu]);
      });
    };

    var init$3 = function () {
      var expansions = Cell({});
      var menus = Cell({});
      var paths = Cell({});
      var primary = Cell(Option.none());
      var directory = Cell({});
      var clear = function () {
        expansions.set({});
        menus.set({});
        paths.set({});
        primary.set(Option.none());
      };
      var isClear = function () {
        return primary.get().isNone();
      };
      var setMenuBuilt = function (menuName, built) {
        var _a;
        menus.set(__assign(__assign({}, menus.get()), (_a = {}, _a[menuName] = {
          type: &apos;prepared&apos;,
          menu: built
        }, _a)));
      };
      var setContents = function (sPrimary, sMenus, sExpansions, dir) {
        primary.set(Option.some(sPrimary));
        expansions.set(sExpansions);
        menus.set(sMenus);
        directory.set(dir);
        var sPaths = generate$5(dir, sExpansions);
        paths.set(sPaths);
      };
      var getTriggeringItem = function (menuValue) {
        return find$1(expansions.get(), function (v, _k) {
          return v === menuValue;
        });
      };
      var getTriggerData = function (menuValue, getItemByValue, path) {
        return getPreparedMenu(menuValue).bind(function (menu) {
          return getTriggeringItem(menuValue).bind(function (triggeringItemValue) {
            return getItemByValue(triggeringItemValue).map(function (triggeredItem) {
              return {
                triggeredMenu: menu,
                triggeringItem: triggeredItem,
                triggeringPath: path
              };
            });
          });
        });
      };
      var getTriggeringPath = function (itemValue, getItemByValue) {
        var extraPath = filter(lookupItem(itemValue).toArray(), function (menuValue) {
          return getPreparedMenu(menuValue).isSome();
        });
        return get(paths.get(), itemValue).bind(function (path) {
          var revPath = reverse(extraPath.concat(path));
          var triggers = bind(revPath, function (menuValue, menuIndex) {
            return getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(function () {
              return primary.get().is(menuValue) ? [] : [Option.none()];
            }, function (data) {
              return [Option.some(data)];
            });
          });
          return sequence(triggers);
        });
      };
      var expand = function (itemValue) {
        return get(expansions.get(), itemValue).map(function (menu) {
          var current = get(paths.get(), itemValue).getOr([]);
          return [menu].concat(current);
        });
      };
      var collapse = function (itemValue) {
        return get(paths.get(), itemValue).bind(function (path) {
          return path.length &gt; 1 ? Option.some(path.slice(1)) : Option.none();
        });
      };
      var refresh = function (itemValue) {
        return get(paths.get(), itemValue);
      };
      var getPreparedMenu = function (menuValue) {
        return lookupMenu(menuValue).bind(extractPreparedMenu);
      };
      var lookupMenu = function (menuValue) {
        return get(menus.get(), menuValue);
      };
      var lookupItem = function (itemValue) {
        return get(expansions.get(), itemValue);
      };
      var otherMenus = function (path) {
        var menuValues = directory.get();
        return difference(keys(menuValues), path);
      };
      var getPrimary = function () {
        return primary.get().bind(getPreparedMenu);
      };
      var getMenus = function () {
        return menus.get();
      };
      return {
        setMenuBuilt: setMenuBuilt,
        setContents: setContents,
        expand: expand,
        refresh: refresh,
        collapse: collapse,
        lookupMenu: lookupMenu,
        lookupItem: lookupItem,
        otherMenus: otherMenus,
        getPrimary: getPrimary,
        getMenus: getMenus,
        clear: clear,
        isClear: isClear,
        getTriggeringPath: getTriggeringPath
      };
    };
    var extractPreparedMenu = function (prep) {
      return prep.type === &apos;prepared&apos; ? Option.some(prep.menu) : Option.none();
    };
    var LayeredState = {
      init: init$3,
      extractPreparedMenu: extractPreparedMenu
    };

    var make$2 = function (detail, _rawUiSpec) {
      var submenuParentItems = Cell(Option.none());
      var buildMenus = function (container, primaryName, menus) {
        return map$1(menus, function (spec, name) {
          var makeSketch = function () {
            return Menu.sketch(__assign(__assign({ dom: spec.dom }, spec), {
              value: name,
              items: spec.items,
              markers: detail.markers,
              fakeFocus: detail.fakeFocus,
              onHighlight: detail.onHighlight,
              focusManager: detail.fakeFocus ? highlights() : dom()
            }));
          };
          return name === primaryName ? {
            type: &apos;prepared&apos;,
            menu: container.getSystem().build(makeSketch())
          } : {
            type: &apos;notbuilt&apos;,
            nbMenu: makeSketch
          };
        });
      };
      var layeredState = LayeredState.init();
      var setup = function (container) {
        var componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
        var directory = toDirectory();
        layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
        return layeredState.getPrimary();
      };
      var getItemValue = function (item) {
        return Representing.getValue(item).value;
      };
      var getItemByValue = function (_container, menus, itemValue) {
        return findMap(menus, function (menu) {
          if (!menu.getSystem().isConnected()) {
            return Option.none();
          }
          var candidates = Highlighting.getCandidates(menu);
          return find(candidates, function (c) {
            return getItemValue(c) === itemValue;
          });
        });
      };
      var toDirectory = function (_container) {
        return map$1(detail.data.menus, function (data, _menuName) {
          return bind(data.items, function (item) {
            return item.type === &apos;separator&apos; ? [] : [item.data.value];
          });
        });
      };
      var setActiveMenu = function (container, menu) {
        Highlighting.highlight(container, menu);
        Highlighting.getHighlighted(menu).orThunk(function () {
          return Highlighting.getFirst(menu);
        }).each(function (item) {
          dispatch(container, item.element(), focusItem());
        });
      };
      var getMenus = function (state, menuValues) {
        return cat(map(menuValues, function (mv) {
          return state.lookupMenu(mv).bind(function (prep) {
            return prep.type === &apos;prepared&apos; ? Option.some(prep.menu) : Option.none();
          });
        }));
      };
      var closeOthers = function (container, state, path) {
        var others = getMenus(state, state.otherMenus(path));
        each(others, function (o) {
          remove$5(o.element(), [detail.markers.backgroundMenu]);
          if (!detail.stayInDom) {
            Replacing.remove(container, o);
          }
        });
      };
      var getSubmenuParents = function (container) {
        return submenuParentItems.get().getOrThunk(function () {
          var r = {};
          var items = descendants(container.element(), &apos;.&apos; + detail.markers.item);
          var parentItems = filter(items, function (i) {
            return get$2(i, &apos;aria-haspopup&apos;) === &apos;true&apos;;
          });
          each(parentItems, function (i) {
            container.getSystem().getByDom(i).each(function (itemComp) {
              var key = getItemValue(itemComp);
              r[key] = itemComp;
            });
          });
          submenuParentItems.set(Option.some(r));
          return r;
        });
      };
      var updateAriaExpansions = function (container, path) {
        var parentItems = getSubmenuParents(container);
        each$1(parentItems, function (v, k) {
          var expanded = contains(path, k);
          set$1(v.element(), &apos;aria-expanded&apos;, expanded);
        });
      };
      var updateMenuPath = function (container, state, path) {
        return Option.from(path[0]).bind(function (latestMenuName) {
          return state.lookupMenu(latestMenuName).bind(function (menuPrep) {
            if (menuPrep.type === &apos;notbuilt&apos;) {
              return Option.none();
            } else {
              var activeMenu = menuPrep.menu;
              var rest = getMenus(state, path.slice(1));
              each(rest, function (r) {
                add$2(r.element(), detail.markers.backgroundMenu);
              });
              if (!inBody(activeMenu.element())) {
                Replacing.append(container, premade$1(activeMenu));
              }
              remove$5(activeMenu.element(), [detail.markers.backgroundMenu]);
              setActiveMenu(container, activeMenu);
              closeOthers(container, state, path);
              return Option.some(activeMenu);
            }
          });
        });
      };
      var ExpandHighlightDecision;
      (function (ExpandHighlightDecision) {
        ExpandHighlightDecision[ExpandHighlightDecision[&apos;HighlightSubmenu&apos;] = 0] = &apos;HighlightSubmenu&apos;;
        ExpandHighlightDecision[ExpandHighlightDecision[&apos;HighlightParent&apos;] = 1] = &apos;HighlightParent&apos;;
      }(ExpandHighlightDecision || (ExpandHighlightDecision = {})));
      var buildIfRequired = function (container, menuName, menuPrep) {
        if (menuPrep.type === &apos;notbuilt&apos;) {
          var menu = container.getSystem().build(menuPrep.nbMenu());
          layeredState.setMenuBuilt(menuName, menu);
          return menu;
        } else {
          return menuPrep.menu;
        }
      };
      var expandRight = function (container, item, decision) {
        if (decision === void 0) {
          decision = ExpandHighlightDecision.HighlightSubmenu;
        }
        var value = getItemValue(item);
        return layeredState.expand(value).bind(function (path) {
          updateAriaExpansions(container, path);
          return Option.from(path[0]).bind(function (menuName) {
            return layeredState.lookupMenu(menuName).bind(function (activeMenuPrep) {
              var activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
              if (!inBody(activeMenu.element())) {
                Replacing.append(container, premade$1(activeMenu));
              }
              detail.onOpenSubmenu(container, item, activeMenu, reverse(path));
              if (decision === ExpandHighlightDecision.HighlightSubmenu) {
                Highlighting.highlightFirst(activeMenu);
                return updateMenuPath(container, layeredState, path);
              } else {
                Highlighting.dehighlightAll(activeMenu);
                return Option.some(item);
              }
            });
          });
        });
      };
      var collapseLeft = function (container, item) {
        var value = getItemValue(item);
        return layeredState.collapse(value).bind(function (path) {
          updateAriaExpansions(container, path);
          return updateMenuPath(container, layeredState, path).map(function (activeMenu) {
            detail.onCollapseMenu(container, item, activeMenu);
            return activeMenu;
          });
        });
      };
      var updateView = function (container, item) {
        var value = getItemValue(item);
        return layeredState.refresh(value).bind(function (path) {
          updateAriaExpansions(container, path);
          return updateMenuPath(container, layeredState, path);
        });
      };
      var onRight = function (container, item) {
        return inside(item.element()) ? Option.none() : expandRight(container, item, ExpandHighlightDecision.HighlightSubmenu);
      };
      var onLeft = function (container, item) {
        return inside(item.element()) ? Option.none() : collapseLeft(container, item);
      };
      var onEscape = function (container, item) {
        return collapseLeft(container, item).orThunk(function () {
          return detail.onEscape(container, item).map(function () {
            return container;
          });
        });
      };
      var keyOnItem = function (f) {
        return function (container, simulatedEvent) {
          return closest$3(simulatedEvent.getSource(), &apos;.&apos; + detail.markers.item).bind(function (target) {
            return container.getSystem().getByDom(target).toOption().bind(function (item) {
              return f(container, item).map(function () {
                return true;
              });
            });
          });
        };
      };
      var events = derive([
        run(focus$4(), function (sandbox, simulatedEvent) {
          var item = simulatedEvent.event().item();
          layeredState.lookupItem(getItemValue(item)).each(function () {
            var menu = simulatedEvent.event().menu();
            Highlighting.highlight(sandbox, menu);
            var value = getItemValue(simulatedEvent.event().item());
            layeredState.refresh(value).each(function (path) {
              return closeOthers(sandbox, layeredState, path);
            });
          });
        }),
        runOnExecute(function (component, simulatedEvent) {
          var target = simulatedEvent.event().target();
          component.getSystem().getByDom(target).each(function (item) {
            var itemValue = getItemValue(item);
            if (itemValue.indexOf(&apos;collapse-item&apos;) === 0) {
              collapseLeft(component, item);
            }
            expandRight(component, item, ExpandHighlightDecision.HighlightSubmenu).fold(function () {
              detail.onExecute(component, item);
            }, function () {
            });
          });
        }),
        runOnAttached(function (container, _simulatedEvent) {
          setup(container).each(function (primary) {
            Replacing.append(container, premade$1(primary));
            detail.onOpenMenu(container, primary);
            if (detail.highlightImmediately) {
              setActiveMenu(container, primary);
            }
          });
        })
      ].concat(detail.navigateOnHover ? [run(hover(), function (sandbox, simulatedEvent) {
          var item = simulatedEvent.event().item();
          updateView(sandbox, item);
          expandRight(sandbox, item, ExpandHighlightDecision.HighlightParent);
          detail.onHover(sandbox, item);
        })] : []));
      var getActiveItem = function (container) {
        return Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);
      };
      var collapseMenuApi = function (container) {
        getActiveItem(container).each(function (currentItem) {
          collapseLeft(container, currentItem);
        });
      };
      var highlightPrimary = function (container) {
        layeredState.getPrimary().each(function (primary) {
          setActiveMenu(container, primary);
        });
      };
      var extractMenuFromContainer = function (container) {
        return Option.from(container.components()[0]).filter(function (comp) {
          return get$2(comp.element(), &apos;role&apos;) === &apos;menu&apos;;
        });
      };
      var repositionMenus = function (container) {
        var maybeActivePrimary = layeredState.getPrimary().bind(function (primary) {
          return getActiveItem(container).bind(function (currentItem) {
            var itemValue = getItemValue(currentItem);
            var allMenus = values(layeredState.getMenus());
            var preparedMenus = cat(map(allMenus, LayeredState.extractPreparedMenu));
            return layeredState.getTriggeringPath(itemValue, function (v) {
              return getItemByValue(container, preparedMenus, v);
            });
          }).map(function (triggeringPath) {
            return {
              primary: primary,
              triggeringPath: triggeringPath
            };
          });
        });
        maybeActivePrimary.fold(function () {
          extractMenuFromContainer(container).each(function (primaryMenu) {
            detail.onRepositionMenu(container, primaryMenu, []);
          });
        }, function (_a) {
          var primary = _a.primary, triggeringPath = _a.triggeringPath;
          detail.onRepositionMenu(container, primary, triggeringPath);
        });
      };
      var apis = {
        collapseMenu: collapseMenuApi,
        highlightPrimary: highlightPrimary,
        repositionMenus: repositionMenus
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        markers: detail.markers,
        behaviours: augment(detail.tmenuBehaviours, [
          Keying.config({
            mode: &apos;special&apos;,
            onRight: keyOnItem(onRight),
            onLeft: keyOnItem(onLeft),
            onEscape: keyOnItem(onEscape),
            focusIn: function (container, _keyInfo) {
              layeredState.getPrimary().each(function (primary) {
                dispatch(container, primary.element(), focusItem());
              });
            }
          }),
          Highlighting.config({
            highlightClass: detail.markers.selectedMenu,
            itemClass: detail.markers.menu
          }),
          Composing.config({
            find: function (container) {
              return Highlighting.getHighlighted(container);
            }
          }),
          Replacing.config({})
        ]),
        eventOrder: detail.eventOrder,
        apis: apis,
        events: events
      };
    };
    var collapseItem = constant(&apos;collapse-item&apos;);

    var tieredData = function (primary, menus, expansions) {
      return {
        primary: primary,
        menus: menus,
        expansions: expansions
      };
    };
    var singleData = function (name, menu) {
      return {
        primary: name,
        menus: wrap$1(name, menu),
        expansions: {}
      };
    };
    var collapseItem$1 = function (text) {
      return {
        value: generate$1(collapseItem()),
        meta: { text: text }
      };
    };
    var tieredMenu = single$2({
      name: &apos;TieredMenu&apos;,
      configFields: [
        onStrictKeyboardHandler(&apos;onExecute&apos;),
        onStrictKeyboardHandler(&apos;onEscape&apos;),
        onStrictHandler(&apos;onOpenMenu&apos;),
        onStrictHandler(&apos;onOpenSubmenu&apos;),
        onHandler(&apos;onRepositionMenu&apos;),
        onHandler(&apos;onCollapseMenu&apos;),
        defaulted$1(&apos;highlightImmediately&apos;, true),
        strictObjOf(&apos;data&apos;, [
          strict$1(&apos;primary&apos;),
          strict$1(&apos;menus&apos;),
          strict$1(&apos;expansions&apos;)
        ]),
        defaulted$1(&apos;fakeFocus&apos;, false),
        onHandler(&apos;onHighlight&apos;),
        onHandler(&apos;onHover&apos;),
        tieredMenuMarkers(),
        strict$1(&apos;dom&apos;),
        defaulted$1(&apos;navigateOnHover&apos;, true),
        defaulted$1(&apos;stayInDom&apos;, false),
        field$1(&apos;tmenuBehaviours&apos;, [
          Keying,
          Highlighting,
          Composing,
          Replacing
        ]),
        defaulted$1(&apos;eventOrder&apos;, {})
      ],
      apis: {
        collapseMenu: function (apis, tmenu) {
          apis.collapseMenu(tmenu);
        },
        highlightPrimary: function (apis, tmenu) {
          apis.highlightPrimary(tmenu);
        },
        repositionMenus: function (apis, tmenu) {
          apis.repositionMenus(tmenu);
        }
      },
      factory: make$2,
      extraApis: {
        tieredData: tieredData,
        singleData: singleData,
        collapseItem: collapseItem$1
      }
    });

    var makeMenu = function (detail, menuSandbox, anchor, menuSpec, getBounds) {
      var lazySink = function () {
        return detail.lazySink(menuSandbox);
      };
      var layouts = menuSpec.type === &apos;horizontal&apos; ? {
        layouts: {
          onLtr: function () {
            return belowOrAbove();
          },
          onRtl: function () {
            return belowOrAboveRtl();
          }
        }
      } : {};
      var isFirstTierSubmenu = function (triggeringPaths) {
        return triggeringPaths.length === 2;
      };
      var getSubmenuLayouts = function (triggeringPaths) {
        return isFirstTierSubmenu(triggeringPaths) ? layouts : {};
      };
      return tieredMenu.sketch({
        dom: { tag: &apos;div&apos; },
        data: menuSpec.data,
        markers: menuSpec.menu.markers,
        highlightImmediately: menuSpec.menu.highlightImmediately,
        onEscape: function () {
          Sandboxing.close(menuSandbox);
          detail.onEscape.map(function (handler) {
            return handler(menuSandbox);
          });
          return Option.some(true);
        },
        onExecute: function () {
          return Option.some(true);
        },
        onOpenMenu: function (tmenu, menu) {
          Positioning.positionWithinBounds(lazySink().getOrDie(), anchor, menu, getBounds());
        },
        onOpenSubmenu: function (tmenu, item, submenu, triggeringPaths) {
          var sink = lazySink().getOrDie();
          Positioning.position(sink, __assign({
            anchor: &apos;submenu&apos;,
            item: item
          }, getSubmenuLayouts(triggeringPaths)), submenu);
        },
        onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {
          var sink = lazySink().getOrDie();
          Positioning.positionWithinBounds(sink, anchor, primaryMenu, getBounds());
          each(submenuTriggers, function (st) {
            var submenuLayouts = getSubmenuLayouts(st.triggeringPath);
            Positioning.position(sink, __assign({
              anchor: &apos;submenu&apos;,
              item: st.triggeringItem
            }, submenuLayouts), st.triggeredMenu);
          });
        }
      });
    };
    var factory = function (detail, spec) {
      var isPartOfRelated = function (sandbox, queryElem) {
        var related = detail.getRelated(sandbox);
        return related.exists(function (rel) {
          return isPartOf(rel, queryElem);
        });
      };
      var setContent = function (sandbox, thing) {
        Sandboxing.setContent(sandbox, thing);
      };
      var showAt = function (sandbox, anchor, thing) {
        showWithin(sandbox, anchor, thing, Option.none());
      };
      var showWithin = function (sandbox, anchor, thing, boxElement) {
        showWithinBounds(sandbox, anchor, thing, function () {
          return boxElement.map(function (elem) {
            return box(elem);
          });
        });
      };
      var showWithinBounds = function (sandbox, anchor, thing, getBounds) {
        var sink = detail.lazySink(sandbox).getOrDie();
        Sandboxing.openWhileCloaked(sandbox, thing, function () {
          return Positioning.positionWithinBounds(sink, anchor, sandbox, getBounds());
        });
        Representing.setValue(sandbox, Option.some({
          mode: &apos;position&apos;,
          anchor: anchor,
          getBounds: getBounds
        }));
      };
      var showMenuAt = function (sandbox, anchor, menuSpec) {
        showMenuWithinBounds(sandbox, anchor, menuSpec, function () {
          return Option.none();
        });
      };
      var showMenuWithinBounds = function (sandbox, anchor, menuSpec, getBounds) {
        var menu = makeMenu(detail, sandbox, anchor, menuSpec, getBounds);
        Sandboxing.open(sandbox, menu);
        Representing.setValue(sandbox, Option.some({
          mode: &apos;menu&apos;,
          menu: menu
        }));
      };
      var hide = function (sandbox) {
        if (Sandboxing.isOpen(sandbox)) {
          Representing.setValue(sandbox, Option.none());
          Sandboxing.close(sandbox);
        }
      };
      var getContent = function (sandbox) {
        return Sandboxing.getState(sandbox);
      };
      var reposition = function (sandbox) {
        if (Sandboxing.isOpen(sandbox)) {
          Representing.getValue(sandbox).each(function (state) {
            switch (state.mode) {
            case &apos;menu&apos;:
              Sandboxing.getState(sandbox).each(function (tmenu) {
                tieredMenu.repositionMenus(tmenu);
              });
              break;
            case &apos;position&apos;:
              var sink = detail.lazySink(sandbox).getOrDie();
              Positioning.positionWithinBounds(sink, state.anchor, sandbox, state.getBounds());
              break;
            }
          });
        }
      };
      var apis = {
        setContent: setContent,
        showAt: showAt,
        showWithin: showWithin,
        showWithinBounds: showWithinBounds,
        showMenuAt: showMenuAt,
        showMenuWithinBounds: showMenuWithinBounds,
        hide: hide,
        getContent: getContent,
        reposition: reposition,
        isOpen: Sandboxing.isOpen
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        behaviours: augment(detail.inlineBehaviours, [
          Sandboxing.config({
            isPartOf: function (sandbox, data, queryElem) {
              return isPartOf(data, queryElem) || isPartOfRelated(sandbox, queryElem);
            },
            getAttachPoint: function (sandbox) {
              return detail.lazySink(sandbox).getOrDie();
            },
            onOpen: function (sandbox) {
              detail.onShow(sandbox);
            },
            onClose: function (sandbox) {
              detail.onHide(sandbox);
            }
          }),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: Option.none()
            }
          }),
          Receiving.config({
            channels: __assign(__assign({}, receivingChannel(__assign({ isExtraPart: spec.isExtraPart }, detail.fireDismissalEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})))), receivingChannel$1(__assign(__assign({}, detail.fireRepositionEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})), { doReposition: reposition })))
          })
        ]),
        eventOrder: detail.eventOrder,
        apis: apis
      };
    };
    var InlineView = single$2({
      name: &apos;InlineView&apos;,
      configFields: [
        strict$1(&apos;lazySink&apos;),
        onHandler(&apos;onShow&apos;),
        onHandler(&apos;onHide&apos;),
        optionFunction(&apos;onEscape&apos;),
        field$1(&apos;inlineBehaviours&apos;, [
          Sandboxing,
          Representing,
          Receiving
        ]),
        optionObjOf(&apos;fireDismissalEventInstead&apos;, [defaulted$1(&apos;event&apos;, dismissRequested())]),
        optionObjOf(&apos;fireRepositionEventInstead&apos;, [defaulted$1(&apos;event&apos;, repositionRequested())]),
        defaulted$1(&apos;getRelated&apos;, Option.none),
        defaulted$1(&apos;isExtraPart&apos;, never),
        defaulted$1(&apos;eventOrder&apos;, Option.none)
      ],
      factory: factory,
      apis: {
        showAt: function (apis, component, anchor, thing) {
          apis.showAt(component, anchor, thing);
        },
        showWithin: function (apis, component, anchor, thing, boxElement) {
          apis.showWithin(component, anchor, thing, boxElement);
        },
        showWithinBounds: function (apis, component, anchor, thing, bounds) {
          apis.showWithinBounds(component, anchor, thing, bounds);
        },
        showMenuAt: function (apis, component, anchor, menuSpec) {
          apis.showMenuAt(component, anchor, menuSpec);
        },
        showMenuWithinBounds: function (apis, component, anchor, menuSpec, bounds) {
          apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
        },
        hide: function (apis, component) {
          apis.hide(component);
        },
        isOpen: function (apis, component) {
          return apis.isOpen(component);
        },
        getContent: function (apis, component) {
          return apis.getContent(component);
        },
        setContent: function (apis, component, thing) {
          apis.setContent(component, thing);
        },
        reposition: function (apis, component) {
          apis.reposition(component);
        }
      }
    });

    var westEdgeX$1 = function (anchor) {
      return anchor.x;
    };
    var middleX$1 = function (anchor, element) {
      return anchor.x + anchor.width / 2 - element.width / 2;
    };
    var eastEdgeX$1 = function (anchor, element) {
      return anchor.x + anchor.width - element.width;
    };
    var northY$2 = function (anchor) {
      return anchor.y;
    };
    var southY$2 = function (anchor, element) {
      return anchor.y + anchor.height - element.height;
    };
    var southeast$3 = function (anchor, element, bubbles) {
      return nu$7(eastEdgeX$1(anchor, element), southY$2(anchor, element), bubbles.innerSoutheast(), northwest(), boundsRestriction(anchor, {
        right: 0,
        bottom: 3
      }), &apos;layout-inner-se&apos;);
    };
    var southwest$3 = function (anchor, element, bubbles) {
      return nu$7(westEdgeX$1(anchor), southY$2(anchor, element), bubbles.innerSouthwest(), northeast(), boundsRestriction(anchor, {
        left: 1,
        bottom: 3
      }), &apos;layout-inner-sw&apos;);
    };
    var northeast$3 = function (anchor, element, bubbles) {
      return nu$7(eastEdgeX$1(anchor, element), northY$2(anchor), bubbles.innerNortheast(), southwest(), boundsRestriction(anchor, {
        right: 0,
        top: 2
      }), &apos;layout-inner-ne&apos;);
    };
    var northwest$3 = function (anchor, element, bubbles) {
      return nu$7(westEdgeX$1(anchor), northY$2(anchor), bubbles.innerNorthwest(), southeast(), boundsRestriction(anchor, {
        left: 1,
        top: 2
      }), &apos;layout-inner-nw&apos;);
    };
    var north$3 = function (anchor, element, bubbles) {
      return nu$7(middleX$1(anchor, element), northY$2(anchor), bubbles.innerNorth(), south(), boundsRestriction(anchor, { top: 2 }), &apos;layout-inner-n&apos;);
    };
    var south$3 = function (anchor, element, bubbles) {
      return nu$7(middleX$1(anchor, element), southY$2(anchor, element), bubbles.innerSouth(), north(), boundsRestriction(anchor, { bottom: 3 }), &apos;layout-inner-s&apos;);
    };

    var global$2 = tinymce.util.Tools.resolve(&apos;tinymce.util.Delay&apos;);

    var factory$1 = function (detail) {
      var events = events$7(detail.action);
      var tag = detail.dom.tag;
      var lookupAttr = function (attr) {
        return get(detail.dom, &apos;attributes&apos;).bind(function (attrs) {
          return get(attrs, attr);
        });
      };
      var getModAttributes = function () {
        if (tag === &apos;button&apos;) {
          var type = lookupAttr(&apos;type&apos;).getOr(&apos;button&apos;);
          var roleAttrs = lookupAttr(&apos;role&apos;).map(function (role) {
            return { role: role };
          }).getOr({});
          return __assign({ type: type }, roleAttrs);
        } else {
          var role = lookupAttr(&apos;role&apos;).getOr(&apos;button&apos;);
          return { role: role };
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: detail.components,
        events: events,
        behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
          Focusing.config({}),
          Keying.config({
            mode: &apos;execution&apos;,
            useSpace: true,
            useEnter: true
          })
        ]),
        domModification: { attributes: getModAttributes() },
        eventOrder: detail.eventOrder
      };
    };
    var Button = single$2({
      name: &apos;Button&apos;,
      factory: factory$1,
      configFields: [
        defaulted$1(&apos;uid&apos;, undefined),
        strict$1(&apos;dom&apos;),
        defaulted$1(&apos;components&apos;, []),
        SketchBehaviours.field(&apos;buttonBehaviours&apos;, [
          Focusing,
          Keying
        ]),
        option(&apos;action&apos;),
        option(&apos;role&apos;),
        defaulted$1(&apos;eventOrder&apos;, {})
      ]
    });

    var record = function (spec) {
      var uid = isSketchSpec(spec) &amp;&amp; hasNonNullableKey(spec, &apos;uid&apos;) ? spec.uid : generate$2(&apos;memento&apos;);
      var get = function (anyInSystem) {
        return anyInSystem.getSystem().getByUid(uid).getOrDie();
      };
      var getOpt = function (anyInSystem) {
        return anyInSystem.getSystem().getByUid(uid).toOption();
      };
      var asSpec = function () {
        return __assign(__assign({}, spec), { uid: uid });
      };
      return {
        get: get,
        getOpt: getOpt,
        asSpec: asSpec
      };
    };

    var defaultIcon = function (icons) {
      return Option.from(icons()[&apos;temporary-placeholder&apos;]).getOr(&apos;!not found!&apos;);
    };
    var get$d = function (name, icons) {
      return Option.from(icons()[name]).getOrThunk(function () {
        return defaultIcon(icons);
      });
    };
    var getOr = function (name, icons, fallback) {
      return Option.from(icons()[name]).or(fallback).getOrThunk(function () {
        return defaultIcon(icons);
      });
    };
    var getFirst$1 = function (names, icons) {
      return findMap(names, function (name) {
        return Option.from(icons()[name]);
      }).getOrThunk(function () {
        return defaultIcon(icons);
      });
    };

    var notificationIconMap = {
      success: &apos;checkmark&apos;,
      error: &apos;warning&apos;,
      err: &apos;error&apos;,
      warning: &apos;warning&apos;,
      warn: &apos;warning&apos;,
      info: &apos;info&apos;
    };
    var factory$2 = function (detail) {
      var memBannerText = record({
        dom: {
          tag: &apos;p&apos;,
          innerHtml: detail.translationProvider(detail.text)
        },
        behaviours: derive$1([Replacing.config({})])
      });
      var renderPercentBar = function (percent) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-bar&apos;],
            attributes: { style: &apos;width: &apos; + percent + &apos;%&apos; }
          }
        };
      };
      var renderPercentText = function (percent) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-text&apos;],
            innerHtml: percent + &apos;%&apos;
          }
        };
      };
      var memBannerProgress = record({
        dom: {
          tag: &apos;div&apos;,
          classes: detail.progress ? [
            &apos;tox-progress-bar&apos;,
            &apos;tox-progress-indicator&apos;
          ] : [&apos;tox-progress-bar&apos;]
        },
        components: [
          {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-bar-container&apos;]
            },
            components: [renderPercentBar(0)]
          },
          renderPercentText(0)
        ],
        behaviours: derive$1([Replacing.config({})])
      });
      var updateProgress = function (comp, percent) {
        if (comp.getSystem().isConnected()) {
          memBannerProgress.getOpt(comp).each(function (progress) {
            Replacing.set(progress, [
              {
                dom: {
                  tag: &apos;div&apos;,
                  classes: [&apos;tox-bar-container&apos;]
                },
                components: [renderPercentBar(percent)]
              },
              renderPercentText(percent)
            ]);
          });
        }
      };
      var updateText = function (comp, text$1) {
        if (comp.getSystem().isConnected()) {
          var banner = memBannerText.get(comp);
          Replacing.set(banner, [text(text$1)]);
        }
      };
      var apis = {
        updateProgress: updateProgress,
        updateText: updateText
      };
      var iconChoices = flatten([
        detail.icon.toArray(),
        detail.level.toArray(),
        detail.level.bind(function (level) {
          return Option.from(notificationIconMap[level]);
        }).toArray()
      ]);
      return {
        uid: detail.uid,
        dom: {
          tag: &apos;div&apos;,
          attributes: { role: &apos;alert&apos; },
          classes: detail.level.map(function (level) {
            return [
              &apos;tox-notification&apos;,
              &apos;tox-notification--in&apos;,
              &apos;tox-notification--&apos; + level
            ];
          }).getOr([
            &apos;tox-notification&apos;,
            &apos;tox-notification--in&apos;
          ])
        },
        components: [
          {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-notification__icon&apos;],
              innerHtml: getFirst$1(iconChoices, detail.iconProvider)
            }
          },
          {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-notification__body&apos;]
            },
            components: [memBannerText.asSpec()],
            behaviours: derive$1([Replacing.config({})])
          }
        ].concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [Button.sketch({
            dom: {
              tag: &apos;button&apos;,
              classes: [
                &apos;tox-notification__dismiss&apos;,
                &apos;tox-button&apos;,
                &apos;tox-button--naked&apos;,
                &apos;tox-button--icon&apos;
              ]
            },
            components: [{
                dom: {
                  tag: &apos;div&apos;,
                  classes: [&apos;tox-icon&apos;],
                  innerHtml: get$d(&apos;close&apos;, detail.iconProvider),
                  attributes: { &apos;aria-label&apos;: detail.translationProvider(&apos;Close&apos;) }
                }
              }],
            action: function (comp) {
              detail.onAction(comp);
            }
          })]),
        apis: apis
      };
    };
    var Notification = single$2({
      name: &apos;Notification&apos;,
      factory: factory$2,
      configFields: [
        option(&apos;level&apos;),
        strict$1(&apos;progress&apos;),
        strict$1(&apos;icon&apos;),
        strict$1(&apos;onAction&apos;),
        strict$1(&apos;text&apos;),
        strict$1(&apos;iconProvider&apos;),
        strict$1(&apos;translationProvider&apos;),
        defaultedBoolean(&apos;closeButton&apos;, true)
      ],
      apis: {
        updateProgress: function (apis, comp, percent) {
          apis.updateProgress(comp, percent);
        },
        updateText: function (apis, comp, text) {
          apis.updateText(comp, text);
        }
      }
    });

    function NotificationManagerImpl (editor, extras, uiMothership) {
      var backstage = extras.backstage;
      var getLayoutDirection = function (rel) {
        switch (rel) {
        case &apos;bc-bc&apos;:
          return south$3;
        case &apos;tc-tc&apos;:
          return north$3;
        case &apos;tc-bc&apos;:
          return north$1;
        case &apos;bc-tc&apos;:
        default:
          return south$1;
        }
      };
      var prePositionNotifications = function (notifications) {
        each(notifications, function (notification) {
          return notification.moveTo(0, 0);
        });
      };
      var positionNotifications = function (notifications) {
        if (notifications.length &gt; 0) {
          head(notifications).each(function (firstItem) {
            return firstItem.moveRel(null, &apos;banner&apos;);
          });
          each(notifications, function (notification, index) {
            if (index &gt; 0) {
              notification.moveRel(notifications[index - 1].getEl(), &apos;bc-tc&apos;);
            }
          });
        }
      };
      var reposition = function (notifications) {
        prePositionNotifications(notifications);
        positionNotifications(notifications);
      };
      var open = function (settings, closeCallback) {
        var hideCloseButton = !settings.closeButton &amp;&amp; settings.timeout &amp;&amp; (settings.timeout &gt; 0 || settings.timeout &lt; 0);
        var close = function () {
          closeCallback();
          InlineView.hide(notificationWrapper);
        };
        var notification = build$1(Notification.sketch({
          text: settings.text,
          level: contains([
            &apos;success&apos;,
            &apos;error&apos;,
            &apos;warning&apos;,
            &apos;warn&apos;,
            &apos;info&apos;
          ], settings.type) ? settings.type : undefined,
          progress: settings.progressBar === true,
          icon: Option.from(settings.icon),
          closeButton: !hideCloseButton,
          onAction: close,
          iconProvider: backstage.shared.providers.icons,
          translationProvider: backstage.shared.providers.translate
        }));
        var notificationWrapper = build$1(InlineView.sketch(__assign({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-notifications-container&apos;]
          },
          lazySink: extras.backstage.shared.getSink,
          fireDismissalEventInstead: {}
        }, backstage.shared.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} })));
        uiMothership.add(notificationWrapper);
        if (settings.timeout &gt; 0) {
          global$2.setTimeout(function () {
            close();
          }, settings.timeout);
        }
        return {
          close: close,
          moveTo: function (x, y) {
            InlineView.showAt(notificationWrapper, {
              anchor: &apos;makeshift&apos;,
              x: x,
              y: y
            }, premade$1(notification));
          },
          moveRel: function (element, rel) {
            if (rel !== &apos;banner&apos;) {
              var layoutDirection_1 = getLayoutDirection(rel);
              var nodeAnchor = {
                anchor: &apos;node&apos;,
                root: body(),
                node: Option.some(Element.fromDom(element)),
                layouts: {
                  onRtl: function () {
                    return [layoutDirection_1];
                  },
                  onLtr: function () {
                    return [layoutDirection_1];
                  }
                }
              };
              InlineView.showAt(notificationWrapper, nodeAnchor, premade$1(notification));
            } else {
              InlineView.showAt(notificationWrapper, extras.backstage.shared.anchors.banner(), premade$1(notification));
            }
          },
          text: function (nuText) {
            Notification.updateText(notification, nuText);
          },
          settings: settings,
          getEl: function () {
            return notification.element().dom();
          },
          progressBar: {
            value: function (percent) {
              Notification.updateProgress(notification, percent);
            }
          }
        };
      };
      var close = function (notification) {
        notification.close();
      };
      var getArgs = function (notification) {
        return notification.settings;
      };
      return {
        open: open,
        close: close,
        reposition: reposition,
        getArgs: getArgs
      };
    }

    var first = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (timer !== null) {
          domGlobals.clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (timer === null) {
          timer = domGlobals.setTimeout(function () {
            fn.apply(null, args);
            timer = null;
          }, rate);
        }
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };
    var last$2 = function (fn, rate) {
      var timer = null;
      var cancel = function () {
        if (timer !== null) {
          domGlobals.clearTimeout(timer);
          timer = null;
        }
      };
      var throttle = function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (timer !== null) {
          domGlobals.clearTimeout(timer);
        }
        timer = domGlobals.setTimeout(function () {
          fn.apply(null, args);
          timer = null;
        }, rate);
      };
      return {
        cancel: cancel,
        throttle: throttle
      };
    };

    var global$3 = tinymce.util.Tools.resolve(&apos;tinymce.dom.TextSeeker&apos;);

    var isBoundary = function (dom, node) {
      return dom.isBlock(node) || contains([
        &apos;BR&apos;,
        &apos;IMG&apos;,
        &apos;HR&apos;,
        &apos;INPUT&apos;
      ], node.nodeName) || dom.getContentEditable(node) === &apos;false&apos;;
    };
    var repeatLeft = function (dom, node, offset, process, rootNode) {
      var search = global$3(dom, function (node) {
        return isBoundary(dom, node);
      });
      return Option.from(search.backwards(node, offset, process, rootNode));
    };

    var autocompleteSelector = &apos;[data-mce-autocompleter]&apos;;
    var create$4 = function (editor, range) {
      return detect$4(Element.fromDom(editor.selection.getNode())).getOrThunk(function () {
        var wrapper = Element.fromHtml(&apos;&lt;span data-mce-autocompleter=&quot;1&quot; data-mce-bogus=&quot;1&quot;&gt;&lt;/span&gt;&apos;, editor.getDoc());
        append(wrapper, Element.fromDom(range.extractContents()));
        range.insertNode(wrapper.dom());
        parent(wrapper).each(function (elm) {
          return elm.dom().normalize();
        });
        last$1(wrapper).map(function (last) {
          editor.selection.setCursorLocation(last.dom(), getEnd(last));
        });
        return wrapper;
      });
    };
    var detect$4 = function (elm) {
      return closest$3(elm, autocompleteSelector);
    };

    var isValidTextRange = function (rng) {
      return rng.collapsed &amp;&amp; rng.startContainer.nodeType === 3;
    };
    var getText = function (rng) {
      return rng.toString().replace(/\u00A0/g, &apos; &apos;).replace(/\uFEFF/g, &apos;&apos;);
    };
    var isWhitespace = function (chr) {
      return chr !== &apos;&apos; &amp;&amp; &apos; \xA0\f\n\r\t\x0B&apos;.indexOf(chr) !== -1;
    };

    var stripTriggerChar = function (text, triggerCh) {
      return text.substring(triggerCh.length);
    };
    var findChar = function (text, index, ch) {
      var i;
      for (i = index - 1; i &gt;= 0; i--) {
        var char = text.charAt(i);
        if (isWhitespace(char)) {
          return Option.none();
        }
        if (char === ch) {
          break;
        }
      }
      return Option.some(i);
    };
    var findStart = function (dom, initRange, ch, minChars) {
      if (minChars === void 0) {
        minChars = 0;
      }
      if (!isValidTextRange(initRange)) {
        return Option.none();
      }
      var findTriggerChIndex = function (element, offset, text) {
        return findChar(text, offset, ch).getOr(offset);
      };
      var root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();
      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerChIndex, root).bind(function (spot) {
        var range = initRange.cloneRange();
        range.setStart(spot.container, spot.offset);
        range.setEnd(initRange.endContainer, initRange.endOffset);
        if (range.collapsed) {
          return Option.none();
        }
        var text = getText(range);
        var triggerCharIndex = text.lastIndexOf(ch);
        if (triggerCharIndex !== 0 || stripTriggerChar(text, ch).length &lt; minChars) {
          return Option.none();
        } else {
          return Option.some({
            text: stripTriggerChar(text, ch),
            range: range,
            triggerChar: ch
          });
        }
      });
    };
    var getContext = function (dom, initRange, ch, minChars) {
      if (minChars === void 0) {
        minChars = 0;
      }
      return detect$4(Element.fromDom(initRange.startContainer)).fold(function () {
        return findStart(dom, initRange, ch, minChars);
      }, function (elm) {
        var range = dom.createRng();
        range.selectNode(elm.dom());
        var text = getText(range);
        return Option.some({
          range: range,
          text: stripTriggerChar(text, ch),
          triggerChar: ch
        });
      });
    };

    var setup = function (api, editor) {
      editor.on(&apos;keypress compositionend&apos;, api.onKeypress.throttle);
      editor.on(&apos;remove&apos;, api.onKeypress.cancel);
      var redirectKeyToItem = function (item, e) {
        emitWith(item, keydown(), { raw: e });
      };
      editor.on(&apos;keydown&apos;, function (e) {
        var getItem = function () {
          return api.getView().bind(Highlighting.getHighlighted);
        };
        if (e.which === 8) {
          api.onKeypress.throttle(e);
        }
        if (api.isActive()) {
          if (e.which === 27) {
            api.cancelIfNecessary();
          }
          if (api.isMenuOpen()) {
            if (e.which === 13) {
              getItem().each(emitExecute);
              e.preventDefault();
            } else if (e.which === 40) {
              getItem().fold(function () {
                api.getView().each(Highlighting.highlightFirst);
              }, function (item) {
                redirectKeyToItem(item, e);
              });
              e.preventDefault();
              e.stopImmediatePropagation();
            } else if (e.which === 37 || e.which === 38 || e.which === 39) {
              getItem().each(function (item) {
                redirectKeyToItem(item, e);
                e.preventDefault();
                e.stopImmediatePropagation();
              });
            }
          } else {
            if (e.which === 13 || e.which === 38 || e.which === 40) {
              api.cancelIfNecessary();
            }
          }
        }
      });
      editor.on(&apos;NodeChange&apos;, function (e) {
        if (api.isActive() &amp;&amp; !api.isProcessingAction() &amp;&amp; detect$4(Element.fromDom(e.element)).isNone()) {
          api.cancelIfNecessary();
        }
      });
    };
    var AutocompleterEditorEvents = { setup: setup };

    var global$4 = tinymce.util.Tools.resolve(&apos;tinymce.util.Promise&apos;);

    var point$2 = function (container, offset) {
      return {
        container: container,
        offset: offset
      };
    };

    var isText$1 = function (node) {
      return node.nodeType === domGlobals.Node.TEXT_NODE;
    };
    var isElement$1 = function (node) {
      return node.nodeType === domGlobals.Node.ELEMENT_NODE;
    };
    var toLast = function (node) {
      if (isText$1(node)) {
        return point$2(node, node.data.length);
      } else {
        var children = node.childNodes;
        return children.length &gt; 0 ? toLast(children[children.length - 1]) : point$2(node, children.length);
      }
    };
    var toLeaf = function (node, offset) {
      var children = node.childNodes;
      if (children.length &gt; 0 &amp;&amp; offset &lt; children.length) {
        return toLeaf(children[offset], 0);
      } else if (children.length &gt; 0 &amp;&amp; isElement$1(node) &amp;&amp; children.length === offset) {
        return toLast(children[children.length - 1]);
      } else {
        return point$2(node, offset);
      }
    };

    var isPreviousCharContent = function (dom, leaf) {
      return repeatLeft(dom, leaf.container, leaf.offset, function (element, offset) {
        return offset === 0 ? -1 : offset;
      }, dom.getRoot()).filter(function (spot) {
        var char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      }).isSome();
    };
    var isStartOfWord = function (dom) {
      return function (rng) {
        var leaf = toLeaf(rng.startContainer, rng.startOffset);
        return !isPreviousCharContent(dom, leaf);
      };
    };
    var getTriggerContext = function (dom, initRange, database) {
      return findMap(database.triggerChars, function (ch) {
        return getContext(dom, initRange, ch);
      });
    };
    var lookup = function (editor, getDatabase) {
      var database = getDatabase();
      var rng = editor.selection.getRng();
      return getTriggerContext(editor.dom, rng, database).bind(function (context) {
        return lookupWithContext(editor, getDatabase, context);
      });
    };
    var lookupWithContext = function (editor, getDatabase, context, fetchOptions) {
      if (fetchOptions === void 0) {
        fetchOptions = {};
      }
      var database = getDatabase();
      var rng = editor.selection.getRng();
      var startText = rng.startContainer.nodeValue;
      var autocompleters = filter(database.lookupByChar(context.triggerChar), function (autocompleter) {
        return context.text.length &gt;= autocompleter.minChars &amp;&amp; autocompleter.matches.getOrThunk(function () {
          return isStartOfWord(editor.dom);
        })(context.range, startText, context.text);
      });
      if (autocompleters.length === 0) {
        return Option.none();
      }
      var lookupData = global$4.all(map(autocompleters, function (ac) {
        var fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);
        return fetchResult.then(function (results) {
          return {
            matchText: context.text,
            items: results,
            columns: ac.columns,
            onAction: ac.onAction
          };
        });
      }));
      return Option.some({
        lookupData: lookupData,
        context: context
      });
    };

    var separatorMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      optionString(&apos;text&apos;)
    ]);
    var createSeparatorMenuItem = function (spec) {
      return asRaw(&apos;separatormenuitem&apos;, separatorMenuItemSchema, spec);
    };

    var autocompleterItemSchema = objOf([
      state$1(&apos;type&apos;, function () {
        return &apos;autocompleteitem&apos;;
      }),
      state$1(&apos;active&apos;, function () {
        return false;
      }),
      state$1(&apos;disabled&apos;, function () {
        return false;
      }),
      defaulted$1(&apos;meta&apos;, {}),
      strictString(&apos;value&apos;),
      optionString(&apos;text&apos;),
      optionString(&apos;icon&apos;)
    ]);
    var autocompleterSchema = objOf([
      strictString(&apos;type&apos;),
      strictString(&apos;ch&apos;),
      defaultedNumber(&apos;minChars&apos;, 1),
      defaulted$1(&apos;columns&apos;, 1),
      defaultedNumber(&apos;maxResults&apos;, 10),
      optionFunction(&apos;matches&apos;),
      strictFunction(&apos;fetch&apos;),
      strictFunction(&apos;onAction&apos;)
    ]);
    var createSeparatorItem = function (spec) {
      return asRaw(&apos;Autocompleter.Separator&apos;, separatorMenuItemSchema, spec);
    };
    var createAutocompleterItem = function (spec) {
      return asRaw(&apos;Autocompleter.Item&apos;, autocompleterItemSchema, spec);
    };
    var createAutocompleter = function (spec) {
      return asRaw(&apos;Autocompleter&apos;, autocompleterSchema, spec);
    };

    var stringArray = function (a) {
      var all = {};
      each(a, function (key) {
        all[key] = {};
      });
      return keys(all);
    };

    var register = function (editor) {
      var popups = editor.ui.registry.getAll().popups;
      var dataset = map$1(popups, function (popup) {
        return createAutocompleter(popup).fold(function (err) {
          throw new Error(formatError(err));
        }, function (x) {
          return x;
        });
      });
      var triggerChars = stringArray(mapToArray(dataset, function (v) {
        return v.ch;
      }));
      var datasetValues = values(dataset);
      var lookupByChar = function (ch) {
        return filter(datasetValues, function (dv) {
          return dv.ch === ch;
        });
      };
      return {
        dataset: dataset,
        triggerChars: triggerChars,
        lookupByChar: lookupByChar
      };
    };

    var commonMenuItemFields = [
      defaultedBoolean(&apos;disabled&apos;, false),
      optionString(&apos;text&apos;),
      optionString(&apos;shortcut&apos;),
      field(&apos;value&apos;, &apos;value&apos;, defaultedThunk(function () {
        return generate$1(&apos;menuitem-value&apos;);
      }), anyValue$1()),
      defaulted$1(&apos;meta&apos;, {})
    ];

    var menuItemSchema = objOf([
      strictString(&apos;type&apos;),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      }),
      defaultedFunction(&apos;onAction&apos;, noop),
      optionString(&apos;icon&apos;)
    ].concat(commonMenuItemFields));
    var createMenuItem = function (spec) {
      return asRaw(&apos;menuitem&apos;, menuItemSchema, spec);
    };

    var nestedMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      strictFunction(&apos;getSubmenuItems&apos;),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      }),
      optionString(&apos;icon&apos;)
    ].concat(commonMenuItemFields));
    var createNestedMenuItem = function (spec) {
      return asRaw(&apos;nestedmenuitem&apos;, nestedMenuItemSchema, spec);
    };

    var toggleMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      optionString(&apos;icon&apos;),
      defaultedBoolean(&apos;active&apos;, false),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      }),
      strictFunction(&apos;onAction&apos;)
    ].concat(commonMenuItemFields));
    var createToggleMenuItem = function (spec) {
      return asRaw(&apos;togglemenuitem&apos;, toggleMenuItemSchema, spec);
    };

    var choiceMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      defaultedBoolean(&apos;active&apos;, false),
      optionString(&apos;icon&apos;)
    ].concat(commonMenuItemFields));
    var createChoiceMenuItem = function (spec) {
      return asRaw(&apos;choicemenuitem&apos;, choiceMenuItemSchema, spec);
    };

    var fancyTypes = [
      &apos;inserttable&apos;,
      &apos;colorswatch&apos;
    ];
    var fancyMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      strictStringEnum(&apos;fancytype&apos;, fancyTypes),
      defaultedFunction(&apos;onAction&apos;, noop)
    ]);
    var createFancyMenuItem = function (spec) {
      return asRaw(&apos;fancymenuitem&apos;, fancyMenuItemSchema, spec);
    };

    var detectSize = function (comp, margin, selectorClass) {
      var descendants$1 = descendants(comp.element(), &apos;.&apos; + selectorClass);
      if (descendants$1.length &gt; 0) {
        var columnLength = findIndex(descendants$1, function (c) {
          var thisTop = c.dom().getBoundingClientRect().top;
          var cTop = descendants$1[0].dom().getBoundingClientRect().top;
          return Math.abs(thisTop - cTop) &gt; margin;
        }).getOr(descendants$1.length);
        return Option.some({
          numColumns: columnLength,
          numRows: Math.ceil(descendants$1.length / columnLength)
        });
      } else {
        return Option.none();
      }
    };

    var namedEvents = function (name, handlers) {
      return derive$1([config(name, handlers)]);
    };
    var unnamedEvents = function (handlers) {
      return namedEvents(generate$1(&apos;unnamed-events&apos;), handlers);
    };
    var SimpleBehaviours = {
      namedEvents: namedEvents,
      unnamedEvents: unnamedEvents
    };

    var TooltippingSchema = [
      strict$1(&apos;lazySink&apos;),
      strict$1(&apos;tooltipDom&apos;),
      defaulted$1(&apos;exclusive&apos;, true),
      defaulted$1(&apos;tooltipComponents&apos;, []),
      defaulted$1(&apos;delay&apos;, 300),
      defaultedStringEnum(&apos;mode&apos;, &apos;normal&apos;, [
        &apos;normal&apos;,
        &apos;follow-highlight&apos;
      ]),
      defaulted$1(&apos;anchor&apos;, function (comp) {
        return {
          anchor: &apos;hotspot&apos;,
          hotspot: comp,
          layouts: {
            onLtr: constant([
              south$1,
              north$1,
              southeast$1,
              northeast$1,
              southwest$1,
              northwest$1
            ]),
            onRtl: constant([
              south$1,
              north$1,
              southeast$1,
              northeast$1,
              southwest$1,
              northwest$1
            ])
          }
        };
      }),
      onHandler(&apos;onHide&apos;),
      onHandler(&apos;onShow&apos;)
    ];

    var init$4 = function () {
      var timer = Cell(Option.none());
      var popup = Cell(Option.none());
      var getTooltip = function () {
        return popup.get();
      };
      var setTooltip = function (comp) {
        popup.set(Option.some(comp));
      };
      var clearTooltip = function () {
        popup.set(Option.none());
      };
      var clearTimer = function () {
        timer.get().each(function (t) {
          domGlobals.clearTimeout(t);
        });
      };
      var resetTimer = function (f, delay) {
        clearTimer();
        timer.set(Option.some(domGlobals.setTimeout(function () {
          f();
        }, delay)));
      };
      var isShowing = function () {
        return popup.get().isSome();
      };
      var readState = constant(&apos;not-implemented&apos;);
      return nu$5({
        getTooltip: getTooltip,
        isShowing: isShowing,
        setTooltip: setTooltip,
        clearTooltip: clearTooltip,
        clearTimer: clearTimer,
        resetTimer: resetTimer,
        readState: readState
      });
    };

    var TooltippingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$4
    });

    var ExclusivityChannel = generate$1(&apos;tooltip.exclusive&apos;);
    var ShowTooltipEvent = generate$1(&apos;tooltip.show&apos;);
    var HideTooltipEvent = generate$1(&apos;tooltip.hide&apos;);

    var hideAllExclusive = function (component, _tConfig, _tState) {
      component.getSystem().broadcastOn([ExclusivityChannel], {});
    };
    var setComponents = function (component, tConfig, tState, specs) {
      tState.getTooltip().each(function (tooltip) {
        if (tooltip.getSystem().isConnected()) {
          Replacing.set(tooltip, specs);
        }
      });
    };

    var TooltippingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hideAllExclusive: hideAllExclusive,
        setComponents: setComponents
    });

    var events$8 = function (tooltipConfig, state) {
      var hide = function (comp) {
        state.getTooltip().each(function (p) {
          detach(p);
          tooltipConfig.onHide(comp, p);
          state.clearTooltip();
        });
        state.clearTimer();
      };
      var show = function (comp) {
        if (!state.isShowing()) {
          hideAllExclusive(comp);
          var sink = tooltipConfig.lazySink(comp).getOrDie();
          var popup = comp.getSystem().build({
            dom: tooltipConfig.tooltipDom,
            components: tooltipConfig.tooltipComponents,
            events: derive(tooltipConfig.mode === &apos;normal&apos; ? [
              run(mouseover(), function (_) {
                emit(comp, ShowTooltipEvent);
              }),
              run(mouseout(), function (_) {
                emit(comp, HideTooltipEvent);
              })
            ] : []),
            behaviours: derive$1([Replacing.config({})])
          });
          state.setTooltip(popup);
          attach$1(sink, popup);
          tooltipConfig.onShow(comp, popup);
          Positioning.position(sink, tooltipConfig.anchor(comp), popup);
        }
      };
      return derive(flatten([
        [
          run(ShowTooltipEvent, function (comp) {
            state.resetTimer(function () {
              show(comp);
            }, tooltipConfig.delay);
          }),
          run(HideTooltipEvent, function (comp) {
            state.resetTimer(function () {
              hide(comp);
            }, tooltipConfig.delay);
          }),
          run(receive(), function (comp, message) {
            var receivingData = message;
            if (contains(receivingData.channels(), ExclusivityChannel)) {
              hide(comp);
            }
          }),
          runOnDetached(function (comp) {
            hide(comp);
          })
        ],
        tooltipConfig.mode === &apos;normal&apos; ? [
          run(focusin(), function (comp) {
            emit(comp, ShowTooltipEvent);
          }),
          run(postBlur(), function (comp) {
            emit(comp, HideTooltipEvent);
          }),
          run(mouseover(), function (comp) {
            emit(comp, ShowTooltipEvent);
          }),
          run(mouseout(), function (comp) {
            emit(comp, HideTooltipEvent);
          })
        ] : [
          run(highlight(), function (comp, _se) {
            emit(comp, ShowTooltipEvent);
          }),
          run(dehighlight(), function (comp) {
            emit(comp, HideTooltipEvent);
          })
        ]
      ]));
    };

    var ActiveTooltipping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$8
    });

    var Tooltipping = create$1({
      fields: TooltippingSchema,
      name: &apos;tooltipping&apos;,
      active: ActiveTooltipping,
      state: TooltippingState,
      apis: TooltippingApis
    });

    var global$5 = tinymce.util.Tools.resolve(&apos;tinymce.util.I18n&apos;);

    var navClass = &apos;tox-menu-nav__js&apos;;
    var selectableClass = &apos;tox-collection__item&apos;;
    var colorClass = &apos;tox-swatch&apos;;
    var presetClasses = {
      normal: navClass,
      color: colorClass
    };
    var tickedClass = &apos;tox-collection__item--enabled&apos;;
    var groupHeadingClass = &apos;tox-collection__group-heading&apos;;
    var iconClass = &apos;tox-collection__item-icon&apos;;
    var textClass = &apos;tox-collection__item-label&apos;;
    var accessoryClass = &apos;tox-collection__item-accessory&apos;;
    var caretClass = &apos;tox-collection__item-caret&apos;;
    var checkmarkClass = &apos;tox-collection__item-checkmark&apos;;
    var activeClass = &apos;tox-collection__item--active&apos;;
    var iconClassRtl = &apos;tox-collection__item-icon-rtl&apos;;
    var classForPreset = function (presets) {
      return get(presetClasses, presets).getOr(navClass);
    };

    var global$6 = tinymce.util.Tools.resolve(&apos;tinymce.Env&apos;);

    var convertText = function (source) {
      var mac = {
        alt: &apos;&amp;#x2325;&apos;,
        ctrl: &apos;&amp;#x2303;&apos;,
        shift: &apos;&amp;#x21E7;&apos;,
        meta: &apos;&amp;#x2318;&apos;,
        access: &apos;&amp;#x2303;&amp;#x2325;&apos;
      };
      var other = {
        meta: &apos;Ctrl&apos;,
        access: &apos;Shift+Alt&apos;
      };
      var replace = global$6.mac ? mac : other;
      var shortcut = source.split(&apos;+&apos;);
      var updated = map(shortcut, function (segment) {
        var search = segment.toLowerCase().trim();
        return has(replace, search) ? replace[search] : segment;
      });
      return global$6.mac ? updated.join(&apos;&apos;) : updated.join(&apos;+&apos;);
    };

    var renderIcon = function (iconHtml) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [iconClass],
          innerHtml: iconHtml
        }
      };
    };
    var renderText = function (text$1) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [textClass]
        },
        components: [text(global$5.translate(text$1))]
      };
    };
    var renderHtml = function (html) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [textClass],
          innerHtml: html
        }
      };
    };
    var renderStyledText = function (style, text$1) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [textClass]
        },
        components: [{
            dom: {
              tag: style.tag,
              styles: style.styles
            },
            components: [text(global$5.translate(text$1))]
          }]
      };
    };
    var renderShortcut = function (shortcut) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [accessoryClass],
          innerHtml: convertText(shortcut)
        }
      };
    };
    var renderCheckmark = function (icons) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [checkmarkClass],
          innerHtml: get$d(&apos;checkmark&apos;, icons)
        }
      };
    };
    var renderSubmenuCaret = function (icons) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [caretClass],
          innerHtml: get$d(&apos;chevron-right&apos;, icons)
        }
      };
    };
    var renderDownwardsCaret = function (icons) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [caretClass],
          innerHtml: get$d(&apos;chevron-down&apos;, icons)
        }
      };
    };

    var renderColorStructure = function (itemText, itemValue, iconSvg, providerBackstage) {
      var colorPickerCommand = &apos;custom&apos;;
      var removeColorCommand = &apos;remove&apos;;
      var getDom = function () {
        var common = colorClass;
        var icon = iconSvg.getOr(&apos;&apos;);
        var attributes = itemText.map(function (text) {
          return { title: providerBackstage.translate(text) };
        }).getOr({});
        var baseDom = {
          tag: &apos;div&apos;,
          attributes: attributes,
          classes: [common]
        };
        if (itemValue === colorPickerCommand) {
          return __assign(__assign({}, baseDom), {
            tag: &apos;button&apos;,
            classes: __spreadArrays(baseDom.classes, [&apos;tox-swatches__picker-btn&apos;]),
            innerHtml: icon
          });
        } else if (itemValue === removeColorCommand) {
          return __assign(__assign({}, baseDom), {
            classes: __spreadArrays(baseDom.classes, [&apos;tox-swatch--remove&apos;]),
            innerHtml: icon
          });
        } else {
          return __assign(__assign({}, baseDom), {
            attributes: __assign(__assign({}, baseDom.attributes), { &apos;data-mce-color&apos;: itemValue }),
            styles: { &apos;background-color&apos;: itemValue }
          });
        }
      };
      return {
        dom: getDom(),
        optComponents: []
      };
    };
    var renderNormalItemStructure = function (info, icon, renderIcons, textRender, rtlClass) {
      var leftIcon = renderIcons ? icon.or(Option.some(&apos;&apos;)).map(renderIcon) : Option.none();
      var checkmark = info.checkMark;
      var domTitle = info.ariaLabel.map(function (label) {
        return { attributes: { title: global$5.translate(label) } };
      }).getOr({});
      var dom = __assign({
        tag: &apos;div&apos;,
        classes: [
          navClass,
          selectableClass
        ].concat(rtlClass ? [iconClassRtl] : [])
      }, domTitle);
      var content = info.htmlContent.fold(function () {
        return info.textContent.map(textRender);
      }, function (html) {
        return Option.some(renderHtml(html));
      });
      var menuItem = {
        dom: dom,
        optComponents: [
          leftIcon,
          content,
          info.shortcutContent.map(renderShortcut),
          checkmark,
          info.caret
        ]
      };
      return menuItem;
    };
    var rtlIcon = [
      &apos;list-num-default&apos;,
      &apos;list-num-lower-alpha&apos;,
      &apos;list-num-lower-greek&apos;,
      &apos;list-num-lower-roman&apos;,
      &apos;list-num-upper-alpha&apos;,
      &apos;list-num-upper-roman&apos;
    ];
    var rtlTransform = [
      &apos;list-bull-circle&apos;,
      &apos;list-bull-default&apos;,
      &apos;list-bull-square&apos;
    ];
    var renderItemStructure = function (info, providersBackstage, renderIcons, fallbackIcon) {
      if (fallbackIcon === void 0) {
        fallbackIcon = Option.none();
      }
      var getIconName = function (iconName) {
        return iconName.map(function (name) {
          return global$5.isRtl() &amp;&amp; contains(rtlIcon, name) ? name + &apos;-rtl&apos; : name;
        });
      };
      var needRtlClass = global$5.isRtl() &amp;&amp; info.iconContent.exists(function (name) {
        return contains(rtlTransform, name);
      });
      var icon = getIconName(info.iconContent).map(function (iconName) {
        return getOr(iconName, providersBackstage.icons, fallbackIcon);
      });
      var textRender = Option.from(info.meta).fold(function () {
        return renderText;
      }, function (meta) {
        return has(meta, &apos;style&apos;) ? curry(renderStyledText, meta.style) : renderText;
      });
      if (info.presets === &apos;color&apos;) {
        return renderColorStructure(info.ariaLabel, info.value, icon, providersBackstage);
      } else {
        return renderNormalItemStructure(info, icon, renderIcons, textRender, needRtlClass);
      }
    };

    var nativeDisabled = [
      &apos;input&apos;,
      &apos;button&apos;,
      &apos;textarea&apos;,
      &apos;select&apos;
    ];
    var onLoad$5 = function (component, disableConfig, disableState) {
      var f = disableConfig.disabled() ? disable : enable;
      f(component, disableConfig, disableState);
    };
    var hasNative = function (component, config) {
      return config.useNative === true &amp;&amp; contains(nativeDisabled, name(component.element()));
    };
    var nativeIsDisabled = function (component) {
      return has$1(component.element(), &apos;disabled&apos;);
    };
    var nativeDisable = function (component) {
      set$1(component.element(), &apos;disabled&apos;, &apos;disabled&apos;);
    };
    var nativeEnable = function (component) {
      remove$1(component.element(), &apos;disabled&apos;);
    };
    var ariaIsDisabled = function (component) {
      return get$2(component.element(), &apos;aria-disabled&apos;) === &apos;true&apos;;
    };
    var ariaDisable = function (component) {
      set$1(component.element(), &apos;aria-disabled&apos;, &apos;true&apos;);
    };
    var ariaEnable = function (component) {
      set$1(component.element(), &apos;aria-disabled&apos;, &apos;false&apos;);
    };
    var disable = function (component, disableConfig, _disableState) {
      disableConfig.disableClass.each(function (disableClass) {
        add$2(component.element(), disableClass);
      });
      var f = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;
      f(component);
      disableConfig.onDisabled(component);
    };
    var enable = function (component, disableConfig, _disableState) {
      disableConfig.disableClass.each(function (disableClass) {
        remove$4(component.element(), disableClass);
      });
      var f = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;
      f(component);
      disableConfig.onEnabled(component);
    };
    var isDisabled = function (component, disableConfig) {
      return hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);
    };
    var set$7 = function (component, disableConfig, disableState, disabled) {
      var f = disabled ? disable : enable;
      f(component, disableConfig, disableState);
    };

    var DisableApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        enable: enable,
        disable: disable,
        isDisabled: isDisabled,
        onLoad: onLoad$5,
        set: set$7
    });

    var exhibit$3 = function (base, disableConfig) {
      return nu$6({ classes: disableConfig.disabled ? disableConfig.disableClass.map(pure).getOr([]) : [] });
    };
    var events$9 = function (disableConfig, disableState) {
      return derive([
        abort(execute(), function (component, _simulatedEvent) {
          return isDisabled(component, disableConfig);
        }),
        loadEvent(disableConfig, disableState, onLoad$5)
      ]);
    };

    var ActiveDisable = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$3,
        events: events$9
    });

    var DisableSchema = [
      defaultedFunction(&apos;disabled&apos;, never),
      defaulted$1(&apos;useNative&apos;, true),
      option(&apos;disableClass&apos;),
      onHandler(&apos;onDisabled&apos;),
      onHandler(&apos;onEnabled&apos;)
    ];

    var Disabling = create$1({
      fields: DisableSchema,
      name: &apos;disabling&apos;,
      active: ActiveDisable,
      apis: DisableApis
    });

    var global$7 = tinymce.util.Tools.resolve(&apos;tinymce.dom.DOMUtils&apos;);

    var global$8 = tinymce.util.Tools.resolve(&apos;tinymce.EditorManager&apos;);

    var getSkinUrl = function (editor) {
      var settings = editor.settings;
      var skin = settings.skin;
      var skinUrl = settings.skin_url;
      if (skin !== false) {
        var skinName = skin ? skin : &apos;oxide&apos;;
        if (skinUrl) {
          skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
        } else {
          skinUrl = global$8.baseURL + &apos;/skins/ui/&apos; + skinName;
        }
      }
      return skinUrl;
    };
    var isReadOnly = function (editor) {
      return editor.getParam(&apos;readonly&apos;, false, &apos;boolean&apos;);
    };
    var isSkinDisabled = function (editor) {
      return editor.getParam(&apos;skin&apos;) === false;
    };
    var getHeightSetting = function (editor) {
      return editor.getParam(&apos;height&apos;, Math.max(editor.getElement().offsetHeight, 200));
    };
    var getWidthSetting = function (editor) {
      return editor.getParam(&apos;width&apos;, global$7.DOM.getStyle(editor.getElement(), &apos;width&apos;));
    };
    var getMinWidthSetting = function (editor) {
      return Option.from(editor.settings.min_width).filter(isNumber);
    };
    var getMinHeightSetting = function (editor) {
      return Option.from(editor.settings.min_height).filter(isNumber);
    };
    var getMaxWidthSetting = function (editor) {
      return Option.from(editor.getParam(&apos;max_width&apos;)).filter(isNumber);
    };
    var getMaxHeightSetting = function (editor) {
      return Option.from(editor.getParam(&apos;max_height&apos;)).filter(isNumber);
    };
    var getUserStyleFormats = function (editor) {
      return Option.from(editor.getParam(&apos;style_formats&apos;)).filter(isArray);
    };
    var isMergeStyleFormats = function (editor) {
      return editor.getParam(&apos;style_formats_merge&apos;, false, &apos;boolean&apos;);
    };
    var getRemovedMenuItems = function (editor) {
      return editor.getParam(&apos;removed_menuitems&apos;, &apos;&apos;);
    };
    var isMenubarEnabled = function (editor) {
      return editor.getParam(&apos;menubar&apos;, true, &apos;boolean&apos;) !== false;
    };
    var isToolbarEnabled = function (editor) {
      var toolbar = editor.getParam(&apos;toolbar&apos;, true);
      var isToolbarTrue = toolbar === true;
      var isToolbarString = isString(toolbar);
      var isToolbarObjectArray = isArray(toolbar) &amp;&amp; toolbar.length &gt; 0;
      return !isMultipleToolbars(editor) &amp;&amp; (isToolbarObjectArray || isToolbarString || isToolbarTrue);
    };
    var getMultipleToolbarsSetting = function (editor) {
      var keys$1 = keys(editor.settings);
      var toolbarKeys = filter(keys$1, function (key) {
        return /^toolbar([1-9])$/.test(key);
      });
      var toolbars = map(toolbarKeys, function (key) {
        return editor.getParam(key, false, &apos;string&apos;);
      });
      var toolbarArray = filter(toolbars, function (toolbar) {
        return typeof toolbar === &apos;string&apos;;
      });
      return toolbarArray.length &gt; 0 ? Option.some(toolbarArray) : Option.none();
    };
    var isMultipleToolbars = function (editor) {
      return getMultipleToolbarsSetting(editor).fold(function () {
        var toolbar = editor.getParam(&apos;toolbar&apos;, [], &apos;string[]&apos;);
        return toolbar.length &gt; 0;
      }, function () {
        return true;
      });
    };
    var ToolbarMode;
    (function (ToolbarMode) {
      ToolbarMode[&apos;default&apos;] = &apos;wrap&apos;;
      ToolbarMode[&apos;floating&apos;] = &apos;floating&apos;;
      ToolbarMode[&apos;sliding&apos;] = &apos;sliding&apos;;
      ToolbarMode[&apos;scrolling&apos;] = &apos;scrolling&apos;;
    }(ToolbarMode || (ToolbarMode = {})));
    var getToolbarMode = function (editor) {
      return editor.getParam(&apos;toolbar_mode&apos;, &apos;&apos;, &apos;string&apos;);
    };
    var ToolbarLocation;
    (function (ToolbarLocation) {
      ToolbarLocation[&apos;auto&apos;] = &apos;auto&apos;;
      ToolbarLocation[&apos;top&apos;] = &apos;top&apos;;
      ToolbarLocation[&apos;bottom&apos;] = &apos;bottom&apos;;
    }(ToolbarLocation || (ToolbarLocation = {})));
    var getToolbarGroups = function (editor) {
      return editor.getParam(&apos;toolbar_groups&apos;, {}, &apos;object&apos;);
    };
    var getToolbarLocation = function (editor) {
      return editor.getParam(&apos;toolbar_location&apos;, ToolbarLocation.auto, &apos;string&apos;);
    };
    var isToolbarLocationBottom = function (editor) {
      return getToolbarLocation(editor) === ToolbarLocation.bottom;
    };
    var fixedContainerSelector = function (editor) {
      return editor.getParam(&apos;fixed_toolbar_container&apos;, &apos;&apos;, &apos;string&apos;);
    };
    var fixedContainerElement = function (editor) {
      var selector = fixedContainerSelector(editor);
      return selector.length &gt; 0 &amp;&amp; editor.inline ? descendant$1(body(), selector) : Option.none();
    };
    var useFixedContainer = function (editor) {
      return editor.inline &amp;&amp; fixedContainerElement(editor).isSome();
    };
    var getUiContainer = function (editor) {
      var fixedContainer = fixedContainerElement(editor);
      return fixedContainer.getOr(body());
    };
    var isDistractionFree = function (editor) {
      return editor.inline &amp;&amp; !isMenubarEnabled(editor) &amp;&amp; !isToolbarEnabled(editor) &amp;&amp; !isMultipleToolbars(editor);
    };
    var isStickyToolbar = function (editor) {
      var isStickyToolbar = editor.getParam(&apos;toolbar_sticky&apos;, false, &apos;boolean&apos;);
      return (isStickyToolbar || editor.inline) &amp;&amp; !useFixedContainer(editor) &amp;&amp; !isDistractionFree(editor);
    };
    var isDraggableModal = function (editor) {
      return editor.getParam(&apos;draggable_modal&apos;, false, &apos;boolean&apos;);
    };

    var ReadOnlyChannel = &apos;silver.readonly&apos;;
    var ReadOnlyDataSchema = objOf([strictBoolean(&apos;readonly&apos;)]);
    var broadcastReadonly = function (uiComponents, readonly) {
      var outerContainer = uiComponents.outerContainer;
      var target = outerContainer.element();
      if (readonly) {
        uiComponents.mothership.broadcastOn([dismissPopups()], { target: target });
        uiComponents.uiMothership.broadcastOn([dismissPopups()], { target: target });
      }
      uiComponents.mothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });
      uiComponents.uiMothership.broadcastOn([ReadOnlyChannel], { readonly: readonly });
    };
    var setupReadonlyModeSwitch = function (editor, uiComponents) {
      editor.on(&apos;init&apos;, function () {
        if (editor.mode.isReadOnly()) {
          broadcastReadonly(uiComponents, true);
        }
      });
      editor.on(&apos;SwitchMode&apos;, function () {
        return broadcastReadonly(uiComponents, editor.mode.isReadOnly());
      });
      if (isReadOnly(editor)) {
        editor.setMode(&apos;readonly&apos;);
      }
    };
    var receivingConfig = function () {
      var _a;
      return Receiving.config({
        channels: (_a = {}, _a[ReadOnlyChannel] = {
          schema: ReadOnlyDataSchema,
          onReceive: function (comp, data) {
            Disabling.set(comp, data.readonly);
          }
        }, _a)
      });
    };

    var item = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: &apos;tox-collection__item--state-disabled&apos;
      });
    };
    var button = function (disabled) {
      return Disabling.config({ disabled: disabled });
    };
    var splitButton = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: &apos;tox-tbtn--disabled&apos;
      });
    };
    var toolbarButton = function (disabled) {
      return Disabling.config({
        disabled: disabled,
        disableClass: &apos;tox-tbtn--disabled&apos;,
        useNative: false
      });
    };
    var DisablingConfigs = {
      item: item,
      button: button,
      splitButton: splitButton,
      toolbarButton: toolbarButton
    };

    var runWithApi = function (info, comp) {
      var api = info.getApi(comp);
      return function (f) {
        f(api);
      };
    };
    var onControlAttached = function (info, editorOffCell) {
      return runOnAttached(function (comp) {
        var run = runWithApi(info, comp);
        run(function (api) {
          var onDestroy = info.onSetup(api);
          if (onDestroy !== null &amp;&amp; onDestroy !== undefined) {
            editorOffCell.set(onDestroy);
          }
        });
      });
    };
    var onControlDetached = function (getApi, editorOffCell) {
      return runOnDetached(function (comp) {
        return runWithApi(getApi, comp)(editorOffCell.get());
      });
    };

    var ItemResponse;
    (function (ItemResponse) {
      ItemResponse[ItemResponse[&apos;CLOSE_ON_EXECUTE&apos;] = 0] = &apos;CLOSE_ON_EXECUTE&apos;;
      ItemResponse[ItemResponse[&apos;BUBBLE_TO_SANDBOX&apos;] = 1] = &apos;BUBBLE_TO_SANDBOX&apos;;
    }(ItemResponse || (ItemResponse = {})));
    var ItemResponse$1 = ItemResponse;

    var onMenuItemExecute = function (info, itemResponse) {
      return runOnExecute(function (comp, simulatedEvent) {
        runWithApi(info, comp)(info.onAction);
        if (!info.triggersSubmenu &amp;&amp; itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
          emit(comp, sandboxClose());
          simulatedEvent.stop();
        }
      });
    };
    var menuItemEventOrder = {
      &apos;alloy.execute&apos;: [
        &apos;disabling&apos;,
        &apos;alloy.base.behaviour&apos;,
        &apos;toggling&apos;,
        &apos;item-events&apos;
      ]
    };

    var componentRenderPipeline = function (xs) {
      return bind(xs, function (o) {
        return o.toArray();
      });
    };
    var renderCommonItem = function (spec, structure, itemResponse, providersbackstage) {
      var editorOffCell = Cell(noop);
      return {
        type: &apos;item&apos;,
        dom: structure.dom,
        components: componentRenderPipeline(structure.optComponents),
        data: spec.data,
        eventOrder: menuItemEventOrder,
        hasSubmenu: spec.triggersSubmenu,
        itemBehaviours: derive$1([
          config(&apos;item-events&apos;, [
            onMenuItemExecute(spec, itemResponse),
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell)
          ]),
          DisablingConfigs.item(function () {
            return spec.disabled || providersbackstage.isReadOnly();
          }),
          receivingConfig(),
          Replacing.config({})
        ].concat(spec.itemBehaviours))
      };
    };
    var buildData = function (source) {
      return {
        value: source.value,
        meta: __assign({ text: source.text.getOr(&apos;&apos;) }, source.meta)
      };
    };

    var tooltipBehaviour = function (meta, sharedBackstage) {
      return get(meta, &apos;tooltipWorker&apos;).map(function (tooltipWorker) {
        return [Tooltipping.config({
            lazySink: sharedBackstage.getSink,
            tooltipDom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-tooltip-worker-container&apos;]
            },
            tooltipComponents: [],
            anchor: function (comp) {
              return {
                anchor: &apos;submenu&apos;,
                item: comp,
                overrides: { maxHeightFunction: expandable }
              };
            },
            mode: &apos;follow-highlight&apos;,
            onShow: function (component, _tooltip) {
              tooltipWorker(function (elm) {
                Tooltipping.setComponents(component, [external({ element: Element.fromDom(elm) })]);
              });
            }
          })];
      }).getOr([]);
    };
    var escapeRegExp = function (text) {
      return text.replace(/[.*+?^${}()|[\]\\]/g, &apos;\\$&amp;&apos;);
    };
    var encodeText = function (text) {
      return global$7.DOM.encode(text);
    };
    var replaceText = function (text, matchText) {
      var translated = global$5.translate(text);
      var encoded = encodeText(translated);
      if (matchText.length &gt; 0) {
        var escapedMatchRegex = new RegExp(escapeRegExp(matchText), &apos;gi&apos;);
        return encoded.replace(escapedMatchRegex, function (match) {
          return &apos;&lt;span class=&quot;tox-autocompleter-highlight&quot;&gt;&apos; + match + &apos;&lt;/span&gt;&apos;;
        });
      } else {
        return encoded;
      }
    };
    var renderAutocompleteItem = function (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var structure = renderItemStructure({
        presets: presets,
        textContent: Option.none(),
        htmlContent: useText ? spec.text.map(function (text) {
          return replaceText(text, matchText);
        }) : Option.none(),
        ariaLabel: spec.text,
        iconContent: spec.icon,
        shortcutContent: Option.none(),
        checkMark: Option.none(),
        caret: Option.none(),
        value: spec.value
      }, sharedBackstage.providers, renderIcons, spec.icon);
      return renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: function () {
          return {};
        },
        onAction: function (_api) {
          return onItemValueHandler(spec.value, spec.meta);
        },
        onSetup: function () {
          return function () {
          };
        },
        triggersSubmenu: false,
        itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)
      }, structure, itemResponse, sharedBackstage.providers);
    };

    var renderChoiceItem = function (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          setActive: function (state) {
            Toggling.set(component, state);
          },
          isActive: function () {
            return Toggling.isOn(component);
          },
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: presets,
        textContent: useText ? spec.text : Option.none(),
        htmlContent: Option.none(),
        ariaLabel: spec.text,
        iconContent: spec.icon,
        shortcutContent: useText ? spec.shortcut : Option.none(),
        checkMark: useText ? Option.some(renderCheckmark(providersBackstage.icons)) : Option.none(),
        caret: Option.none(),
        value: spec.value
      }, providersBackstage, renderIcons);
      return deepMerge(renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: getApi,
        onAction: function (_api) {
          return onItemValueHandler(spec.value);
        },
        onSetup: function (api) {
          api.setActive(isSelected);
          return function () {
          };
        },
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage), {
        toggling: {
          toggleClass: tickedClass,
          toggleOnExecute: false,
          selected: spec.active
        }
      });
    };

    var parts$2 = constant(generate$4(owner$2(), parts()));

    var cellOverEvent = generate$1(&apos;cell-over&apos;);
    var cellExecuteEvent = generate$1(&apos;cell-execute&apos;);
    var makeCell = function (row, col, labelId) {
      var _a;
      var emitCellOver = function (c) {
        return emitWith(c, cellOverEvent, {
          row: row,
          col: col
        });
      };
      var emitExecute = function (c) {
        return emitWith(c, cellExecuteEvent, {
          row: row,
          col: col
        });
      };
      var onClick = function (c, se) {
        se.stop();
        emitExecute(c);
      };
      return build$1({
        dom: {
          tag: &apos;div&apos;,
          attributes: (_a = { role: &apos;button&apos; }, _a[&apos;aria-labelledby&apos;] = labelId, _a)
        },
        behaviours: derive$1([
          config(&apos;insert-table-picker-cell&apos;, [
            run(mouseover(), Focusing.focus),
            run(execute(), emitExecute),
            run(click(), onClick),
            run(tap(), onClick)
          ]),
          Toggling.config({
            toggleClass: &apos;tox-insert-table-picker__selected&apos;,
            toggleOnExecute: false
          }),
          Focusing.config({ onFocus: emitCellOver })
        ])
      });
    };
    var makeCells = function (labelId, numRows, numCols) {
      var cells = [];
      for (var i = 0; i &lt; numRows; i++) {
        var row = [];
        for (var j = 0; j &lt; numCols; j++) {
          row.push(makeCell(i, j, labelId));
        }
        cells.push(row);
      }
      return cells;
    };
    var selectCells = function (cells, selectedRow, selectedColumn, numRows, numColumns) {
      for (var i = 0; i &lt; numRows; i++) {
        for (var j = 0; j &lt; numColumns; j++) {
          Toggling.set(cells[i][j], i &lt;= selectedRow &amp;&amp; j &lt;= selectedColumn);
        }
      }
    };
    var makeComponents = function (cells) {
      return bind(cells, function (cellRow) {
        return map(cellRow, premade$1);
      });
    };
    var makeLabelText = function (row, col) {
      return text(col + 1 + &apos;x&apos; + (row + 1));
    };
    var renderInsertTableMenuItem = function (spec) {
      var numRows = 10;
      var numColumns = 10;
      var sizeLabelId = generate$1(&apos;size-label&apos;);
      var cells = makeCells(sizeLabelId, numRows, numColumns);
      var memLabel = record({
        dom: {
          tag: &apos;span&apos;,
          classes: [&apos;tox-insert-table-picker__label&apos;],
          attributes: { id: sizeLabelId }
        },
        components: [text(&apos;0x0&apos;)],
        behaviours: derive$1([Replacing.config({})])
      });
      return {
        type: &apos;widget&apos;,
        data: { value: generate$1(&apos;widget-id&apos;) },
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-fancymenuitem&apos;]
        },
        autofocus: true,
        components: [parts$2().widget({
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-insert-table-picker&apos;]
            },
            components: makeComponents(cells).concat(memLabel.asSpec()),
            behaviours: derive$1([
              config(&apos;insert-table-picker&apos;, [
                runWithTarget(cellOverEvent, function (c, t, e) {
                  var row = e.event().row();
                  var col = e.event().col();
                  selectCells(cells, row, col, numRows, numColumns);
                  Replacing.set(memLabel.get(c), [makeLabelText(row, col)]);
                }),
                runWithTarget(cellExecuteEvent, function (c, _, e) {
                  spec.onAction({
                    numRows: e.event().row() + 1,
                    numColumns: e.event().col() + 1
                  });
                  emit(c, sandboxClose());
                })
              ]),
              Keying.config({
                initSize: {
                  numRows: numRows,
                  numColumns: numColumns
                },
                mode: &apos;flatgrid&apos;,
                selector: &apos;[role=&quot;button&quot;]&apos;
              })
            ])
          })]
      };
    };

    var hexColour = function (value) {
      return { value: value };
    };
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    var longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var isHexString = function (hex) {
      return shorthandRegex.test(hex) || longformRegex.test(hex);
    };
    var getLongForm = function (hex) {
      var hexString = hex.value.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      return { value: hexString };
    };
    var extractValues = function (hex) {
      var longForm = getLongForm(hex);
      var splitForm = longformRegex.exec(longForm.value);
      return splitForm === null ? [
        &apos;FFFFFF&apos;,
        &apos;FF&apos;,
        &apos;FF&apos;,
        &apos;FF&apos;
      ] : splitForm;
    };
    var toHex = function (component) {
      var hex = component.toString(16);
      return hex.length === 1 ? &apos;0&apos; + hex : hex;
    };
    var fromRgba = function (rgbaColour) {
      var value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);
      return hexColour(value);
    };

    var min = Math.min;
    var max = Math.max;
    var round = Math.round;
    var rgbRegex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
    var rgbaRegex = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d?(?:\.\d+)?)\)/;
    var rgbaColour = function (red, green, blue, alpha) {
      return {
        red: red,
        green: green,
        blue: blue,
        alpha: alpha
      };
    };
    var isRgbaComponent = function (value) {
      var num = parseInt(value, 10);
      return num.toString() === value &amp;&amp; num &gt;= 0 &amp;&amp; num &lt;= 255;
    };
    var fromHsv = function (hsv) {
      var r;
      var g;
      var b;
      var hue = (hsv.hue || 0) % 360;
      var saturation = hsv.saturation / 100;
      var brightness = hsv.value / 100;
      saturation = max(0, min(saturation, 1));
      brightness = max(0, min(brightness, 1));
      if (saturation === 0) {
        r = g = b = round(255 * brightness);
        return rgbaColour(r, g, b, 1);
      }
      var side = hue / 60;
      var chroma = brightness * saturation;
      var x = chroma * (1 - Math.abs(side % 2 - 1));
      var match = brightness - chroma;
      switch (Math.floor(side)) {
      case 0:
        r = chroma;
        g = x;
        b = 0;
        break;
      case 1:
        r = x;
        g = chroma;
        b = 0;
        break;
      case 2:
        r = 0;
        g = chroma;
        b = x;
        break;
      case 3:
        r = 0;
        g = x;
        b = chroma;
        break;
      case 4:
        r = x;
        g = 0;
        b = chroma;
        break;
      case 5:
        r = chroma;
        g = 0;
        b = x;
        break;
      default:
        r = g = b = 0;
      }
      r = round(255 * (r + match));
      g = round(255 * (g + match));
      b = round(255 * (b + match));
      return rgbaColour(r, g, b, 1);
    };
    var fromHex = function (hexColour) {
      var result = extractValues(hexColour);
      var red = parseInt(result[1], 16);
      var green = parseInt(result[2], 16);
      var blue = parseInt(result[3], 16);
      return rgbaColour(red, green, blue, 1);
    };
    var fromStringValues = function (red, green, blue, alpha) {
      var r = parseInt(red, 10);
      var g = parseInt(green, 10);
      var b = parseInt(blue, 10);
      var a = parseFloat(alpha);
      return rgbaColour(r, g, b, a);
    };
    var fromString = function (rgbaString) {
      if (rgbaString === &apos;transparent&apos;) {
        return Option.some(rgbaColour(0, 0, 0, 0));
      }
      var rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Option.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], &apos;1&apos;));
      }
      var rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Option.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Option.none();
    };
    var toString = function (rgba) {
      return &apos;rgba(&apos; + rgba.red + &apos;,&apos; + rgba.green + &apos;,&apos; + rgba.blue + &apos;,&apos; + rgba.alpha + &apos;)&apos;;
    };
    var red = rgbaColour(255, 0, 0, 1);

    var global$9 = tinymce.util.Tools.resolve(&apos;tinymce.util.LocalStorage&apos;);

    var storageName = &apos;tinymce-custom-colors&apos;;
    function ColorCache (max) {
      if (max === void 0) {
        max = 10;
      }
      var storageString = global$9.getItem(storageName);
      var localstorage = isString(storageString) ? JSON.parse(storageString) : [];
      var prune = function (list) {
        var diff = max - list.length;
        return diff &lt; 0 ? list.slice(0, max) : list;
      };
      var cache = prune(localstorage);
      var add = function (key) {
        indexOf(cache, key).each(remove);
        cache.unshift(key);
        if (cache.length &gt; max) {
          cache.pop();
        }
        global$9.setItem(storageName, JSON.stringify(cache));
      };
      var remove = function (idx) {
        cache.splice(idx, 1);
      };
      var state = function () {
        return cache.slice(0);
      };
      return {
        add: add,
        state: state
      };
    }

    var choiceItem = &apos;choiceitem&apos;;
    var defaultColors = [
      {
        type: choiceItem,
        text: &apos;Light Green&apos;,
        value: &apos;#BFEDD2&apos;
      },
      {
        type: choiceItem,
        text: &apos;Light Yellow&apos;,
        value: &apos;#FBEEB8&apos;
      },
      {
        type: choiceItem,
        text: &apos;Light Red&apos;,
        value: &apos;#F8CAC6&apos;
      },
      {
        type: choiceItem,
        text: &apos;Light Purple&apos;,
        value: &apos;#ECCAFA&apos;
      },
      {
        type: choiceItem,
        text: &apos;Light Blue&apos;,
        value: &apos;#C2E0F4&apos;
      },
      {
        type: choiceItem,
        text: &apos;Green&apos;,
        value: &apos;#2DC26B&apos;
      },
      {
        type: choiceItem,
        text: &apos;Yellow&apos;,
        value: &apos;#F1C40F&apos;
      },
      {
        type: choiceItem,
        text: &apos;Red&apos;,
        value: &apos;#E03E2D&apos;
      },
      {
        type: choiceItem,
        text: &apos;Purple&apos;,
        value: &apos;#B96AD9&apos;
      },
      {
        type: choiceItem,
        text: &apos;Blue&apos;,
        value: &apos;#3598DB&apos;
      },
      {
        type: choiceItem,
        text: &apos;Dark Turquoise&apos;,
        value: &apos;#169179&apos;
      },
      {
        type: choiceItem,
        text: &apos;Orange&apos;,
        value: &apos;#E67E23&apos;
      },
      {
        type: choiceItem,
        text: &apos;Dark Red&apos;,
        value: &apos;#BA372A&apos;
      },
      {
        type: choiceItem,
        text: &apos;Dark Purple&apos;,
        value: &apos;#843FA1&apos;
      },
      {
        type: choiceItem,
        text: &apos;Dark Blue&apos;,
        value: &apos;#236FA1&apos;
      },
      {
        type: choiceItem,
        text: &apos;Light Gray&apos;,
        value: &apos;#ECF0F1&apos;
      },
      {
        type: choiceItem,
        text: &apos;Medium Gray&apos;,
        value: &apos;#CED4D9&apos;
      },
      {
        type: choiceItem,
        text: &apos;Gray&apos;,
        value: &apos;#95A5A6&apos;
      },
      {
        type: choiceItem,
        text: &apos;Dark Gray&apos;,
        value: &apos;#7E8C8D&apos;
      },
      {
        type: choiceItem,
        text: &apos;Navy Blue&apos;,
        value: &apos;#34495E&apos;
      },
      {
        type: choiceItem,
        text: &apos;Black&apos;,
        value: &apos;#000000&apos;
      },
      {
        type: choiceItem,
        text: &apos;White&apos;,
        value: &apos;#ffffff&apos;
      }
    ];
    var colorCache = ColorCache(10);
    var mapColors = function (colorMap) {
      var colors = [];
      var canvas = domGlobals.document.createElement(&apos;canvas&apos;);
      canvas.height = 1;
      canvas.width = 1;
      var ctx = canvas.getContext(&apos;2d&apos;);
      var byteAsHex = function (colorByte, alphaByte) {
        var bg = 255;
        var alpha = alphaByte / 255;
        var colorByteWithWhiteBg = Math.round(colorByte * alpha + bg * (1 - alpha));
        return (&apos;0&apos; + colorByteWithWhiteBg.toString(16)).slice(-2).toUpperCase();
      };
      var asHexColor = function (color) {
        if (/^[0-9A-Fa-f]{6}$/.test(color)) {
          return &apos;#&apos; + color.toUpperCase();
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = &apos;#FFFFFF&apos;;
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, 1, 1);
        var rgba = ctx.getImageData(0, 0, 1, 1).data;
        var r = rgba[0], g = rgba[1], b = rgba[2], a = rgba[3];
        return &apos;#&apos; + byteAsHex(r, a) + byteAsHex(g, a) + byteAsHex(b, a);
      };
      for (var i = 0; i &lt; colorMap.length; i += 2) {
        colors.push({
          text: colorMap[i + 1],
          value: asHexColor(colorMap[i]),
          type: &apos;choiceitem&apos;
        });
      }
      return colors;
    };
    var getColorCols = function (editor, defaultCols) {
      return editor.getParam(&apos;color_cols&apos;, defaultCols, &apos;number&apos;);
    };
    var hasCustomColors = function (editor) {
      return editor.getParam(&apos;custom_colors&apos;) !== false;
    };
    var getColorMap = function (editor) {
      return editor.getParam(&apos;color_map&apos;);
    };
    var getColors = function (editor) {
      var unmapped = getColorMap(editor);
      return unmapped !== undefined ? mapColors(unmapped) : defaultColors;
    };
    var getCurrentColors = function () {
      return map(colorCache.state(), function (color) {
        return {
          type: choiceItem,
          text: color,
          value: color
        };
      });
    };
    var addColor = function (color) {
      colorCache.add(color);
    };

    var fireSkinLoaded = function (editor) {
      return editor.fire(&apos;SkinLoaded&apos;);
    };
    var fireSkinLoadError = function (editor, error) {
      return editor.fire(&apos;SkinLoadError&apos;, error);
    };
    var fireResizeEditor = function (editor) {
      return editor.fire(&apos;ResizeEditor&apos;);
    };
    var fireResizeContent = function (editor, e) {
      return editor.fire(&apos;ResizeContent&apos;, e);
    };
    var fireScrollContent = function (editor, e) {
      return editor.fire(&apos;ScrollContent&apos;, e);
    };
    var fireTextColorChange = function (editor, data) {
      return editor.fire(&apos;TextColorChange&apos;, data);
    };

    var getCurrentColor = function (editor, format) {
      var color;
      editor.dom.getParents(editor.selection.getStart(), function (elm) {
        var value;
        if (value = elm.style[format === &apos;forecolor&apos; ? &apos;color&apos; : &apos;background-color&apos;]) {
          color = color ? color : value;
        }
      });
      return color;
    };
    var applyFormat = function (editor, format, value) {
      editor.undoManager.transact(function () {
        editor.focus();
        editor.formatter.apply(format, { value: value });
        editor.nodeChanged();
      });
    };
    var removeFormat = function (editor, format) {
      editor.undoManager.transact(function () {
        editor.focus();
        editor.formatter.remove(format, { value: null }, null, true);
        editor.nodeChanged();
      });
    };
    var registerCommands = function (editor) {
      editor.addCommand(&apos;mceApplyTextcolor&apos;, function (format, value) {
        applyFormat(editor, format, value);
      });
      editor.addCommand(&apos;mceRemoveTextcolor&apos;, function (format) {
        removeFormat(editor, format);
      });
    };
    var calcCols = function (colors) {
      return Math.max(5, Math.ceil(Math.sqrt(colors)));
    };
    var getColorCols$1 = function (editor) {
      var colors = getColors(editor);
      var defaultCols = calcCols(colors.length);
      return getColorCols(editor, defaultCols);
    };
    var getAdditionalColors = function (hasCustom) {
      var type = &apos;choiceitem&apos;;
      var remove = {
        type: type,
        text: &apos;Remove color&apos;,
        icon: &apos;color-swatch-remove-color&apos;,
        value: &apos;remove&apos;
      };
      var custom = {
        type: type,
        text: &apos;Custom color&apos;,
        icon: &apos;color-picker&apos;,
        value: &apos;custom&apos;
      };
      return hasCustom ? [
        remove,
        custom
      ] : [remove];
    };
    var applyColor = function (editor, format, value, onChoice) {
      if (value === &apos;custom&apos;) {
        var dialog = colorPickerDialog(editor);
        dialog(function (colorOpt) {
          colorOpt.each(function (color) {
            addColor(color);
            editor.execCommand(&apos;mceApplyTextcolor&apos;, format, color);
            onChoice(color);
          });
        }, &apos;#000000&apos;);
      } else if (value === &apos;remove&apos;) {
        onChoice(&apos;&apos;);
        editor.execCommand(&apos;mceRemoveTextcolor&apos;, format);
      } else {
        onChoice(value);
        editor.execCommand(&apos;mceApplyTextcolor&apos;, format, value);
      }
    };
    var getColors$1 = function (colors, hasCustom) {
      return colors.concat(getCurrentColors().concat(getAdditionalColors(hasCustom)));
    };
    var getFetch = function (colors, hasCustom) {
      return function (callback) {
        callback(getColors$1(colors, hasCustom));
      };
    };
    var setIconColor = function (splitButtonApi, name, newColor) {
      var setIconFillAndStroke = function (pathId, color) {
        splitButtonApi.setIconFill(pathId, color);
        splitButtonApi.setIconStroke(pathId, color);
      };
      var id = name === &apos;forecolor&apos; ? &apos;tox-icon-text-color__color&apos; : &apos;tox-icon-highlight-bg-color__color&apos;;
      setIconFillAndStroke(id, newColor);
    };
    var registerTextColorButton = function (editor, name, format, tooltip, lastColor) {
      editor.ui.registry.addSplitButton(name, {
        tooltip: tooltip,
        presets: &apos;color&apos;,
        icon: name === &apos;forecolor&apos; ? &apos;text-color&apos; : &apos;highlight-bg-color&apos;,
        select: function (value) {
          var optCurrentRgb = Option.from(getCurrentColor(editor, format));
          return optCurrentRgb.bind(function (currentRgb) {
            return fromString(currentRgb).map(function (rgba) {
              var currentHex = fromRgba(rgba).value;
              return contains$1(value.toLowerCase(), currentHex);
            });
          }).getOr(false);
        },
        columns: getColorCols$1(editor),
        fetch: getFetch(getColors(editor), hasCustomColors(editor)),
        onAction: function (_splitButtonApi) {
          if (lastColor.get() !== null) {
            applyColor(editor, format, lastColor.get(), function () {
            });
          }
        },
        onItemAction: function (_splitButtonApi, value) {
          applyColor(editor, format, value, function (newColor) {
            lastColor.set(newColor);
            fireTextColorChange(editor, {
              name: name,
              color: newColor
            });
          });
        },
        onSetup: function (splitButtonApi) {
          if (lastColor.get() !== null) {
            setIconColor(splitButtonApi, name, lastColor.get());
          }
          var handler = function (e) {
            if (e.name === name) {
              setIconColor(splitButtonApi, e.name, e.color);
            }
          };
          editor.on(&apos;TextColorChange&apos;, handler);
          return function () {
            editor.off(&apos;TextColorChange&apos;, handler);
          };
        }
      });
    };
    var registerTextColorMenuItem = function (editor, name, format, text) {
      editor.ui.registry.addNestedMenuItem(name, {
        text: text,
        icon: name === &apos;forecolor&apos; ? &apos;text-color&apos; : &apos;highlight-bg-color&apos;,
        getSubmenuItems: function () {
          return [{
              type: &apos;fancymenuitem&apos;,
              fancytype: &apos;colorswatch&apos;,
              onAction: function (data) {
                applyColor(editor, format, data.value, noop);
              }
            }];
        }
      });
    };
    var colorPickerDialog = function (editor) {
      return function (callback, value) {
        var getOnSubmit = function (callback) {
          return function (api) {
            var data = api.getData();
            callback(Option.from(data.colorpicker));
            api.close();
          };
        };
        var onAction = function (api, details) {
          if (details.name === &apos;hex-valid&apos;) {
            if (details.value) {
              api.enable(&apos;ok&apos;);
            } else {
              api.disable(&apos;ok&apos;);
            }
          }
        };
        var initialData = { colorpicker: value };
        var submit = getOnSubmit(callback);
        editor.windowManager.open({
          title: &apos;Color Picker&apos;,
          size: &apos;normal&apos;,
          body: {
            type: &apos;panel&apos;,
            items: [{
                type: &apos;colorpicker&apos;,
                name: &apos;colorpicker&apos;,
                label: &apos;Color&apos;
              }]
          },
          buttons: [
            {
              type: &apos;cancel&apos;,
              name: &apos;cancel&apos;,
              text: &apos;Cancel&apos;
            },
            {
              type: &apos;submit&apos;,
              name: &apos;save&apos;,
              text: &apos;Save&apos;,
              primary: true
            }
          ],
          initialData: initialData,
          onAction: onAction,
          onSubmit: submit,
          onClose: function () {
          },
          onCancel: function () {
            callback(Option.none());
          }
        });
      };
    };
    var register$1 = function (editor) {
      registerCommands(editor);
      var lastForeColor = Cell(null);
      var lastBackColor = Cell(null);
      registerTextColorButton(editor, &apos;forecolor&apos;, &apos;forecolor&apos;, &apos;Text color&apos;, lastForeColor);
      registerTextColorButton(editor, &apos;backcolor&apos;, &apos;hilitecolor&apos;, &apos;Background color&apos;, lastBackColor);
      registerTextColorMenuItem(editor, &apos;forecolor&apos;, &apos;forecolor&apos;, &apos;Text color&apos;);
      registerTextColorMenuItem(editor, &apos;backcolor&apos;, &apos;hilitecolor&apos;, &apos;Background color&apos;);
    };

    var forMenu = function (presets) {
      if (presets === &apos;color&apos;) {
        return &apos;tox-swatches&apos;;
      } else {
        return &apos;tox-menu&apos;;
      }
    };
    var classes = function (presets) {
      return {
        backgroundMenu: &apos;tox-background-menu&apos;,
        selectedMenu: &apos;tox-selected-menu&apos;,
        selectedItem: &apos;tox-collection__item--active&apos;,
        hasIcons: &apos;tox-menu--has-icons&apos;,
        menu: forMenu(presets),
        tieredMenu: &apos;tox-tiered-menu&apos;
      };
    };

    var markers$1 = function (presets) {
      var menuClasses = classes(presets);
      return {
        backgroundMenu: menuClasses.backgroundMenu,
        selectedMenu: menuClasses.selectedMenu,
        menu: menuClasses.menu,
        selectedItem: menuClasses.selectedItem,
        item: classForPreset(presets)
      };
    };
    var dom$1 = function (hasIcons, columns, presets) {
      var menuClasses = classes(presets);
      return {
        tag: &apos;div&apos;,
        classes: flatten([
          [
            menuClasses.menu,
            &apos;tox-menu-&apos; + columns + &apos;-column&apos;
          ],
          hasIcons ? [menuClasses.hasIcons] : []
        ])
      };
    };
    var components$1 = [Menu.parts().items({})];
    var part = function (hasIcons, columns, presets) {
      var menuClasses = classes(presets);
      var d = {
        tag: &apos;div&apos;,
        classes: flatten([[menuClasses.tieredMenu]])
      };
      return {
        dom: d,
        markers: markers$1(presets)
      };
    };

    var chunk$1 = function (rowDom, numColumns) {
      return function (items) {
        var chunks = chunk(items, numColumns);
        return map(chunks, function (c) {
          return {
            dom: rowDom,
            components: c
          };
        });
      };
    };
    var forSwatch = function (columns) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-menu&apos;,
            &apos;tox-swatches-menu&apos;
          ]
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-swatches&apos;]
            },
            components: [Menu.parts().items({
                preprocess: columns !== &apos;auto&apos; ? chunk$1({
                  tag: &apos;div&apos;,
                  classes: [&apos;tox-swatches__row&apos;]
                }, columns) : identity
              })]
          }]
      };
    };
    var forToolbar = function (columns) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-menu&apos;,
            &apos;tox-collection&apos;,
            &apos;tox-collection--toolbar&apos;,
            &apos;tox-collection--toolbar-lg&apos;
          ]
        },
        components: [Menu.parts().items({
            preprocess: chunk$1({
              tag: &apos;div&apos;,
              classes: [&apos;tox-collection__group&apos;]
            }, columns)
          })]
      };
    };
    var preprocessCollection = function (items, isSeparator) {
      var allSplits = [];
      var currentSplit = [];
      each(items, function (item, i) {
        if (isSeparator(item, i)) {
          if (currentSplit.length &gt; 0) {
            allSplits.push(currentSplit);
          }
          currentSplit = [];
          if (has(item.dom, &apos;innerHtml&apos;)) {
            currentSplit.push(item);
          }
        } else {
          currentSplit.push(item);
        }
      });
      if (currentSplit.length &gt; 0) {
        allSplits.push(currentSplit);
      }
      return map(allSplits, function (s) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-collection__group&apos;]
          },
          components: s
        };
      });
    };
    var forCollection = function (columns, initItems, _hasIcons) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-menu&apos;,
            &apos;tox-collection&apos;
          ].concat(columns === 1 ? [&apos;tox-collection--list&apos;] : [&apos;tox-collection--grid&apos;])
        },
        components: [Menu.parts().items({
            preprocess: function (items) {
              if (columns !== &apos;auto&apos; &amp;&amp; columns &gt; 1) {
                return chunk$1({
                  tag: &apos;div&apos;,
                  classes: [&apos;tox-collection__group&apos;]
                }, columns)(items);
              } else {
                return preprocessCollection(items, function (_item, i) {
                  return initItems[i].type === &apos;separator&apos;;
                });
              }
            }
          })]
      };
    };
    var forHorizontalCollection = function (initItems, _hasIcons) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-collection&apos;,
            &apos;tox-collection--horizontal&apos;
          ]
        },
        components: [Menu.parts().items({
            preprocess: function (items) {
              return preprocessCollection(items, function (_item, i) {
                return initItems[i].type === &apos;separator&apos;;
              });
            }
          })]
      };
    };

    var menuHasIcons = function (xs) {
      return exists(xs, function (item) {
        return &apos;icon&apos; in item &amp;&amp; item.icon !== undefined;
      });
    };
    var handleError = function (error) {
      domGlobals.console.error(formatError(error));
      domGlobals.console.log(error);
      return Option.none();
    };
    var createHorizontalPartialMenuWithAlloyItems = function (value, _hasIcons, items, _columns, _presets) {
      var structure = forHorizontalCollection(items);
      return {
        value: value,
        dom: structure.dom,
        components: structure.components,
        items: items
      };
    };
    var createPartialMenuWithAlloyItems = function (value, hasIcons, items, columns, presets) {
      if (presets === &apos;color&apos;) {
        var structure = forSwatch(columns);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === &apos;normal&apos; &amp;&amp; columns === &apos;auto&apos;) {
        var structure = forCollection(columns, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === &apos;normal&apos; &amp;&amp; columns === 1) {
        var structure = forCollection(1, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === &apos;normal&apos;) {
        var structure = forCollection(columns, items);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      if (presets === &apos;listpreview&apos; &amp;&amp; columns !== &apos;auto&apos;) {
        var structure = forToolbar(columns);
        return {
          value: value,
          dom: structure.dom,
          components: structure.components,
          items: items
        };
      }
      return {
        value: value,
        dom: dom$1(hasIcons, columns, presets),
        components: components$1,
        items: items
      };
    };

    var createPartialChoiceMenu = function (value, items, onItemValueHandler, columns, presets, itemResponse, select, providersBackstage) {
      var hasIcons = menuHasIcons(items);
      var presetItemTypes = presets !== &apos;color&apos; ? &apos;normal&apos; : &apos;color&apos;;
      var alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select, providersBackstage);
      return createPartialMenuWithAlloyItems(value, hasIcons, alloyItems, columns, presets);
    };
    var createChoiceItems = function (items, onItemValueHandler, columns, itemPresets, itemResponse, select, providersBackstage) {
      return cat(map(items, function (item) {
        if (item.type === &apos;choiceitem&apos;) {
          return createChoiceMenuItem(item).fold(handleError, function (d) {
            return Option.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select(item.value), itemResponse, providersBackstage, menuHasIcons(items)));
          });
        } else {
          return Option.none();
        }
      }));
    };

    var deriveMenuMovement = function (columns, presets) {
      var menuMarkers = markers$1(presets);
      if (columns === 1) {
        return {
          mode: &apos;menu&apos;,
          moveOnTab: true
        };
      } else if (columns === &apos;auto&apos;) {
        return {
          mode: &apos;grid&apos;,
          selector: &apos;.&apos; + menuMarkers.item,
          initSize: {
            numColumns: 1,
            numRows: 1
          }
        };
      } else {
        var rowClass = presets === &apos;color&apos; ? &apos;tox-swatches__row&apos; : &apos;tox-collection__group&apos;;
        return {
          mode: &apos;matrix&apos;,
          rowSelector: &apos;.&apos; + rowClass
        };
      }
    };
    var deriveCollectionMovement = function (columns, presets) {
      if (columns === 1) {
        return {
          mode: &apos;menu&apos;,
          moveOnTab: false,
          selector: &apos;.tox-collection__item&apos;
        };
      } else if (columns === &apos;auto&apos;) {
        return {
          mode: &apos;flatgrid&apos;,
          selector: &apos;.&apos; + &apos;tox-collection__item&apos;,
          initSize: {
            numColumns: 1,
            numRows: 1
          }
        };
      } else {
        return {
          mode: &apos;matrix&apos;,
          selectors: {
            row: presets === &apos;color&apos; ? &apos;.tox-swatches__row&apos; : &apos;.tox-collection__group&apos;,
            cell: presets === &apos;color&apos; ? &apos;.&apos; + colorClass : &apos;.&apos; + selectableClass
          }
        };
      }
    };

    function renderColorSwatchItem(spec, backstage) {
      var items = getColors$1(backstage.colorinput.getColors(), backstage.colorinput.hasCustomColors());
      var columns = backstage.colorinput.getColorCols();
      var presets = &apos;color&apos;;
      var menuSpec = createPartialChoiceMenu(generate$1(&apos;menu-value&apos;), items, function (value) {
        spec.onAction({ value: value });
      }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, function () {
        return false;
      }, backstage.shared.providers);
      var widgetSpec = __assign(__assign({}, menuSpec), {
        markers: markers$1(presets),
        movement: deriveMenuMovement(columns, presets)
      });
      return {
        type: &apos;widget&apos;,
        data: { value: generate$1(&apos;widget-id&apos;) },
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-fancymenuitem&apos;]
        },
        autofocus: true,
        components: [parts$2().widget(Menu.sketch(widgetSpec))]
      };
    }

    var fancyMenuItems = {
      inserttable: renderInsertTableMenuItem,
      colorswatch: renderColorSwatchItem
    };
    var valueOpt = function (obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key) ? Option.some(obj[key]) : Option.none();
    };
    var renderFancyMenuItem = function (spec, backstage) {
      return valueOpt(fancyMenuItems, spec.fancytype).map(function (render) {
        return render(spec, backstage);
      });
    };

    var renderNormalItem = function (spec, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: &apos;normal&apos;,
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Option.none(),
        ariaLabel: spec.text,
        caret: Option.none(),
        checkMark: Option.none(),
        shortcutContent: spec.shortcut
      }, providersBackstage, renderIcons);
      return renderCommonItem({
        data: buildData(spec),
        getApi: getApi,
        disabled: spec.disabled,
        onAction: spec.onAction,
        onSetup: spec.onSetup,
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage);
    };

    var renderNestedItem = function (spec, itemResponse, providersBackstage, renderIcons, downwardsCaret) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      if (downwardsCaret === void 0) {
        downwardsCaret = false;
      }
      var caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
      var getApi = function (component) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        presets: &apos;normal&apos;,
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Option.none(),
        ariaLabel: spec.text,
        caret: Option.some(caret),
        checkMark: Option.none(),
        shortcutContent: spec.shortcut
      }, providersBackstage, renderIcons);
      return renderCommonItem({
        data: buildData(spec),
        getApi: getApi,
        disabled: spec.disabled,
        onAction: noop,
        onSetup: spec.onSetup,
        triggersSubmenu: true,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage);
    };

    var renderSeparatorItem = function (spec) {
      var innerHtml = spec.text.fold(function () {
        return {};
      }, function (text) {
        return { innerHtml: text };
      });
      return {
        type: &apos;separator&apos;,
        dom: __assign({
          tag: &apos;div&apos;,
          classes: [
            selectableClass,
            groupHeadingClass
          ]
        }, innerHtml),
        components: []
      };
    };

    var renderToggleMenuItem = function (spec, itemResponse, providersBackstage, renderIcons) {
      if (renderIcons === void 0) {
        renderIcons = true;
      }
      var getApi = function (component) {
        return {
          setActive: function (state) {
            Toggling.set(component, state);
          },
          isActive: function () {
            return Toggling.isOn(component);
          },
          isDisabled: function () {
            return Disabling.isDisabled(component);
          },
          setDisabled: function (state) {
            return Disabling.set(component, state);
          }
        };
      };
      var structure = renderItemStructure({
        iconContent: spec.icon,
        textContent: spec.text,
        htmlContent: Option.none(),
        ariaLabel: spec.text,
        checkMark: Option.some(renderCheckmark(providersBackstage.icons)),
        caret: Option.none(),
        shortcutContent: spec.shortcut,
        presets: &apos;normal&apos;,
        meta: spec.meta
      }, providersBackstage, renderIcons);
      return deepMerge(renderCommonItem({
        data: buildData(spec),
        disabled: spec.disabled,
        getApi: getApi,
        onAction: spec.onAction,
        onSetup: spec.onSetup,
        triggersSubmenu: false,
        itemBehaviours: []
      }, structure, itemResponse, providersBackstage), {
        toggling: {
          toggleClass: tickedClass,
          toggleOnExecute: false,
          selected: spec.active
        }
      });
    };

    var autocomplete = renderAutocompleteItem;
    var separator = renderSeparatorItem;
    var normal = renderNormalItem;
    var nested = renderNestedItem;
    var toggle$1 = renderToggleMenuItem;
    var fancy = renderFancyMenuItem;

    var FocusMode;
    (function (FocusMode) {
      FocusMode[FocusMode[&apos;ContentFocus&apos;] = 0] = &apos;ContentFocus&apos;;
      FocusMode[FocusMode[&apos;UiFocus&apos;] = 1] = &apos;UiFocus&apos;;
    }(FocusMode || (FocusMode = {})));
    var createMenuItemFromBridge = function (item, itemResponse, backstage, menuHasIcons, isHorizontalMenu) {
      var providersBackstage = backstage.shared.providers;
      var parseForHorizontalMenu = function (menuitem) {
        return !isHorizontalMenu ? menuitem : __assign(__assign({}, menuitem), {
          shortcut: Option.none(),
          icon: menuitem.text.isSome() ? Option.none() : menuitem.icon
        });
      };
      switch (item.type) {
      case &apos;menuitem&apos;:
        return createMenuItem(item).fold(handleError, function (d) {
          return Option.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));
        });
      case &apos;nestedmenuitem&apos;:
        return createNestedMenuItem(item).fold(handleError, function (d) {
          return Option.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons, isHorizontalMenu));
        });
      case &apos;togglemenuitem&apos;:
        return createToggleMenuItem(item).fold(handleError, function (d) {
          return Option.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons));
        });
      case &apos;separator&apos;:
        return createSeparatorMenuItem(item).fold(handleError, function (d) {
          return Option.some(separator(d));
        });
      case &apos;fancymenuitem&apos;:
        return createFancyMenuItem(item).fold(handleError, function (d) {
          return fancy(parseForHorizontalMenu(d), backstage);
        });
      default: {
          domGlobals.console.error(&apos;Unknown item in general menu&apos;, item);
          return Option.none();
        }
      }
    };
    var createAutocompleteItems = function (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage) {
      var renderText = columns === 1;
      var renderIcons = !renderText || menuHasIcons(items);
      return cat(map(items, function (item) {
        if (item.type === &apos;separator&apos;) {
          return createSeparatorItem(item).fold(handleError, function (d) {
            return Option.some(separator(d));
          });
        } else {
          return createAutocompleterItem(item).fold(handleError, function (d) {
            return Option.some(autocomplete(d, matchText, renderText, &apos;normal&apos;, onItemValueHandler, itemResponse, sharedBackstage, renderIcons));
          });
        }
      }));
    };
    var createPartialMenu = function (value, items, itemResponse, backstage, isHorizontalMenu) {
      var hasIcons = menuHasIcons(items);
      var alloyItems = cat(map(items, function (item) {
        var itemHasIcon = function (i) {
          return isHorizontalMenu ? !i.hasOwnProperty(&apos;text&apos;) : hasIcons;
        };
        var createItem = function (i) {
          return createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);
        };
        if (item.type === &apos;nestedmenuitem&apos; &amp;&amp; item.getSubmenuItems().length &lt;= 0) {
          return createItem(__assign(__assign({}, item), { disabled: true }));
        } else {
          return createItem(item);
        }
      }));
      var createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;
      return createPartial(value, hasIcons, alloyItems, 1, &apos;normal&apos;);
    };
    var createTieredDataFrom = function (partialMenu) {
      return tieredMenu.singleData(partialMenu.value, partialMenu);
    };
    var createMenuFrom = function (partialMenu, columns, focusMode, presets) {
      var focusManager = focusMode === FocusMode.ContentFocus ? highlights() : dom();
      var movement = deriveMenuMovement(columns, presets);
      var menuMarkers = markers$1(presets);
      return {
        dom: partialMenu.dom,
        components: partialMenu.components,
        items: partialMenu.items,
        value: partialMenu.value,
        markers: {
          selectedItem: menuMarkers.selectedItem,
          item: menuMarkers.item
        },
        movement: movement,
        fakeFocus: focusMode === FocusMode.ContentFocus,
        focusManager: focusManager,
        menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== &apos;auto&apos; ? [] : [runOnAttached(function (comp, _se) {
            detectSize(comp, 4, menuMarkers.item).each(function (_a) {
              var numColumns = _a.numColumns, numRows = _a.numRows;
              Keying.setGridSize(comp, numRows, numColumns);
            });
          })])
      };
    };

    var register$2 = function (editor, sharedBackstage) {
      var activeAutocompleter = Cell(Option.none());
      var processingAction = Cell(false);
      var autocompleter = build$1(InlineView.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-autocompleter&apos;]
        },
        components: [],
        fireDismissalEventInstead: {},
        inlineBehaviours: derive$1([config(&apos;dismissAutocompleter&apos;, [run(dismissRequested(), function () {
              return cancelIfNecessary();
            })])]),
        lazySink: sharedBackstage.getSink
      }));
      var isMenuOpen = function () {
        return InlineView.isOpen(autocompleter);
      };
      var isActive = function () {
        return activeAutocompleter.get().isSome();
      };
      var hideIfNecessary = function () {
        if (isActive()) {
          InlineView.hide(autocompleter);
        }
      };
      var cancelIfNecessary = function () {
        if (isActive()) {
          var lastElement = activeAutocompleter.get().map(function (ac) {
            return ac.element;
          });
          detect$4(lastElement.getOr(Element.fromDom(editor.selection.getNode()))).each(unwrap);
          hideIfNecessary();
          activeAutocompleter.set(Option.none());
          processingAction.set(false);
        }
      };
      var getAutocompleters = cached(function () {
        return register(editor);
      });
      var getCombinedItems = function (triggerChar, matches) {
        var columns = findMap(matches, function (m) {
          return Option.from(m.columns);
        }).getOr(1);
        return bind(matches, function (match) {
          var choices = match.items;
          return createAutocompleteItems(choices, match.matchText, function (itemValue, itemMeta) {
            var nr = editor.selection.getRng();
            getContext(editor.dom, nr, triggerChar).fold(function () {
              return domGlobals.console.error(&apos;Lost context. Cursor probably moved&apos;);
            }, function (_a) {
              var range = _a.range;
              var autocompleterApi = {
                hide: function () {
                  cancelIfNecessary();
                },
                reload: function (fetchOptions) {
                  hideIfNecessary();
                  load(fetchOptions);
                }
              };
              processingAction.set(true);
              match.onAction(autocompleterApi, range, itemValue, itemMeta);
              processingAction.set(false);
            });
          }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage);
        });
      };
      var commenceIfNecessary = function (context) {
        if (!isActive()) {
          var wrapper = create$4(editor, context.range);
          activeAutocompleter.set(Option.some({
            triggerChar: context.triggerChar,
            element: wrapper,
            matchLength: context.text.length
          }));
          processingAction.set(false);
        }
      };
      var display = function (ac, context, lookupData, items) {
        ac.matchLength = context.text.length;
        var columns = findMap(lookupData, function (ld) {
          return Option.from(ld.columns);
        }).getOr(1);
        InlineView.showAt(autocompleter, {
          anchor: &apos;node&apos;,
          root: Element.fromDom(editor.getBody()),
          node: Option.from(ac.element)
        }, Menu.sketch(createMenuFrom(createPartialMenuWithAlloyItems(&apos;autocompleter-value&apos;, true, items, columns, &apos;normal&apos;), columns, FocusMode.ContentFocus, &apos;normal&apos;)));
        InlineView.getContent(autocompleter).each(Highlighting.highlightFirst);
      };
      var doLookup = function (fetchOptions) {
        return activeAutocompleter.get().map(function (ac) {
          return getContext(editor.dom, editor.selection.getRng(), ac.triggerChar).bind(function (newContext) {
            return lookupWithContext(editor, getAutocompleters, newContext, fetchOptions);
          });
        }).getOrThunk(function () {
          return lookup(editor, getAutocompleters);
        });
      };
      var load = function (fetchOptions) {
        doLookup(fetchOptions).fold(cancelIfNecessary, function (lookupInfo) {
          commenceIfNecessary(lookupInfo.context);
          lookupInfo.lookupData.then(function (lookupData) {
            activeAutocompleter.get().map(function (ac) {
              var context = lookupInfo.context;
              if (ac.triggerChar === context.triggerChar) {
                var combinedItems = getCombinedItems(context.triggerChar, lookupData);
                if (combinedItems.length &gt; 0) {
                  display(ac, context, lookupData, combinedItems);
                } else if (context.text.length - ac.matchLength &gt;= 10) {
                  cancelIfNecessary();
                } else {
                  hideIfNecessary();
                }
              }
            });
          });
        });
      };
      var onKeypress = last$2(function (e) {
        if (e.which === 27) {
          return;
        }
        load();
      }, 50);
      var autocompleterUiApi = {
        onKeypress: onKeypress,
        cancelIfNecessary: cancelIfNecessary,
        isMenuOpen: isMenuOpen,
        isActive: isActive,
        isProcessingAction: processingAction.get,
        getView: function () {
          return InlineView.getContent(autocompleter);
        }
      };
      AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
    };
    var Autocompleter = { register: register$2 };

    var filter$2 = constant(true);
    var bind$3 = function (element, event, handler) {
      return bind$2(element, event, filter$2, handler);
    };
    var capture$1 = function (element, event, handler) {
      return capture(element, event, filter$2, handler);
    };
    var fromRawEvent$1 = fromRawEvent;

    var closest$4 = function (scope, selector, isRoot) {
      return closest$3(scope, selector, isRoot).isSome();
    };

    function DelayedFunction (fun, delay) {
      var ref = null;
      var schedule = function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        ref = domGlobals.setTimeout(function () {
          fun.apply(null, args);
          ref = null;
        }, delay);
      };
      var cancel = function () {
        if (ref !== null) {
          domGlobals.clearTimeout(ref);
          ref = null;
        }
      };
      return {
        cancel: cancel,
        schedule: schedule
      };
    }

    var SIGNIFICANT_MOVE = 5;
    var LONGPRESS_DELAY = 400;
    var getTouch = function (event) {
      var raw = event.raw();
      if (raw.touches === undefined || raw.touches.length !== 1) {
        return Option.none();
      }
      return Option.some(raw.touches[0]);
    };
    var isFarEnough = function (touch, data) {
      var distX = Math.abs(touch.clientX - data.x);
      var distY = Math.abs(touch.clientY - data.y);
      return distX &gt; SIGNIFICANT_MOVE || distY &gt; SIGNIFICANT_MOVE;
    };
    var monitor = function (settings) {
      var startData = Cell(Option.none());
      var longpressFired = Cell(false);
      var longpress$1 = DelayedFunction(function (event) {
        settings.triggerEvent(longpress(), event);
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      var handleTouchstart = function (event) {
        getTouch(event).each(function (touch) {
          longpress$1.cancel();
          var data = {
            x: touch.clientX,
            y: touch.clientY,
            target: event.target()
          };
          longpress$1.schedule(event);
          longpressFired.set(false);
          startData.set(Option.some(data));
        });
        return Option.none();
      };
      var handleTouchmove = function (event) {
        longpress$1.cancel();
        getTouch(event).each(function (touch) {
          startData.get().each(function (data) {
            if (isFarEnough(touch, data)) {
              startData.set(Option.none());
            }
          });
        });
        return Option.none();
      };
      var handleTouchend = function (event) {
        longpress$1.cancel();
        var isSame = function (data) {
          return eq$1(data.target, event.target());
        };
        return startData.get().filter(isSame).map(function (_data) {
          if (longpressFired.get()) {
            event.prevent();
            return false;
          } else {
            return settings.triggerEvent(tap(), event);
          }
        });
      };
      var handlers = wrapAll$1([
        {
          key: touchstart(),
          value: handleTouchstart
        },
        {
          key: touchmove(),
          value: handleTouchmove
        },
        {
          key: touchend(),
          value: handleTouchend
        }
      ]);
      var fireIfReady = function (event, type) {
        return get(handlers, type).bind(function (handler) {
          return handler(event);
        });
      };
      return { fireIfReady: fireIfReady };
    };

    var isDangerous = function (event) {
      var keyEv = event.raw();
      return keyEv.which === BACKSPACE()[0] &amp;&amp; !contains([
        &apos;input&apos;,
        &apos;textarea&apos;
      ], name(event.target())) &amp;&amp; !closest$4(event.target(), &apos;[contenteditable=&quot;true&quot;]&apos;);
    };
    var isFirefox = function () {
      return detect$3().browser.isFirefox();
    };
    var settingsSchema = objOfOnly([
      strictFunction(&apos;triggerEvent&apos;),
      defaulted$1(&apos;stopBackspace&apos;, true)
    ]);
    var bindFocus = function (container, handler) {
      if (isFirefox()) {
        return capture$1(container, &apos;focus&apos;, handler);
      } else {
        return bind$3(container, &apos;focusin&apos;, handler);
      }
    };
    var bindBlur = function (container, handler) {
      if (isFirefox()) {
        return capture$1(container, &apos;blur&apos;, handler);
      } else {
        return bind$3(container, &apos;focusout&apos;, handler);
      }
    };
    var setup$1 = function (container, rawSettings) {
      var settings = asRawOrDie(&apos;Getting GUI events settings&apos;, settingsSchema, rawSettings);
      var pointerEvents = [
        &apos;touchstart&apos;,
        &apos;touchmove&apos;,
        &apos;touchend&apos;,
        &apos;touchcancel&apos;,
        &apos;gesturestart&apos;,
        &apos;mousedown&apos;,
        &apos;mouseup&apos;,
        &apos;mouseover&apos;,
        &apos;mousemove&apos;,
        &apos;mouseout&apos;,
        &apos;click&apos;
      ];
      var tapEvent = monitor(settings);
      var simpleEvents = map(pointerEvents.concat([
        &apos;selectstart&apos;,
        &apos;input&apos;,
        &apos;contextmenu&apos;,
        &apos;change&apos;,
        &apos;transitionend&apos;,
        &apos;drag&apos;,
        &apos;dragstart&apos;,
        &apos;dragend&apos;,
        &apos;dragenter&apos;,
        &apos;dragleave&apos;,
        &apos;dragover&apos;,
        &apos;drop&apos;,
        &apos;keyup&apos;
      ]), function (type) {
        return bind$3(container, type, function (event) {
          tapEvent.fireIfReady(event, type).each(function (tapStopped) {
            if (tapStopped) {
              event.kill();
            }
          });
          var stopped = settings.triggerEvent(type, event);
          if (stopped) {
            event.kill();
          }
        });
      });
      var pasteTimeout = Cell(Option.none());
      var onPaste = bind$3(container, &apos;paste&apos;, function (event) {
        tapEvent.fireIfReady(event, &apos;paste&apos;).each(function (tapStopped) {
          if (tapStopped) {
            event.kill();
          }
        });
        var stopped = settings.triggerEvent(&apos;paste&apos;, event);
        if (stopped) {
          event.kill();
        }
        pasteTimeout.set(Option.some(domGlobals.setTimeout(function () {
          settings.triggerEvent(postPaste(), event);
        }, 0)));
      });
      var onKeydown = bind$3(container, &apos;keydown&apos;, function (event) {
        var stopped = settings.triggerEvent(&apos;keydown&apos;, event);
        if (stopped) {
          event.kill();
        } else if (settings.stopBackspace === true &amp;&amp; isDangerous(event)) {
          event.prevent();
        }
      });
      var onFocusIn = bindFocus(container, function (event) {
        var stopped = settings.triggerEvent(&apos;focusin&apos;, event);
        if (stopped) {
          event.kill();
        }
      });
      var focusoutTimeout = Cell(Option.none());
      var onFocusOut = bindBlur(container, function (event) {
        var stopped = settings.triggerEvent(&apos;focusout&apos;, event);
        if (stopped) {
          event.kill();
        }
        focusoutTimeout.set(Option.some(domGlobals.setTimeout(function () {
          settings.triggerEvent(postBlur(), event);
        }, 0)));
      });
      var unbind = function () {
        each(simpleEvents, function (e) {
          e.unbind();
        });
        onKeydown.unbind();
        onFocusIn.unbind();
        onFocusOut.unbind();
        onPaste.unbind();
        pasteTimeout.get().each(domGlobals.clearTimeout);
        focusoutTimeout.get().each(domGlobals.clearTimeout);
      };
      return { unbind: unbind };
    };

    var derive$2 = function (rawEvent, rawTarget) {
      var source = get(rawEvent, &apos;target&apos;).map(function (getTarget) {
        return getTarget();
      }).getOr(rawTarget);
      return Cell(source);
    };

    var fromSource = function (event, source) {
      var stopper = Cell(false);
      var cutter = Cell(false);
      var stop = function () {
        stopper.set(true);
      };
      var cut = function () {
        cutter.set(true);
      };
      return {
        stop: stop,
        cut: cut,
        isStopped: stopper.get,
        isCut: cutter.get,
        event: constant(event),
        setSource: source.set,
        getSource: source.get
      };
    };
    var fromExternal = function (event) {
      var stopper = Cell(false);
      var stop = function () {
        stopper.set(true);
      };
      return {
        stop: stop,
        cut: noop,
        isStopped: stopper.get,
        isCut: constant(false),
        event: constant(event),
        setSource: die(&apos;Cannot set source of a broadcasted event&apos;),
        getSource: die(&apos;Cannot get source of a broadcasted event&apos;)
      };
    };

    var adt$b = Adt.generate([
      { stopped: [] },
      { resume: [&apos;element&apos;] },
      { complete: [] }
    ]);
    var doTriggerHandler = function (lookup, eventType, rawEvent, target, source, logger) {
      var handler = lookup(eventType, target);
      var simulatedEvent = fromSource(rawEvent, source);
      return handler.fold(function () {
        logger.logEventNoHandlers(eventType, target);
        return adt$b.complete();
      }, function (handlerInfo) {
        var descHandler = handlerInfo.descHandler;
        var eventHandler = getCurried(descHandler);
        eventHandler(simulatedEvent);
        if (simulatedEvent.isStopped()) {
          logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose());
          return adt$b.stopped();
        } else if (simulatedEvent.isCut()) {
          logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose());
          return adt$b.complete();
        } else {
          return parent(handlerInfo.element).fold(function () {
            logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose());
            return adt$b.complete();
          }, function (parent) {
            logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose());
            return adt$b.resume(parent);
          });
        }
      });
    };
    var doTriggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, source, logger) {
      return doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(function () {
        return true;
      }, function (parent) {
        return doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger);
      }, function () {
        return false;
      });
    };
    var triggerHandler = function (lookup, eventType, rawEvent, target, logger) {
      var source = derive$2(rawEvent, target);
      return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
    };
    var broadcast = function (listeners, rawEvent, _logger) {
      var simulatedEvent = fromExternal(rawEvent);
      each(listeners, function (listener) {
        var descHandler = listener.descHandler();
        var handler = getCurried(descHandler);
        handler(simulatedEvent);
      });
      return simulatedEvent.isStopped();
    };
    var triggerUntilStopped = function (lookup, eventType, rawEvent, logger) {
      var rawTarget = rawEvent.target();
      return triggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, logger);
    };
    var triggerOnUntilStopped = function (lookup, eventType, rawEvent, rawTarget, logger) {
      var source = derive$2(rawEvent, rawTarget);
      return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
    };

    var eventHandler = function (element, descHandler) {
      return {
        element: element,
        descHandler: descHandler
      };
    };
    var broadcastHandler = function (id, handler) {
      return {
        id: constant(id),
        descHandler: constant(handler)
      };
    };
    function EventRegistry () {
      var registry = {};
      var registerId = function (extraArgs, id, events) {
        each$1(events, function (v, k) {
          var handlers = registry[k] !== undefined ? registry[k] : {};
          handlers[id] = curryArgs(v, extraArgs);
          registry[k] = handlers;
        });
      };
      var findHandler = function (handlers, elem) {
        return read$1(elem).fold(function () {
          return Option.none();
        }, function (id) {
          return handlers.bind(function (h) {
            return get(h, id);
          }).map(function (descHandler) {
            return eventHandler(elem, descHandler);
          });
        });
      };
      var filterByType = function (type) {
        return get(registry, type).map(function (handlers) {
          return mapToArray(handlers, function (f, id) {
            return broadcastHandler(id, f);
          });
        }).getOr([]);
      };
      var find = function (isAboveRoot, type, target) {
        var handlers = get(registry, type);
        return closest(target, function (elem) {
          return findHandler(handlers, elem);
        }, isAboveRoot);
      };
      var unregisterId = function (id) {
        each$1(registry, function (handlersById, _eventName) {
          if (handlersById.hasOwnProperty(id)) {
            delete handlersById[id];
          }
        });
      };
      return {
        registerId: registerId,
        unregisterId: unregisterId,
        filterByType: filterByType,
        find: find
      };
    }

    function Registry () {
      var events = EventRegistry();
      var components = {};
      var readOrTag = function (component) {
        var elem = component.element();
        return read$1(elem).fold(function () {
          return write(&apos;uid-&apos;, component.element());
        }, function (uid) {
          return uid;
        });
      };
      var failOnDuplicate = function (component, tagId) {
        var conflict = components[tagId];
        if (conflict === component) {
          unregister(component);
        } else {
          throw new Error(&apos;The tagId &quot;&apos; + tagId + &apos;&quot; is already used by: &apos; + element(conflict.element()) + &apos;\nCannot use it for: &apos; + element(component.element()) + &apos;\n&apos; + &apos;The conflicting element is&apos; + (inBody(conflict.element()) ? &apos; &apos; : &apos; not &apos;) + &apos;already in the DOM&apos;);
        }
      };
      var register = function (component) {
        var tagId = readOrTag(component);
        if (hasNonNullableKey(components, tagId)) {
          failOnDuplicate(component, tagId);
        }
        var extraArgs = [component];
        events.registerId(extraArgs, tagId, component.events());
        components[tagId] = component;
      };
      var unregister = function (component) {
        read$1(component.element()).each(function (tagId) {
          delete components[tagId];
          events.unregisterId(tagId);
        });
      };
      var filter = function (type) {
        return events.filterByType(type);
      };
      var find = function (isAboveRoot, type, target) {
        return events.find(isAboveRoot, type, target);
      };
      var getById = function (id) {
        return get(components, id);
      };
      return {
        find: find,
        filter: filter,
        register: register,
        unregister: unregister,
        getById: getById
      };
    }

    var factory$3 = function (detail) {
      var _a = detail.dom, attributes = _a.attributes, domWithoutAttributes = __rest(_a, [&apos;attributes&apos;]);
      return {
        uid: detail.uid,
        dom: __assign({
          tag: &apos;div&apos;,
          attributes: __assign({ role: &apos;presentation&apos; }, attributes)
        }, domWithoutAttributes),
        components: detail.components,
        behaviours: get$c(detail.containerBehaviours),
        events: detail.events,
        domModification: detail.domModification,
        eventOrder: detail.eventOrder
      };
    };
    var Container = single$2({
      name: &apos;Container&apos;,
      factory: factory$3,
      configFields: [
        defaulted$1(&apos;components&apos;, []),
        field$1(&apos;containerBehaviours&apos;, []),
        defaulted$1(&apos;events&apos;, {}),
        defaulted$1(&apos;domModification&apos;, {}),
        defaulted$1(&apos;eventOrder&apos;, {})
      ]
    });

    var takeover = function (root) {
      var isAboveRoot = function (el) {
        return parent(root.element()).fold(function () {
          return true;
        }, function (parent) {
          return eq$1(el, parent);
        });
      };
      var registry = Registry();
      var lookup = function (eventName, target) {
        return registry.find(isAboveRoot, eventName, target);
      };
      var domEvents = setup$1(root.element(), {
        triggerEvent: function (eventName, event) {
          return monitorEvent(eventName, event.target(), function (logger) {
            return triggerUntilStopped(lookup, eventName, event, logger);
          });
        }
      });
      var systemApi = {
        debugInfo: constant(&apos;real&apos;),
        triggerEvent: function (eventName, target, data) {
          monitorEvent(eventName, target, function (logger) {
            return triggerOnUntilStopped(lookup, eventName, data, target, logger);
          });
        },
        triggerFocus: function (target, originator) {
          read$1(target).fold(function () {
            focus$1(target);
          }, function (_alloyId) {
            monitorEvent(focus(), target, function (logger) {
              triggerHandler(lookup, focus(), {
                originator: constant(originator),
                kill: noop,
                prevent: noop,
                target: constant(target)
              }, target, logger);
              return false;
            });
          });
        },
        triggerEscape: function (comp, simulatedEvent) {
          systemApi.triggerEvent(&apos;keydown&apos;, comp.element(), simulatedEvent.event());
        },
        getByUid: function (uid) {
          return getByUid(uid);
        },
        getByDom: function (elem) {
          return getByDom(elem);
        },
        build: build$1,
        addToGui: function (c) {
          add(c);
        },
        removeFromGui: function (c) {
          remove$1(c);
        },
        addToWorld: function (c) {
          addToWorld(c);
        },
        removeFromWorld: function (c) {
          removeFromWorld(c);
        },
        broadcast: function (message) {
          broadcast$1(message);
        },
        broadcastOn: function (channels, message) {
          broadcastOn(channels, message);
        },
        broadcastEvent: function (eventName, event) {
          broadcastEvent(eventName, event);
        },
        isConnected: constant(true)
      };
      var addToWorld = function (component) {
        component.connect(systemApi);
        if (!isText(component.element())) {
          registry.register(component);
          each(component.components(), addToWorld);
          systemApi.triggerEvent(systemInit(), component.element(), { target: constant(component.element()) });
        }
      };
      var removeFromWorld = function (component) {
        if (!isText(component.element())) {
          each(component.components(), removeFromWorld);
          registry.unregister(component);
        }
        component.disconnect();
      };
      var add = function (component) {
        attach$1(root, component);
      };
      var remove$1 = function (component) {
        detach(component);
      };
      var destroy = function () {
        domEvents.unbind();
        remove(root.element());
      };
      var broadcastData = function (data) {
        var receivers = registry.filter(receive());
        each(receivers, function (receiver) {
          var descHandler = receiver.descHandler();
          var handler = getCurried(descHandler);
          handler(data);
        });
      };
      var broadcast$1 = function (message) {
        broadcastData({
          universal: constant(true),
          data: constant(message)
        });
      };
      var broadcastOn = function (channels, message) {
        broadcastData({
          universal: constant(false),
          channels: constant(channels),
          data: constant(message)
        });
      };
      var broadcastEvent = function (eventName, event) {
        var listeners = registry.filter(eventName);
        return broadcast(listeners, event);
      };
      var getByUid = function (uid) {
        return registry.getById(uid).fold(function () {
          return Result.error(new Error(&apos;Could not find component with uid: &quot;&apos; + uid + &apos;&quot; in system.&apos;));
        }, Result.value);
      };
      var getByDom = function (elem) {
        var uid = read$1(elem).getOr(&apos;not found&apos;);
        return getByUid(uid);
      };
      addToWorld(root);
      return {
        root: constant(root),
        element: root.element,
        destroy: destroy,
        add: add,
        remove: remove$1,
        getByUid: getByUid,
        getByDom: getByDom,
        addToWorld: addToWorld,
        removeFromWorld: removeFromWorld,
        broadcast: broadcast$1,
        broadcastOn: broadcastOn,
        broadcastEvent: broadcastEvent
      };
    };

    var formChangeEvent = generate$1(&apos;form-component-change&apos;);
    var formCloseEvent = generate$1(&apos;form-close&apos;);
    var formCancelEvent = generate$1(&apos;form-cancel&apos;);
    var formActionEvent = generate$1(&apos;form-action&apos;);
    var formSubmitEvent = generate$1(&apos;form-submit&apos;);
    var formBlockEvent = generate$1(&apos;form-block&apos;);
    var formUnblockEvent = generate$1(&apos;form-unblock&apos;);
    var formTabChangeEvent = generate$1(&apos;form-tabchange&apos;);
    var formResizeEvent = generate$1(&apos;form-resize&apos;);

    var renderAlertBanner = function (spec, providersBackstage) {
      return Container.sketch({
        dom: {
          tag: &apos;div&apos;,
          attributes: { role: &apos;alert&apos; },
          classes: [
            &apos;tox-notification&apos;,
            &apos;tox-notification--in&apos;,
            &apos;tox-notification--&apos; + spec.level
          ]
        },
        components: [
          {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-notification__icon&apos;]
            },
            components: [Button.sketch({
                dom: {
                  tag: &apos;button&apos;,
                  classes: [
                    &apos;tox-button&apos;,
                    &apos;tox-button--naked&apos;,
                    &apos;tox-button--icon&apos;
                  ],
                  innerHtml: get$d(spec.icon, providersBackstage.icons),
                  attributes: { title: providersBackstage.translate(spec.iconTooltip) }
                },
                action: function (comp) {
                  emitWith(comp, formActionEvent, {
                    name: &apos;alert-banner&apos;,
                    value: spec.url
                  });
                }
              })]
          },
          {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-notification__body&apos;],
              innerHtml: providersBackstage.translate(spec.text)
            }
          }
        ]
      });
    };

    var renderBar = function (spec, backstage) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-bar&apos;,
            &apos;tox-form__controls-h-stack&apos;
          ]
        },
        components: map(spec.items, backstage.interpreter)
      };
    };

    var schema$e = constant([
      defaulted$1(&apos;prefix&apos;, &apos;form-field&apos;),
      field$1(&apos;fieldBehaviours&apos;, [
        Composing,
        Representing
      ])
    ]);
    var parts$3 = constant([
      optional({
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;label&apos;
      }),
      optional({
        factory: {
          sketch: function (spec) {
            return {
              uid: spec.uid,
              dom: {
                tag: &apos;span&apos;,
                styles: { display: &apos;none&apos; },
                attributes: { &apos;aria-hidden&apos;: &apos;true&apos; },
                innerHtml: spec.text
              }
            };
          }
        },
        schema: [strict$1(&apos;text&apos;)],
        name: &apos;aria-descriptor&apos;
      }),
      required({
        factory: {
          sketch: function (spec) {
            var excludeFactory = exclude$1(spec, [&apos;factory&apos;]);
            return spec.factory.sketch(excludeFactory);
          }
        },
        schema: [strict$1(&apos;factory&apos;)],
        name: &apos;field&apos;
      })
    ]);

    var factory$4 = function (detail, components, _spec, _externals) {
      var behaviours = augment(detail.fieldBehaviours, [
        Composing.config({
          find: function (container) {
            return getPart(container, detail, &apos;field&apos;);
          }
        }),
        Representing.config({
          store: {
            mode: &apos;manual&apos;,
            getValue: function (field) {
              return Composing.getCurrent(field).bind(Representing.getValue);
            },
            setValue: function (field, value) {
              Composing.getCurrent(field).each(function (current) {
                Representing.setValue(current, value);
              });
            }
          }
        })
      ]);
      var events = derive([runOnAttached(function (component, _simulatedEvent) {
          var ps = getParts(component, detail, [
            &apos;label&apos;,
            &apos;field&apos;,
            &apos;aria-descriptor&apos;
          ]);
          ps.field().each(function (field) {
            var id = generate$1(detail.prefix);
            ps.label().each(function (label) {
              set$1(label.element(), &apos;for&apos;, id);
              set$1(field.element(), &apos;id&apos;, id);
            });
            ps[&apos;aria-descriptor&apos;]().each(function (descriptor) {
              var descriptorId = generate$1(detail.prefix);
              set$1(descriptor.element(), &apos;id&apos;, descriptorId);
              set$1(field.element(), &apos;aria-describedby&apos;, descriptorId);
            });
          });
        })]);
      var apis = {
        getField: function (container) {
          return getPart(container, detail, &apos;field&apos;);
        },
        getLabel: function (container) {
          return getPart(container, detail, &apos;label&apos;);
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: behaviours,
        events: events,
        apis: apis
      };
    };
    var FormField = composite$1({
      name: &apos;FormField&apos;,
      configFields: schema$e(),
      partFields: parts$3(),
      factory: factory$4,
      apis: {
        getField: function (apis, comp) {
          return apis.getField(comp);
        },
        getLabel: function (apis, comp) {
          return apis.getLabel(comp);
        }
      }
    });

    var schema$f = constant([
      option(&apos;data&apos;),
      defaulted$1(&apos;inputAttributes&apos;, {}),
      defaulted$1(&apos;inputStyles&apos;, {}),
      defaulted$1(&apos;tag&apos;, &apos;input&apos;),
      defaulted$1(&apos;inputClasses&apos;, []),
      onHandler(&apos;onSetValue&apos;),
      defaulted$1(&apos;styles&apos;, {}),
      defaulted$1(&apos;eventOrder&apos;, {}),
      field$1(&apos;inputBehaviours&apos;, [
        Representing,
        Focusing
      ]),
      defaulted$1(&apos;selectOnFocus&apos;, true)
    ]);
    var focusBehaviours = function (detail) {
      return derive$1([Focusing.config({
          onFocus: !detail.selectOnFocus ? noop : function (component) {
            var input = component.element();
            var value = get$5(input);
            input.dom().setSelectionRange(0, value.length);
          }
        })]);
    };
    var behaviours = function (detail) {
      return __assign(__assign({}, focusBehaviours(detail)), augment(detail.inputBehaviours, [Representing.config({
          store: __assign(__assign({ mode: &apos;manual&apos; }, detail.data.map(function (data) {
            return { initialValue: data };
          }).getOr({})), {
            getValue: function (input) {
              return get$5(input.element());
            },
            setValue: function (input, data) {
              var current = get$5(input.element());
              if (current !== data) {
                set$3(input.element(), data);
              }
            }
          }),
          onSetValue: detail.onSetValue
        })]));
    };
    var dom$2 = function (detail) {
      return {
        tag: detail.tag,
        attributes: __assign({ type: &apos;text&apos; }, detail.inputAttributes),
        styles: detail.inputStyles,
        classes: detail.inputClasses
      };
    };

    var factory$5 = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: dom$2(detail),
        components: [],
        behaviours: behaviours(detail),
        eventOrder: detail.eventOrder
      };
    };
    var Input = single$2({
      name: &apos;Input&apos;,
      configFields: schema$f(),
      factory: factory$5
    });

    var exports$1 = {}, module = { exports: exports$1 };
    (function (define, exports, module, require) {
      (function (f) {
        if (typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos;) {
          module.exports = f();
        } else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== &apos;undefined&apos;) {
            g = window;
          } else if (typeof global !== &apos;undefined&apos;) {
            g = global;
          } else if (typeof self !== &apos;undefined&apos;) {
            g = self;
          } else {
            g = this;
          }
          g.EphoxContactWrapper = f();
        }
      }(function () {
        return function () {
          function r(e, n, t) {
            function o(i, f) {
              if (!n[i]) {
                if (!e[i]) {
                  var c = &apos;function&apos; == typeof require &amp;&amp; require;
                  if (!f &amp;&amp; c)
                    return c(i, !0);
                  if (u)
                    return u(i, !0);
                  var a = new Error(&apos;Cannot find module \&apos;&apos; + i + &apos;\&apos;&apos;);
                  throw a.code = &apos;MODULE_NOT_FOUND&apos;, a;
                }
                var p = n[i] = { exports: {} };
                e[i][0].call(p.exports, function (r) {
                  var n = e[i][1][r];
                  return o(n || r);
                }, p, p.exports, r, e, n, t);
              }
              return n[i].exports;
            }
            for (var u = &apos;function&apos; == typeof require &amp;&amp; require, i = 0; i &lt; t.length; i++)
              o(t[i]);
            return o;
          }
          return r;
        }()({
          1: [
            function (require, module, exports) {
              var process = module.exports = {};
              var cachedSetTimeout;
              var cachedClearTimeout;
              function defaultSetTimout() {
                throw new Error(&apos;setTimeout has not been defined&apos;);
              }
              function defaultClearTimeout() {
                throw new Error(&apos;clearTimeout has not been defined&apos;);
              }
              (function () {
                try {
                  if (typeof setTimeout === &apos;function&apos;) {
                    cachedSetTimeout = setTimeout;
                  } else {
                    cachedSetTimeout = defaultSetTimout;
                  }
                } catch (e) {
                  cachedSetTimeout = defaultSetTimout;
                }
                try {
                  if (typeof clearTimeout === &apos;function&apos;) {
                    cachedClearTimeout = clearTimeout;
                  } else {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                } catch (e) {
                  cachedClearTimeout = defaultClearTimeout;
                }
              }());
              function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                  return setTimeout(fun, 0);
                }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {
                  cachedSetTimeout = setTimeout;
                  return setTimeout(fun, 0);
                }
                try {
                  return cachedSetTimeout(fun, 0);
                } catch (e) {
                  try {
                    return cachedSetTimeout.call(null, fun, 0);
                  } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                  }
                }
              }
              function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                  return clearTimeout(marker);
                }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {
                  cachedClearTimeout = clearTimeout;
                  return clearTimeout(marker);
                }
                try {
                  return cachedClearTimeout(marker);
                } catch (e) {
                  try {
                    return cachedClearTimeout.call(null, marker);
                  } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                  }
                }
              }
              var queue = [];
              var draining = false;
              var currentQueue;
              var queueIndex = -1;
              function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                  return;
                }
                draining = false;
                if (currentQueue.length) {
                  queue = currentQueue.concat(queue);
                } else {
                  queueIndex = -1;
                }
                if (queue.length) {
                  drainQueue();
                }
              }
              function drainQueue() {
                if (draining) {
                  return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                  currentQueue = queue;
                  queue = [];
                  while (++queueIndex &lt; len) {
                    if (currentQueue) {
                      currentQueue[queueIndex].run();
                    }
                  }
                  queueIndex = -1;
                  len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
              }
              process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length &gt; 1) {
                  for (var i = 1; i &lt; arguments.length; i++) {
                    args[i - 1] = arguments[i];
                  }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 &amp;&amp; !draining) {
                  runTimeout(drainQueue);
                }
              };
              function Item(fun, array) {
                this.fun = fun;
                this.array = array;
              }
              Item.prototype.run = function () {
                this.fun.apply(null, this.array);
              };
              process.title = &apos;browser&apos;;
              process.browser = true;
              process.env = {};
              process.argv = [];
              process.version = &apos;&apos;;
              process.versions = {};
              function noop() {
              }
              process.on = noop;
              process.addListener = noop;
              process.once = noop;
              process.off = noop;
              process.removeListener = noop;
              process.removeAllListeners = noop;
              process.emit = noop;
              process.prependListener = noop;
              process.prependOnceListener = noop;
              process.listeners = function (name) {
                return [];
              };
              process.binding = function (name) {
                throw new Error(&apos;process.binding is not supported&apos;);
              };
              process.cwd = function () {
                return &apos;/&apos;;
              };
              process.chdir = function (dir) {
                throw new Error(&apos;process.chdir is not supported&apos;);
              };
              process.umask = function () {
                return 0;
              };
            },
            {}
          ],
          2: [
            function (require, module, exports) {
              (function (setImmediate) {
                (function (root) {
                  var setTimeoutFunc = setTimeout;
                  function noop() {
                  }
                  function bind(fn, thisArg) {
                    return function () {
                      fn.apply(thisArg, arguments);
                    };
                  }
                  function Promise(fn) {
                    if (typeof this !== &apos;object&apos;)
                      throw new TypeError(&apos;Promises must be constructed via new&apos;);
                    if (typeof fn !== &apos;function&apos;)
                      throw new TypeError(&apos;not a function&apos;);
                    this._state = 0;
                    this._handled = false;
                    this._value = undefined;
                    this._deferreds = [];
                    doResolve(fn, this);
                  }
                  function handle(self, deferred) {
                    while (self._state === 3) {
                      self = self._value;
                    }
                    if (self._state === 0) {
                      self._deferreds.push(deferred);
                      return;
                    }
                    self._handled = true;
                    Promise._immediateFn(function () {
                      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                      if (cb === null) {
                        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                        return;
                      }
                      var ret;
                      try {
                        ret = cb(self._value);
                      } catch (e) {
                        reject(deferred.promise, e);
                        return;
                      }
                      resolve(deferred.promise, ret);
                    });
                  }
                  function resolve(self, newValue) {
                    try {
                      if (newValue === self)
                        throw new TypeError(&apos;A promise cannot be resolved with itself.&apos;);
                      if (newValue &amp;&amp; (typeof newValue === &apos;object&apos; || typeof newValue === &apos;function&apos;)) {
                        var then = newValue.then;
                        if (newValue instanceof Promise) {
                          self._state = 3;
                          self._value = newValue;
                          finale(self);
                          return;
                        } else if (typeof then === &apos;function&apos;) {
                          doResolve(bind(then, newValue), self);
                          return;
                        }
                      }
                      self._state = 1;
                      self._value = newValue;
                      finale(self);
                    } catch (e) {
                      reject(self, e);
                    }
                  }
                  function reject(self, newValue) {
                    self._state = 2;
                    self._value = newValue;
                    finale(self);
                  }
                  function finale(self) {
                    if (self._state === 2 &amp;&amp; self._deferreds.length === 0) {
                      Promise._immediateFn(function () {
                        if (!self._handled) {
                          Promise._unhandledRejectionFn(self._value);
                        }
                      });
                    }
                    for (var i = 0, len = self._deferreds.length; i &lt; len; i++) {
                      handle(self, self._deferreds[i]);
                    }
                    self._deferreds = null;
                  }
                  function Handler(onFulfilled, onRejected, promise) {
                    this.onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : null;
                    this.onRejected = typeof onRejected === &apos;function&apos; ? onRejected : null;
                    this.promise = promise;
                  }
                  function doResolve(fn, self) {
                    var done = false;
                    try {
                      fn(function (value) {
                        if (done)
                          return;
                        done = true;
                        resolve(self, value);
                      }, function (reason) {
                        if (done)
                          return;
                        done = true;
                        reject(self, reason);
                      });
                    } catch (ex) {
                      if (done)
                        return;
                      done = true;
                      reject(self, ex);
                    }
                  }
                  Promise.prototype[&apos;catch&apos;] = function (onRejected) {
                    return this.then(null, onRejected);
                  };
                  Promise.prototype.then = function (onFulfilled, onRejected) {
                    var prom = new this.constructor(noop);
                    handle(this, new Handler(onFulfilled, onRejected, prom));
                    return prom;
                  };
                  Promise.all = function (arr) {
                    var args = Array.prototype.slice.call(arr);
                    return new Promise(function (resolve, reject) {
                      if (args.length === 0)
                        return resolve([]);
                      var remaining = args.length;
                      function res(i, val) {
                        try {
                          if (val &amp;&amp; (typeof val === &apos;object&apos; || typeof val === &apos;function&apos;)) {
                            var then = val.then;
                            if (typeof then === &apos;function&apos;) {
                              then.call(val, function (val) {
                                res(i, val);
                              }, reject);
                              return;
                            }
                          }
                          args[i] = val;
                          if (--remaining === 0) {
                            resolve(args);
                          }
                        } catch (ex) {
                          reject(ex);
                        }
                      }
                      for (var i = 0; i &lt; args.length; i++) {
                        res(i, args[i]);
                      }
                    });
                  };
                  Promise.resolve = function (value) {
                    if (value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Promise) {
                      return value;
                    }
                    return new Promise(function (resolve) {
                      resolve(value);
                    });
                  };
                  Promise.reject = function (value) {
                    return new Promise(function (resolve, reject) {
                      reject(value);
                    });
                  };
                  Promise.race = function (values) {
                    return new Promise(function (resolve, reject) {
                      for (var i = 0, len = values.length; i &lt; len; i++) {
                        values[i].then(resolve, reject);
                      }
                    });
                  };
                  Promise._immediateFn = typeof setImmediate === &apos;function&apos; ? function (fn) {
                    setImmediate(fn);
                  } : function (fn) {
                    setTimeoutFunc(fn, 0);
                  };
                  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
                    if (typeof console !== &apos;undefined&apos; &amp;&amp; console) {
                      console.warn(&apos;Possible Unhandled Promise Rejection:&apos;, err);
                    }
                  };
                  Promise._setImmediateFn = function _setImmediateFn(fn) {
                    Promise._immediateFn = fn;
                  };
                  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                    Promise._unhandledRejectionFn = fn;
                  };
                  if (typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) {
                    module.exports = Promise;
                  } else if (!root.Promise) {
                    root.Promise = Promise;
                  }
                }(this));
              }.call(this, require(&apos;timers&apos;).setImmediate));
            },
            { &apos;timers&apos;: 3 }
          ],
          3: [
            function (require, module, exports) {
              (function (setImmediate, clearImmediate) {
                var nextTick = require(&apos;process/browser.js&apos;).nextTick;
                var apply = Function.prototype.apply;
                var slice = Array.prototype.slice;
                var immediateIds = {};
                var nextImmediateId = 0;
                exports.setTimeout = function () {
                  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                };
                exports.setInterval = function () {
                  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                };
                exports.clearTimeout = exports.clearInterval = function (timeout) {
                  timeout.close();
                };
                function Timeout(id, clearFn) {
                  this._id = id;
                  this._clearFn = clearFn;
                }
                Timeout.prototype.unref = Timeout.prototype.ref = function () {
                };
                Timeout.prototype.close = function () {
                  this._clearFn.call(window, this._id);
                };
                exports.enroll = function (item, msecs) {
                  clearTimeout(item._idleTimeoutId);
                  item._idleTimeout = msecs;
                };
                exports.unenroll = function (item) {
                  clearTimeout(item._idleTimeoutId);
                  item._idleTimeout = -1;
                };
                exports._unrefActive = exports.active = function (item) {
                  clearTimeout(item._idleTimeoutId);
                  var msecs = item._idleTimeout;
                  if (msecs &gt;= 0) {
                    item._idleTimeoutId = setTimeout(function onTimeout() {
                      if (item._onTimeout)
                        item._onTimeout();
                    }, msecs);
                  }
                };
                exports.setImmediate = typeof setImmediate === &apos;function&apos; ? setImmediate : function (fn) {
                  var id = nextImmediateId++;
                  var args = arguments.length &lt; 2 ? false : slice.call(arguments, 1);
                  immediateIds[id] = true;
                  nextTick(function onNextTick() {
                    if (immediateIds[id]) {
                      if (args) {
                        fn.apply(null, args);
                      } else {
                        fn.call(null);
                      }
                      exports.clearImmediate(id);
                    }
                  });
                  return id;
                };
                exports.clearImmediate = typeof clearImmediate === &apos;function&apos; ? clearImmediate : function (id) {
                  delete immediateIds[id];
                };
              }.call(this, require(&apos;timers&apos;).setImmediate, require(&apos;timers&apos;).clearImmediate));
            },
            {
              &apos;process/browser.js&apos;: 1,
              &apos;timers&apos;: 3
            }
          ],
          4: [
            function (require, module, exports) {
              var promisePolyfill = require(&apos;promise-polyfill&apos;);
              var Global = function () {
                if (typeof window !== &apos;undefined&apos;) {
                  return window;
                } else {
                  return Function(&apos;return this;&apos;)();
                }
              }();
              module.exports = { boltExport: Global.Promise || promisePolyfill };
            },
            { &apos;promise-polyfill&apos;: 2 }
          ]
        }, {}, [4])(4);
      }));
    }(undefined, exports$1, module, undefined));
    var Promise = module.exports.boltExport;

    var nu$a = function (baseFn) {
      var data = Option.none();
      var callbacks = [];
      var map = function (f) {
        return nu$a(function (nCallback) {
          get(function (data) {
            nCallback(f(data));
          });
        });
      };
      var get = function (nCallback) {
        if (isReady()) {
          call(nCallback);
        } else {
          callbacks.push(nCallback);
        }
      };
      var set = function (x) {
        data = Option.some(x);
        run(callbacks);
        callbacks = [];
      };
      var isReady = function () {
        return data.isSome();
      };
      var run = function (cbs) {
        each(cbs, call);
      };
      var call = function (cb) {
        data.each(function (x) {
          domGlobals.setTimeout(function () {
            cb(x);
          }, 0);
        });
      };
      baseFn(set);
      return {
        get: get,
        map: map,
        isReady: isReady
      };
    };
    var pure$1 = function (a) {
      return nu$a(function (callback) {
        callback(a);
      });
    };
    var LazyValue = {
      nu: nu$a,
      pure: pure$1
    };

    var errorReporter = function (err) {
      domGlobals.setTimeout(function () {
        throw err;
      }, 0);
    };
    var make$3 = function (run) {
      var get = function (callback) {
        run().then(callback, errorReporter);
      };
      var map = function (fab) {
        return make$3(function () {
          return run().then(fab);
        });
      };
      var bind = function (aFutureB) {
        return make$3(function () {
          return run().then(function (v) {
            return aFutureB(v).toPromise();
          });
        });
      };
      var anonBind = function (futureB) {
        return make$3(function () {
          return run().then(function () {
            return futureB.toPromise();
          });
        });
      };
      var toLazy = function () {
        return LazyValue.nu(get);
      };
      var toCached = function () {
        var cache = null;
        return make$3(function () {
          if (cache === null) {
            cache = run();
          }
          return cache;
        });
      };
      var toPromise = run;
      return {
        map: map,
        bind: bind,
        anonBind: anonBind,
        toLazy: toLazy,
        toCached: toCached,
        toPromise: toPromise,
        get: get
      };
    };
    var nu$b = function (baseFn) {
      return make$3(function () {
        return new Promise(baseFn);
      });
    };
    var pure$2 = function (a) {
      return make$3(function () {
        return Promise.resolve(a);
      });
    };
    var Future = {
      nu: nu$b,
      pure: pure$2
    };

    var ariaElements = [
      &apos;input&apos;,
      &apos;textarea&apos;
    ];
    var isAriaElement = function (elem) {
      var name$1 = name(elem);
      return contains(ariaElements, name$1);
    };
    var markValid = function (component, invalidConfig) {
      var elem = invalidConfig.getRoot(component).getOr(component.element());
      remove$4(elem, invalidConfig.invalidClass);
      invalidConfig.notify.each(function (notifyInfo) {
        if (isAriaElement(component.element())) {
          set$1(component.element(), &apos;aria-invalid&apos;, false);
        }
        notifyInfo.getContainer(component).each(function (container) {
          set(container, notifyInfo.validHtml);
        });
        notifyInfo.onValid(component);
      });
    };
    var markInvalid = function (component, invalidConfig, invalidState, text) {
      var elem = invalidConfig.getRoot(component).getOr(component.element());
      add$2(elem, invalidConfig.invalidClass);
      invalidConfig.notify.each(function (notifyInfo) {
        if (isAriaElement(component.element())) {
          set$1(component.element(), &apos;aria-invalid&apos;, true);
        }
        notifyInfo.getContainer(component).each(function (container) {
          set(container, text);
        });
        notifyInfo.onInvalid(component, text);
      });
    };
    var query = function (component, invalidConfig, _invalidState) {
      return invalidConfig.validator.fold(function () {
        return Future.pure(Result.value(true));
      }, function (validatorInfo) {
        return validatorInfo.validate(component);
      });
    };
    var run$1 = function (component, invalidConfig, invalidState) {
      invalidConfig.notify.each(function (notifyInfo) {
        notifyInfo.onValidate(component);
      });
      return query(component, invalidConfig).map(function (valid) {
        if (component.getSystem().isConnected()) {
          return valid.fold(function (err) {
            markInvalid(component, invalidConfig, invalidState, err);
            return Result.error(err);
          }, function (v) {
            markValid(component, invalidConfig);
            return Result.value(v);
          });
        } else {
          return Result.error(&apos;No longer in system&apos;);
        }
      });
    };
    var isInvalid = function (component, invalidConfig) {
      var elem = invalidConfig.getRoot(component).getOr(component.element());
      return has$2(elem, invalidConfig.invalidClass);
    };

    var InvalidateApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        markValid: markValid,
        markInvalid: markInvalid,
        query: query,
        run: run$1,
        isInvalid: isInvalid
    });

    var events$a = function (invalidConfig, invalidState) {
      return invalidConfig.validator.map(function (validatorInfo) {
        return derive([run(validatorInfo.onEvent, function (component) {
            run$1(component, invalidConfig, invalidState).get(identity);
          })].concat(validatorInfo.validateOnLoad ? [runOnAttached(function (component) {
            run$1(component, invalidConfig, invalidState).get(noop);
          })] : []));
      }).getOr({});
    };

    var ActiveInvalidate = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$a
    });

    var InvalidateSchema = [
      strict$1(&apos;invalidClass&apos;),
      defaulted$1(&apos;getRoot&apos;, Option.none),
      optionObjOf(&apos;notify&apos;, [
        defaulted$1(&apos;aria&apos;, &apos;alert&apos;),
        defaulted$1(&apos;getContainer&apos;, Option.none),
        defaulted$1(&apos;validHtml&apos;, &apos;&apos;),
        onHandler(&apos;onValid&apos;),
        onHandler(&apos;onInvalid&apos;),
        onHandler(&apos;onValidate&apos;)
      ]),
      optionObjOf(&apos;validator&apos;, [
        strict$1(&apos;validate&apos;),
        defaulted$1(&apos;onEvent&apos;, &apos;input&apos;),
        defaulted$1(&apos;validateOnLoad&apos;, true)
      ])
    ];

    var Invalidating = create$1({
      fields: InvalidateSchema,
      name: &apos;invalidating&apos;,
      active: ActiveInvalidate,
      apis: InvalidateApis,
      extra: {
        validation: function (validator) {
          return function (component) {
            var v = Representing.getValue(component);
            return Future.pure(validator(v));
          };
        }
      }
    });

    var exhibit$4 = function (base, tabConfig) {
      return nu$6({
        attributes: wrapAll$1([{
            key: tabConfig.tabAttr,
            value: &apos;true&apos;
          }])
      });
    };

    var ActiveTabstopping = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$4
    });

    var TabstopSchema = [defaulted$1(&apos;tabAttr&apos;, &apos;data-alloy-tabstop&apos;)];

    var Tabstopping = create$1({
      fields: TabstopSchema,
      name: &apos;tabstopping&apos;,
      active: ActiveTabstopping
    });

    var renderFormFieldWith = function (pLabel, pField, extraClasses, extraBehaviours) {
      var spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
      return FormField.sketch(spec);
    };
    var renderFormField = function (pLabel, pField) {
      return renderFormFieldWith(pLabel, pField, [], []);
    };
    var renderFormFieldSpecWith = function (pLabel, pField, extraClasses, extraBehaviours) {
      return {
        dom: renderFormFieldDomWith(extraClasses),
        components: pLabel.toArray().concat([pField]),
        fieldBehaviours: derive$1(extraBehaviours)
      };
    };
    var renderFormFieldDom = function () {
      return renderFormFieldDomWith([]);
    };
    var renderFormFieldDomWith = function (extraClasses) {
      return {
        tag: &apos;div&apos;,
        classes: [&apos;tox-form__group&apos;].concat(extraClasses)
      };
    };
    var renderLabel = function (label, providersBackstage) {
      return FormField.parts().label({
        dom: {
          tag: &apos;label&apos;,
          classes: [&apos;tox-label&apos;],
          innerHtml: providersBackstage.translate(label)
        }
      });
    };

    var getCoupled = function (component, coupleConfig, coupleState, name) {
      return coupleState.getOrCreate(component, coupleConfig, name);
    };

    var CouplingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getCoupled: getCoupled
    });

    var CouplingSchema = [strictOf(&apos;others&apos;, setOf$1(Result.value, anyValue$1()))];

    var init$5 = function () {
      var coupled = {};
      var getOrCreate = function (component, coupleConfig, name) {
        var available = keys(coupleConfig.others);
        if (!available) {
          throw new Error(&apos;Cannot find coupled component: &apos; + name + &apos;. Known coupled components: &apos; + JSON.stringify(available, null, 2));
        } else {
          return get(coupled, name).getOrThunk(function () {
            var builder = get(coupleConfig.others, name).getOrDie(&apos;No information found for coupled component: &apos; + name);
            var spec = builder(component);
            var built = component.getSystem().build(spec);
            coupled[name] = built;
            return built;
          });
        }
      };
      var readState = constant({});
      return nu$5({
        readState: readState,
        getOrCreate: getOrCreate
      });
    };

    var CouplingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$5
    });

    var Coupling = create$1({
      fields: CouplingSchema,
      name: &apos;coupling&apos;,
      apis: CouplingApis,
      state: CouplingState
    });

    var suffix = constant(&apos;sink&apos;);
    var partType = constant(optional({
      name: suffix(),
      overrides: constant({
        dom: { tag: &apos;div&apos; },
        behaviours: derive$1([Positioning.config({ useFixed: always })]),
        events: derive([
          cutter(keydown()),
          cutter(mousedown()),
          cutter(click())
        ])
      })
    }));

    var HighlightOnOpen;
    (function (HighlightOnOpen) {
      HighlightOnOpen[HighlightOnOpen[&apos;HighlightFirst&apos;] = 0] = &apos;HighlightFirst&apos;;
      HighlightOnOpen[HighlightOnOpen[&apos;HighlightNone&apos;] = 1] = &apos;HighlightNone&apos;;
    }(HighlightOnOpen || (HighlightOnOpen = {})));
    var getAnchor = function (detail, component) {
      var hotspot = detail.getHotspot(component).getOr(component);
      var anchor = &apos;hotspot&apos;;
      var overrides = detail.getAnchorOverrides();
      return detail.layouts.fold(function () {
        return {
          anchor: anchor,
          hotspot: hotspot,
          overrides: overrides
        };
      }, function (layouts) {
        return {
          anchor: anchor,
          hotspot: hotspot,
          overrides: overrides,
          layouts: layouts
        };
      });
    };
    var fetch = function (detail, mapFetch, component) {
      var fetcher = detail.fetch;
      return fetcher(component).map(mapFetch);
    };
    var openF = function (detail, mapFetch, anchor, component, sandbox, externals, highlightOnOpen) {
      var futureData = fetch(detail, mapFetch, component);
      var getLazySink = getSink(component, detail);
      return futureData.map(function (tdata) {
        return tdata.bind(function (data) {
          return Option.from(tieredMenu.sketch(__assign(__assign({}, externals.menu()), {
            uid: generate$2(&apos;&apos;),
            data: data,
            highlightImmediately: highlightOnOpen === HighlightOnOpen.HighlightFirst,
            onOpenMenu: function (tmenu, menu) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, anchor, menu);
              Sandboxing.decloak(sandbox);
            },
            onOpenSubmenu: function (tmenu, item, submenu) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, {
                anchor: &apos;submenu&apos;,
                item: item
              }, submenu);
              Sandboxing.decloak(sandbox);
            },
            onRepositionMenu: function (tmenu, primaryMenu, submenuTriggers) {
              var sink = getLazySink().getOrDie();
              Positioning.position(sink, anchor, primaryMenu);
              each(submenuTriggers, function (st) {
                Positioning.position(sink, {
                  anchor: &apos;submenu&apos;,
                  item: st.triggeringItem
                }, st.triggeredMenu);
              });
            },
            onEscape: function () {
              Focusing.focus(component);
              Sandboxing.close(sandbox);
              return Option.some(true);
            }
          })));
        });
      });
    };
    var open$1 = function (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) {
      var anchor = getAnchor(detail, hotspot);
      var processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
      return processed.map(function (tdata) {
        tdata.fold(function () {
          if (Sandboxing.isOpen(sandbox)) {
            Sandboxing.close(sandbox);
          }
        }, function (data) {
          Sandboxing.cloak(sandbox);
          Sandboxing.open(sandbox, data);
          onOpenSync(sandbox);
        });
        return sandbox;
      });
    };
    var close$1 = function (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) {
      Sandboxing.close(sandbox);
      return Future.pure(sandbox);
    };
    var togglePopup = function (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) {
      var sandbox = Coupling.getCoupled(hotspot, &apos;sandbox&apos;);
      var showing = Sandboxing.isOpen(sandbox);
      var action = showing ? close$1 : open$1;
      return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
    };
    var matchWidth = function (hotspot, container, useMinWidth) {
      var menu = Composing.getCurrent(container).getOr(container);
      var buttonWidth = get$7(hotspot.element());
      if (useMinWidth) {
        set$2(menu.element(), &apos;min-width&apos;, buttonWidth + &apos;px&apos;);
      } else {
        set$4(menu.element(), buttonWidth);
      }
    };
    var getSink = function (anyInSystem, sinkDetail) {
      return anyInSystem.getSystem().getByUid(sinkDetail.uid + &apos;-&apos; + suffix()).map(function (internalSink) {
        return function () {
          return Result.value(internalSink);
        };
      }).getOrThunk(function () {
        return sinkDetail.lazySink.fold(function () {
          return function () {
            return Result.error(new Error(&apos;No internal sink is specified, nor could an external sink be found&apos;));
          };
        }, function (lazySinkFn) {
          return function () {
            return lazySinkFn(anyInSystem);
          };
        });
      });
    };
    var doRepositionMenus = function (sandbox) {
      Sandboxing.getState(sandbox).each(function (tmenu) {
        tieredMenu.repositionMenus(tmenu);
      });
    };
    var makeSandbox = function (detail, hotspot, extras) {
      var ariaOwner = manager();
      var onOpen = function (component, menu) {
        var anchor = getAnchor(detail, hotspot);
        ariaOwner.link(hotspot.element());
        if (detail.matchWidth) {
          matchWidth(anchor.hotspot, menu, detail.useMinWidth);
        }
        detail.onOpen(anchor, component, menu);
        if (extras !== undefined &amp;&amp; extras.onOpen !== undefined) {
          extras.onOpen(component, menu);
        }
      };
      var onClose = function (component, menu) {
        ariaOwner.unlink(hotspot.element());
        if (extras !== undefined &amp;&amp; extras.onClose !== undefined) {
          extras.onClose(component, menu);
        }
      };
      var lazySink = getSink(hotspot, detail);
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: detail.sandboxClasses,
          attributes: {
            id: ariaOwner.id,
            role: &apos;listbox&apos;
          }
        },
        behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: hotspot
            }
          }),
          Sandboxing.config({
            onOpen: onOpen,
            onClose: onClose,
            isPartOf: function (container, data, queryElem) {
              return isPartOf(data, queryElem) || isPartOf(hotspot, queryElem);
            },
            getAttachPoint: function () {
              return lazySink().getOrDie();
            }
          }),
          Composing.config({
            find: function (sandbox) {
              return Sandboxing.getState(sandbox).bind(function (menu) {
                return Composing.getCurrent(menu);
              });
            }
          }),
          Receiving.config({ channels: __assign(__assign({}, receivingChannel({ isExtraPart: never })), receivingChannel$1({ doReposition: doRepositionMenus })) })
        ])
      };
    };
    var repositionMenus = function (comp) {
      var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
      doRepositionMenus(sandbox);
    };

    var sandboxFields = function () {
      return [
        defaulted$1(&apos;sandboxClasses&apos;, []),
        SketchBehaviours.field(&apos;sandboxBehaviours&apos;, [
          Composing,
          Receiving,
          Sandboxing,
          Representing
        ])
      ];
    };

    var schema$g = constant([
      strict$1(&apos;dom&apos;),
      strict$1(&apos;fetch&apos;),
      onHandler(&apos;onOpen&apos;),
      onKeyboardHandler(&apos;onExecute&apos;),
      defaulted$1(&apos;getHotspot&apos;, Option.some),
      defaulted$1(&apos;getAnchorOverrides&apos;, constant({})),
      schema$1(),
      field$1(&apos;dropdownBehaviours&apos;, [
        Toggling,
        Coupling,
        Keying,
        Focusing
      ]),
      strict$1(&apos;toggleClass&apos;),
      defaulted$1(&apos;eventOrder&apos;, {}),
      option(&apos;lazySink&apos;),
      defaulted$1(&apos;matchWidth&apos;, false),
      defaulted$1(&apos;useMinWidth&apos;, false),
      option(&apos;role&apos;)
    ].concat(sandboxFields()));
    var parts$4 = constant([
      external$1({
        schema: [tieredMenuMarkers()],
        name: &apos;menu&apos;,
        defaults: function (detail) {
          return { onExecute: detail.onExecute };
        }
      }),
      partType()
    ]);

    var factory$6 = function (detail, components, _spec, externals) {
      var _a;
      var lookupAttr = function (attr) {
        return get(detail.dom, &apos;attributes&apos;).bind(function (attrs) {
          return get(attrs, attr);
        });
      };
      var switchToMenu = function (sandbox) {
        Sandboxing.getState(sandbox).each(function (tmenu) {
          tieredMenu.highlightPrimary(tmenu);
        });
      };
      var action = function (component) {
        var onOpenSync = switchToMenu;
        togglePopup(detail, function (x) {
          return x;
        }, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
      };
      var apis = {
        expand: function (comp) {
          if (!Toggling.isOn(comp)) {
            togglePopup(detail, function (x) {
              return x;
            }, comp, externals, noop, HighlightOnOpen.HighlightNone).get(noop);
          }
        },
        open: function (comp) {
          if (!Toggling.isOn(comp)) {
            togglePopup(detail, function (x) {
              return x;
            }, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);
          }
        },
        isOpen: Toggling.isOn,
        close: function (comp) {
          if (Toggling.isOn(comp)) {
            togglePopup(detail, function (x) {
              return x;
            }, comp, externals, noop, HighlightOnOpen.HighlightFirst).get(noop);
          }
        },
        repositionMenus: function (comp) {
          if (Toggling.isOn(comp)) {
            repositionMenus(comp);
          }
        }
      };
      var triggerExecute = function (comp, _se) {
        emitExecute(comp);
        return Option.some(true);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.dropdownBehaviours, [
          Toggling.config({
            toggleClass: detail.toggleClass,
            aria: { mode: &apos;expanded&apos; }
          }),
          Coupling.config({
            others: {
              sandbox: function (hotspot) {
                return makeSandbox(detail, hotspot, {
                  onOpen: function () {
                    Toggling.on(hotspot);
                  },
                  onClose: function () {
                    Toggling.off(hotspot);
                  }
                });
              }
            }
          }),
          Keying.config({
            mode: &apos;special&apos;,
            onSpace: triggerExecute,
            onEnter: triggerExecute,
            onDown: function (comp, _se) {
              if (Dropdown.isOpen(comp)) {
                var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
                switchToMenu(sandbox);
              } else {
                Dropdown.open(comp);
              }
              return Option.some(true);
            },
            onEscape: function (comp, _se) {
              if (Dropdown.isOpen(comp)) {
                Dropdown.close(comp);
                return Option.some(true);
              } else {
                return Option.none();
              }
            }
          }),
          Focusing.config({})
        ]),
        events: events$7(Option.some(action)),
        eventOrder: __assign(__assign({}, detail.eventOrder), (_a = {}, _a[execute()] = [
          &apos;disabling&apos;,
          &apos;toggling&apos;,
          &apos;alloy.base.behaviour&apos;
        ], _a)),
        apis: apis,
        domModification: {
          attributes: __assign(__assign({ &apos;aria-haspopup&apos;: &apos;true&apos; }, detail.role.fold(function () {
            return {};
          }, function (role) {
            return { role: role };
          })), detail.dom.tag === &apos;button&apos; ? { type: lookupAttr(&apos;type&apos;).getOr(&apos;button&apos;) } : {})
        }
      };
    };
    var Dropdown = composite$1({
      name: &apos;Dropdown&apos;,
      configFields: schema$g(),
      partFields: parts$4(),
      factory: factory$6,
      apis: {
        open: function (apis, comp) {
          return apis.open(comp);
        },
        expand: function (apis, comp) {
          return apis.expand(comp);
        },
        close: function (apis, comp) {
          return apis.close(comp);
        },
        isOpen: function (apis, comp) {
          return apis.isOpen(comp);
        },
        repositionMenus: function (apis, comp) {
          return apis.repositionMenus(comp);
        }
      }
    });

    var exhibit$5 = function () {
      return nu$6({
        styles: {
          &apos;-webkit-user-select&apos;: &apos;none&apos;,
          &apos;user-select&apos;: &apos;none&apos;,
          &apos;-ms-user-select&apos;: &apos;none&apos;,
          &apos;-moz-user-select&apos;: &apos;-moz-none&apos;
        },
        attributes: { unselectable: &apos;on&apos; }
      });
    };
    var events$b = function () {
      return derive([abort(selectstart(), constant(true))]);
    };

    var ActiveUnselecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$b,
        exhibit: exhibit$5
    });

    var Unselecting = create$1({
      fields: [],
      name: &apos;unselecting&apos;,
      active: ActiveUnselecting
    });

    var renderPanelButton = function (spec, sharedBackstage) {
      return Dropdown.sketch({
        dom: spec.dom,
        components: spec.components,
        toggleClass: &apos;mce-active&apos;,
        dropdownBehaviours: derive$1([
          DisablingConfigs.button(sharedBackstage.providers.isReadOnly),
          receivingConfig(),
          Unselecting.config({}),
          Tabstopping.config({})
        ]),
        layouts: spec.layouts,
        sandboxClasses: [&apos;tox-dialog__popups&apos;],
        lazySink: sharedBackstage.getSink,
        fetch: function (comp) {
          return Future.nu(function (callback) {
            return spec.fetch(callback);
          }).map(function (items) {
            return Option.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$1(&apos;menu-value&apos;), items, function (value) {
              spec.onItemAction(comp, value);
            }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, function () {
              return false;
            }, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })));
          });
        },
        parts: { menu: part(false, 1, spec.presets) }
      });
    };

    var colorInputChangeEvent = generate$1(&apos;color-input-change&apos;);
    var colorSwatchChangeEvent = generate$1(&apos;color-swatch-change&apos;);
    var colorPickerCancelEvent = generate$1(&apos;color-picker-cancel&apos;);
    var renderColorInput = function (spec, sharedBackstage, colorInputBackstage) {
      var pField = FormField.parts().field({
        factory: Input,
        inputClasses: [&apos;tox-textfield&apos;],
        onSetValue: function (c) {
          return Invalidating.run(c).get(function () {
          });
        },
        inputBehaviours: derive$1([
          Disabling.config({ disabled: sharedBackstage.providers.isReadOnly }),
          receivingConfig(),
          Tabstopping.config({}),
          Invalidating.config({
            invalidClass: &apos;tox-textbox-field-invalid&apos;,
            getRoot: function (comp) {
              return parent(comp.element());
            },
            notify: {
              onValid: function (comp) {
                var val = Representing.getValue(comp);
                emitWith(comp, colorInputChangeEvent, { color: val });
              }
            },
            validator: {
              validateOnLoad: false,
              validate: function (input) {
                var inputValue = Representing.getValue(input);
                if (inputValue.length === 0) {
                  return Future.pure(Result.value(true));
                } else {
                  var span = Element.fromTag(&apos;span&apos;);
                  set$2(span, &apos;background-color&apos;, inputValue);
                  var res = getRaw(span, &apos;background-color&apos;).fold(function () {
                    return Result.error(&apos;blah&apos;);
                  }, function (_) {
                    return Result.value(inputValue);
                  });
                  return Future.pure(res);
                }
              }
            }
          })
        ]),
        selectOnFocus: false
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, sharedBackstage.providers);
      });
      var emitSwatchChange = function (colorBit, value) {
        emitWith(colorBit, colorSwatchChangeEvent, { value: value });
      };
      var onItemAction = function (comp, value) {
        memColorButton.getOpt(comp).each(function (colorBit) {
          if (value === &apos;custom&apos;) {
            colorInputBackstage.colorPicker(function (valueOpt) {
              valueOpt.fold(function () {
                return emit(colorBit, colorPickerCancelEvent);
              }, function (value) {
                emitSwatchChange(colorBit, value);
                addColor(value);
              });
            }, &apos;#ffffff&apos;);
          } else if (value === &apos;remove&apos;) {
            emitSwatchChange(colorBit, &apos;&apos;);
          } else {
            emitSwatchChange(colorBit, value);
          }
        });
      };
      var memColorButton = record(renderPanelButton({
        dom: {
          tag: &apos;span&apos;,
          attributes: { &apos;aria-label&apos;: sharedBackstage.providers.translate(&apos;Color swatch&apos;) }
        },
        layouts: {
          onRtl: function () {
            return [
              southwest$1,
              southeast$1,
              south$1
            ];
          },
          onLtr: function () {
            return [
              southeast$1,
              southwest$1,
              south$1
            ];
          }
        },
        components: [],
        fetch: getFetch(colorInputBackstage.getColors(), colorInputBackstage.hasCustomColors()),
        columns: colorInputBackstage.getColorCols(),
        presets: &apos;color&apos;,
        onItemAction: onItemAction
      }, sharedBackstage));
      return FormField.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-form__group&apos;]
        },
        components: pLabel.toArray().concat([{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-color-input&apos;]
            },
            components: [
              pField,
              memColorButton.asSpec()
            ]
          }]),
        fieldBehaviours: derive$1([config(&apos;form-field-events&apos;, [
            run(colorInputChangeEvent, function (comp, se) {
              memColorButton.getOpt(comp).each(function (colorButton) {
                set$2(colorButton.element(), &apos;background-color&apos;, se.event().color());
              });
              emitWith(comp, formChangeEvent, { name: spec.name });
            }),
            run(colorSwatchChangeEvent, function (comp, se) {
              FormField.getField(comp).each(function (field) {
                Representing.setValue(field, se.event().value());
                Composing.getCurrent(comp).each(Focusing.focus);
              });
            }),
            run(colorPickerCancelEvent, function (comp, _se) {
              FormField.getField(comp).each(function (_field) {
                Composing.getCurrent(comp).each(Focusing.focus);
              });
            })
          ])])
      });
    };

    var hsvColour = function (hue, saturation, value) {
      return {
        hue: hue,
        saturation: saturation,
        value: value
      };
    };
    var fromRgb = function (rgbaColour) {
      var h = 0;
      var s = 0;
      var v = 0;
      var r = rgbaColour.red / 255;
      var g = rgbaColour.green / 255;
      var b = rgbaColour.blue / 255;
      var minRGB = Math.min(r, Math.min(g, b));
      var maxRGB = Math.max(r, Math.max(g, b));
      if (minRGB === maxRGB) {
        v = minRGB;
        return hsvColour(0, 0, v * 100);
      }
      var d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
      h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
      h = 60 * (h - d / (maxRGB - minRGB));
      s = (maxRGB - minRGB) / maxRGB;
      v = maxRGB;
      return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
    };

    var calcHex = function (value) {
      var hue = (100 - value) / 100 * 360;
      var hsv = hsvColour(hue, 100, 100);
      var rgb = fromHsv(hsv);
      return fromRgba(rgb);
    };

    var fieldsUpdate = generate$1(&apos;rgb-hex-update&apos;);
    var sliderUpdate = generate$1(&apos;slider-update&apos;);
    var paletteUpdate = generate$1(&apos;palette-update&apos;);

    var labelPart = optional({
      schema: [strict$1(&apos;dom&apos;)],
      name: &apos;label&apos;
    });
    var edgePart = function (name) {
      return optional({
        name: &apos;&apos; + name + &apos;-edge&apos;,
        overrides: function (detail) {
          var action = detail.model.manager.edgeActions[name];
          return action.fold(function () {
            return {};
          }, function (a) {
            return {
              events: derive([
                runActionExtra(touchstart(), function (comp, se, d) {
                  return a(comp, d);
                }, [detail]),
                runActionExtra(mousedown(), function (comp, se, d) {
                  return a(comp, d);
                }, [detail]),
                runActionExtra(mousemove(), function (comp, se, det) {
                  if (det.mouseIsDown.get()) {
                    a(comp, det);
                  }
                }, [detail])
              ])
            };
          });
        }
      });
    };
    var tlEdgePart = edgePart(&apos;top-left&apos;);
    var tedgePart = edgePart(&apos;top&apos;);
    var trEdgePart = edgePart(&apos;top-right&apos;);
    var redgePart = edgePart(&apos;right&apos;);
    var brEdgePart = edgePart(&apos;bottom-right&apos;);
    var bedgePart = edgePart(&apos;bottom&apos;);
    var blEdgePart = edgePart(&apos;bottom-left&apos;);
    var ledgePart = edgePart(&apos;left&apos;);
    var thumbPart = required({
      name: &apos;thumb&apos;,
      defaults: constant({ dom: { styles: { position: &apos;absolute&apos; } } }),
      overrides: function (detail) {
        return {
          events: derive([
            redirectToPart(touchstart(), detail, &apos;spectrum&apos;),
            redirectToPart(touchmove(), detail, &apos;spectrum&apos;),
            redirectToPart(touchend(), detail, &apos;spectrum&apos;),
            redirectToPart(mousedown(), detail, &apos;spectrum&apos;),
            redirectToPart(mousemove(), detail, &apos;spectrum&apos;),
            redirectToPart(mouseup(), detail, &apos;spectrum&apos;)
          ])
        };
      }
    });
    var spectrumPart = required({
      schema: [state$1(&apos;mouseIsDown&apos;, function () {
          return Cell(false);
        })],
      name: &apos;spectrum&apos;,
      overrides: function (detail) {
        var modelDetail = detail.model;
        var model = modelDetail.manager;
        var setValueFrom = function (component, simulatedEvent) {
          return model.getValueFromEvent(simulatedEvent).map(function (value) {
            return model.setValueFrom(component, detail, value);
          });
        };
        return {
          behaviours: derive$1([
            Keying.config({
              mode: &apos;special&apos;,
              onLeft: function (spectrum) {
                return model.onLeft(spectrum, detail);
              },
              onRight: function (spectrum) {
                return model.onRight(spectrum, detail);
              },
              onUp: function (spectrum) {
                return model.onUp(spectrum, detail);
              },
              onDown: function (spectrum) {
                return model.onDown(spectrum, detail);
              }
            }),
            Focusing.config({})
          ]),
          events: derive([
            run(touchstart(), setValueFrom),
            run(touchmove(), setValueFrom),
            run(mousedown(), setValueFrom),
            run(mousemove(), function (spectrum, se) {
              if (detail.mouseIsDown.get()) {
                setValueFrom(spectrum, se);
              }
            })
          ])
        };
      }
    });
    var SliderParts = [
      labelPart,
      ledgePart,
      redgePart,
      tedgePart,
      bedgePart,
      tlEdgePart,
      trEdgePart,
      blEdgePart,
      brEdgePart,
      thumbPart,
      spectrumPart
    ];

    var _sliderChangeEvent = &apos;slider.change.value&apos;;
    var sliderChangeEvent = constant(_sliderChangeEvent);
    var isTouchEvent = function (evt) {
      return evt.type.indexOf(&apos;touch&apos;) !== -1;
    };
    var getEventSource = function (simulatedEvent) {
      var evt = simulatedEvent.event().raw();
      if (isTouchEvent(evt)) {
        var touchEvent = evt;
        return touchEvent.touches !== undefined &amp;&amp; touchEvent.touches.length === 1 ? Option.some(touchEvent.touches[0]).map(function (t) {
          return Position(t.clientX, t.clientY);
        }) : Option.none();
      } else {
        var mouseEvent = evt;
        return mouseEvent.clientX !== undefined ? Option.some(mouseEvent).map(function (me) {
          return Position(me.clientX, me.clientY);
        }) : Option.none();
      }
    };

    var t = &apos;top&apos;, r$1 = &apos;right&apos;, b = &apos;bottom&apos;, l = &apos;left&apos;;
    var minX = function (detail) {
      return detail.model.minX;
    };
    var minY = function (detail) {
      return detail.model.minY;
    };
    var min1X = function (detail) {
      return detail.model.minX - 1;
    };
    var min1Y = function (detail) {
      return detail.model.minY - 1;
    };
    var maxX = function (detail) {
      return detail.model.maxX;
    };
    var maxY = function (detail) {
      return detail.model.maxY;
    };
    var max1X = function (detail) {
      return detail.model.maxX + 1;
    };
    var max1Y = function (detail) {
      return detail.model.maxY + 1;
    };
    var range$2 = function (detail, max, min) {
      return max(detail) - min(detail);
    };
    var xRange = function (detail) {
      return range$2(detail, maxX, minX);
    };
    var yRange = function (detail) {
      return range$2(detail, maxY, minY);
    };
    var halfX = function (detail) {
      return xRange(detail) / 2;
    };
    var halfY = function (detail) {
      return yRange(detail) / 2;
    };
    var step = function (detail) {
      return detail.stepSize;
    };
    var snap = function (detail) {
      return detail.snapToGrid;
    };
    var snapStart = function (detail) {
      return detail.snapStart;
    };
    var rounded = function (detail) {
      return detail.rounded;
    };
    var hasEdge = function (detail, edgeName) {
      return detail[edgeName + &apos;-edge&apos;] !== undefined;
    };
    var hasLEdge = function (detail) {
      return hasEdge(detail, l);
    };
    var hasREdge = function (detail) {
      return hasEdge(detail, r$1);
    };
    var hasTEdge = function (detail) {
      return hasEdge(detail, t);
    };
    var hasBEdge = function (detail) {
      return hasEdge(detail, b);
    };
    var currentValue = function (detail) {
      return detail.model.value.get();
    };

    var xValue = function (x) {
      return { x: constant(x) };
    };
    var yValue = function (y) {
      return { y: constant(y) };
    };
    var xyValue = function (x, y) {
      return {
        x: constant(x),
        y: constant(y)
      };
    };
    var fireSliderChange = function (component, value) {
      emitWith(component, sliderChangeEvent(), { value: value });
    };
    var setToTLEdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(min1X(detail), min1Y(detail)));
    };
    var setToTEdge = function (edge, detail) {
      fireSliderChange(edge, yValue(min1Y(detail)));
    };
    var setToTEdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(halfX(detail), min1Y(detail)));
    };
    var setToTREdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(max1X(detail), min1Y(detail)));
    };
    var setToREdge = function (edge, detail) {
      fireSliderChange(edge, xValue(max1X(detail)));
    };
    var setToREdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(max1X(detail), halfY(detail)));
    };
    var setToBREdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(max1X(detail), max1Y(detail)));
    };
    var setToBEdge = function (edge, detail) {
      fireSliderChange(edge, yValue(max1Y(detail)));
    };
    var setToBEdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(halfX(detail), max1Y(detail)));
    };
    var setToBLEdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(min1X(detail), max1Y(detail)));
    };
    var setToLEdge = function (edge, detail) {
      fireSliderChange(edge, xValue(min1X(detail)));
    };
    var setToLEdgeXY = function (edge, detail) {
      fireSliderChange(edge, xyValue(min1X(detail), halfY(detail)));
    };

    var reduceBy = function (value, min, max, step) {
      if (value &lt; min) {
        return value;
      } else if (value &gt; max) {
        return max;
      } else if (value === min) {
        return min - 1;
      } else {
        return Math.max(min, value - step);
      }
    };
    var increaseBy = function (value, min, max, step) {
      if (value &gt; max) {
        return value;
      } else if (value &lt; min) {
        return min;
      } else if (value === max) {
        return max + 1;
      } else {
        return Math.min(max, value + step);
      }
    };
    var capValue = function (value, min, max) {
      return Math.max(min, Math.min(max, value));
    };
    var snapValueOf = function (value, min, max, step, snapStart) {
      return snapStart.fold(function () {
        var initValue = value - min;
        var extraValue = Math.round(initValue / step) * step;
        return capValue(min + extraValue, min - 1, max + 1);
      }, function (start) {
        var remainder = (value - start) % step;
        var adjustment = Math.round(remainder / step);
        var rawSteps = Math.floor((value - start) / step);
        var maxSteps = Math.floor((max - start) / step);
        var numSteps = Math.min(maxSteps, rawSteps + adjustment);
        var r = start + numSteps * step;
        return Math.max(start, r);
      });
    };
    var findOffsetOf = function (value, min, max) {
      return Math.min(max, Math.max(value, min)) - min;
    };
    var findValueOf = function (args) {
      var min = args.min, max = args.max, range = args.range, value = args.value, step = args.step, snap = args.snap, snapStart = args.snapStart, rounded = args.rounded, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, minBound = args.minBound, maxBound = args.maxBound, screenRange = args.screenRange;
      var capMin = hasMinEdge ? min - 1 : min;
      var capMax = hasMaxEdge ? max + 1 : max;
      if (value &lt; minBound) {
        return capMin;
      } else if (value &gt; maxBound) {
        return capMax;
      } else {
        var offset = findOffsetOf(value, minBound, maxBound);
        var newValue = capValue(offset / screenRange * range + min, capMin, capMax);
        if (snap &amp;&amp; newValue &gt;= min &amp;&amp; newValue &lt;= max) {
          return snapValueOf(newValue, min, max, step, snapStart);
        } else if (rounded) {
          return Math.round(newValue);
        } else {
          return newValue;
        }
      }
    };
    var findOffsetOfValue = function (args) {
      var min = args.min, max = args.max, range = args.range, value = args.value, hasMinEdge = args.hasMinEdge, hasMaxEdge = args.hasMaxEdge, maxBound = args.maxBound, maxOffset = args.maxOffset, centerMinEdge = args.centerMinEdge, centerMaxEdge = args.centerMaxEdge;
      if (value &lt; min) {
        return hasMinEdge ? 0 : centerMinEdge;
      } else if (value &gt; max) {
        return hasMaxEdge ? maxBound : centerMaxEdge;
      } else {
        return (value - min) / range * maxOffset;
      }
    };

    var top = &apos;top&apos;, right = &apos;right&apos;, bottom = &apos;bottom&apos;, left = &apos;left&apos;, width = &apos;width&apos;, height = &apos;height&apos;;
    var getBounds$1 = function (component) {
      return component.element().dom().getBoundingClientRect();
    };
    var getBoundsProperty = function (bounds, property) {
      return bounds[property];
    };
    var getMinXBounds = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, left);
    };
    var getMaxXBounds = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, right);
    };
    var getMinYBounds = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, top);
    };
    var getMaxYBounds = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, bottom);
    };
    var getXScreenRange = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, width);
    };
    var getYScreenRange = function (component) {
      var bounds = getBounds$1(component);
      return getBoundsProperty(bounds, height);
    };
    var getCenterOffsetOf = function (componentMinEdge, componentMaxEdge, spectrumMinEdge) {
      return (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
    };
    var getXCenterOffSetOf = function (component, spectrum) {
      var componentBounds = getBounds$1(component);
      var spectrumBounds = getBounds$1(spectrum);
      var componentMinEdge = getBoundsProperty(componentBounds, left);
      var componentMaxEdge = getBoundsProperty(componentBounds, right);
      var spectrumMinEdge = getBoundsProperty(spectrumBounds, left);
      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };
    var getYCenterOffSetOf = function (component, spectrum) {
      var componentBounds = getBounds$1(component);
      var spectrumBounds = getBounds$1(spectrum);
      var componentMinEdge = getBoundsProperty(componentBounds, top);
      var componentMaxEdge = getBoundsProperty(componentBounds, bottom);
      var spectrumMinEdge = getBoundsProperty(spectrumBounds, top);
      return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
    };

    var fireSliderChange$1 = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue = function (x) {
      return { x: constant(x) };
    };
    var findValueOfOffset = function (spectrum, detail, left) {
      var args = {
        min: minX(detail),
        max: maxX(detail),
        range: xRange(detail),
        value: left,
        step: step(detail),
        snap: snap(detail),
        snapStart: snapStart(detail),
        rounded: rounded(detail),
        hasMinEdge: hasLEdge(detail),
        hasMaxEdge: hasREdge(detail),
        minBound: getMinXBounds(spectrum),
        maxBound: getMaxXBounds(spectrum),
        screenRange: getXScreenRange(spectrum)
      };
      return findValueOf(args);
    };
    var setValueFrom = function (spectrum, detail, value) {
      var xValue = findValueOfOffset(spectrum, detail, value);
      var sliderVal = sliderValue(xValue);
      fireSliderChange$1(spectrum, sliderVal);
      return xValue;
    };
    var setToMin = function (spectrum, detail) {
      var min = minX(detail);
      fireSliderChange$1(spectrum, sliderValue(min));
    };
    var setToMax = function (spectrum, detail) {
      var max = maxX(detail);
      fireSliderChange$1(spectrum, sliderValue(max));
    };
    var moveBy = function (direction, spectrum, detail) {
      var f = direction &gt; 0 ? increaseBy : reduceBy;
      var xValue = f(currentValue(detail).x(), minX(detail), maxX(detail), step(detail));
      fireSliderChange$1(spectrum, sliderValue(xValue));
      return Option.some(xValue);
    };
    var handleMovement = function (direction) {
      return function (spectrum, detail) {
        return moveBy(direction, spectrum, detail).map(function () {
          return true;
        });
      };
    };
    var getValueFromEvent = function (simulatedEvent) {
      var pos = getEventSource(simulatedEvent);
      return pos.map(function (p) {
        return p.left();
      });
    };
    var findOffsetOfValue$1 = function (spectrum, detail, value, minEdge, maxEdge) {
      var minOffset = 0;
      var maxOffset = getXScreenRange(spectrum);
      var centerMinEdge = minEdge.bind(function (edge) {
        return Option.some(getXCenterOffSetOf(edge, spectrum));
      }).getOr(minOffset);
      var centerMaxEdge = maxEdge.bind(function (edge) {
        return Option.some(getXCenterOffSetOf(edge, spectrum));
      }).getOr(maxOffset);
      var args = {
        min: minX(detail),
        max: maxX(detail),
        range: xRange(detail),
        value: value,
        hasMinEdge: hasLEdge(detail),
        hasMaxEdge: hasREdge(detail),
        minBound: getMinXBounds(spectrum),
        minOffset: minOffset,
        maxBound: getMaxXBounds(spectrum),
        maxOffset: maxOffset,
        centerMinEdge: centerMinEdge,
        centerMaxEdge: centerMaxEdge
      };
      return findOffsetOfValue(args);
    };
    var findPositionOfValue = function (slider, spectrum, value, minEdge, maxEdge, detail) {
      var offset = findOffsetOfValue$1(spectrum, detail, value, minEdge, maxEdge);
      return getMinXBounds(spectrum) - getMinXBounds(slider) + offset;
    };
    var setPositionFromValue = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var pos = findPositionOfValue(slider, edges.getSpectrum(slider), value.x(), edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
      var thumbRadius = get$7(thumb.element()) / 2;
      set$2(thumb.element(), &apos;left&apos;, pos - thumbRadius + &apos;px&apos;);
    };
    var onLeft = handleMovement(-1);
    var onRight = handleMovement(1);
    var onUp = Option.none;
    var onDown = Option.none;
    var edgeActions = {
      &apos;top-left&apos;: Option.none(),
      &apos;top&apos;: Option.none(),
      &apos;top-right&apos;: Option.none(),
      &apos;right&apos;: Option.some(setToREdge),
      &apos;bottom-right&apos;: Option.none(),
      &apos;bottom&apos;: Option.none(),
      &apos;bottom-left&apos;: Option.none(),
      &apos;left&apos;: Option.some(setToLEdge)
    };

    var HorizontalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom,
        setToMin: setToMin,
        setToMax: setToMax,
        findValueOfOffset: findValueOfOffset,
        getValueFromEvent: getValueFromEvent,
        findPositionOfValue: findPositionOfValue,
        setPositionFromValue: setPositionFromValue,
        onLeft: onLeft,
        onRight: onRight,
        onUp: onUp,
        onDown: onDown,
        edgeActions: edgeActions
    });

    var fireSliderChange$2 = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue$1 = function (y) {
      return { y: constant(y) };
    };
    var findValueOfOffset$1 = function (spectrum, detail, top) {
      var args = {
        min: minY(detail),
        max: maxY(detail),
        range: yRange(detail),
        value: top,
        step: step(detail),
        snap: snap(detail),
        snapStart: snapStart(detail),
        rounded: rounded(detail),
        hasMinEdge: hasTEdge(detail),
        hasMaxEdge: hasBEdge(detail),
        minBound: getMinYBounds(spectrum),
        maxBound: getMaxYBounds(spectrum),
        screenRange: getYScreenRange(spectrum)
      };
      return findValueOf(args);
    };
    var setValueFrom$1 = function (spectrum, detail, value) {
      var yValue = findValueOfOffset$1(spectrum, detail, value);
      var sliderVal = sliderValue$1(yValue);
      fireSliderChange$2(spectrum, sliderVal);
      return yValue;
    };
    var setToMin$1 = function (spectrum, detail) {
      var min = minY(detail);
      fireSliderChange$2(spectrum, sliderValue$1(min));
    };
    var setToMax$1 = function (spectrum, detail) {
      var max = maxY(detail);
      fireSliderChange$2(spectrum, sliderValue$1(max));
    };
    var moveBy$1 = function (direction, spectrum, detail) {
      var f = direction &gt; 0 ? increaseBy : reduceBy;
      var yValue = f(currentValue(detail).y(), minY(detail), maxY(detail), step(detail));
      fireSliderChange$2(spectrum, sliderValue$1(yValue));
      return Option.some(yValue);
    };
    var handleMovement$1 = function (direction) {
      return function (spectrum, detail) {
        return moveBy$1(direction, spectrum, detail).map(function () {
          return true;
        });
      };
    };
    var getValueFromEvent$1 = function (simulatedEvent) {
      var pos = getEventSource(simulatedEvent);
      return pos.map(function (p) {
        return p.top();
      });
    };
    var findOffsetOfValue$2 = function (spectrum, detail, value, minEdge, maxEdge) {
      var minOffset = 0;
      var maxOffset = getYScreenRange(spectrum);
      var centerMinEdge = minEdge.bind(function (edge) {
        return Option.some(getYCenterOffSetOf(edge, spectrum));
      }).getOr(minOffset);
      var centerMaxEdge = maxEdge.bind(function (edge) {
        return Option.some(getYCenterOffSetOf(edge, spectrum));
      }).getOr(maxOffset);
      var args = {
        min: minY(detail),
        max: maxY(detail),
        range: yRange(detail),
        value: value,
        hasMinEdge: hasTEdge(detail),
        hasMaxEdge: hasBEdge(detail),
        minBound: getMinYBounds(spectrum),
        minOffset: minOffset,
        maxBound: getMaxYBounds(spectrum),
        maxOffset: maxOffset,
        centerMinEdge: centerMinEdge,
        centerMaxEdge: centerMaxEdge
      };
      return findOffsetOfValue(args);
    };
    var findPositionOfValue$1 = function (slider, spectrum, value, minEdge, maxEdge, detail) {
      var offset = findOffsetOfValue$2(spectrum, detail, value, minEdge, maxEdge);
      return getMinYBounds(spectrum) - getMinYBounds(slider) + offset;
    };
    var setPositionFromValue$1 = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.y(), edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
      var thumbRadius = get$6(thumb.element()) / 2;
      set$2(thumb.element(), &apos;top&apos;, pos - thumbRadius + &apos;px&apos;);
    };
    var onLeft$1 = Option.none;
    var onRight$1 = Option.none;
    var onUp$1 = handleMovement$1(-1);
    var onDown$1 = handleMovement$1(1);
    var edgeActions$1 = {
      &apos;top-left&apos;: Option.none(),
      &apos;top&apos;: Option.some(setToTEdge),
      &apos;top-right&apos;: Option.none(),
      &apos;right&apos;: Option.none(),
      &apos;bottom-right&apos;: Option.none(),
      &apos;bottom&apos;: Option.some(setToBEdge),
      &apos;bottom-left&apos;: Option.none(),
      &apos;left&apos;: Option.none()
    };

    var VerticalModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$1,
        setToMin: setToMin$1,
        setToMax: setToMax$1,
        findValueOfOffset: findValueOfOffset$1,
        getValueFromEvent: getValueFromEvent$1,
        findPositionOfValue: findPositionOfValue$1,
        setPositionFromValue: setPositionFromValue$1,
        onLeft: onLeft$1,
        onRight: onRight$1,
        onUp: onUp$1,
        onDown: onDown$1,
        edgeActions: edgeActions$1
    });

    var fireSliderChange$3 = function (spectrum, value) {
      emitWith(spectrum, sliderChangeEvent(), { value: value });
    };
    var sliderValue$2 = function (x, y) {
      return {
        x: constant(x),
        y: constant(y)
      };
    };
    var setValueFrom$2 = function (spectrum, detail, value) {
      var xValue = findValueOfOffset(spectrum, detail, value.left());
      var yValue = findValueOfOffset$1(spectrum, detail, value.top());
      var val = sliderValue$2(xValue, yValue);
      fireSliderChange$3(spectrum, val);
      return val;
    };
    var moveBy$2 = function (direction, isVerticalMovement, spectrum, detail) {
      var f = direction &gt; 0 ? increaseBy : reduceBy;
      var xValue = isVerticalMovement ? currentValue(detail).x() : f(currentValue(detail).x(), minX(detail), maxX(detail), step(detail));
      var yValue = !isVerticalMovement ? currentValue(detail).y() : f(currentValue(detail).y(), minY(detail), maxY(detail), step(detail));
      fireSliderChange$3(spectrum, sliderValue$2(xValue, yValue));
      return Option.some(xValue);
    };
    var handleMovement$2 = function (direction, isVerticalMovement) {
      return function (spectrum, detail) {
        return moveBy$2(direction, isVerticalMovement, spectrum, detail).map(function () {
          return true;
        });
      };
    };
    var setToMin$2 = function (spectrum, detail) {
      var mX = minX(detail);
      var mY = minY(detail);
      fireSliderChange$3(spectrum, sliderValue$2(mX, mY));
    };
    var setToMax$2 = function (spectrum, detail) {
      var mX = maxX(detail);
      var mY = maxY(detail);
      fireSliderChange$3(spectrum, sliderValue$2(mX, mY));
    };
    var getValueFromEvent$2 = function (simulatedEvent) {
      return getEventSource(simulatedEvent);
    };
    var setPositionFromValue$2 = function (slider, thumb, detail, edges) {
      var value = currentValue(detail);
      var xPos = findPositionOfValue(slider, edges.getSpectrum(slider), value.x(), edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
      var yPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value.y(), edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
      var thumbXRadius = get$7(thumb.element()) / 2;
      var thumbYRadius = get$6(thumb.element()) / 2;
      set$2(thumb.element(), &apos;left&apos;, xPos - thumbXRadius + &apos;px&apos;);
      set$2(thumb.element(), &apos;top&apos;, yPos - thumbYRadius + &apos;px&apos;);
    };
    var onLeft$2 = handleMovement$2(-1, false);
    var onRight$2 = handleMovement$2(1, false);
    var onUp$2 = handleMovement$2(-1, true);
    var onDown$2 = handleMovement$2(1, true);
    var edgeActions$2 = {
      &apos;top-left&apos;: Option.some(setToTLEdgeXY),
      &apos;top&apos;: Option.some(setToTEdgeXY),
      &apos;top-right&apos;: Option.some(setToTREdgeXY),
      &apos;right&apos;: Option.some(setToREdgeXY),
      &apos;bottom-right&apos;: Option.some(setToBREdgeXY),
      &apos;bottom&apos;: Option.some(setToBEdgeXY),
      &apos;bottom-left&apos;: Option.some(setToBLEdgeXY),
      &apos;left&apos;: Option.some(setToLEdgeXY)
    };

    var TwoDModel = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setValueFrom: setValueFrom$2,
        setToMin: setToMin$2,
        setToMax: setToMax$2,
        getValueFromEvent: getValueFromEvent$2,
        setPositionFromValue: setPositionFromValue$2,
        onLeft: onLeft$2,
        onRight: onRight$2,
        onUp: onUp$2,
        onDown: onDown$2,
        edgeActions: edgeActions$2
    });

    var SliderSchema = [
      defaulted$1(&apos;stepSize&apos;, 1),
      defaulted$1(&apos;onChange&apos;, noop),
      defaulted$1(&apos;onChoose&apos;, noop),
      defaulted$1(&apos;onInit&apos;, noop),
      defaulted$1(&apos;onDragStart&apos;, noop),
      defaulted$1(&apos;onDragEnd&apos;, noop),
      defaulted$1(&apos;snapToGrid&apos;, false),
      defaulted$1(&apos;rounded&apos;, true),
      option(&apos;snapStart&apos;),
      strictOf(&apos;model&apos;, choose$1(&apos;mode&apos;, {
        x: [
          defaulted$1(&apos;minX&apos;, 0),
          defaulted$1(&apos;maxX&apos;, 100),
          state$1(&apos;value&apos;, function (spec) {
            return Cell(spec.mode.minX);
          }),
          strict$1(&apos;getInitialValue&apos;),
          output(&apos;manager&apos;, HorizontalModel)
        ],
        y: [
          defaulted$1(&apos;minY&apos;, 0),
          defaulted$1(&apos;maxY&apos;, 100),
          state$1(&apos;value&apos;, function (spec) {
            return Cell(spec.mode.minY);
          }),
          strict$1(&apos;getInitialValue&apos;),
          output(&apos;manager&apos;, VerticalModel)
        ],
        xy: [
          defaulted$1(&apos;minX&apos;, 0),
          defaulted$1(&apos;maxX&apos;, 100),
          defaulted$1(&apos;minY&apos;, 0),
          defaulted$1(&apos;maxY&apos;, 100),
          state$1(&apos;value&apos;, function (spec) {
            return Cell({
              x: constant(spec.mode.minX),
              y: constant(spec.mode.minY)
            });
          }),
          strict$1(&apos;getInitialValue&apos;),
          output(&apos;manager&apos;, TwoDModel)
        ]
      })),
      field$1(&apos;sliderBehaviours&apos;, [
        Keying,
        Representing
      ]),
      state$1(&apos;mouseIsDown&apos;, function () {
        return Cell(false);
      })
    ];

    var sketch = function (detail, components, _spec, _externals) {
      var _a;
      var getThumb = function (component) {
        return getPartOrDie(component, detail, &apos;thumb&apos;);
      };
      var getSpectrum = function (component) {
        return getPartOrDie(component, detail, &apos;spectrum&apos;);
      };
      var getLeftEdge = function (component) {
        return getPart(component, detail, &apos;left-edge&apos;);
      };
      var getRightEdge = function (component) {
        return getPart(component, detail, &apos;right-edge&apos;);
      };
      var getTopEdge = function (component) {
        return getPart(component, detail, &apos;top-edge&apos;);
      };
      var getBottomEdge = function (component) {
        return getPart(component, detail, &apos;bottom-edge&apos;);
      };
      var modelDetail = detail.model;
      var model = modelDetail.manager;
      var refresh = function (slider, thumb) {
        model.setPositionFromValue(slider, thumb, detail, {
          getLeftEdge: getLeftEdge,
          getRightEdge: getRightEdge,
          getTopEdge: getTopEdge,
          getBottomEdge: getBottomEdge,
          getSpectrum: getSpectrum
        });
      };
      var changeValue = function (slider, newValue) {
        modelDetail.value.set(newValue);
        var thumb = getThumb(slider);
        refresh(slider, thumb);
        detail.onChange(slider, thumb, newValue);
        return Option.some(true);
      };
      var resetToMin = function (slider) {
        model.setToMin(slider, detail);
      };
      var resetToMax = function (slider) {
        model.setToMax(slider, detail);
      };
      var choose = function (slider) {
        var fireOnChoose = function () {
          getPart(slider, detail, &apos;thumb&apos;).each(function (thumb) {
            var value = modelDetail.value.get();
            detail.onChoose(slider, thumb, value);
          });
        };
        var wasDown = detail.mouseIsDown.get();
        detail.mouseIsDown.set(false);
        if (wasDown) {
          fireOnChoose();
        }
      };
      var onDragStart = function (slider, simulatedEvent) {
        simulatedEvent.stop();
        detail.mouseIsDown.set(true);
        detail.onDragStart(slider, getThumb(slider));
      };
      var onDragEnd = function (slider, simulatedEvent) {
        simulatedEvent.stop();
        detail.onDragEnd(slider, getThumb(slider));
        choose(slider);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.sliderBehaviours, [
          Keying.config({
            mode: &apos;special&apos;,
            focusIn: function (slider) {
              return getPart(slider, detail, &apos;spectrum&apos;).map(Keying.focusIn).map(constant(true));
            }
          }),
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function (_) {
                return modelDetail.value.get();
              }
            }
          }),
          Receiving.config({ channels: (_a = {}, _a[mouseReleased()] = { onReceive: choose }, _a) })
        ]),
        events: derive([
          run(sliderChangeEvent(), function (slider, simulatedEvent) {
            changeValue(slider, simulatedEvent.event().value());
          }),
          runOnAttached(function (slider, _simulatedEvent) {
            var getInitial = modelDetail.getInitialValue();
            modelDetail.value.set(getInitial);
            var thumb = getThumb(slider);
            refresh(slider, thumb);
            var spectrum = getSpectrum(slider);
            detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
          }),
          run(touchstart(), onDragStart),
          run(touchend(), onDragEnd),
          run(mousedown(), onDragStart),
          run(mouseup(), onDragEnd)
        ]),
        apis: {
          resetToMin: resetToMin,
          resetToMax: resetToMax,
          changeValue: changeValue,
          refresh: refresh
        },
        domModification: { styles: { position: &apos;relative&apos; } }
      };
    };

    var Slider = composite$1({
      name: &apos;Slider&apos;,
      configFields: SliderSchema,
      partFields: SliderParts,
      factory: sketch,
      apis: {
        resetToMin: function (apis, slider) {
          apis.resetToMin(slider);
        },
        resetToMax: function (apis, slider) {
          apis.resetToMax(slider);
        },
        refresh: function (apis, slider) {
          apis.refresh(slider);
        }
      }
    });

    var sliderFactory = function (translate, getClass) {
      var spectrum = Slider.parts().spectrum({
        dom: {
          tag: &apos;div&apos;,
          classes: [getClass(&apos;hue-slider-spectrum&apos;)],
          attributes: { role: &apos;presentation&apos; }
        }
      });
      var thumb = Slider.parts().thumb({
        dom: {
          tag: &apos;div&apos;,
          classes: [getClass(&apos;hue-slider-thumb&apos;)],
          attributes: { role: &apos;presentation&apos; }
        }
      });
      return Slider.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [getClass(&apos;hue-slider&apos;)],
          attributes: { role: &apos;presentation&apos; }
        },
        rounded: false,
        model: {
          mode: &apos;y&apos;,
          getInitialValue: constant({ y: constant(0) })
        },
        components: [
          spectrum,
          thumb
        ],
        sliderBehaviours: derive$1([Focusing.config({})]),
        onChange: function (slider, _thumb, value) {
          emitWith(slider, sliderUpdate, { value: value });
        }
      });
    };

    var owner$3 = &apos;form&apos;;
    var schema$h = [field$1(&apos;formBehaviours&apos;, [Representing])];
    var getPartName = function (name) {
      return &apos;&lt;alloy.field.&apos; + name + &apos;&gt;&apos;;
    };
    var sketch$1 = function (fSpec) {
      var parts = function () {
        var record = [];
        var field = function (name, config) {
          record.push(name);
          return generateOne(owner$3, getPartName(name), config);
        };
        return {
          field: field,
          record: function () {
            return record;
          }
        };
      }();
      var spec = fSpec(parts);
      var partNames = parts.record();
      var fieldParts = map(partNames, function (n) {
        return required({
          name: n,
          pname: getPartName(n)
        });
      });
      return composite(owner$3, schema$h, fieldParts, make$4, spec);
    };
    var toResult$1 = function (o, e) {
      return o.fold(function () {
        return Result.error(e);
      }, Result.value);
    };
    var make$4 = function (detail, components) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.formBehaviours, [Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function (form) {
                var resPs = getAllParts(form, detail);
                return map$1(resPs, function (resPThunk, pName) {
                  return resPThunk().bind(function (v) {
                    var opt = Composing.getCurrent(v);
                    return toResult$1(opt, new Error(&apos;Cannot find a current component to extract the value from for form part \&apos;&apos; + pName + &apos;\&apos;: &apos; + element(v.element())));
                  }).map(Representing.getValue);
                });
              },
              setValue: function (form, values) {
                each$1(values, function (newValue, key) {
                  getPart(form, detail, key).each(function (wrapper) {
                    Composing.getCurrent(wrapper).each(function (field) {
                      Representing.setValue(field, newValue);
                    });
                  });
                });
              }
            }
          })]),
        apis: {
          getField: function (form, key) {
            return getPart(form, detail, key).bind(Composing.getCurrent);
          }
        }
      };
    };
    var Form = {
      getField: makeApi(function (apis, component, key) {
        return apis.getField(component, key);
      }),
      sketch: sketch$1
    };

    var validInput = generate$1(&apos;valid-input&apos;);
    var invalidInput = generate$1(&apos;invalid-input&apos;);
    var validatingInput = generate$1(&apos;validating-input&apos;);
    var translatePrefix = &apos;colorcustom.rgb.&apos;;
    var rgbFormFactory = function (translate, getClass, onValidHexx, onInvalidHexx) {
      var invalidation = function (label, isValid) {
        return Invalidating.config({
          invalidClass: getClass(&apos;invalid&apos;),
          notify: {
            onValidate: function (comp) {
              emitWith(comp, validatingInput, { type: label });
            },
            onValid: function (comp) {
              emitWith(comp, validInput, {
                type: label,
                value: Representing.getValue(comp)
              });
            },
            onInvalid: function (comp) {
              emitWith(comp, invalidInput, {
                type: label,
                value: Representing.getValue(comp)
              });
            }
          },
          validator: {
            validate: function (comp) {
              var value = Representing.getValue(comp);
              var res = isValid(value) ? Result.value(true) : Result.error(translate(&apos;aria.input.invalid&apos;));
              return Future.pure(res);
            },
            validateOnLoad: false
          }
        });
      };
      var renderTextField = function (isValid, name, label, description, data) {
        var helptext = translate(translatePrefix + &apos;range&apos;);
        var pLabel = FormField.parts().label({
          dom: {
            tag: &apos;label&apos;,
            innerHtml: label,
            attributes: { &apos;aria-label&apos;: description }
          }
        });
        var pField = FormField.parts().field({
          data: data,
          factory: Input,
          inputAttributes: __assign({ type: &apos;text&apos; }, name === &apos;hex&apos; ? { &apos;aria-live&apos;: &apos;polite&apos; } : {}),
          inputClasses: [getClass(&apos;textfield&apos;)],
          inputBehaviours: derive$1([
            invalidation(name, isValid),
            Tabstopping.config({})
          ]),
          onSetValue: function (input) {
            if (Invalidating.isInvalid(input)) {
              var run = Invalidating.run(input);
              run.get(noop);
            }
          }
        });
        var comps = [
          pLabel,
          pField
        ];
        var concats = name !== &apos;hex&apos; ? [FormField.parts()[&apos;aria-descriptor&apos;]({ text: helptext })] : [];
        var components = comps.concat(concats);
        return {
          dom: {
            tag: &apos;div&apos;,
            attributes: { role: &apos;presentation&apos; }
          },
          components: components
        };
      };
      var copyRgbToHex = function (form, rgba) {
        var hex = fromRgba(rgba);
        Form.getField(form, &apos;hex&apos;).each(function (hexField) {
          if (!Focusing.isFocused(hexField)) {
            Representing.setValue(form, { hex: hex.value });
          }
        });
        return hex;
      };
      var copyRgbToForm = function (form, rgb) {
        var red = rgb.red;
        var green = rgb.green;
        var blue = rgb.blue;
        Representing.setValue(form, {
          red: red,
          green: green,
          blue: blue
        });
      };
      var memPreview = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [getClass(&apos;rgba-preview&apos;)],
          styles: { &apos;background-color&apos;: &apos;white&apos; },
          attributes: { role: &apos;presentation&apos; }
        }
      });
      var updatePreview = function (anyInSystem, hex) {
        memPreview.getOpt(anyInSystem).each(function (preview) {
          set$2(preview.element(), &apos;background-color&apos;, &apos;#&apos; + hex.value);
        });
      };
      var factory = function () {
        var state = {
          red: Cell(Option.some(255)),
          green: Cell(Option.some(255)),
          blue: Cell(Option.some(255)),
          hex: Cell(Option.some(&apos;ffffff&apos;))
        };
        var copyHexToRgb = function (form, hex) {
          var rgb = fromHex(hex);
          copyRgbToForm(form, rgb);
          setValueRgb(rgb);
        };
        var get = function (prop) {
          return state[prop].get();
        };
        var set = function (prop, value) {
          state[prop].set(value);
        };
        var getValueRgb = function () {
          return get(&apos;red&apos;).bind(function (red) {
            return get(&apos;green&apos;).bind(function (green) {
              return get(&apos;blue&apos;).map(function (blue) {
                return rgbaColour(red, green, blue, 1);
              });
            });
          });
        };
        var setValueRgb = function (rgb) {
          var red = rgb.red;
          var green = rgb.green;
          var blue = rgb.blue;
          set(&apos;red&apos;, Option.some(red));
          set(&apos;green&apos;, Option.some(green));
          set(&apos;blue&apos;, Option.some(blue));
        };
        var onInvalidInput = function (form, simulatedEvent) {
          var data = simulatedEvent.event();
          if (data.type() !== &apos;hex&apos;) {
            set(data.type(), Option.none());
          } else {
            onInvalidHexx(form);
          }
        };
        var onValidHex = function (form, value) {
          onValidHexx(form);
          var hex = hexColour(value);
          set(&apos;hex&apos;, Option.some(value));
          var rgb = fromHex(hex);
          copyRgbToForm(form, rgb);
          setValueRgb(rgb);
          emitWith(form, fieldsUpdate, { hex: hex });
          updatePreview(form, hex);
        };
        var onValidRgb = function (form, prop, value) {
          var val = parseInt(value, 10);
          set(prop, Option.some(val));
          getValueRgb().each(function (rgb) {
            var hex = copyRgbToHex(form, rgb);
            updatePreview(form, hex);
          });
        };
        var isHexInputEvent = function (data) {
          return data.type() === &apos;hex&apos;;
        };
        var onValidInput = function (form, simulatedEvent) {
          var data = simulatedEvent.event();
          if (isHexInputEvent(data)) {
            onValidHex(form, data.value());
          } else {
            onValidRgb(form, data.type(), data.value());
          }
        };
        var formPartStrings = function (key) {
          return {
            label: translate(translatePrefix + key + &apos;.label&apos;),
            description: translate(translatePrefix + key + &apos;.description&apos;)
          };
        };
        var redStrings = formPartStrings(&apos;red&apos;);
        var greenStrings = formPartStrings(&apos;green&apos;);
        var blueStrings = formPartStrings(&apos;blue&apos;);
        var hexStrings = formPartStrings(&apos;hex&apos;);
        return deepMerge(Form.sketch(function (parts) {
          return {
            dom: {
              tag: &apos;form&apos;,
              classes: [getClass(&apos;rgb-form&apos;)],
              attributes: { &apos;aria-label&apos;: translate(&apos;aria.color.picker&apos;) }
            },
            components: [
              parts.field(&apos;red&apos;, FormField.sketch(renderTextField(isRgbaComponent, &apos;red&apos;, redStrings.label, redStrings.description, 255))),
              parts.field(&apos;green&apos;, FormField.sketch(renderTextField(isRgbaComponent, &apos;green&apos;, greenStrings.label, greenStrings.description, 255))),
              parts.field(&apos;blue&apos;, FormField.sketch(renderTextField(isRgbaComponent, &apos;blue&apos;, blueStrings.label, blueStrings.description, 255))),
              parts.field(&apos;hex&apos;, FormField.sketch(renderTextField(isHexString, &apos;hex&apos;, hexStrings.label, hexStrings.description, &apos;ffffff&apos;))),
              memPreview.asSpec()
            ],
            formBehaviours: derive$1([
              Invalidating.config({ invalidClass: getClass(&apos;form-invalid&apos;) }),
              config(&apos;rgb-form-events&apos;, [
                run(validInput, onValidInput),
                run(invalidInput, onInvalidInput),
                run(validatingInput, onInvalidInput)
              ])
            ])
          };
        }), {
          apis: {
            updateHex: function (form, hex) {
              Representing.setValue(form, { hex: hex.value });
              copyHexToRgb(form, hex);
              updatePreview(form, hex);
            }
          }
        });
      };
      var rgbFormSketcher = single$2({
        factory: factory,
        name: &apos;RgbForm&apos;,
        configFields: [],
        apis: {
          updateHex: function (apis, form, hex) {
            apis.updateHex(form, hex);
          }
        },
        extraApis: {}
      });
      return rgbFormSketcher;
    };

    var paletteFactory = function (_translate, getClass) {
      var spectrumPart = Slider.parts().spectrum({
        dom: {
          tag: &apos;canvas&apos;,
          attributes: { role: &apos;presentation&apos; },
          classes: [getClass(&apos;sv-palette-spectrum&apos;)]
        }
      });
      var thumbPart = Slider.parts().thumb({
        dom: {
          tag: &apos;div&apos;,
          attributes: { role: &apos;presentation&apos; },
          classes: [getClass(&apos;sv-palette-thumb&apos;)],
          innerHtml: &apos;&lt;div class=&apos; + getClass(&apos;sv-palette-inner-thumb&apos;) + &apos; role=&quot;presentation&quot;&gt;&lt;/div&gt;&apos;
        }
      });
      var setColour = function (canvas, rgba) {
        var width = canvas.width, height = canvas.height;
        var ctx = canvas.getContext(&apos;2d&apos;);
        if (ctx === null) {
          return;
        }
        ctx.fillStyle = rgba;
        ctx.fillRect(0, 0, width, height);
        var grdWhite = ctx.createLinearGradient(0, 0, width, 0);
        grdWhite.addColorStop(0, &apos;rgba(255,255,255,1)&apos;);
        grdWhite.addColorStop(1, &apos;rgba(255,255,255,0)&apos;);
        ctx.fillStyle = grdWhite;
        ctx.fillRect(0, 0, width, height);
        var grdBlack = ctx.createLinearGradient(0, 0, 0, height);
        grdBlack.addColorStop(0, &apos;rgba(0,0,0,0)&apos;);
        grdBlack.addColorStop(1, &apos;rgba(0,0,0,1)&apos;);
        ctx.fillStyle = grdBlack;
        ctx.fillRect(0, 0, width, height);
      };
      var setSliderColour = function (slider, rgba) {
        var canvas = slider.components()[0].element().dom();
        setColour(canvas, toString(rgba));
      };
      var factory = function (_detail) {
        var getInitialValue = constant({
          x: constant(0),
          y: constant(0)
        });
        var onChange = function (slider, _thumb, value) {
          emitWith(slider, paletteUpdate, { value: value });
        };
        var onInit = function (_slider, _thumb, spectrum, _value) {
          setColour(spectrum.element().dom(), toString(red));
        };
        var sliderBehaviours = derive$1([
          Composing.config({ find: Option.some }),
          Focusing.config({})
        ]);
        return Slider.sketch({
          dom: {
            tag: &apos;div&apos;,
            attributes: { role: &apos;presentation&apos; },
            classes: [getClass(&apos;sv-palette&apos;)]
          },
          model: {
            mode: &apos;xy&apos;,
            getInitialValue: getInitialValue
          },
          rounded: false,
          components: [
            spectrumPart,
            thumbPart
          ],
          onChange: onChange,
          onInit: onInit,
          sliderBehaviours: sliderBehaviours
        });
      };
      var saturationBrightnessPaletteSketcher = single$2({
        factory: factory,
        name: &apos;SaturationBrightnessPalette&apos;,
        configFields: [],
        apis: {
          setRgba: function (_apis, slider, rgba) {
            setSliderColour(slider, rgba);
          }
        },
        extraApis: {}
      });
      return saturationBrightnessPaletteSketcher;
    };

    var makeFactory = function (translate, getClass) {
      var factory = function (detail) {
        var rgbForm = rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);
        var sbPalette = paletteFactory(translate, getClass);
        var state = { paletteRgba: Cell(red) };
        var memPalette = record(sbPalette.sketch({}));
        var memRgb = record(rgbForm.sketch({}));
        var updatePalette = function (anyInSystem, hex) {
          memPalette.getOpt(anyInSystem).each(function (palette) {
            var rgba = fromHex(hex);
            state.paletteRgba.set(rgba);
            sbPalette.setRgba(palette, rgba);
          });
        };
        var updateFields = function (anyInSystem, hex) {
          memRgb.getOpt(anyInSystem).each(function (form) {
            rgbForm.updateHex(form, hex);
          });
        };
        var runUpdates = function (anyInSystem, hex, updates) {
          each(updates, function (update) {
            update(anyInSystem, hex);
          });
        };
        var paletteUpdates = function () {
          var updates = [updateFields];
          return function (form, simulatedEvent) {
            var value = simulatedEvent.event().value();
            var oldRgb = state.paletteRgba.get();
            var hsvColour$1 = fromRgb(oldRgb);
            var newHsvColour = hsvColour(hsvColour$1.hue, value.x(), 100 - value.y());
            var rgb = fromHsv(newHsvColour);
            var nuHex = fromRgba(rgb);
            runUpdates(form, nuHex, updates);
          };
        };
        var sliderUpdates = function () {
          var updates = [
            updatePalette,
            updateFields
          ];
          return function (form, simulatedEvent) {
            var value = simulatedEvent.event().value();
            var hex = calcHex(value.y());
            runUpdates(form, hex, updates);
          };
        };
        return {
          uid: detail.uid,
          dom: detail.dom,
          components: [
            memPalette.asSpec(),
            sliderFactory(translate, getClass),
            memRgb.asSpec()
          ],
          behaviours: derive$1([
            config(&apos;colour-picker-events&apos;, [
              run(paletteUpdate, paletteUpdates()),
              run(sliderUpdate, sliderUpdates())
            ]),
            Composing.config({
              find: function (comp) {
                return memRgb.getOpt(comp);
              }
            }),
            Keying.config({ mode: &apos;acyclic&apos; })
          ])
        };
      };
      var colourPickerSketcher = single$2({
        name: &apos;ColourPicker&apos;,
        configFields: [
          strict$1(&apos;dom&apos;),
          defaulted$1(&apos;onValidHex&apos;, noop),
          defaulted$1(&apos;onInvalidHex&apos;, noop)
        ],
        factory: factory
      });
      return colourPickerSketcher;
    };

    var self$1 = function () {
      return Composing.config({ find: Option.some });
    };
    var memento = function (mem) {
      return Composing.config({ find: mem.getOpt });
    };
    var childAt = function (index) {
      return Composing.config({
        find: function (comp) {
          return child(comp.element(), index).bind(function (element) {
            return comp.getSystem().getByDom(element).toOption();
          });
        }
      });
    };
    var ComposingConfigs = {
      self: self$1,
      memento: memento,
      childAt: childAt
    };

    var english = {
      &apos;colorcustom.rgb.red.label&apos;: &apos;R&apos;,
      &apos;colorcustom.rgb.red.description&apos;: &apos;Red component&apos;,
      &apos;colorcustom.rgb.green.label&apos;: &apos;G&apos;,
      &apos;colorcustom.rgb.green.description&apos;: &apos;Green component&apos;,
      &apos;colorcustom.rgb.blue.label&apos;: &apos;B&apos;,
      &apos;colorcustom.rgb.blue.description&apos;: &apos;Blue component&apos;,
      &apos;colorcustom.rgb.hex.label&apos;: &apos;#&apos;,
      &apos;colorcustom.rgb.hex.description&apos;: &apos;Hex color code&apos;,
      &apos;colorcustom.rgb.range&apos;: &apos;Range 0 to 255&apos;,
      &apos;colorcustom.sb.saturation&apos;: &apos;Saturation&apos;,
      &apos;colorcustom.sb.brightness&apos;: &apos;Brightness&apos;,
      &apos;colorcustom.sb.picker&apos;: &apos;Saturation and Brightness Picker&apos;,
      &apos;colorcustom.sb.palette&apos;: &apos;Saturation and Brightness Palette&apos;,
      &apos;colorcustom.sb.instructions&apos;: &apos;Use arrow keys to select saturation and brightness, on x and y axes&apos;,
      &apos;colorcustom.hue.hue&apos;: &apos;Hue&apos;,
      &apos;colorcustom.hue.slider&apos;: &apos;Hue Slider&apos;,
      &apos;colorcustom.hue.palette&apos;: &apos;Hue Palette&apos;,
      &apos;colorcustom.hue.instructions&apos;: &apos;Use arrow keys to select a hue&apos;,
      &apos;aria.color.picker&apos;: &apos;Color Picker&apos;,
      &apos;aria.input.invalid&apos;: &apos;Invalid input&apos;
    };
    var getEnglishText = function (key) {
      return english[key];
    };
    var translate$1 = function (key) {
      return getEnglishText(key);
    };
    var renderColorPicker = function (_spec) {
      var getClass = function (key) {
        return &apos;tox-&apos; + key;
      };
      var colourPickerFactory = makeFactory(translate$1, getClass);
      var onValidHex = function (form) {
        emitWith(form, formActionEvent, {
          name: &apos;hex-valid&apos;,
          value: true
        });
      };
      var onInvalidHex = function (form) {
        emitWith(form, formActionEvent, {
          name: &apos;hex-valid&apos;,
          value: false
        });
      };
      var memPicker = record(colourPickerFactory.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [getClass(&apos;color-picker-container&apos;)],
          attributes: { role: &apos;presentation&apos; }
        },
        onValidHex: onValidHex,
        onInvalidHex: onInvalidHex
      }));
      return {
        dom: { tag: &apos;div&apos; },
        components: [memPicker.asSpec()],
        behaviours: derive$1([
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function (comp) {
                var picker = memPicker.get(comp);
                var optRgbForm = Composing.getCurrent(picker);
                var optHex = optRgbForm.bind(function (rgbForm) {
                  var formValues = Representing.getValue(rgbForm);
                  return formValues.hex;
                });
                return optHex.map(function (hex) {
                  return &apos;#&apos; + hex;
                }).getOr(&apos;&apos;);
              },
              setValue: function (comp, newValue) {
                var pattern = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
                var m = pattern.exec(newValue);
                var picker = memPicker.get(comp);
                var optRgbForm = Composing.getCurrent(picker);
                optRgbForm.fold(function () {
                  domGlobals.console.log(&apos;Can not find form&apos;);
                }, function (rgbForm) {
                  Representing.setValue(rgbForm, { hex: Option.from(m[1]).getOr(&apos;&apos;) });
                  Form.getField(rgbForm, &apos;hex&apos;).each(function (hexField) {
                    emit(hexField, input());
                  });
                });
              }
            }
          }),
          ComposingConfigs.self()
        ])
      };
    };

    var global$a = tinymce.util.Tools.resolve(&apos;tinymce.Resource&apos;);

    var isOldCustomEditor = function (spec) {
      return Object.prototype.hasOwnProperty.call(spec, &apos;init&apos;);
    };
    var renderCustomEditor = function (spec) {
      var editorApi = Cell(Option.none());
      var memReplaced = record({ dom: { tag: spec.tag } });
      var initialValue = Cell(Option.none());
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-custom-editor&apos;]
        },
        behaviours: derive$1([
          config(&apos;editor-foo-events&apos;, [runOnAttached(function (component) {
              memReplaced.getOpt(component).each(function (ta) {
                (isOldCustomEditor(spec) ? spec.init(ta.element().dom()) : global$a.load(spec.scriptId, spec.scriptUrl).then(function (init) {
                  return init(ta.element().dom(), spec.settings);
                })).then(function (ea) {
                  initialValue.get().each(function (cvalue) {
                    ea.setValue(cvalue);
                  });
                  initialValue.set(Option.none());
                  editorApi.set(Option.some(ea));
                });
              });
            })]),
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function () {
                return editorApi.get().fold(function () {
                  return initialValue.get().getOr(&apos;&apos;);
                }, function (ed) {
                  return ed.getValue();
                });
              },
              setValue: function (component, value) {
                editorApi.get().fold(function () {
                  initialValue.set(Option.some(value));
                }, function (ed) {
                  return ed.setValue(value);
                });
              }
            }
          }),
          ComposingConfigs.self()
        ]),
        components: [memReplaced.asSpec()]
      };
    };

    var processors = objOf([
      defaulted$1(&apos;preprocess&apos;, identity),
      defaulted$1(&apos;postprocess&apos;, identity)
    ]);
    var memento$1 = function (mem, rawProcessors) {
      var ps = asRawOrDie(&apos;RepresentingConfigs.memento processors&apos;, processors, rawProcessors);
      return Representing.config({
        store: {
          mode: &apos;manual&apos;,
          getValue: function (comp) {
            var other = mem.get(comp);
            var rawValue = Representing.getValue(other);
            return ps.postprocess(rawValue);
          },
          setValue: function (comp, rawValue) {
            var newValue = ps.preprocess(rawValue);
            var other = mem.get(comp);
            Representing.setValue(other, newValue);
          }
        }
      });
    };
    var withComp = function (optInitialValue, getter, setter) {
      return Representing.config(deepMerge({
        store: {
          mode: &apos;manual&apos;,
          getValue: getter,
          setValue: setter
        }
      }, optInitialValue.map(function (initialValue) {
        return { store: { initialValue: initialValue } };
      }).getOr({})));
    };
    var withElement = function (initialValue, getter, setter) {
      return withComp(initialValue, function (c) {
        return getter(c.element());
      }, function (c, v) {
        return setter(c.element(), v);
      });
    };
    var domValue = function (optInitialValue) {
      return withElement(optInitialValue, get$5, set$3);
    };
    var domHtml = function (optInitialValue) {
      return withElement(optInitialValue, get$1, set);
    };
    var memory$1 = function (initialValue) {
      return Representing.config({
        store: {
          mode: &apos;memory&apos;,
          initialValue: initialValue
        }
      });
    };
    var RepresentingConfigs = {
      memento: memento$1,
      withElement: withElement,
      withComp: withComp,
      domValue: domValue,
      domHtml: domHtml,
      memory: memory$1
    };

    var extensionsAccepted = &apos;.jpg,.jpeg,.png,.gif&apos;;
    var filterByExtension = function (files) {
      var re = new RegExp(&apos;(&apos; + extensionsAccepted.split(/\s*,\s*/).join(&apos;|&apos;) + &apos;)$&apos;, &apos;i&apos;);
      return filter(from$1(files), function (file) {
        return re.test(file.name);
      });
    };
    var renderDropZone = function (spec, providersBackstage) {
      var stopper = function (_, se) {
        se.stop();
      };
      var sequence = function (actions) {
        return function (comp, se) {
          each(actions, function (a) {
            a(comp, se);
          });
        };
      };
      var onDrop = function (comp, se) {
        if (!Disabling.isDisabled(comp)) {
          var transferEvent = se.event().raw();
          handleFiles(comp, transferEvent.dataTransfer.files);
        }
      };
      var onSelect = function (component, simulatedEvent) {
        var files = simulatedEvent.event().raw().target.files;
        handleFiles(component, files);
      };
      var handleFiles = function (component, files) {
        Representing.setValue(component, filterByExtension(files));
        emitWith(component, formChangeEvent, { name: spec.name });
      };
      var memInput = record({
        dom: {
          tag: &apos;input&apos;,
          attributes: {
            type: &apos;file&apos;,
            accept: &apos;image/*&apos;
          },
          styles: { display: &apos;none&apos; }
        },
        behaviours: derive$1([config(&apos;input-file-events&apos;, [
            cutter(click()),
            cutter(tap())
          ])])
      });
      var renderField = function (s) {
        return {
          uid: s.uid,
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-dropzone-container&apos;]
          },
          behaviours: derive$1([
            RepresentingConfigs.memory([]),
            ComposingConfigs.self(),
            Disabling.config({}),
            Toggling.config({
              toggleClass: &apos;dragenter&apos;,
              toggleOnExecute: false
            }),
            config(&apos;dropzone-events&apos;, [
              run(&apos;dragenter&apos;, sequence([
                stopper,
                Toggling.toggle
              ])),
              run(&apos;dragleave&apos;, sequence([
                stopper,
                Toggling.toggle
              ])),
              run(&apos;dragover&apos;, stopper),
              run(&apos;drop&apos;, sequence([
                stopper,
                onDrop
              ])),
              run(change(), onSelect)
            ])
          ]),
          components: [{
              dom: {
                tag: &apos;div&apos;,
                classes: [&apos;tox-dropzone&apos;],
                styles: {}
              },
              components: [
                {
                  dom: {
                    tag: &apos;p&apos;,
                    innerHtml: providersBackstage.translate(&apos;Drop an image here&apos;)
                  }
                },
                Button.sketch({
                  dom: {
                    tag: &apos;button&apos;,
                    innerHtml: providersBackstage.translate(&apos;Browse for an image&apos;),
                    styles: { position: &apos;relative&apos; },
                    classes: [
                      &apos;tox-button&apos;,
                      &apos;tox-button--secondary&apos;
                    ]
                  },
                  components: [memInput.asSpec()],
                  action: function (comp) {
                    var inputComp = memInput.get(comp);
                    inputComp.element().dom().click();
                  },
                  buttonBehaviours: derive$1([
                    Tabstopping.config({}),
                    DisablingConfigs.button(providersBackstage.isReadOnly),
                    receivingConfig()
                  ])
                })
              ]
            }]
        };
      };
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var pField = FormField.parts().field({ factory: { sketch: renderField } });
      return renderFormFieldWith(pLabel, pField, [&apos;tox-form__group--stretched&apos;], []);
    };

    var renderGrid = function (spec, backstage) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-form__grid&apos;,
            &apos;tox-form__grid--&apos; + spec.columns + &apos;col&apos;
          ]
        },
        components: map(spec.items, backstage.interpreter)
      };
    };

    var beforeObject = generate$1(&apos;alloy-fake-before-tabstop&apos;);
    var afterObject = generate$1(&apos;alloy-fake-after-tabstop&apos;);
    var craftWithClasses = function (classes) {
      return {
        dom: {
          tag: &apos;div&apos;,
          styles: {
            width: &apos;1px&apos;,
            height: &apos;1px&apos;,
            outline: &apos;none&apos;
          },
          attributes: { tabindex: &apos;0&apos; },
          classes: classes
        },
        behaviours: derive$1([
          Focusing.config({ ignore: true }),
          Tabstopping.config({})
        ])
      };
    };
    var craft = function (spec) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-navobj&apos;]
        },
        components: [
          craftWithClasses([beforeObject]),
          spec,
          craftWithClasses([afterObject])
        ],
        behaviours: derive$1([ComposingConfigs.childAt(1)])
      };
    };
    var triggerTab = function (placeholder, shiftKey) {
      emitWith(placeholder, keydown(), {
        raw: {
          which: 9,
          shiftKey: shiftKey
        }
      });
    };
    var onFocus$1 = function (container, targetComp) {
      var target = targetComp.element();
      if (has$2(target, beforeObject)) {
        triggerTab(container, true);
      } else if (has$2(target, afterObject)) {
        triggerTab(container, false);
      }
    };
    var isPseudoStop = function (element) {
      return closest$4(element, [
        &apos;.&apos; + beforeObject,
        &apos;.&apos; + afterObject
      ].join(&apos;,&apos;), constant(false));
    };

    var platformNeedsSandboxing = !(detect$3().browser.isIE() || detect$3().browser.isEdge());
    var getDynamicSource = function (isSandbox) {
      var cachedValue = Cell(&apos;&apos;);
      return {
        getValue: function (_frameComponent) {
          return cachedValue.get();
        },
        setValue: function (frameComponent, html) {
          if (!isSandbox) {
            set$1(frameComponent.element(), &apos;src&apos;, &apos;javascript:\&apos;\&apos;&apos;);
            var doc = frameComponent.element().dom().contentWindow.document;
            doc.open();
            doc.write(html);
            doc.close();
          } else {
            set$1(frameComponent.element(), &apos;srcdoc&apos;, html);
          }
          cachedValue.set(html);
        }
      };
    };
    var renderIFrame = function (spec, providersBackstage) {
      var isSandbox = platformNeedsSandboxing &amp;&amp; spec.sandboxed;
      var attributes = __assign(__assign({}, spec.label.map(function (title) {
        return { title: title };
      }).getOr({})), isSandbox ? { sandbox: &apos;allow-scripts allow-same-origin&apos; } : {});
      var sourcing = getDynamicSource(isSandbox);
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var factory = function (newSpec) {
        return craft({
          uid: newSpec.uid,
          dom: {
            tag: &apos;iframe&apos;,
            attributes: attributes
          },
          behaviours: derive$1([
            Tabstopping.config({}),
            Focusing.config({}),
            RepresentingConfigs.withComp(Option.none(), sourcing.getValue, sourcing.setValue)
          ])
        });
      };
      var pField = FormField.parts().field({ factory: { sketch: factory } });
      return renderFormFieldWith(pLabel, pField, [&apos;tox-form__group--stretched&apos;], []);
    };

    function create$5(width, height) {
      return resize(domGlobals.document.createElement(&apos;canvas&apos;), width, height);
    }
    function clone$1(canvas) {
      var tCanvas = create$5(canvas.width, canvas.height);
      var ctx = get2dContext(tCanvas);
      ctx.drawImage(canvas, 0, 0);
      return tCanvas;
    }
    function get2dContext(canvas) {
      return canvas.getContext(&apos;2d&apos;);
    }
    function resize(canvas, width, height) {
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }

    function getWidth(image) {
      return image.naturalWidth || image.width;
    }
    function getHeight(image) {
      return image.naturalHeight || image.height;
    }

    var promise = function () {
      var Promise = function (fn) {
        if (typeof this !== &apos;object&apos;) {
          throw new TypeError(&apos;Promises must be constructed via new&apos;);
        }
        if (typeof fn !== &apos;function&apos;) {
          throw new TypeError(&apos;not a function&apos;);
        }
        this._state = null;
        this._value = null;
        this._deferreds = [];
        doResolve(fn, bind(resolve, this), bind(reject, this));
      };
      var asap = Promise.immediateFn || typeof window.setImmediate === &apos;function&apos; &amp;&amp; window.setImmediate || function (fn) {
        domGlobals.setTimeout(fn, 1);
      };
      function bind(fn, thisArg) {
        return function () {
          return fn.apply(thisArg, arguments);
        };
      }
      var isArray = Array.isArray || function (value) {
        return Object.prototype.toString.call(value) === &apos;[object Array]&apos;;
      };
      function handle(deferred) {
        var me = this;
        if (this._state === null) {
          this._deferreds.push(deferred);
          return;
        }
        asap(function () {
          var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
          if (cb === null) {
            (me._state ? deferred.resolve : deferred.reject)(me._value);
            return;
          }
          var ret;
          try {
            ret = cb(me._value);
          } catch (e) {
            deferred.reject(e);
            return;
          }
          deferred.resolve(ret);
        });
      }
      function resolve(newValue) {
        try {
          if (newValue === this) {
            throw new TypeError(&apos;A promise cannot be resolved with itself.&apos;);
          }
          if (newValue &amp;&amp; (typeof newValue === &apos;object&apos; || typeof newValue === &apos;function&apos;)) {
            var then = newValue.then;
            if (typeof then === &apos;function&apos;) {
              doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
              return;
            }
          }
          this._state = true;
          this._value = newValue;
          finale.call(this);
        } catch (e) {
          reject.call(this, e);
        }
      }
      function reject(newValue) {
        this._state = false;
        this._value = newValue;
        finale.call(this);
      }
      function finale() {
        for (var _i = 0, _a = this._deferreds; _i &lt; _a.length; _i++) {
          var deferred = _a[_i];
          handle.call(this, deferred);
        }
        this._deferreds = [];
      }
      function Handler(onFulfilled, onRejected, resolve, reject) {
        this.onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : null;
        this.onRejected = typeof onRejected === &apos;function&apos; ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
      }
      function doResolve(fn, onFulfilled, onRejected) {
        var done = false;
        try {
          fn(function (value) {
            if (done) {
              return;
            }
            done = true;
            onFulfilled(value);
          }, function (reason) {
            if (done) {
              return;
            }
            done = true;
            onRejected(reason);
          });
        } catch (ex) {
          if (done) {
            return;
          }
          done = true;
          onRejected(ex);
        }
      }
      Promise.prototype.catch = function (onRejected) {
        return this.then(null, onRejected);
      };
      Promise.prototype.then = function (onFulfilled, onRejected) {
        var me = this;
        return new Promise(function (resolve, reject) {
          handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
        });
      };
      Promise.all = function () {
        var values = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        var args = Array.prototype.slice.call(values.length === 1 &amp;&amp; isArray(values[0]) ? values[0] : values);
        return new Promise(function (resolve, reject) {
          if (args.length === 0) {
            return resolve([]);
          }
          var remaining = args.length;
          function res(i, val) {
            try {
              if (val &amp;&amp; (typeof val === &apos;object&apos; || typeof val === &apos;function&apos;)) {
                var then = val.then;
                if (typeof then === &apos;function&apos;) {
                  then.call(val, function (val) {
                    res(i, val);
                  }, reject);
                  return;
                }
              }
              args[i] = val;
              if (--remaining === 0) {
                resolve(args);
              }
            } catch (ex) {
              reject(ex);
            }
          }
          for (var i = 0; i &lt; args.length; i++) {
            res(i, args[i]);
          }
        });
      };
      Promise.resolve = function (value) {
        if (value &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value.constructor === Promise) {
          return value;
        }
        return new Promise(function (resolve) {
          resolve(value);
        });
      };
      Promise.reject = function (reason) {
        return new Promise(function (resolve, reject) {
          reject(reason);
        });
      };
      Promise.race = function (values) {
        return new Promise(function (resolve, reject) {
          for (var _i = 0, values_1 = values; _i &lt; values_1.length; _i++) {
            var value = values_1[_i];
            value.then(resolve, reject);
          }
        });
      };
      return Promise;
    };
    var Promise$1 = window.Promise ? window.Promise : promise();

    function blobToImage(blob) {
      return new Promise$1(function (resolve, reject) {
        var blobUrl = domGlobals.URL.createObjectURL(blob);
        var image = new domGlobals.Image();
        var removeListeners = function () {
          image.removeEventListener(&apos;load&apos;, loaded);
          image.removeEventListener(&apos;error&apos;, error);
        };
        function loaded() {
          removeListeners();
          resolve(image);
        }
        function error() {
          removeListeners();
          reject(&apos;Unable to load data of type &apos; + blob.type + &apos;: &apos; + blobUrl);
        }
        image.addEventListener(&apos;load&apos;, loaded);
        image.addEventListener(&apos;error&apos;, error);
        image.src = blobUrl;
        if (image.complete) {
          loaded();
        }
      });
    }
    function dataUriToBlobSync(uri) {
      var data = uri.split(&apos;,&apos;);
      var matches = /data:([^;]+)/.exec(data[0]);
      if (!matches) {
        return Option.none();
      }
      var mimetype = matches[1];
      var base64 = data[1];
      var sliceSize = 1024;
      var byteCharacters = domGlobals.atob(base64);
      var bytesLength = byteCharacters.length;
      var slicesCount = Math.ceil(bytesLength / sliceSize);
      var byteArrays = new Array(slicesCount);
      for (var sliceIndex = 0; sliceIndex &lt; slicesCount; ++sliceIndex) {
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);
        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset &lt; end; ++i, ++offset) {
          bytes[i] = byteCharacters[offset].charCodeAt(0);
        }
        byteArrays[sliceIndex] = new Uint8Array(bytes);
      }
      return Option.some(new domGlobals.Blob(byteArrays, { type: mimetype }));
    }
    function dataUriToBlob(uri) {
      return new Promise$1(function (resolve, reject) {
        dataUriToBlobSync(uri).fold(function () {
          reject(&apos;uri is not base64: &apos; + uri);
        }, resolve);
      });
    }
    function canvasToBlob(canvas, type, quality) {
      type = type || &apos;image/png&apos;;
      if (domGlobals.HTMLCanvasElement.prototype.toBlob) {
        return new Promise$1(function (resolve, reject) {
          canvas.toBlob(function (blob) {
            if (blob) {
              resolve(blob);
            } else {
              reject();
            }
          }, type, quality);
        });
      } else {
        return dataUriToBlob(canvas.toDataURL(type, quality));
      }
    }
    function canvasToDataURL(canvas, type, quality) {
      type = type || &apos;image/png&apos;;
      return canvas.toDataURL(type, quality);
    }
    function blobToCanvas(blob) {
      return blobToImage(blob).then(function (image) {
        revokeImageUrl(image);
        var canvas = create$5(getWidth(image), getHeight(image));
        var context = get2dContext(canvas);
        context.drawImage(image, 0, 0);
        return canvas;
      });
    }
    function blobToDataUri(blob) {
      return new Promise$1(function (resolve) {
        var reader = new domGlobals.FileReader();
        reader.onloadend = function () {
          resolve(reader.result);
        };
        reader.readAsDataURL(blob);
      });
    }
    function revokeImageUrl(image) {
      domGlobals.URL.revokeObjectURL(image.src);
    }

    function create$6(getCanvas, blob, uri) {
      var initialType = blob.type;
      var getType = constant(initialType);
      function toBlob() {
        return Promise$1.resolve(blob);
      }
      var toDataURL = constant(uri);
      function toBase64() {
        return uri.split(&apos;,&apos;)[1];
      }
      function toAdjustedBlob(type, quality) {
        return getCanvas.then(function (canvas) {
          return canvasToBlob(canvas, type, quality);
        });
      }
      function toAdjustedDataURL(type, quality) {
        return getCanvas.then(function (canvas) {
          return canvasToDataURL(canvas, type, quality);
        });
      }
      function toAdjustedBase64(type, quality) {
        return toAdjustedDataURL(type, quality).then(function (dataurl) {
          return dataurl.split(&apos;,&apos;)[1];
        });
      }
      function toCanvas() {
        return getCanvas.then(clone$1);
      }
      return {
        getType: getType,
        toBlob: toBlob,
        toDataURL: toDataURL,
        toBase64: toBase64,
        toAdjustedBlob: toAdjustedBlob,
        toAdjustedDataURL: toAdjustedDataURL,
        toAdjustedBase64: toAdjustedBase64,
        toCanvas: toCanvas
      };
    }
    function fromBlob(blob) {
      return blobToDataUri(blob).then(function (uri) {
        return create$6(blobToCanvas(blob), blob, uri);
      });
    }
    function fromCanvas(canvas, type) {
      return canvasToBlob(canvas, type).then(function (blob) {
        return create$6(Promise$1.resolve(canvas), blob, canvas.toDataURL());
      });
    }

    var blobToImageResult = function (blob) {
      return fromBlob(blob);
    };

    function clamp$1(value, min, max) {
      var parsedValue = typeof value === &apos;string&apos; ? parseFloat(value) : value;
      if (parsedValue &gt; max) {
        parsedValue = max;
      } else if (parsedValue &lt; min) {
        parsedValue = min;
      }
      return parsedValue;
    }
    function identity$1() {
      return [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ];
    }
    var DELTA_INDEX = [
      0,
      0.01,
      0.02,
      0.04,
      0.05,
      0.06,
      0.07,
      0.08,
      0.1,
      0.11,
      0.12,
      0.14,
      0.15,
      0.16,
      0.17,
      0.18,
      0.2,
      0.21,
      0.22,
      0.24,
      0.25,
      0.27,
      0.28,
      0.3,
      0.32,
      0.34,
      0.36,
      0.38,
      0.4,
      0.42,
      0.44,
      0.46,
      0.48,
      0.5,
      0.53,
      0.56,
      0.59,
      0.62,
      0.65,
      0.68,
      0.71,
      0.74,
      0.77,
      0.8,
      0.83,
      0.86,
      0.89,
      0.92,
      0.95,
      0.98,
      1,
      1.06,
      1.12,
      1.18,
      1.24,
      1.3,
      1.36,
      1.42,
      1.48,
      1.54,
      1.6,
      1.66,
      1.72,
      1.78,
      1.84,
      1.9,
      1.96,
      2,
      2.12,
      2.25,
      2.37,
      2.5,
      2.62,
      2.75,
      2.87,
      3,
      3.2,
      3.4,
      3.6,
      3.8,
      4,
      4.3,
      4.7,
      4.9,
      5,
      5.5,
      6,
      6.5,
      6.8,
      7,
      7.3,
      7.5,
      7.8,
      8,
      8.4,
      8.7,
      9,
      9.4,
      9.6,
      9.8,
      10
    ];
    function multiply(matrix1, matrix2) {
      var col = [];
      var out = new Array(25);
      var val;
      for (var i = 0; i &lt; 5; i++) {
        for (var j = 0; j &lt; 5; j++) {
          col[j] = matrix2[j + i * 5];
        }
        for (var j = 0; j &lt; 5; j++) {
          val = 0;
          for (var k = 0; k &lt; 5; k++) {
            val += matrix1[j + k * 5] * col[k];
          }
          out[j + i * 5] = val;
        }
      }
      return out;
    }
    function adjustContrast(matrix, value) {
      var x;
      value = clamp$1(value, -1, 1);
      value *= 100;
      if (value &lt; 0) {
        x = 127 + value / 100 * 127;
      } else {
        x = value % 1;
        if (x === 0) {
          x = DELTA_INDEX[value];
        } else {
          x = DELTA_INDEX[Math.floor(value)] * (1 - x) + DELTA_INDEX[Math.floor(value) + 1] * x;
        }
        x = x * 127 + 127;
      }
      return multiply(matrix, [
        x / 127,
        0,
        0,
        0,
        0.5 * (127 - x),
        0,
        x / 127,
        0,
        0,
        0.5 * (127 - x),
        0,
        0,
        x / 127,
        0,
        0.5 * (127 - x),
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    }
    function adjustBrightness(matrix, value) {
      value = clamp$1(255 * value, -255, 255);
      return multiply(matrix, [
        1,
        0,
        0,
        0,
        value,
        0,
        1,
        0,
        0,
        value,
        0,
        0,
        1,
        0,
        value,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    }
    function adjustColors(matrix, adjustR, adjustG, adjustB) {
      adjustR = clamp$1(adjustR, 0, 2);
      adjustG = clamp$1(adjustG, 0, 2);
      adjustB = clamp$1(adjustB, 0, 2);
      return multiply(matrix, [
        adjustR,
        0,
        0,
        0,
        0,
        0,
        adjustG,
        0,
        0,
        0,
        0,
        0,
        adjustB,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
    }

    function colorFilter(ir, matrix) {
      return ir.toCanvas().then(function (canvas) {
        return applyColorFilter(canvas, ir.getType(), matrix);
      });
    }
    function applyColorFilter(canvas, type, matrix) {
      var context = get2dContext(canvas);
      function applyMatrix(pixelsData, m) {
        var r, g, b, a;
        var data = pixelsData.data, m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7], m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11], m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15], m16 = m[16], m17 = m[17], m18 = m[18], m19 = m[19];
        for (var i = 0; i &lt; data.length; i += 4) {
          r = data[i];
          g = data[i + 1];
          b = data[i + 2];
          a = data[i + 3];
          data[i] = r * m0 + g * m1 + b * m2 + a * m3 + m4;
          data[i + 1] = r * m5 + g * m6 + b * m7 + a * m8 + m9;
          data[i + 2] = r * m10 + g * m11 + b * m12 + a * m13 + m14;
          data[i + 3] = r * m15 + g * m16 + b * m17 + a * m18 + m19;
        }
        return pixelsData;
      }
      var pixels = applyMatrix(context.getImageData(0, 0, canvas.width, canvas.height), matrix);
      context.putImageData(pixels, 0, 0);
      return fromCanvas(canvas, type);
    }
    function convoluteFilter(ir, matrix) {
      return ir.toCanvas().then(function (canvas) {
        return applyConvoluteFilter(canvas, ir.getType(), matrix);
      });
    }
    function applyConvoluteFilter(canvas, type, matrix) {
      var context = get2dContext(canvas);
      function applyMatrix(pIn, pOut, aMatrix) {
        function clamp(value, min, max) {
          if (value &gt; max) {
            value = max;
          } else if (value &lt; min) {
            value = min;
          }
          return value;
        }
        var side = Math.round(Math.sqrt(aMatrix.length));
        var halfSide = Math.floor(side / 2);
        var rgba = pIn.data;
        var drgba = pOut.data;
        var w = pIn.width;
        var h = pIn.height;
        for (var y = 0; y &lt; h; y++) {
          for (var x = 0; x &lt; w; x++) {
            var r = 0;
            var g = 0;
            var b = 0;
            for (var cy = 0; cy &lt; side; cy++) {
              for (var cx = 0; cx &lt; side; cx++) {
                var scx = clamp(x + cx - halfSide, 0, w - 1);
                var scy = clamp(y + cy - halfSide, 0, h - 1);
                var innerOffset = (scy * w + scx) * 4;
                var wt = aMatrix[cy * side + cx];
                r += rgba[innerOffset] * wt;
                g += rgba[innerOffset + 1] * wt;
                b += rgba[innerOffset + 2] * wt;
              }
            }
            var offset = (y * w + x) * 4;
            drgba[offset] = clamp(r, 0, 255);
            drgba[offset + 1] = clamp(g, 0, 255);
            drgba[offset + 2] = clamp(b, 0, 255);
          }
        }
        return pOut;
      }
      var pixelsIn = context.getImageData(0, 0, canvas.width, canvas.height);
      var pixelsOut = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelsOut = applyMatrix(pixelsIn, pixelsOut, matrix);
      context.putImageData(pixelsOut, 0, 0);
      return fromCanvas(canvas, type);
    }
    function functionColorFilter(colorFn) {
      var filterImpl = function (canvas, type, value) {
        var context = get2dContext(canvas);
        var lookup = new Array(256);
        function applyLookup(pixelsData, lookupData) {
          var data = pixelsData.data;
          for (var i = 0; i &lt; data.length; i += 4) {
            data[i] = lookupData[data[i]];
            data[i + 1] = lookupData[data[i + 1]];
            data[i + 2] = lookupData[data[i + 2]];
          }
          return pixelsData;
        }
        for (var i = 0; i &lt; lookup.length; i++) {
          lookup[i] = colorFn(i, value);
        }
        var pixels = applyLookup(context.getImageData(0, 0, canvas.width, canvas.height), lookup);
        context.putImageData(pixels, 0, 0);
        return fromCanvas(canvas, type);
      };
      return function (ir, value) {
        return ir.toCanvas().then(function (canvas) {
          return filterImpl(canvas, ir.getType(), value);
        });
      };
    }
    function complexAdjustableColorFilter(matrixAdjustFn) {
      return function (ir, adjust) {
        return colorFilter(ir, matrixAdjustFn(identity$1(), adjust));
      };
    }
    function basicColorFilter(matrix) {
      return function (ir) {
        return colorFilter(ir, matrix);
      };
    }
    function basicConvolutionFilter(kernel) {
      return function (ir) {
        return convoluteFilter(ir, kernel);
      };
    }
    var invert = basicColorFilter([
      -1,
      0,
      0,
      0,
      255,
      0,
      -1,
      0,
      0,
      255,
      0,
      0,
      -1,
      0,
      255,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1
    ]);
    var brightness = complexAdjustableColorFilter(adjustBrightness);
    var contrast = complexAdjustableColorFilter(adjustContrast);
    var colorize = function (ir, adjustR, adjustG, adjustB) {
      return colorFilter(ir, adjustColors(identity$1(), adjustR, adjustG, adjustB));
    };
    var sharpen = basicConvolutionFilter([
      0,
      -1,
      0,
      -1,
      5,
      -1,
      0,
      -1,
      0
    ]);
    var gamma = functionColorFilter(function (color, value) {
      return Math.pow(color / 255, 1 - value) * 255;
    });

    function scale(image, dW, dH) {
      var sW = getWidth(image);
      var sH = getHeight(image);
      var wRatio = dW / sW;
      var hRatio = dH / sH;
      var scaleCapped = false;
      if (wRatio &lt; 0.5 || wRatio &gt; 2) {
        wRatio = wRatio &lt; 0.5 ? 0.5 : 2;
        scaleCapped = true;
      }
      if (hRatio &lt; 0.5 || hRatio &gt; 2) {
        hRatio = hRatio &lt; 0.5 ? 0.5 : 2;
        scaleCapped = true;
      }
      var scaled = _scale(image, wRatio, hRatio);
      return !scaleCapped ? scaled : scaled.then(function (tCanvas) {
        return scale(tCanvas, dW, dH);
      });
    }
    function _scale(image, wRatio, hRatio) {
      return new Promise$1(function (resolve) {
        var sW = getWidth(image);
        var sH = getHeight(image);
        var dW = Math.floor(sW * wRatio);
        var dH = Math.floor(sH * hRatio);
        var canvas = create$5(dW, dH);
        var context = get2dContext(canvas);
        context.drawImage(image, 0, 0, sW, sH, 0, 0, dW, dH);
        resolve(canvas);
      });
    }

    function rotate(ir, angle) {
      return ir.toCanvas().then(function (canvas) {
        return applyRotate(canvas, ir.getType(), angle);
      });
    }
    function applyRotate(image, type, angle) {
      var canvas = create$5(image.width, image.height);
      var context = get2dContext(canvas);
      var translateX = 0;
      var translateY = 0;
      angle = angle &lt; 0 ? 360 + angle : angle;
      if (angle === 90 || angle === 270) {
        resize(canvas, canvas.height, canvas.width);
      }
      if (angle === 90 || angle === 180) {
        translateX = canvas.width;
      }
      if (angle === 270 || angle === 180) {
        translateY = canvas.height;
      }
      context.translate(translateX, translateY);
      context.rotate(angle * Math.PI / 180);
      context.drawImage(image, 0, 0);
      return fromCanvas(canvas, type);
    }
    function flip(ir, axis) {
      return ir.toCanvas().then(function (canvas) {
        return applyFlip(canvas, ir.getType(), axis);
      });
    }
    function applyFlip(image, type, axis) {
      var canvas = create$5(image.width, image.height);
      var context = get2dContext(canvas);
      if (axis === &apos;v&apos;) {
        context.scale(1, -1);
        context.drawImage(image, 0, -canvas.height);
      } else {
        context.scale(-1, 1);
        context.drawImage(image, -canvas.width, 0);
      }
      return fromCanvas(canvas, type);
    }
    function crop(ir, x, y, w, h) {
      return ir.toCanvas().then(function (canvas) {
        return applyCrop(canvas, ir.getType(), x, y, w, h);
      });
    }
    function applyCrop(image, type, x, y, w, h) {
      var canvas = create$5(w, h);
      var context = get2dContext(canvas);
      context.drawImage(image, -x, -y);
      return fromCanvas(canvas, type);
    }
    function resize$1(ir, w, h) {
      return ir.toCanvas().then(function (canvas) {
        return scale(canvas, w, h).then(function (newCanvas) {
          return fromCanvas(newCanvas, ir.getType());
        });
      });
    }

    var invert$1 = function (ir) {
      return invert(ir);
    };
    var sharpen$1 = function (ir) {
      return sharpen(ir);
    };
    var gamma$1 = function (ir, value) {
      return gamma(ir, value);
    };
    var colorize$1 = function (ir, adjustR, adjustG, adjustB) {
      return colorize(ir, adjustR, adjustG, adjustB);
    };
    var brightness$1 = function (ir, adjust) {
      return brightness(ir, adjust);
    };
    var contrast$1 = function (ir, adjust) {
      return contrast(ir, adjust);
    };
    var flip$1 = function (ir, axis) {
      return flip(ir, axis);
    };
    var crop$1 = function (ir, x, y, w, h) {
      return crop(ir, x, y, w, h);
    };
    var resize$2 = function (ir, w, h) {
      return resize$1(ir, w, h);
    };
    var rotate$1 = function (ir, angle) {
      return rotate(ir, angle);
    };

    var renderIcon$1 = function (iconHtml, behaviours) {
      return __assign({
        dom: {
          tag: &apos;span&apos;,
          innerHtml: iconHtml,
          classes: [
            &apos;tox-icon&apos;,
            &apos;tox-tbtn__icon-wrap&apos;
          ]
        }
      }, behaviours);
    };
    var renderIconFromPack = function (iconName, iconsProvider) {
      return renderIcon$1(get$d(iconName, iconsProvider), {});
    };
    var renderReplacableIconFromPack = function (iconName, iconsProvider) {
      return renderIcon$1(get$d(iconName, iconsProvider), { behaviours: derive$1([Replacing.config({})]) });
    };
    var renderLabel$1 = function (text, prefix, providersBackstage) {
      return {
        dom: {
          tag: &apos;span&apos;,
          innerHtml: providersBackstage.translate(text),
          classes: [prefix + &apos;__select-label&apos;]
        },
        behaviours: derive$1([Replacing.config({})])
      };
    };

    var internalToolbarButtonExecute = generate$1(&apos;toolbar.button.execute&apos;);
    var onToolbarButtonExecute = function (info) {
      return runOnExecute(function (comp, _simulatedEvent) {
        runWithApi(info, comp)(function (itemApi) {
          emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });
          info.onAction(itemApi);
        });
      });
    };
    var toolbarButtonEventOrder = {
      &apos;alloy.execute&apos;: [
        &apos;disabling&apos;,
        &apos;alloy.base.behaviour&apos;,
        &apos;toggling&apos;,
        &apos;toolbar-button-events&apos;
      ]
    };

    var updateMenuText = generate$1(&apos;update-menu-text&apos;);
    var updateMenuIcon = generate$1(&apos;update-menu-icon&apos;);
    var renderCommonDropdown = function (spec, prefix, sharedBackstage) {
      var editorOffCell = Cell(noop);
      var optMemDisplayText = spec.text.map(function (text) {
        return record(renderLabel$1(text, prefix, sharedBackstage.providers));
      });
      var optMemDisplayIcon = spec.icon.map(function (iconName) {
        return record(renderReplacableIconFromPack(iconName, sharedBackstage.providers.icons));
      });
      var onLeftOrRightInMenu = function (comp, se) {
        var dropdown = Representing.getValue(comp);
        Focusing.focus(dropdown);
        emitWith(dropdown, &apos;keydown&apos;, { raw: se.event().raw() });
        Dropdown.close(dropdown);
        return Option.some(true);
      };
      var role = spec.role.fold(function () {
        return {};
      }, function (role) {
        return { role: role };
      });
      var tooltipAttributes = spec.tooltip.fold(function () {
        return {};
      }, function (tooltip) {
        var translatedTooltip = sharedBackstage.providers.translate(tooltip);
        return {
          &apos;title&apos;: translatedTooltip,
          &apos;aria-label&apos;: translatedTooltip
        };
      });
      var memDropdown = record(Dropdown.sketch(__assign(__assign({}, role), {
        dom: {
          tag: &apos;button&apos;,
          classes: [
            prefix,
            prefix + &apos;--select&apos;
          ].concat(map(spec.classes, function (c) {
            return prefix + &apos;--&apos; + c;
          })),
          attributes: __assign({}, tooltipAttributes)
        },
        components: componentRenderPipeline([
          optMemDisplayIcon.map(function (mem) {
            return mem.asSpec();
          }),
          optMemDisplayText.map(function (mem) {
            return mem.asSpec();
          }),
          Option.some({
            dom: {
              tag: &apos;div&apos;,
              classes: [prefix + &apos;__select-chevron&apos;],
              innerHtml: get$d(&apos;chevron-down&apos;, sharedBackstage.providers.icons)
            }
          })
        ]),
        matchWidth: true,
        useMinWidth: true,
        dropdownBehaviours: derive$1(__spreadArrays(spec.dropdownBehaviours, [
          DisablingConfigs.button(function () {
            return spec.disabled || sharedBackstage.providers.isReadOnly();
          }),
          receivingConfig(),
          Unselecting.config({}),
          Replacing.config({}),
          config(&apos;dropdown-events&apos;, [
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell)
          ]),
          config(&apos;menubutton-update-display-text&apos;, [
            run(updateMenuText, function (comp, se) {
              optMemDisplayText.bind(function (mem) {
                return mem.getOpt(comp);
              }).each(function (displayText) {
                Replacing.set(displayText, [text(sharedBackstage.providers.translate(se.event().text()))]);
              });
            }),
            run(updateMenuIcon, function (comp, se) {
              optMemDisplayIcon.bind(function (mem) {
                return mem.getOpt(comp);
              }).each(function (displayIcon) {
                Replacing.set(displayIcon, [renderReplacableIconFromPack(se.event().icon(), sharedBackstage.providers.icons)]);
              });
            })
          ])
        ])),
        eventOrder: deepMerge(toolbarButtonEventOrder, {
          mousedown: [
            &apos;focusing&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;item-type-events&apos;,
            &apos;normal-dropdown-events&apos;
          ]
        }),
        sandboxBehaviours: derive$1([Keying.config({
            mode: &apos;special&apos;,
            onLeft: onLeftOrRightInMenu,
            onRight: onLeftOrRightInMenu
          })]),
        lazySink: sharedBackstage.getSink,
        toggleClass: prefix + &apos;--active&apos;,
        parts: { menu: part(false, spec.columns, spec.presets) },
        fetch: function () {
          return Future.nu(spec.fetch);
        }
      })));
      return memDropdown.asSpec();
    };

    var isMenuItemReference = function (item) {
      return isString(item);
    };
    var isSeparator = function (item) {
      return item.type === &apos;separator&apos;;
    };
    var isExpandingMenuItem = function (item) {
      return has(item, &apos;getSubmenuItems&apos;);
    };
    var separator$1 = { type: &apos;separator&apos; };
    var unwrapReferences = function (items, menuItems) {
      var realItems = foldl(items, function (acc, item) {
        if (isMenuItemReference(item)) {
          if (item === &apos;&apos;) {
            return acc;
          } else if (item === &apos;|&apos;) {
            return acc.length &gt; 0 &amp;&amp; !isSeparator(acc[acc.length - 1]) ? acc.concat([separator$1]) : acc;
          } else if (has(menuItems, item.toLowerCase())) {
            return acc.concat([menuItems[item.toLowerCase()]]);
          } else {
            return acc;
          }
        } else {
          return acc.concat([item]);
        }
      }, []);
      if (realItems.length &gt; 0 &amp;&amp; isSeparator(realItems[realItems.length - 1])) {
        realItems.pop();
      }
      return realItems;
    };
    var getFromExpandingItem = function (item, menuItems) {
      var submenuItems = item.getSubmenuItems();
      var rest = expand(submenuItems, menuItems);
      var newMenus = deepMerge(rest.menus, wrap$1(item.value, rest.items));
      var newExpansions = deepMerge(rest.expansions, wrap$1(item.value, item.value));
      return {
        item: item,
        menus: newMenus,
        expansions: newExpansions
      };
    };
    var getFromItem = function (item, menuItems) {
      return isExpandingMenuItem(item) ? getFromExpandingItem(item, menuItems) : {
        item: item,
        menus: {},
        expansions: {}
      };
    };
    var generateValueIfRequired = function (item) {
      if (isSeparator(item)) {
        return item;
      } else {
        var itemValue = get(item, &apos;value&apos;).getOrThunk(function () {
          return generate$1(&apos;generated-menu-item&apos;);
        });
        return deepMerge({ value: itemValue }, item);
      }
    };
    var expand = function (items, menuItems) {
      var realItems = unwrapReferences(isString(items) ? items.split(&apos; &apos;) : items, menuItems);
      return foldr(realItems, function (acc, item) {
        var itemWithValue = generateValueIfRequired(item);
        var newData = getFromItem(itemWithValue, menuItems);
        return {
          menus: deepMerge(acc.menus, newData.menus),
          items: [newData.item].concat(acc.items),
          expansions: deepMerge(acc.expansions, newData.expansions)
        };
      }, {
        menus: {},
        expansions: {},
        items: []
      });
    };

    var build$2 = function (items, itemResponse, backstage, isHorizontalMenu) {
      var primary = generate$1(&apos;primary-menu&apos;);
      var data = expand(items, backstage.shared.providers.menuItems());
      if (data.items.length === 0) {
        return Option.none();
      }
      var mainMenu = createPartialMenu(primary, data.items, itemResponse, backstage, isHorizontalMenu);
      var submenus = map$1(data.menus, function (menuItems, menuName) {
        return createPartialMenu(menuName, menuItems, itemResponse, backstage, false);
      });
      var menus = deepMerge(submenus, wrap$1(primary, mainMenu));
      return Option.from(tieredMenu.tieredData(primary, menus, data.expansions));
    };

    var getMenuButtonApi = function (component) {
      return {
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        },
        setActive: function (state) {
          var elm = component.element();
          if (state) {
            add$2(elm, &apos;tox-tbtn--enabled&apos;);
            set$1(elm, &apos;aria-pressed&apos;, true);
          } else {
            remove$4(elm, &apos;tox-tbtn--enabled&apos;);
            remove$1(elm, &apos;aria-pressed&apos;);
          }
        },
        isActive: function () {
          return has$2(component.element(), &apos;tox-tbtn--enabled&apos;);
        }
      };
    };
    var renderMenuButton = function (spec, prefix, backstage, role) {
      return renderCommonDropdown({
        text: spec.text,
        icon: spec.icon,
        tooltip: spec.tooltip,
        role: role,
        fetch: function (callback) {
          spec.fetch(function (items) {
            callback(build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false));
          });
        },
        onSetup: spec.onSetup,
        getApi: getMenuButtonApi,
        columns: 1,
        presets: &apos;normal&apos;,
        classes: [],
        dropdownBehaviours: [Tabstopping.config({})]
      }, prefix, backstage.shared);
    };
    var getFetch$1 = function (items, getButton, backstage) {
      var getMenuItemAction = function (item) {
        return function (api) {
          var newValue = !api.isActive();
          api.setActive(newValue);
          item.storage.set(newValue);
          backstage.shared.getSink().each(function (sink) {
            getButton().getOpt(sink).each(function (orig) {
              focus$1(orig.element());
              emitWith(orig, formActionEvent, {
                name: item.name,
                value: item.storage.get()
              });
            });
          });
        };
      };
      var getMenuItemSetup = function (item) {
        return function (api) {
          api.setActive(item.storage.get());
        };
      };
      return function (success) {
        success(map(items, function (item) {
          var text = item.text.fold(function () {
            return {};
          }, function (text) {
            return { text: text };
          });
          return __assign(__assign({
            type: item.type,
            active: false
          }, text), {
            onAction: getMenuItemAction(item),
            onSetup: getMenuItemSetup(item)
          });
        }));
      };
    };

    var renderCommonSpec = function (spec, actionOpt, extraBehaviours, dom, components, providersBackstage) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var action = actionOpt.fold(function () {
        return {};
      }, function (action) {
        return { action: action };
      });
      var common = __assign({
        buttonBehaviours: derive$1([
          DisablingConfigs.button(function () {
            return spec.disabled || providersBackstage.isReadOnly();
          }),
          receivingConfig(),
          Tabstopping.config({}),
          config(&apos;button press&apos;, [
            preventDefault(&apos;click&apos;),
            preventDefault(&apos;mousedown&apos;)
          ])
        ].concat(extraBehaviours)),
        eventOrder: {
          click: [
            &apos;button press&apos;,
            &apos;alloy.base.behaviour&apos;
          ],
          mousedown: [
            &apos;button press&apos;,
            &apos;alloy.base.behaviour&apos;
          ]
        }
      }, action);
      var domFinal = deepMerge(common, { dom: dom });
      return deepMerge(domFinal, { components: components });
    };
    var renderIconButtonSpec = function (spec, action, providersBackstage, extraBehaviours) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var tooltipAttributes = spec.tooltip.map(function (tooltip) {
        return {
          &apos;aria-label&apos;: providersBackstage.translate(tooltip),
          &apos;title&apos;: providersBackstage.translate(tooltip)
        };
      }).getOr({});
      var dom = {
        tag: &apos;button&apos;,
        classes: [&apos;tox-tbtn&apos;],
        attributes: tooltipAttributes
      };
      var icon = spec.icon.map(function (iconName) {
        return renderIconFromPack(iconName, providersBackstage.icons);
      });
      var components = componentRenderPipeline([icon]);
      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    var renderIconButton = function (spec, action, providersBackstage, extraBehaviours) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      var iconButtonSpec = renderIconButtonSpec(spec, Option.some(action), providersBackstage, extraBehaviours);
      return Button.sketch(iconButtonSpec);
    };
    var renderButtonSpec = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      if (extraClasses === void 0) {
        extraClasses = [];
      }
      var translatedText = providersBackstage.translate(spec.text);
      var icon = spec.icon ? spec.icon.map(function (iconName) {
        return renderIconFromPack(iconName, providersBackstage.icons);
      }) : Option.none();
      var components = icon.isSome() ? componentRenderPipeline([icon]) : [];
      var innerHtml = icon.isSome() ? {} : { innerHtml: translatedText };
      var classes = __spreadArrays(!spec.primary &amp;&amp; !spec.borderless ? [
        &apos;tox-button&apos;,
        &apos;tox-button--secondary&apos;
      ] : [&apos;tox-button&apos;], icon.isSome() ? [&apos;tox-button--icon&apos;] : [], spec.borderless ? [&apos;tox-button--naked&apos;] : [], extraClasses);
      var dom = __assign(__assign({
        tag: &apos;button&apos;,
        classes: classes
      }, innerHtml), { attributes: { title: translatedText } });
      return renderCommonSpec(spec, action, extraBehaviours, dom, components, providersBackstage);
    };
    var renderButton = function (spec, action, providersBackstage, extraBehaviours, extraClasses) {
      if (extraBehaviours === void 0) {
        extraBehaviours = [];
      }
      if (extraClasses === void 0) {
        extraClasses = [];
      }
      var buttonSpec = renderButtonSpec(spec, Option.some(action), providersBackstage, extraBehaviours, extraClasses);
      return Button.sketch(buttonSpec);
    };
    var getAction = function (name, buttonType) {
      return function (comp) {
        if (buttonType === &apos;custom&apos;) {
          emitWith(comp, formActionEvent, {
            name: name,
            value: {}
          });
        } else if (buttonType === &apos;submit&apos;) {
          emit(comp, formSubmitEvent);
        } else if (buttonType === &apos;cancel&apos;) {
          emit(comp, formCancelEvent);
        } else {
          domGlobals.console.error(&apos;Unknown button type: &apos;, buttonType);
        }
      };
    };
    var isMenuFooterButtonSpec = function (spec, buttonType) {
      return buttonType === &apos;menu&apos;;
    };
    var isNormalFooterButtonSpec = function (spec, buttonType) {
      return buttonType === &apos;custom&apos; || buttonType === &apos;cancel&apos; || buttonType === &apos;submit&apos;;
    };
    var renderFooterButton = function (spec, buttonType, backstage) {
      if (isMenuFooterButtonSpec(spec, buttonType)) {
        var getButton = function () {
          return memButton_1;
        };
        var menuButtonSpec = spec;
        var fixedSpec = __assign(__assign({}, spec), {
          onSetup: function (api) {
            api.setDisabled(spec.disabled);
            return noop;
          },
          fetch: getFetch$1(menuButtonSpec.items, getButton, backstage)
        });
        var memButton_1 = record(renderMenuButton(fixedSpec, &apos;tox-tbtn&apos;, backstage, Option.none()));
        return memButton_1.asSpec();
      } else if (isNormalFooterButtonSpec(spec, buttonType)) {
        var action = getAction(spec.name, buttonType);
        var buttonSpec = __assign(__assign({}, spec), { borderless: false });
        return renderButton(buttonSpec, action, backstage.shared.providers, []);
      } else {
        domGlobals.console.error(&apos;Unknown footer button type: &apos;, buttonType);
      }
    };
    var renderDialogButton = function (spec, providersBackstage) {
      var action = getAction(spec.name, &apos;custom&apos;);
      return renderFormField(Option.none(), FormField.parts().field(__assign({ factory: Button }, renderButtonSpec(spec, Option.some(action), providersBackstage, [
        RepresentingConfigs.memory(&apos;&apos;),
        ComposingConfigs.self()
      ]))));
    };

    var schema$i = constant([
      defaulted$1(&apos;field1Name&apos;, &apos;field1&apos;),
      defaulted$1(&apos;field2Name&apos;, &apos;field2&apos;),
      onStrictHandler(&apos;onLockedChange&apos;),
      markers([&apos;lockClass&apos;]),
      defaulted$1(&apos;locked&apos;, false),
      SketchBehaviours.field(&apos;coupledFieldBehaviours&apos;, [
        Composing,
        Representing
      ])
    ]);
    var getField = function (comp, detail, partName) {
      return getPart(comp, detail, partName).bind(Composing.getCurrent);
    };
    var coupledPart = function (selfName, otherName) {
      return required({
        factory: FormField,
        name: selfName,
        overrides: function (detail) {
          return {
            fieldBehaviours: derive$1([config(&apos;coupled-input-behaviour&apos;, [run(input(), function (me) {
                  getField(me, detail, otherName).each(function (other) {
                    getPart(me, detail, &apos;lock&apos;).each(function (lock) {
                      if (Toggling.isOn(lock)) {
                        detail.onLockedChange(me, other, lock);
                      }
                    });
                  });
                })])])
          };
        }
      });
    };
    var parts$5 = constant([
      coupledPart(&apos;field1&apos;, &apos;field2&apos;),
      coupledPart(&apos;field2&apos;, &apos;field1&apos;),
      required({
        factory: Button,
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;lock&apos;,
        overrides: function (detail) {
          return {
            buttonBehaviours: derive$1([Toggling.config({
                selected: detail.locked,
                toggleClass: detail.markers.lockClass,
                aria: { mode: &apos;pressed&apos; }
              })])
          };
        }
      })
    ]);

    var factory$7 = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [
          Composing.config({ find: Option.some }),
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function (comp) {
                var _a;
                var parts = getPartsOrDie(comp, detail, [
                  &apos;field1&apos;,
                  &apos;field2&apos;
                ]);
                return _a = {}, _a[detail.field1Name] = Representing.getValue(parts.field1()), _a[detail.field2Name] = Representing.getValue(parts.field2()), _a;
              },
              setValue: function (comp, value) {
                var parts = getPartsOrDie(comp, detail, [
                  &apos;field1&apos;,
                  &apos;field2&apos;
                ]);
                if (hasNonNullableKey(value, detail.field1Name)) {
                  Representing.setValue(parts.field1(), value[detail.field1Name]);
                }
                if (hasNonNullableKey(value, detail.field2Name)) {
                  Representing.setValue(parts.field2(), value[detail.field2Name]);
                }
              }
            }
          })
        ]),
        apis: {
          getField1: function (component) {
            return getPart(component, detail, &apos;field1&apos;);
          },
          getField2: function (component) {
            return getPart(component, detail, &apos;field2&apos;);
          },
          getLock: function (component) {
            return getPart(component, detail, &apos;lock&apos;);
          }
        }
      };
    };
    var FormCoupledInputs = composite$1({
      name: &apos;FormCoupledInputs&apos;,
      configFields: schema$i(),
      partFields: parts$5(),
      factory: factory$7,
      apis: {
        getField1: function (apis, component) {
          return apis.getField1(component);
        },
        getField2: function (apis, component) {
          return apis.getField2(component);
        },
        getLock: function (apis, component) {
          return apis.getLock(component);
        }
      }
    });

    var formatSize = function (size) {
      var unitDec = {
        &apos;&apos;: 0,
        &apos;px&apos;: 0,
        &apos;pt&apos;: 1,
        &apos;mm&apos;: 1,
        &apos;pc&apos;: 2,
        &apos;ex&apos;: 2,
        &apos;em&apos;: 2,
        &apos;ch&apos;: 2,
        &apos;rem&apos;: 2,
        &apos;cm&apos;: 3,
        &apos;in&apos;: 4,
        &apos;%&apos;: 4
      };
      var maxDecimal = function (unit) {
        return unit in unitDec ? unitDec[unit] : 1;
      };
      var numText = size.value.toFixed(maxDecimal(size.unit));
      if (numText.indexOf(&apos;.&apos;) !== -1) {
        numText = numText.replace(/\.?0*$/, &apos;&apos;);
      }
      return numText + size.unit;
    };
    var parseSize = function (sizeText) {
      var numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
      var match = numPattern.exec(sizeText);
      if (match !== null) {
        var value = parseFloat(match[1]);
        var unit = match[2];
        return Result.value({
          value: value,
          unit: unit
        });
      } else {
        return Result.error(sizeText);
      }
    };
    var convertUnit = function (size, unit) {
      var inInch = {
        &apos;&apos;: 96,
        &apos;px&apos;: 96,
        &apos;pt&apos;: 72,
        &apos;cm&apos;: 2.54,
        &apos;pc&apos;: 12,
        &apos;mm&apos;: 25.4,
        &apos;in&apos;: 1
      };
      var supported = function (u) {
        return Object.prototype.hasOwnProperty.call(inInch, u);
      };
      if (size.unit === unit) {
        return Option.some(size.value);
      } else if (supported(size.unit) &amp;&amp; supported(unit)) {
        if (inInch[size.unit] === inInch[unit]) {
          return Option.some(size.value);
        } else {
          return Option.some(size.value / inInch[size.unit] * inInch[unit]);
        }
      } else {
        return Option.none();
      }
    };
    var noSizeConversion = function (_input) {
      return Option.none();
    };
    var ratioSizeConversion = function (scale, unit) {
      return function (size) {
        return convertUnit(size, unit).map(function (value) {
          return {
            value: value * scale,
            unit: unit
          };
        });
      };
    };
    var makeRatioConverter = function (currentFieldText, otherFieldText) {
      var cValue = parseSize(currentFieldText).toOption();
      var oValue = parseSize(otherFieldText).toOption();
      return lift2(cValue, oValue, function (cSize, oSize) {
        return convertUnit(cSize, oSize.unit).map(function (val) {
          return oSize.value / val;
        }).map(function (r) {
          return ratioSizeConversion(r, oSize.unit);
        }).getOr(noSizeConversion);
      }).getOr(noSizeConversion);
    };

    var renderSizeInput = function (spec, providersBackstage) {
      var converter = noSizeConversion;
      var ratioEvent = generate$1(&apos;ratio-event&apos;);
      var pLock = FormCoupledInputs.parts().lock({
        dom: {
          tag: &apos;button&apos;,
          classes: [
            &apos;tox-lock&apos;,
            &apos;tox-button&apos;,
            &apos;tox-button--naked&apos;,
            &apos;tox-button--icon&apos;
          ],
          attributes: { title: providersBackstage.translate(spec.label.getOr(&apos;Constrain proportions&apos;)) }
        },
        components: [
          {
            dom: {
              tag: &apos;span&apos;,
              classes: [
                &apos;tox-icon&apos;,
                &apos;tox-lock-icon__lock&apos;
              ],
              innerHtml: get$d(&apos;lock&apos;, providersBackstage.icons)
            }
          },
          {
            dom: {
              tag: &apos;span&apos;,
              classes: [
                &apos;tox-icon&apos;,
                &apos;tox-lock-icon__unlock&apos;
              ],
              innerHtml: get$d(&apos;unlock&apos;, providersBackstage.icons)
            }
          }
        ],
        buttonBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            }
          }),
          receivingConfig(),
          Tabstopping.config({})
        ])
      });
      var formGroup = function (components) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-form__group&apos;]
          },
          components: components
        };
      };
      var getFieldPart = function (isField1) {
        return FormField.parts().field({
          factory: Input,
          inputClasses: [&apos;tox-textfield&apos;],
          inputBehaviours: derive$1([
            Disabling.config({
              disabled: function () {
                return spec.disabled || providersBackstage.isReadOnly();
              }
            }),
            receivingConfig(),
            Tabstopping.config({}),
            config(&apos;size-input-events&apos;, [
              run(focusin(), function (component, _simulatedEvent) {
                emitWith(component, ratioEvent, { isField1: isField1 });
              }),
              run(change(), function (component, _simulatedEvent) {
                emitWith(component, formChangeEvent, { name: spec.name });
              })
            ])
          ]),
          selectOnFocus: false
        });
      };
      var getLabel = function (label) {
        return {
          dom: {
            tag: &apos;label&apos;,
            classes: [&apos;tox-label&apos;],
            innerHtml: providersBackstage.translate(label)
          }
        };
      };
      var widthField = FormCoupledInputs.parts().field1(formGroup([
        FormField.parts().label(getLabel(&apos;Width&apos;)),
        getFieldPart(true)
      ]));
      var heightField = FormCoupledInputs.parts().field2(formGroup([
        FormField.parts().label(getLabel(&apos;Height&apos;)),
        getFieldPart(false)
      ]));
      return FormCoupledInputs.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-form__group&apos;]
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-form__controls-h-stack&apos;]
            },
            components: [
              widthField,
              heightField,
              formGroup([
                getLabel(&apos;&amp;nbsp;&apos;),
                pLock
              ])
            ]
          }],
        field1Name: &apos;width&apos;,
        field2Name: &apos;height&apos;,
        locked: true,
        markers: { lockClass: &apos;tox-locked&apos; },
        onLockedChange: function (current, other, _lock) {
          parseSize(Representing.getValue(current)).each(function (size) {
            converter(size).each(function (newSize) {
              Representing.setValue(other, formatSize(newSize));
            });
          });
        },
        coupledFieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            },
            onDisabled: function (comp) {
              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
              FormCoupledInputs.getLock(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
              FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
              FormCoupledInputs.getLock(comp).each(Disabling.enable);
            }
          }),
          receivingConfig(),
          config(&apos;size-input-events2&apos;, [run(ratioEvent, function (component, simulatedEvent) {
              var isField1 = simulatedEvent.event().isField1();
              var optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
              var optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
              var value1 = optCurrent.map(Representing.getValue).getOr(&apos;&apos;);
              var value2 = optOther.map(Representing.getValue).getOr(&apos;&apos;);
              converter = makeRatioConverter(value1, value2);
            })])
        ])
      });
    };

    var undo = constant(generate$1(&apos;undo&apos;));
    var redo = constant(generate$1(&apos;redo&apos;));
    var zoom = constant(generate$1(&apos;zoom&apos;));
    var back = constant(generate$1(&apos;back&apos;));
    var apply = constant(generate$1(&apos;apply&apos;));
    var swap = constant(generate$1(&apos;swap&apos;));
    var transform = constant(generate$1(&apos;transform&apos;));
    var tempTransform = constant(generate$1(&apos;temp-transform&apos;));
    var transformApply = constant(generate$1(&apos;transform-apply&apos;));
    var internal = {
      undo: undo,
      redo: redo,
      zoom: zoom,
      back: back,
      apply: apply,
      swap: swap,
      transform: transform,
      tempTransform: tempTransform,
      transformApply: transformApply
    };
    var saveState = constant(&apos;save-state&apos;);
    var disable$1 = constant(&apos;disable&apos;);
    var enable$1 = constant(&apos;enable&apos;);
    var external$2 = {
      formActionEvent: formActionEvent,
      saveState: saveState,
      disable: disable$1,
      enable: enable$1
    };

    var renderEditPanel = function (imagePanel, providersBackstage) {
      var createButton = function (text, action, disabled, primary) {
        return record(renderButton({
          name: text,
          text: text,
          disabled: disabled,
          primary: primary,
          icon: Option.none(),
          borderless: false
        }, action, providersBackstage));
      };
      var createIconButton = function (icon, tooltip, action, disabled) {
        return record(renderIconButton({
          name: icon,
          icon: Option.some(icon),
          tooltip: Option.some(tooltip),
          disabled: disabled,
          primary: false,
          borderless: false
        }, action, providersBackstage));
      };
      var disableAllComponents = function (comps, eventcomp) {
        comps.map(function (mem) {
          var component = mem.get(eventcomp);
          if (component.hasConfigured(Disabling)) {
            Disabling.disable(component);
          }
        });
      };
      var enableAllComponents = function (comps, eventcomp) {
        comps.map(function (mem) {
          var component = mem.get(eventcomp);
          if (component.hasConfigured(Disabling)) {
            Disabling.enable(component);
          }
        });
      };
      var panelDom = {
        tag: &apos;div&apos;,
        classes: [
          &apos;tox-image-tools__toolbar&apos;,
          &apos;tox-image-tools-edit-panel&apos;
        ]
      };
      var noop$1 = noop;
      var emit$1 = function (comp, event, data) {
        emitWith(comp, event, data);
      };
      var emitDisable = function (component) {
        return emit(component, external$2.disable());
      };
      var emitEnable = function (component) {
        return emit(component, external$2.enable());
      };
      var emitTransform = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.transform(), { transform: transform });
        emitEnable(comp);
      };
      var emitTempTransform = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.tempTransform(), { transform: transform });
        emitEnable(comp);
      };
      var getBackSwap = function (anyInSystem) {
        return function () {
          memContainer.getOpt(anyInSystem).each(function (container) {
            Replacing.set(container, [ButtonPanel]);
          });
        };
      };
      var emitTransformApply = function (comp, transform) {
        emitDisable(comp);
        emit$1(comp, internal.transformApply(), {
          transform: transform,
          swap: getBackSwap(comp)
        });
        emitEnable(comp);
      };
      var createBackButton = function () {
        return createButton(&apos;Back&apos;, function (button) {
          return emit$1(button, internal.back(), { swap: getBackSwap(button) });
        }, false, false);
      };
      var createSpacer = function () {
        return record({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-spacer&apos;]
          },
          behaviours: derive$1([Disabling.config({})])
        });
      };
      var createApplyButton = function () {
        return createButton(&apos;Apply&apos;, function (button) {
          return emit$1(button, internal.apply(), { swap: getBackSwap(button) });
        }, true, true);
      };
      var makeCropTransform = function () {
        return function (ir) {
          var rect = imagePanel.getRect();
          return crop$1(ir, rect.x, rect.y, rect.w, rect.h);
        };
      };
      var cropPanelComponents = [
        createBackButton(),
        createSpacer(),
        createButton(&apos;Apply&apos;, function (button) {
          var transform = makeCropTransform();
          emitTransformApply(button, transform);
          imagePanel.hideCrop();
        }, false, true)
      ];
      var CropPanel = Container.sketch({
        dom: panelDom,
        components: cropPanelComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config(&apos;image-tools-crop-buttons-events&apos;, [
            run(external$2.disable(), function (comp, _se) {
              disableAllComponents(cropPanelComponents, comp);
            }),
            run(external$2.enable(), function (comp, _se) {
              enableAllComponents(cropPanelComponents, comp);
            })
          ])])
      });
      var memSize = record(renderSizeInput({
        name: &apos;size&apos;,
        label: Option.none(),
        constrain: true,
        disabled: false
      }, providersBackstage));
      var makeResizeTransform = function (width, height) {
        return function (ir) {
          return resize$2(ir, width, height);
        };
      };
      var resizePanelComponents = [
        createBackButton(),
        createSpacer(),
        memSize,
        createSpacer(),
        createButton(&apos;Apply&apos;, function (button) {
          memSize.getOpt(button).each(function (sizeInput) {
            var value = Representing.getValue(sizeInput);
            var width = parseInt(value.width, 10);
            var height = parseInt(value.height, 10);
            var transform = makeResizeTransform(width, height);
            emitTransformApply(button, transform);
          });
        }, false, true)
      ];
      var ResizePanel = Container.sketch({
        dom: panelDom,
        components: resizePanelComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config(&apos;image-tools-resize-buttons-events&apos;, [
            run(external$2.disable(), function (comp, _se) {
              disableAllComponents(resizePanelComponents, comp);
            }),
            run(external$2.enable(), function (comp, _se) {
              enableAllComponents(resizePanelComponents, comp);
            })
          ])])
      });
      var makeValueTransform = function (transform, value) {
        return function (ir) {
          return transform(ir, value);
        };
      };
      var horizontalFlip = makeValueTransform(flip$1, &apos;h&apos;);
      var verticalFlip = makeValueTransform(flip$1, &apos;v&apos;);
      var counterclockwiseRotate = makeValueTransform(rotate$1, -90);
      var clockwiseRotate = makeValueTransform(rotate$1, 90);
      var flipRotateOnAction = function (comp, operation) {
        emitTempTransform(comp, operation);
      };
      var flipRotateComponents = [
        createBackButton(),
        createSpacer(),
        createIconButton(&apos;flip-horizontally&apos;, &apos;Flip horizontally&apos;, function (button) {
          flipRotateOnAction(button, horizontalFlip);
        }, false),
        createIconButton(&apos;flip-vertically&apos;, &apos;Flip vertically&apos;, function (button) {
          flipRotateOnAction(button, verticalFlip);
        }, false),
        createIconButton(&apos;rotate-left&apos;, &apos;Rotate counterclockwise&apos;, function (button) {
          flipRotateOnAction(button, counterclockwiseRotate);
        }, false),
        createIconButton(&apos;rotate-right&apos;, &apos;Rotate clockwise&apos;, function (button) {
          flipRotateOnAction(button, clockwiseRotate);
        }, false),
        createSpacer(),
        createApplyButton()
      ];
      var FlipRotatePanel = Container.sketch({
        dom: panelDom,
        components: flipRotateComponents.map(function (mem) {
          return mem.asSpec();
        }),
        containerBehaviours: derive$1([config(&apos;image-tools-fliprotate-buttons-events&apos;, [
            run(external$2.disable(), function (comp, _se) {
              disableAllComponents(flipRotateComponents, comp);
            }),
            run(external$2.enable(), function (comp, _se) {
              enableAllComponents(flipRotateComponents, comp);
            })
          ])])
      });
      var makeSlider = function (label, onChoose, min, value, max) {
        var labelPart = Slider.parts().label({
          dom: {
            tag: &apos;label&apos;,
            classes: [&apos;tox-label&apos;],
            innerHtml: providersBackstage.translate(label)
          }
        });
        var spectrum = Slider.parts().spectrum({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-slider__rail&apos;],
            attributes: { role: &apos;presentation&apos; }
          }
        });
        var thumb = Slider.parts().thumb({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-slider__handle&apos;],
            attributes: { role: &apos;presentation&apos; }
          }
        });
        return record(Slider.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-slider&apos;],
            attributes: { role: &apos;presentation&apos; }
          },
          model: {
            mode: &apos;x&apos;,
            minX: min,
            maxX: max,
            getInitialValue: constant({ x: constant(value) })
          },
          components: [
            labelPart,
            spectrum,
            thumb
          ],
          sliderBehaviours: derive$1([Focusing.config({})]),
          onChoose: onChoose
        }));
      };
      var makeVariableSlider = function (label, transform, min, value, max) {
        var onChoose = function (slider, _thumb, value) {
          var valTransform = makeValueTransform(transform, value.x() / 100);
          emitTransform(slider, valTransform);
        };
        return makeSlider(label, onChoose, min, value, max);
      };
      var variableFilterPanelComponents = function (label, transform, min, value, max) {
        return [
          createBackButton(),
          makeVariableSlider(label, transform, min, value, max),
          createApplyButton()
        ];
      };
      var createVariableFilterPanel = function (label, transform, min, value, max) {
        var filterPanelComponents = variableFilterPanelComponents(label, transform, min, value, max);
        return Container.sketch({
          dom: panelDom,
          components: filterPanelComponents.map(function (mem) {
            return mem.asSpec();
          }),
          containerBehaviours: derive$1([config(&apos;image-tools-filter-panel-buttons-events&apos;, [
              run(external$2.disable(), function (comp, _se) {
                disableAllComponents(filterPanelComponents, comp);
              }),
              run(external$2.enable(), function (comp, _se) {
                enableAllComponents(filterPanelComponents, comp);
              })
            ])])
        });
      };
      var filterPanelComponents = [
        createBackButton(),
        createSpacer(),
        createApplyButton()
      ];
      var FilterPanel = Container.sketch({
        dom: panelDom,
        components: filterPanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var BrightnessPanel = createVariableFilterPanel(&apos;Brightness&apos;, brightness$1, -100, 0, 100);
      var ContrastPanel = createVariableFilterPanel(&apos;Contrast&apos;, contrast$1, -100, 0, 100);
      var GammaPanel = createVariableFilterPanel(&apos;Gamma&apos;, gamma$1, -100, 0, 100);
      var makeColorTransform = function (red, green, blue) {
        return function (ir) {
          return colorize$1(ir, red, green, blue);
        };
      };
      var makeColorSlider = function (label) {
        var onChoose = function (slider, _thumb, _value) {
          var redOpt = memRed.getOpt(slider);
          var blueOpt = memBlue.getOpt(slider);
          var greenOpt = memGreen.getOpt(slider);
          redOpt.each(function (red) {
            blueOpt.each(function (blue) {
              greenOpt.each(function (green) {
                var r = Representing.getValue(red).x() / 100;
                var g = Representing.getValue(green).x() / 100;
                var b = Representing.getValue(blue).x() / 100;
                var transform = makeColorTransform(r, g, b);
                emitTransform(slider, transform);
              });
            });
          });
        };
        return makeSlider(label, onChoose, 0, 100, 200);
      };
      var memRed = makeColorSlider(&apos;R&apos;);
      var memGreen = makeColorSlider(&apos;G&apos;);
      var memBlue = makeColorSlider(&apos;B&apos;);
      var colorizePanelComponents = [
        createBackButton(),
        memRed,
        memGreen,
        memBlue,
        createApplyButton()
      ];
      var ColorizePanel = Container.sketch({
        dom: panelDom,
        components: colorizePanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var getTransformPanelEvent = function (panel, transform, update) {
        return function (button) {
          var swap = function () {
            memContainer.getOpt(button).each(function (container) {
              Replacing.set(container, [panel]);
              update(container);
            });
          };
          emit$1(button, internal.swap(), {
            transform: transform,
            swap: swap
          });
        };
      };
      var cropPanelUpdate = function (_anyInSystem) {
        imagePanel.showCrop();
      };
      var resizePanelUpdate = function (anyInSystem) {
        memSize.getOpt(anyInSystem).each(function (sizeInput) {
          var measurements = imagePanel.getMeasurements();
          var width = measurements.width;
          var height = measurements.height;
          Representing.setValue(sizeInput, {
            width: width,
            height: height
          });
        });
      };
      var sharpenTransform = Option.some(sharpen$1);
      var invertTransform = Option.some(invert$1);
      var buttonPanelComponents = [
        createIconButton(&apos;crop&apos;, &apos;Crop&apos;, getTransformPanelEvent(CropPanel, Option.none(), cropPanelUpdate), false),
        createIconButton(&apos;resize&apos;, &apos;Resize&apos;, getTransformPanelEvent(ResizePanel, Option.none(), resizePanelUpdate), false),
        createIconButton(&apos;orientation&apos;, &apos;Orientation&apos;, getTransformPanelEvent(FlipRotatePanel, Option.none(), noop$1), false),
        createIconButton(&apos;brightness&apos;, &apos;Brightness&apos;, getTransformPanelEvent(BrightnessPanel, Option.none(), noop$1), false),
        createIconButton(&apos;sharpen&apos;, &apos;Sharpen&apos;, getTransformPanelEvent(FilterPanel, sharpenTransform, noop$1), false),
        createIconButton(&apos;contrast&apos;, &apos;Contrast&apos;, getTransformPanelEvent(ContrastPanel, Option.none(), noop$1), false),
        createIconButton(&apos;color-levels&apos;, &apos;Color levels&apos;, getTransformPanelEvent(ColorizePanel, Option.none(), noop$1), false),
        createIconButton(&apos;gamma&apos;, &apos;Gamma&apos;, getTransformPanelEvent(GammaPanel, Option.none(), noop$1), false),
        createIconButton(&apos;invert&apos;, &apos;Invert&apos;, getTransformPanelEvent(FilterPanel, invertTransform, noop$1), false)
      ];
      var ButtonPanel = Container.sketch({
        dom: panelDom,
        components: buttonPanelComponents.map(function (mem) {
          return mem.asSpec();
        })
      });
      var container = Container.sketch({
        dom: { tag: &apos;div&apos; },
        components: [ButtonPanel],
        containerBehaviours: derive$1([Replacing.config({})])
      });
      var memContainer = record(container);
      var getApplyButton = function (anyInSystem) {
        return memContainer.getOpt(anyInSystem).map(function (container) {
          var panel = container.components()[0];
          return panel.components()[panel.components().length - 1];
        });
      };
      return {
        memContainer: memContainer,
        getApplyButton: getApplyButton
      };
    };

    var global$b = tinymce.util.Tools.resolve(&apos;tinymce.dom.DomQuery&apos;);

    var global$c = tinymce.util.Tools.resolve(&apos;tinymce.geom.Rect&apos;);

    var global$d = tinymce.util.Tools.resolve(&apos;tinymce.util.Observable&apos;);

    var global$e = tinymce.util.Tools.resolve(&apos;tinymce.util.Tools&apos;);

    var global$f = tinymce.util.Tools.resolve(&apos;tinymce.util.VK&apos;);

    function getDocumentSize(doc) {
      var documentElement, body, scrollWidth, clientWidth;
      var offsetWidth, scrollHeight, clientHeight, offsetHeight;
      var max = Math.max;
      documentElement = doc.documentElement;
      body = doc.body;
      scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
      clientWidth = max(documentElement.clientWidth, body.clientWidth);
      offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
      scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
      clientHeight = max(documentElement.clientHeight, body.clientHeight);
      offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
      return {
        width: scrollWidth &lt; offsetWidth ? clientWidth : scrollWidth,
        height: scrollHeight &lt; offsetHeight ? clientHeight : scrollHeight
      };
    }
    function updateWithTouchData(e) {
      var keys, i;
      if (e.changedTouches) {
        keys = &apos;screenX screenY pageX pageY clientX clientY&apos;.split(&apos; &apos;);
        for (i = 0; i &lt; keys.length; i++) {
          e[keys[i]] = e.changedTouches[0][keys[i]];
        }
      }
    }
    function DragHelper (id, settings) {
      var $eventOverlay;
      var doc = settings.document || domGlobals.document;
      var downButton;
      var start, stop, drag, startX, startY;
      settings = settings || {};
      var handleElement = doc.getElementById(settings.handle || id);
      start = function (e) {
        var docSize = getDocumentSize(doc);
        var handleElm, cursor;
        updateWithTouchData(e);
        e.preventDefault();
        downButton = e.button;
        handleElm = handleElement;
        startX = e.screenX;
        startY = e.screenY;
        if (domGlobals.window.getComputedStyle) {
          cursor = domGlobals.window.getComputedStyle(handleElm, null).getPropertyValue(&apos;cursor&apos;);
        } else {
          cursor = handleElm.runtimeStyle.cursor;
        }
        $eventOverlay = global$b(&apos;&lt;div&gt;&lt;/div&gt;&apos;).css({
          position: &apos;absolute&apos;,
          top: 0,
          left: 0,
          width: docSize.width,
          height: docSize.height,
          zIndex: 2147483647,
          opacity: 0.0001,
          cursor: cursor
        }).appendTo(doc.body);
        global$b(doc).on(&apos;mousemove touchmove&apos;, drag).on(&apos;mouseup touchend&apos;, stop);
        settings.start(e);
      };
      drag = function (e) {
        updateWithTouchData(e);
        if (e.button !== downButton) {
          return stop(e);
        }
        e.deltaX = e.screenX - startX;
        e.deltaY = e.screenY - startY;
        e.preventDefault();
        settings.drag(e);
      };
      stop = function (e) {
        updateWithTouchData(e);
        global$b(doc).off(&apos;mousemove touchmove&apos;, drag).off(&apos;mouseup touchend&apos;, stop);
        $eventOverlay.remove();
        if (settings.stop) {
          settings.stop(e);
        }
      };
      this.destroy = function () {
        global$b(handleElement).off();
      };
      global$b(handleElement).on(&apos;mousedown touchstart&apos;, start);
    }

    var count = 0;
    var create$7 = function (currentRect, viewPortRect, clampRect, containerElm, action) {
      var instance;
      var dragHelpers;
      var blockers;
      var prefix = &apos;tox-&apos;;
      var id = prefix + &apos;crid-&apos; + count++;
      var handles = [
        {
          name: &apos;move&apos;,
          xMul: 0,
          yMul: 0,
          deltaX: 1,
          deltaY: 1,
          deltaW: 0,
          deltaH: 0,
          label: &apos;Crop Mask&apos;
        },
        {
          name: &apos;nw&apos;,
          xMul: 0,
          yMul: 0,
          deltaX: 1,
          deltaY: 1,
          deltaW: -1,
          deltaH: -1,
          label: &apos;Top Left Crop Handle&apos;
        },
        {
          name: &apos;ne&apos;,
          xMul: 1,
          yMul: 0,
          deltaX: 0,
          deltaY: 1,
          deltaW: 1,
          deltaH: -1,
          label: &apos;Top Right Crop Handle&apos;
        },
        {
          name: &apos;sw&apos;,
          xMul: 0,
          yMul: 1,
          deltaX: 1,
          deltaY: 0,
          deltaW: -1,
          deltaH: 1,
          label: &apos;Bottom Left Crop Handle&apos;
        },
        {
          name: &apos;se&apos;,
          xMul: 1,
          yMul: 1,
          deltaX: 0,
          deltaY: 0,
          deltaW: 1,
          deltaH: 1,
          label: &apos;Bottom Right Crop Handle&apos;
        }
      ];
      blockers = [
        &apos;top&apos;,
        &apos;right&apos;,
        &apos;bottom&apos;,
        &apos;left&apos;
      ];
      var getAbsoluteRect = function (outerRect, relativeRect) {
        return {
          x: relativeRect.x + outerRect.x,
          y: relativeRect.y + outerRect.y,
          w: relativeRect.w,
          h: relativeRect.h
        };
      };
      var getRelativeRect = function (outerRect, innerRect) {
        return {
          x: innerRect.x - outerRect.x,
          y: innerRect.y - outerRect.y,
          w: innerRect.w,
          h: innerRect.h
        };
      };
      var getInnerRect = function () {
        return getRelativeRect(clampRect, currentRect);
      };
      function moveRect(handle, startRect, deltaX, deltaY) {
        var x, y, w, h, rect;
        x = startRect.x;
        y = startRect.y;
        w = startRect.w;
        h = startRect.h;
        x += deltaX * handle.deltaX;
        y += deltaY * handle.deltaY;
        w += deltaX * handle.deltaW;
        h += deltaY * handle.deltaH;
        if (w &lt; 20) {
          w = 20;
        }
        if (h &lt; 20) {
          h = 20;
        }
        rect = currentRect = global$c.clamp({
          x: x,
          y: y,
          w: w,
          h: h
        }, clampRect, handle.name === &apos;move&apos;);
        rect = getRelativeRect(clampRect, rect);
        instance.fire(&apos;updateRect&apos;, { rect: rect });
        setInnerRect(rect);
      }
      function render() {
        function createDragHelper(handle) {
          var startRect;
          return new DragHelper(id, {
            document: containerElm.ownerDocument,
            handle: id + &apos;-&apos; + handle.name,
            start: function () {
              startRect = currentRect;
            },
            drag: function (e) {
              moveRect(handle, startRect, e.deltaX, e.deltaY);
            }
          });
        }
        global$b(&apos;&lt;div id=&quot;&apos; + id + &apos;&quot; class=&quot;&apos; + prefix + &apos;croprect-container&quot;&apos; + &apos; role=&quot;grid&quot; aria-dropeffect=&quot;execute&quot;&gt;&apos;).appendTo(containerElm);
        global$e.each(blockers, function (blocker) {
          global$b(&apos;#&apos; + id, containerElm).append(&apos;&lt;div id=&quot;&apos; + id + &apos;-&apos; + blocker + &apos;&quot;class=&quot;&apos; + prefix + &apos;croprect-block&quot; style=&quot;display: none&quot; data-mce-bogus=&quot;all&quot;&gt;&apos;);
        });
        global$e.each(handles, function (handle) {
          global$b(&apos;#&apos; + id, containerElm).append(&apos;&lt;div id=&quot;&apos; + id + &apos;-&apos; + handle.name + &apos;&quot; class=&quot;&apos; + prefix + &apos;croprect-handle &apos; + prefix + &apos;croprect-handle-&apos; + handle.name + &apos;&quot;&apos; + &apos;style=&quot;display: none&quot; data-mce-bogus=&quot;all&quot; role=&quot;gridcell&quot; tabindex=&quot;-1&quot;&apos; + &apos; aria-label=&quot;&apos; + handle.label + &apos;&quot; aria-grabbed=&quot;false&quot; title=&quot;&apos; + handle.label + &apos;&quot;&gt;&apos;);
        });
        dragHelpers = global$e.map(handles, createDragHelper);
        repaint(currentRect);
        global$b(containerElm).on(&apos;focusin focusout&apos;, function (e) {
          global$b(e.target).attr(&apos;aria-grabbed&apos;, e.type === &apos;focus&apos; ? &apos;true&apos; : &apos;false&apos;);
        });
        global$b(containerElm).on(&apos;keydown&apos;, function (e) {
          var activeHandle;
          global$e.each(handles, function (handle) {
            if (e.target.id === id + &apos;-&apos; + handle.name) {
              activeHandle = handle;
              return false;
            }
          });
          function moveAndBlock(evt, handle, startRect, deltaX, deltaY) {
            evt.stopPropagation();
            evt.preventDefault();
            moveRect(activeHandle, startRect, deltaX, deltaY);
          }
          switch (e.keyCode) {
          case global$f.LEFT:
            moveAndBlock(e, activeHandle, currentRect, -10, 0);
            break;
          case global$f.RIGHT:
            moveAndBlock(e, activeHandle, currentRect, 10, 0);
            break;
          case global$f.UP:
            moveAndBlock(e, activeHandle, currentRect, 0, -10);
            break;
          case global$f.DOWN:
            moveAndBlock(e, activeHandle, currentRect, 0, 10);
            break;
          case global$f.ENTER:
          case global$f.SPACEBAR:
            e.preventDefault();
            action();
            break;
          }
        });
      }
      function toggleVisibility(state) {
        var selectors;
        selectors = global$e.map(handles, function (handle) {
          return &apos;#&apos; + id + &apos;-&apos; + handle.name;
        }).concat(global$e.map(blockers, function (blocker) {
          return &apos;#&apos; + id + &apos;-&apos; + blocker;
        })).join(&apos;,&apos;);
        if (state) {
          global$b(selectors, containerElm).show();
        } else {
          global$b(selectors, containerElm).hide();
        }
      }
      function repaint(rect) {
        function updateElementRect(name, rect) {
          if (rect.h &lt; 0) {
            rect.h = 0;
          }
          if (rect.w &lt; 0) {
            rect.w = 0;
          }
          global$b(&apos;#&apos; + id + &apos;-&apos; + name, containerElm).css({
            left: rect.x,
            top: rect.y,
            width: rect.w,
            height: rect.h
          });
        }
        global$e.each(handles, function (handle) {
          global$b(&apos;#&apos; + id + &apos;-&apos; + handle.name, containerElm).css({
            left: rect.w * handle.xMul + rect.x,
            top: rect.h * handle.yMul + rect.y
          });
        });
        updateElementRect(&apos;top&apos;, {
          x: viewPortRect.x,
          y: viewPortRect.y,
          w: viewPortRect.w,
          h: rect.y - viewPortRect.y
        });
        updateElementRect(&apos;right&apos;, {
          x: rect.x + rect.w,
          y: rect.y,
          w: viewPortRect.w - rect.x - rect.w + viewPortRect.x,
          h: rect.h
        });
        updateElementRect(&apos;bottom&apos;, {
          x: viewPortRect.x,
          y: rect.y + rect.h,
          w: viewPortRect.w,
          h: viewPortRect.h - rect.y - rect.h + viewPortRect.y
        });
        updateElementRect(&apos;left&apos;, {
          x: viewPortRect.x,
          y: rect.y,
          w: rect.x - viewPortRect.x,
          h: rect.h
        });
        updateElementRect(&apos;move&apos;, rect);
      }
      function setRect(rect) {
        currentRect = rect;
        repaint(currentRect);
      }
      function setViewPortRect(rect) {
        viewPortRect = rect;
        repaint(currentRect);
      }
      function setInnerRect(rect) {
        setRect(getAbsoluteRect(clampRect, rect));
      }
      function setClampRect(rect) {
        clampRect = rect;
        repaint(currentRect);
      }
      function destroy() {
        global$e.each(dragHelpers, function (helper) {
          helper.destroy();
        });
        dragHelpers = [];
      }
      render();
      instance = global$e.extend({
        toggleVisibility: toggleVisibility,
        setClampRect: setClampRect,
        setRect: setRect,
        getInnerRect: getInnerRect,
        setInnerRect: setInnerRect,
        setViewPortRect: setViewPortRect,
        destroy: destroy
      }, global$d);
      return instance;
    };
    var CropRect = { create: create$7 };

    var loadImage = function (image) {
      return new global$4(function (resolve) {
        var loaded = function () {
          image.removeEventListener(&apos;load&apos;, loaded);
          resolve(image);
        };
        if (image.complete) {
          resolve(image);
        } else {
          image.addEventListener(&apos;load&apos;, loaded);
        }
      });
    };
    var renderImagePanel = function (initialUrl) {
      var memBg = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-image-tools__image-bg&apos;],
          attributes: { role: &apos;presentation&apos; }
        }
      });
      var zoomState = Cell(1);
      var cropRect = Cell(Option.none());
      var rectState = Cell({
        x: 0,
        y: 0,
        w: 1,
        h: 1
      });
      var viewRectState = Cell({
        x: 0,
        y: 0,
        w: 1,
        h: 1
      });
      var repaintImg = function (anyInSystem, img) {
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var zoom = zoomState.get();
          var panelW = get$7(panel.element());
          var panelH = get$6(panel.element());
          var width = img.dom().naturalWidth * zoom;
          var height = img.dom().naturalHeight * zoom;
          var left = Math.max(0, panelW / 2 - width / 2);
          var top = Math.max(0, panelH / 2 - height / 2);
          var css = {
            left: left.toString() + &apos;px&apos;,
            top: top.toString() + &apos;px&apos;,
            width: width.toString() + &apos;px&apos;,
            height: height.toString() + &apos;px&apos;,
            position: &apos;absolute&apos;
          };
          setAll$1(img, css);
          memBg.getOpt(panel).each(function (bg) {
            setAll$1(bg.element(), css);
          });
          cropRect.get().each(function (cRect) {
            var rect = rectState.get();
            cRect.setRect({
              x: rect.x * zoom + left,
              y: rect.y * zoom + top,
              w: rect.w * zoom,
              h: rect.h * zoom
            });
            cRect.setClampRect({
              x: left,
              y: top,
              w: width,
              h: height
            });
            cRect.setViewPortRect({
              x: 0,
              y: 0,
              w: panelW,
              h: panelH
            });
          });
        });
      };
      var zoomFit = function (anyInSystem, img) {
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var panelW = get$7(panel.element());
          var panelH = get$6(panel.element());
          var width = img.dom().naturalWidth;
          var height = img.dom().naturalHeight;
          var zoom = Math.min(panelW / width, panelH / height);
          if (zoom &gt;= 1) {
            zoomState.set(1);
          } else {
            zoomState.set(zoom);
          }
        });
      };
      var updateSrc = function (anyInSystem, url) {
        var img = Element.fromTag(&apos;img&apos;);
        set$1(img, &apos;src&apos;, url);
        return loadImage(img.dom()).then(function () {
          return memContainer.getOpt(anyInSystem).map(function (panel) {
            var aImg = external({ element: img });
            Replacing.replaceAt(panel, 1, Option.some(aImg));
            var lastViewRect = viewRectState.get();
            var viewRect = {
              x: 0,
              y: 0,
              w: img.dom().naturalWidth,
              h: img.dom().naturalHeight
            };
            viewRectState.set(viewRect);
            var rect = global$c.inflate(viewRect, -20, -20);
            rectState.set(rect);
            if (lastViewRect.w !== viewRect.w || lastViewRect.h !== viewRect.h) {
              zoomFit(panel, img);
            }
            repaintImg(panel, img);
            return img;
          });
        });
      };
      var zoom = function (anyInSystem, direction) {
        var currentZoom = zoomState.get();
        var newZoom = direction &gt; 0 ? Math.min(2, currentZoom + 0.1) : Math.max(0.1, currentZoom - 0.1);
        zoomState.set(newZoom);
        memContainer.getOpt(anyInSystem).each(function (panel) {
          var img = panel.components()[1].element();
          repaintImg(panel, img);
        });
      };
      var showCrop = function () {
        cropRect.get().each(function (cRect) {
          cRect.toggleVisibility(true);
        });
      };
      var hideCrop = function () {
        cropRect.get().each(function (cRect) {
          cRect.toggleVisibility(false);
        });
      };
      var getRect = function () {
        return rectState.get();
      };
      var container = Container.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-image-tools__image&apos;]
        },
        components: [
          memBg.asSpec(),
          {
            dom: {
              tag: &apos;img&apos;,
              attributes: { src: initialUrl }
            }
          },
          {
            dom: { tag: &apos;div&apos; },
            behaviours: derive$1([config(&apos;image-panel-crop-events&apos;, [runOnAttached(function (comp) {
                  memContainer.getOpt(comp).each(function (container) {
                    var el = container.element().dom();
                    var cRect = CropRect.create({
                      x: 10,
                      y: 10,
                      w: 100,
                      h: 100
                    }, {
                      x: 0,
                      y: 0,
                      w: 200,
                      h: 200
                    }, {
                      x: 0,
                      y: 0,
                      w: 200,
                      h: 200
                    }, el, function () {
                    });
                    cRect.toggleVisibility(false);
                    cRect.on(&apos;updateRect&apos;, function (e) {
                      var rect = e.rect;
                      var zoom = zoomState.get();
                      var newRect = {
                        x: Math.round(rect.x / zoom),
                        y: Math.round(rect.y / zoom),
                        w: Math.round(rect.w / zoom),
                        h: Math.round(rect.h / zoom)
                      };
                      rectState.set(newRect);
                    });
                    cropRect.set(Option.some(cRect));
                  });
                })])])
          }
        ],
        containerBehaviours: derive$1([
          Replacing.config({}),
          config(&apos;image-panel-events&apos;, [runOnAttached(function (comp) {
              updateSrc(comp, initialUrl);
            })])
        ])
      });
      var memContainer = record(container);
      var getMeasurements = function () {
        var viewRect = viewRectState.get();
        return {
          width: viewRect.w,
          height: viewRect.h
        };
      };
      return {
        memContainer: memContainer,
        updateSrc: updateSrc,
        zoom: zoom,
        showCrop: showCrop,
        hideCrop: hideCrop,
        getRect: getRect,
        getMeasurements: getMeasurements
      };
    };

    var createButton = function (innerHtml, icon, disabled, action, providersBackstage) {
      return renderIconButton({
        name: innerHtml,
        icon: Option.some(icon),
        disabled: disabled,
        tooltip: Option.some(innerHtml),
        primary: false,
        borderless: false
      }, action, providersBackstage);
    };
    var setButtonEnabled = function (button, enabled) {
      if (enabled) {
        Disabling.enable(button);
      } else {
        Disabling.disable(button);
      }
    };
    var renderSideBar = function (providersBackstage) {
      var updateButtonUndoStates = function (anyInSystem, undoEnabled, redoEnabled) {
        memUndo.getOpt(anyInSystem).each(function (undo) {
          setButtonEnabled(undo, undoEnabled);
        });
        memRedo.getOpt(anyInSystem).each(function (redo) {
          setButtonEnabled(redo, redoEnabled);
        });
      };
      var memUndo = record(createButton(&apos;Undo&apos;, &apos;undo&apos;, true, function (button) {
        emitWith(button, internal.undo(), { direction: 1 });
      }, providersBackstage));
      var memRedo = record(createButton(&apos;Redo&apos;, &apos;redo&apos;, true, function (button) {
        emitWith(button, internal.redo(), { direction: 1 });
      }, providersBackstage));
      var container = Container.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-image-tools__toolbar&apos;,
            &apos;tox-image-tools__sidebar&apos;
          ]
        },
        components: [
          memUndo.asSpec(),
          memRedo.asSpec(),
          createButton(&apos;Zoom in&apos;, &apos;zoom-in&apos;, false, function (button) {
            emitWith(button, internal.zoom(), { direction: 1 });
          }, providersBackstage),
          createButton(&apos;Zoom out&apos;, &apos;zoom-out&apos;, false, function (button) {
            emitWith(button, internal.zoom(), { direction: -1 });
          }, providersBackstage)
        ]
      });
      return {
        container: container,
        updateButtonUndoStates: updateButtonUndoStates
      };
    };

    function UndoStack () {
      var data = [];
      var index = -1;
      function add(state) {
        var removed;
        removed = data.splice(++index);
        data.push(state);
        return {
          state: state,
          removed: removed
        };
      }
      function undo() {
        if (canUndo()) {
          return data[--index];
        }
      }
      function redo() {
        if (canRedo()) {
          return data[++index];
        }
      }
      function canUndo() {
        return index &gt; 0;
      }
      function canRedo() {
        return index !== -1 &amp;&amp; index &lt; data.length - 1;
      }
      return {
        data: data,
        add: add,
        undo: undo,
        redo: redo,
        canUndo: canUndo,
        canRedo: canRedo
      };
    }

    var makeState = function (initialState) {
      var blobState = Cell(initialState);
      var tempState = Cell(Option.none());
      var undoStack = UndoStack();
      undoStack.add(initialState);
      var getBlobState = function () {
        return blobState.get();
      };
      var setBlobState = function (state) {
        blobState.set(state);
      };
      var getTempState = function () {
        return tempState.get().fold(function () {
          return blobState.get();
        }, function (temp) {
          return temp;
        });
      };
      var updateTempState = function (blob) {
        var newTempState = createState(blob);
        destroyTempState();
        tempState.set(Option.some(newTempState));
        return newTempState.url;
      };
      var createState = function (blob) {
        return {
          blob: blob,
          url: domGlobals.URL.createObjectURL(blob)
        };
      };
      var destroyState = function (state) {
        domGlobals.URL.revokeObjectURL(state.url);
      };
      var destroyStates = function (states) {
        global$e.each(states, destroyState);
      };
      var destroyTempState = function () {
        tempState.get().each(destroyState);
        tempState.set(Option.none());
      };
      var addBlobState = function (blob) {
        var newState = createState(blob);
        setBlobState(newState);
        var removed = undoStack.add(newState).removed;
        destroyStates(removed);
        return newState.url;
      };
      var addTempState = function (blob) {
        var newState = createState(blob);
        tempState.set(Option.some(newState));
        return newState.url;
      };
      var applyTempState = function (postApply) {
        return tempState.get().fold(function () {
        }, function (temp) {
          addBlobState(temp.blob);
          postApply();
        });
      };
      var undo = function () {
        var currentState = undoStack.undo();
        setBlobState(currentState);
        return currentState.url;
      };
      var redo = function () {
        var currentState = undoStack.redo();
        setBlobState(currentState);
        return currentState.url;
      };
      var getHistoryStates = function () {
        var undoEnabled = undoStack.canUndo();
        var redoEnabled = undoStack.canRedo();
        return {
          undoEnabled: undoEnabled,
          redoEnabled: redoEnabled
        };
      };
      return {
        getBlobState: getBlobState,
        setBlobState: setBlobState,
        addBlobState: addBlobState,
        getTempState: getTempState,
        updateTempState: updateTempState,
        addTempState: addTempState,
        applyTempState: applyTempState,
        destroyTempState: destroyTempState,
        undo: undo,
        redo: redo,
        getHistoryStates: getHistoryStates
      };
    };

    var renderImageTools = function (detail, providersBackstage) {
      var state = makeState(detail.currentState);
      var zoom = function (anyInSystem, simulatedEvent) {
        var direction = simulatedEvent.event().direction();
        imagePanel.zoom(anyInSystem, direction);
      };
      var updateButtonUndoStates = function (anyInSystem) {
        var historyStates = state.getHistoryStates();
        sideBar.updateButtonUndoStates(anyInSystem, historyStates.undoEnabled, historyStates.redoEnabled);
        emitWith(anyInSystem, external$2.formActionEvent, {
          name: external$2.saveState(),
          value: historyStates.undoEnabled
        });
      };
      var disableUndoRedo = function (anyInSystem) {
        sideBar.updateButtonUndoStates(anyInSystem, false, false);
      };
      var undo = function (anyInSystem, _simulatedEvent) {
        var url = state.undo();
        updateSrc(anyInSystem, url).then(function (_oImg) {
          unblock(anyInSystem);
          updateButtonUndoStates(anyInSystem);
        });
      };
      var redo = function (anyInSystem, _simulatedEvent) {
        var url = state.redo();
        updateSrc(anyInSystem, url).then(function (_oImg) {
          unblock(anyInSystem);
          updateButtonUndoStates(anyInSystem);
        });
      };
      var imageResultToBlob = function (ir) {
        return ir.toBlob();
      };
      var block = function (anyInSystem) {
        emitWith(anyInSystem, external$2.formActionEvent, {
          name: external$2.disable(),
          value: {}
        });
      };
      var unblock = function (anyInSystem) {
        editPanel.getApplyButton(anyInSystem).each(function (applyButton) {
          Disabling.enable(applyButton);
        });
        emitWith(anyInSystem, external$2.formActionEvent, {
          name: external$2.enable(),
          value: {}
        });
      };
      var updateSrc = function (anyInSystem, src) {
        block(anyInSystem);
        return imagePanel.updateSrc(anyInSystem, src);
      };
      var blobManipulate = function (anyInSystem, blob, filter, action, swap) {
        block(anyInSystem);
        return blobToImageResult(blob).then(filter).then(imageResultToBlob).then(action).then(function (url) {
          return updateSrc(anyInSystem, url).then(function (oImg) {
            updateButtonUndoStates(anyInSystem);
            swap();
            unblock(anyInSystem);
            return oImg;
          });
        }).catch(function (err) {
          domGlobals.console.log(err);
          unblock(anyInSystem);
          return err;
        });
      };
      var manipulate = function (anyInSystem, filter, swap) {
        var blob = state.getBlobState().blob;
        var action = function (blob) {
          return state.updateTempState(blob);
        };
        blobManipulate(anyInSystem, blob, filter, action, swap);
      };
      var tempManipulate = function (anyInSystem, filter) {
        var blob = state.getTempState().blob;
        var action = function (blob) {
          return state.addTempState(blob);
        };
        blobManipulate(anyInSystem, blob, filter, action, noop);
      };
      var manipulateApply = function (anyInSystem, filter, swap) {
        var blob = state.getBlobState().blob;
        var action = function (blob) {
          var url = state.addBlobState(blob);
          destroyTempState(anyInSystem);
          return url;
        };
        blobManipulate(anyInSystem, blob, filter, action, swap);
      };
      var apply = function (anyInSystem, simulatedEvent) {
        var postApply = function () {
          destroyTempState(anyInSystem);
          var swap = simulatedEvent.event().swap();
          swap();
        };
        state.applyTempState(postApply);
      };
      var destroyTempState = function (anyInSystem) {
        var currentUrl = state.getBlobState().url;
        state.destroyTempState();
        updateButtonUndoStates(anyInSystem);
        return currentUrl;
      };
      var cancel = function (anyInSystem) {
        var currentUrl = destroyTempState(anyInSystem);
        updateSrc(anyInSystem, currentUrl).then(function (_oImg) {
          unblock(anyInSystem);
        });
      };
      var back = function (anyInSystem, simulatedEvent) {
        cancel(anyInSystem);
        var swap = simulatedEvent.event().swap();
        swap();
        imagePanel.hideCrop();
      };
      var transform = function (anyInSystem, simulatedEvent) {
        return manipulate(anyInSystem, simulatedEvent.event().transform(), noop);
      };
      var tempTransform = function (anyInSystem, simulatedEvent) {
        return tempManipulate(anyInSystem, simulatedEvent.event().transform());
      };
      var transformApply = function (anyInSystem, simulatedEvent) {
        return manipulateApply(anyInSystem, simulatedEvent.event().transform(), simulatedEvent.event().swap());
      };
      var imagePanel = renderImagePanel(detail.currentState.url);
      var sideBar = renderSideBar(providersBackstage);
      var editPanel = renderEditPanel(imagePanel, providersBackstage);
      var swap = function (anyInSystem, simulatedEvent) {
        disableUndoRedo(anyInSystem);
        var transform = simulatedEvent.event().transform();
        var swap = simulatedEvent.event().swap();
        transform.fold(function () {
          swap();
        }, function (transform) {
          manipulate(anyInSystem, transform, swap);
        });
      };
      return {
        dom: {
          tag: &apos;div&apos;,
          attributes: { role: &apos;presentation&apos; }
        },
        components: [
          editPanel.memContainer.asSpec(),
          imagePanel.memContainer.asSpec(),
          sideBar.container
        ],
        behaviours: derive$1([
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function () {
                return state.getBlobState();
              }
            }
          }),
          config(&apos;image-tools-events&apos;, [
            run(internal.undo(), undo),
            run(internal.redo(), redo),
            run(internal.zoom(), zoom),
            run(internal.back(), back),
            run(internal.apply(), apply),
            run(internal.transform(), transform),
            run(internal.tempTransform(), tempTransform),
            run(internal.transformApply(), transformApply),
            run(internal.swap(), swap)
          ]),
          ComposingConfigs.self()
        ])
      };
    };

    var factory$8 = function (detail, _spec) {
      var options = map(detail.options, function (option) {
        return {
          dom: {
            tag: &apos;option&apos;,
            value: option.value,
            innerHtml: option.text
          }
        };
      });
      var initialValues = detail.data.map(function (v) {
        return wrap$1(&apos;initialValue&apos;, v);
      }).getOr({});
      return {
        uid: detail.uid,
        dom: {
          tag: &apos;select&apos;,
          classes: detail.selectClasses,
          attributes: detail.selectAttributes
        },
        components: options,
        behaviours: augment(detail.selectBehaviours, [
          Focusing.config({}),
          Representing.config({
            store: __assign({
              mode: &apos;manual&apos;,
              getValue: function (select) {
                return get$5(select.element());
              },
              setValue: function (select, newValue) {
                var found = find(detail.options, function (opt) {
                  return opt.value === newValue;
                });
                if (found.isSome()) {
                  set$3(select.element(), newValue);
                }
              }
            }, initialValues)
          })
        ])
      };
    };
    var HtmlSelect = single$2({
      name: &apos;HtmlSelect&apos;,
      configFields: [
        strict$1(&apos;options&apos;),
        field$1(&apos;selectBehaviours&apos;, [
          Focusing,
          Representing
        ]),
        defaulted$1(&apos;selectClasses&apos;, []),
        defaulted$1(&apos;selectAttributes&apos;, {}),
        option(&apos;data&apos;)
      ],
      factory: factory$8
    });

    var renderSelectBox = function (spec, providersBackstage) {
      var translatedOptions = map(spec.items, function (item) {
        return {
          text: providersBackstage.translate(item.text),
          value: item.value
        };
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var pField = FormField.parts().field({
        dom: {},
        selectAttributes: { size: spec.size },
        options: translatedOptions,
        factory: HtmlSelect,
        selectBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            }
          }),
          Tabstopping.config({}),
          config(&apos;selectbox-change&apos;, [run(change(), function (component, _) {
              emitWith(component, formChangeEvent, { name: spec.name });
            })])
        ])
      });
      var chevron = spec.size &gt; 1 ? Option.none() : Option.some({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-selectfield__icon-js&apos;],
          innerHtml: get$d(&apos;chevron-down&apos;, providersBackstage.icons)
        }
      });
      var selectWrap = {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-selectfield&apos;]
        },
        components: flatten([
          [pField],
          chevron.toArray()
        ])
      };
      return FormField.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-form__group&apos;]
        },
        components: flatten([
          pLabel.toArray(),
          [selectWrap]
        ]),
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            },
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
            }
          }),
          receivingConfig()
        ])
      });
    };

    var renderTextField = function (spec, providersBackstage) {
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var baseInputBehaviours = [
        Disabling.config({
          disabled: function () {
            return spec.disabled || providersBackstage.isReadOnly();
          }
        }),
        receivingConfig(),
        Keying.config({
          mode: &apos;execution&apos;,
          useEnter: spec.multiline !== true,
          useControlEnter: spec.multiline === true,
          execute: function (comp) {
            emit(comp, formSubmitEvent);
            return Option.some(true);
          }
        }),
        config(&apos;textfield-change&apos;, [
          run(input(), function (component, _) {
            emitWith(component, formChangeEvent, { name: spec.name });
          }),
          run(postPaste(), function (component, _) {
            emitWith(component, formChangeEvent, { name: spec.name });
          })
        ]),
        Tabstopping.config({})
      ];
      var validatingBehaviours = spec.validation.map(function (vl) {
        return Invalidating.config({
          getRoot: function (input) {
            return parent(input.element());
          },
          invalidClass: &apos;tox-invalid&apos;,
          validator: {
            validate: function (input) {
              var v = Representing.getValue(input);
              var result = vl.validator(v);
              return Future.pure(result === true ? Result.value(v) : Result.error(result));
            },
            validateOnLoad: vl.validateOnLoad
          }
        });
      }).toArray();
      var placeholder = spec.placeholder.fold(constant({}), function (p) {
        return { placeholder: providersBackstage.translate(p) };
      });
      var inputMode = spec.inputMode.fold(constant({}), function (mode) {
        return { inputmode: mode };
      });
      var inputAttributes = __assign(__assign({}, placeholder), inputMode);
      var pField = FormField.parts().field({
        tag: spec.multiline === true ? &apos;textarea&apos; : &apos;input&apos;,
        inputAttributes: inputAttributes,
        inputClasses: [spec.classname],
        inputBehaviours: derive$1(flatten([
          baseInputBehaviours,
          validatingBehaviours
        ])),
        selectOnFocus: false,
        factory: Input
      });
      var extraClasses = spec.flex ? [&apos;tox-form__group--stretched&apos;] : [];
      var extraClasses2 = extraClasses.concat(spec.maximized ? [&apos;tox-form-group--maximize&apos;] : []);
      var extraBehaviours = [
        Disabling.config({
          disabled: function () {
            return spec.disabled || providersBackstage.isReadOnly();
          },
          onDisabled: function (comp) {
            FormField.getField(comp).each(Disabling.disable);
          },
          onEnabled: function (comp) {
            FormField.getField(comp).each(Disabling.enable);
          }
        }),
        receivingConfig()
      ];
      return renderFormFieldWith(pLabel, pField, extraClasses2, extraBehaviours);
    };
    var renderInput = function (spec, providersBackstage) {
      return renderTextField({
        name: spec.name,
        multiline: false,
        label: spec.label,
        inputMode: spec.inputMode,
        placeholder: spec.placeholder,
        flex: false,
        disabled: spec.disabled,
        classname: &apos;tox-textfield&apos;,
        validation: Option.none(),
        maximized: spec.maximized
      }, providersBackstage);
    };
    var renderTextarea = function (spec, providersBackstage) {
      return renderTextField({
        name: spec.name,
        multiline: true,
        label: spec.label,
        inputMode: Option.none(),
        placeholder: spec.placeholder,
        flex: true,
        disabled: spec.disabled,
        classname: &apos;tox-textarea&apos;,
        validation: Option.none(),
        maximized: spec.maximized
      }, providersBackstage);
    };

    var events$c = function (streamConfig, streamState) {
      var streams = streamConfig.stream.streams;
      var processor = streams.setup(streamConfig, streamState);
      return derive([
        run(streamConfig.event, processor),
        runOnDetached(function () {
          return streamState.cancel();
        })
      ].concat(streamConfig.cancelEvent.map(function (e) {
        return [run(e, function () {
            return streamState.cancel();
          })];
      }).getOr([])));
    };

    var ActiveStreaming = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$c
    });

    var throttle = function (_config) {
      var state = Cell(null);
      var readState = function () {
        return { timer: state.get() !== null ? &apos;set&apos; : &apos;unset&apos; };
      };
      var setTimer = function (t) {
        state.set(t);
      };
      var cancel = function () {
        var t = state.get();
        if (t !== null) {
          t.cancel();
        }
      };
      return nu$5({
        readState: readState,
        setTimer: setTimer,
        cancel: cancel
      });
    };
    var init$6 = function (spec) {
      return spec.stream.streams.state(spec);
    };

    var StreamingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        throttle: throttle,
        init: init$6
    });

    var setup$2 = function (streamInfo, streamState) {
      var sInfo = streamInfo.stream;
      var throttler = last$2(streamInfo.onStream, sInfo.delay);
      streamState.setTimer(throttler);
      return function (component, simulatedEvent) {
        throttler.throttle(component, simulatedEvent);
        if (sInfo.stopEvent) {
          simulatedEvent.stop();
        }
      };
    };
    var StreamingSchema = [
      strictOf(&apos;stream&apos;, choose$1(&apos;mode&apos;, {
        throttle: [
          strict$1(&apos;delay&apos;),
          defaulted$1(&apos;stopEvent&apos;, true),
          output(&apos;streams&apos;, {
            setup: setup$2,
            state: throttle
          })
        ]
      })),
      defaulted$1(&apos;event&apos;, &apos;input&apos;),
      option(&apos;cancelEvent&apos;),
      onStrictHandler(&apos;onStream&apos;)
    ];

    var Streaming = create$1({
      fields: StreamingSchema,
      name: &apos;streaming&apos;,
      active: ActiveStreaming,
      state: StreamingState
    });

    var setValueFromItem = function (model, input, item) {
      var itemData = Representing.getValue(item);
      Representing.setValue(input, itemData);
      setCursorAtEnd(input);
    };
    var setSelectionOn = function (input, f) {
      var el = input.element();
      var value = get$5(el);
      var node = el.dom();
      if (get$2(el, &apos;type&apos;) !== &apos;number&apos;) {
        f(node, value);
      }
    };
    var setCursorAtEnd = function (input) {
      setSelectionOn(input, function (node, value) {
        return node.setSelectionRange(value.length, value.length);
      });
    };
    var setSelectionToEnd = function (input, startOffset) {
      setSelectionOn(input, function (node, value) {
        return node.setSelectionRange(startOffset, value.length);
      });
    };
    var attemptSelectOver = function (model, input, item) {
      if (!model.selectsOver) {
        return Option.none();
      } else {
        var currentValue = Representing.getValue(input);
        var inputDisplay_1 = model.getDisplayText(currentValue);
        var itemValue = Representing.getValue(item);
        var itemDisplay = model.getDisplayText(itemValue);
        return itemDisplay.indexOf(inputDisplay_1) === 0 ? Option.some(function () {
          setValueFromItem(model, input, item);
          setSelectionToEnd(input, inputDisplay_1.length);
        }) : Option.none();
      }
    };

    var itemExecute = constant(&apos;alloy.typeahead.itemexecute&apos;);

    var make$5 = function (detail, components, spec, externals) {
      var navigateList = function (comp, simulatedEvent, highlighter) {
        detail.previewing.set(false);
        var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
        if (Sandboxing.isOpen(sandbox)) {
          Composing.getCurrent(sandbox).each(function (menu) {
            Highlighting.getHighlighted(menu).fold(function () {
              highlighter(menu);
            }, function () {
              dispatchEvent(sandbox, menu.element(), &apos;keydown&apos;, simulatedEvent);
            });
          });
        } else {
          var onOpenSync = function (sandbox) {
            Composing.getCurrent(sandbox).each(highlighter);
          };
          open$1(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
        }
      };
      var focusBehaviours$1 = focusBehaviours(detail);
      var mapFetch = function (comp) {
        return function (tdata) {
          return tdata.map(function (data) {
            var menus = values(data.menus);
            var items = bind(menus, function (menu) {
              return filter(menu.items, function (item) {
                return item.type === &apos;item&apos;;
              });
            });
            var repState = Representing.getState(comp);
            repState.update(map(items, function (item) {
              return item.data;
            }));
            return data;
          });
        };
      };
      var behaviours = [
        Focusing.config({}),
        Representing.config({
          onSetValue: detail.onSetValue,
          store: __assign({
            mode: &apos;dataset&apos;,
            getDataKey: function (comp) {
              return get$5(comp.element());
            },
            getFallbackEntry: function (itemString) {
              return {
                value: itemString,
                meta: {}
              };
            },
            setValue: function (comp, data) {
              set$3(comp.element(), detail.model.getDisplayText(data));
            }
          }, detail.initialData.map(function (d) {
            return wrap$1(&apos;initialValue&apos;, d);
          }).getOr({}))
        }),
        Streaming.config({
          stream: {
            mode: &apos;throttle&apos;,
            delay: detail.responseTime,
            stopEvent: false
          },
          onStream: function (component, _simulatedEvent) {
            var sandbox = Coupling.getCoupled(component, &apos;sandbox&apos;);
            var focusInInput = Focusing.isFocused(component);
            if (focusInInput) {
              if (get$5(component.element()).length &gt;= detail.minChars) {
                var previousValue_1 = Composing.getCurrent(sandbox).bind(function (menu) {
                  return Highlighting.getHighlighted(menu).map(Representing.getValue);
                });
                detail.previewing.set(true);
                var onOpenSync = function (_sandbox) {
                  Composing.getCurrent(sandbox).each(function (menu) {
                    previousValue_1.fold(function () {
                      if (detail.model.selectsOver) {
                        Highlighting.highlightFirst(menu);
                      }
                    }, function (pv) {
                      Highlighting.highlightBy(menu, function (item) {
                        var itemData = Representing.getValue(item);
                        return itemData.value === pv.value;
                      });
                      Highlighting.getHighlighted(menu).orThunk(function () {
                        Highlighting.highlightFirst(menu);
                        return Option.none();
                      });
                    });
                  });
                };
                open$1(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
              }
            }
          },
          cancelEvent: typeaheadCancel()
        }),
        Keying.config({
          mode: &apos;special&apos;,
          onDown: function (comp, simulatedEvent) {
            navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
            return Option.some(true);
          },
          onEscape: function (comp) {
            var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
            if (Sandboxing.isOpen(sandbox)) {
              Sandboxing.close(sandbox);
              return Option.some(true);
            }
            return Option.none();
          },
          onUp: function (comp, simulatedEvent) {
            navigateList(comp, simulatedEvent, Highlighting.highlightLast);
            return Option.some(true);
          },
          onEnter: function (comp) {
            var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
            var sandboxIsOpen = Sandboxing.isOpen(sandbox);
            if (sandboxIsOpen &amp;&amp; !detail.previewing.get()) {
              return Composing.getCurrent(sandbox).bind(function (menu) {
                return Highlighting.getHighlighted(menu);
              }).map(function (item) {
                emitWith(comp, itemExecute(), { item: item });
                return true;
              });
            } else {
              var currentValue = Representing.getValue(comp);
              emit(comp, typeaheadCancel());
              detail.onExecute(sandbox, comp, currentValue);
              if (sandboxIsOpen) {
                Sandboxing.close(sandbox);
              }
              return Option.some(true);
            }
          }
        }),
        Toggling.config({
          toggleClass: detail.markers.openClass,
          aria: { mode: &apos;expanded&apos; }
        }),
        Coupling.config({
          others: {
            sandbox: function (hotspot) {
              return makeSandbox(detail, hotspot, {
                onOpen: function () {
                  return Toggling.on(hotspot);
                },
                onClose: function () {
                  return Toggling.off(hotspot);
                }
              });
            }
          }
        }),
        config(&apos;typeaheadevents&apos;, [
          runOnExecute(function (comp) {
            var onOpenSync = noop;
            togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
          }),
          run(itemExecute(), function (comp, se) {
            var sandbox = Coupling.getCoupled(comp, &apos;sandbox&apos;);
            setValueFromItem(detail.model, comp, se.event().item());
            emit(comp, typeaheadCancel());
            detail.onItemExecute(comp, sandbox, se.event().item(), Representing.getValue(comp));
            Sandboxing.close(sandbox);
            setCursorAtEnd(comp);
          })
        ].concat(detail.dismissOnBlur ? [run(postBlur(), function (typeahead) {
            var sandbox = Coupling.getCoupled(typeahead, &apos;sandbox&apos;);
            if (search(sandbox.element()).isNone()) {
              Sandboxing.close(sandbox);
            }
          })] : []))
      ];
      return {
        uid: detail.uid,
        dom: dom$2(deepMerge(detail, {
          inputAttributes: {
            &apos;role&apos;: &apos;combobox&apos;,
            &apos;aria-autocomplete&apos;: &apos;list&apos;,
            &apos;aria-haspopup&apos;: &apos;true&apos;
          }
        })),
        behaviours: __assign(__assign({}, focusBehaviours$1), augment(detail.typeaheadBehaviours, behaviours)),
        eventOrder: detail.eventOrder
      };
    };

    var schema$j = constant([
      option(&apos;lazySink&apos;),
      strict$1(&apos;fetch&apos;),
      defaulted$1(&apos;minChars&apos;, 5),
      defaulted$1(&apos;responseTime&apos;, 1000),
      onHandler(&apos;onOpen&apos;),
      defaulted$1(&apos;getHotspot&apos;, Option.some),
      defaulted$1(&apos;getAnchorOverrides&apos;, constant({})),
      defaulted$1(&apos;layouts&apos;, Option.none()),
      defaulted$1(&apos;eventOrder&apos;, {}),
      defaultedObjOf(&apos;model&apos;, {}, [
        defaulted$1(&apos;getDisplayText&apos;, function (itemData) {
          return itemData.meta !== undefined &amp;&amp; itemData.meta.text !== undefined ? itemData.meta.text : itemData.value;
        }),
        defaulted$1(&apos;selectsOver&apos;, true),
        defaulted$1(&apos;populateFromBrowse&apos;, true)
      ]),
      onHandler(&apos;onSetValue&apos;),
      onKeyboardHandler(&apos;onExecute&apos;),
      onHandler(&apos;onItemExecute&apos;),
      defaulted$1(&apos;inputClasses&apos;, []),
      defaulted$1(&apos;inputAttributes&apos;, {}),
      defaulted$1(&apos;inputStyles&apos;, {}),
      defaulted$1(&apos;matchWidth&apos;, true),
      defaulted$1(&apos;useMinWidth&apos;, false),
      defaulted$1(&apos;dismissOnBlur&apos;, true),
      markers([&apos;openClass&apos;]),
      option(&apos;initialData&apos;),
      field$1(&apos;typeaheadBehaviours&apos;, [
        Focusing,
        Representing,
        Streaming,
        Keying,
        Toggling,
        Coupling
      ]),
      state$1(&apos;previewing&apos;, function () {
        return Cell(true);
      })
    ].concat(schema$f()).concat(sandboxFields()));
    var parts$6 = constant([external$1({
        schema: [tieredMenuMarkers()],
        name: &apos;menu&apos;,
        overrides: function (detail) {
          return {
            fakeFocus: true,
            onHighlight: function (menu, item) {
              if (!detail.previewing.get()) {
                menu.getSystem().getByUid(detail.uid).each(function (input) {
                  if (detail.model.populateFromBrowse) {
                    setValueFromItem(detail.model, input, item);
                  }
                });
              } else {
                menu.getSystem().getByUid(detail.uid).each(function (input) {
                  attemptSelectOver(detail.model, input, item).fold(function () {
                    return Highlighting.dehighlight(menu, item);
                  }, function (fn) {
                    return fn();
                  });
                });
              }
              detail.previewing.set(false);
            },
            onExecute: function (menu, item) {
              return menu.getSystem().getByUid(detail.uid).toOption().map(function (typeahead) {
                emitWith(typeahead, itemExecute(), { item: item });
                return true;
              });
            },
            onHover: function (menu, item) {
              detail.previewing.set(false);
              menu.getSystem().getByUid(detail.uid).each(function (input) {
                if (detail.model.populateFromBrowse) {
                  setValueFromItem(detail.model, input, item);
                }
              });
            }
          };
        }
      })]);

    var Typeahead = composite$1({
      name: &apos;Typeahead&apos;,
      configFields: schema$j(),
      partFields: parts$6(),
      factory: make$5
    });

    var wrap$2 = function (delegate) {
      var toCached = function () {
        return wrap$2(delegate.toCached());
      };
      var bindFuture = function (f) {
        return wrap$2(delegate.bind(function (resA) {
          return resA.fold(function (err) {
            return Future.pure(Result.error(err));
          }, function (a) {
            return f(a);
          });
        }));
      };
      var bindResult = function (f) {
        return wrap$2(delegate.map(function (resA) {
          return resA.bind(f);
        }));
      };
      var mapResult = function (f) {
        return wrap$2(delegate.map(function (resA) {
          return resA.map(f);
        }));
      };
      var mapError = function (f) {
        return wrap$2(delegate.map(function (resA) {
          return resA.mapError(f);
        }));
      };
      var foldResult = function (whenError, whenValue) {
        return delegate.map(function (res) {
          return res.fold(whenError, whenValue);
        });
      };
      var withTimeout = function (timeout, errorThunk) {
        return wrap$2(Future.nu(function (callback) {
          var timedOut = false;
          var timer = domGlobals.setTimeout(function () {
            timedOut = true;
            callback(Result.error(errorThunk()));
          }, timeout);
          delegate.get(function (result) {
            if (!timedOut) {
              domGlobals.clearTimeout(timer);
              callback(result);
            }
          });
        }));
      };
      return __assign(__assign({}, delegate), {
        toCached: toCached,
        bindFuture: bindFuture,
        bindResult: bindResult,
        mapResult: mapResult,
        mapError: mapError,
        foldResult: foldResult,
        withTimeout: withTimeout
      });
    };
    var nu$c = function (worker) {
      return wrap$2(Future.nu(worker));
    };
    var value$2 = function (value) {
      return wrap$2(Future.pure(Result.value(value)));
    };
    var error$1 = function (error) {
      return wrap$2(Future.pure(Result.error(error)));
    };
    var fromResult$1 = function (result) {
      return wrap$2(Future.pure(result));
    };
    var fromFuture = function (future) {
      return wrap$2(future.map(Result.value));
    };
    var fromPromise = function (promise) {
      return nu$c(function (completer) {
        promise.then(function (value) {
          completer(Result.value(value));
        }, function (error) {
          completer(Result.error(error));
        });
      });
    };
    var FutureResult = {
      nu: nu$c,
      wrap: wrap$2,
      pure: value$2,
      value: value$2,
      error: error$1,
      fromResult: fromResult$1,
      fromFuture: fromFuture,
      fromPromise: fromPromise
    };

    var separator$2 = { type: &apos;separator&apos; };
    var toMenuItem = function (target) {
      return {
        type: &apos;menuitem&apos;,
        value: target.url,
        text: target.title,
        meta: { attach: target.attach },
        onAction: function () {
        }
      };
    };
    var staticMenuItem = function (title, url) {
      return {
        type: &apos;menuitem&apos;,
        value: url,
        text: title,
        meta: { attach: undefined },
        onAction: function () {
        }
      };
    };
    var toMenuItems = function (targets) {
      return map(targets, toMenuItem);
    };
    var filterLinkTargets = function (type, targets) {
      return filter(targets, function (target) {
        return target.type === type;
      });
    };
    var filteredTargets = function (type, targets) {
      return toMenuItems(filterLinkTargets(type, targets));
    };
    var headerTargets = function (linkInfo) {
      return filteredTargets(&apos;header&apos;, linkInfo.targets);
    };
    var anchorTargets = function (linkInfo) {
      return filteredTargets(&apos;anchor&apos;, linkInfo.targets);
    };
    var anchorTargetTop = function (linkInfo) {
      return Option.from(linkInfo.anchorTop).map(function (url) {
        return staticMenuItem(&apos;&lt;top&gt;&apos;, url);
      }).toArray();
    };
    var anchorTargetBottom = function (linkInfo) {
      return Option.from(linkInfo.anchorBottom).map(function (url) {
        return staticMenuItem(&apos;&lt;bottom&gt;&apos;, url);
      }).toArray();
    };
    var historyTargets = function (history) {
      return map(history, function (url) {
        return staticMenuItem(url, url);
      });
    };
    var joinMenuLists = function (items) {
      return foldl(items, function (a, b) {
        var bothEmpty = a.length === 0 || b.length === 0;
        return bothEmpty ? a.concat(b) : a.concat(separator$2, b);
      }, []);
    };
    var filterByQuery = function (term, menuItems) {
      var lowerCaseTerm = term.toLowerCase();
      return filter(menuItems, function (item) {
        var text = item.meta !== undefined &amp;&amp; item.meta.text !== undefined ? item.meta.text : item.text;
        return contains$1(text.toLowerCase(), lowerCaseTerm) || contains$1(item.value.toLowerCase(), lowerCaseTerm);
      });
    };

    var getItems = function (fileType, input, urlBackstage) {
      var urlInputValue = Representing.getValue(input);
      var term = urlInputValue.meta.text !== undefined ? urlInputValue.meta.text : urlInputValue.value;
      var info = urlBackstage.getLinkInformation();
      return info.fold(function () {
        return [];
      }, function (linkInfo) {
        var history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
        return fileType === &apos;file&apos; ? joinMenuLists([
          history,
          filterByQuery(term, headerTargets(linkInfo)),
          filterByQuery(term, flatten([
            anchorTargetTop(linkInfo),
            anchorTargets(linkInfo),
            anchorTargetBottom(linkInfo)
          ]))
        ]) : history;
      });
    };
    var errorId = generate$1(&apos;aria-invalid&apos;);
    var renderUrlInput = function (spec, backstage, urlBackstage) {
      var _a;
      var providersBackstage = backstage.shared.providers;
      var updateHistory = function (component) {
        var urlEntry = Representing.getValue(component);
        urlBackstage.addToHistory(urlEntry.value, spec.filetype);
      };
      var pField = FormField.parts().field({
        factory: Typeahead,
        dismissOnBlur: true,
        inputClasses: [&apos;tox-textfield&apos;],
        sandboxClasses: [&apos;tox-dialog__popups&apos;],
        inputAttributes: {
          &apos;aria-errormessage&apos;: errorId,
          &apos;type&apos;: &apos;url&apos;
        },
        minChars: 0,
        responseTime: 0,
        fetch: function (input) {
          var items = getItems(spec.filetype, input, urlBackstage);
          var tdata = build$2(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, false);
          return Future.pure(tdata);
        },
        getHotspot: function (comp) {
          return memUrlBox.getOpt(comp);
        },
        onSetValue: function (comp, _newValue) {
          if (comp.hasConfigured(Invalidating)) {
            Invalidating.run(comp).get(noop);
          }
        },
        typeaheadBehaviours: derive$1(flatten([
          urlBackstage.getValidationHandler().map(function (handler) {
            return Invalidating.config({
              getRoot: function (comp) {
                return parent(comp.element());
              },
              invalidClass: &apos;tox-control-wrap--status-invalid&apos;,
              notify: {
                onInvalid: function (comp, err) {
                  memInvalidIcon.getOpt(comp).each(function (invalidComp) {
                    set$1(invalidComp.element(), &apos;title&apos;, providersBackstage.translate(err));
                  });
                }
              },
              validator: {
                validate: function (input) {
                  var urlEntry = Representing.getValue(input);
                  return FutureResult.nu(function (completer) {
                    handler({
                      type: spec.filetype,
                      url: urlEntry.value
                    }, function (validation) {
                      if (validation.status === &apos;invalid&apos;) {
                        var err = Result.error(validation.message);
                        completer(err);
                      } else {
                        var val = Result.value(validation.message);
                        completer(val);
                      }
                    });
                  });
                },
                validateOnLoad: false
              }
            });
          }).toArray(),
          [
            Disabling.config({
              disabled: function () {
                return spec.disabled || providersBackstage.isReadOnly();
              }
            }),
            Tabstopping.config({}),
            config(&apos;urlinput-events&apos;, flatten([
              spec.filetype === &apos;file&apos; ? [run(input(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                })] : [],
              [
                run(change(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                  updateHistory(comp);
                }),
                run(postPaste(), function (comp) {
                  emitWith(comp, formChangeEvent, { name: spec.name });
                  updateHistory(comp);
                })
              ]
            ]))
          ]
        ])),
        eventOrder: (_a = {}, _a[input()] = [
          &apos;streaming&apos;,
          &apos;urlinput-events&apos;,
          &apos;invalidating&apos;
        ], _a),
        model: {
          getDisplayText: function (itemData) {
            return itemData.value;
          },
          selectsOver: false,
          populateFromBrowse: false
        },
        markers: { openClass: &apos;tox-textfield--popup-open&apos; },
        lazySink: backstage.shared.getSink,
        parts: { menu: part(false, 1, &apos;normal&apos;) },
        onExecute: function (_menu, component, _entry) {
          emitWith(component, formSubmitEvent, {});
        },
        onItemExecute: function (typeahead, _sandbox, _item, _value) {
          updateHistory(typeahead);
          emitWith(typeahead, formChangeEvent, { name: spec.name });
        }
      });
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var makeIcon = function (name, errId, icon, label) {
        if (icon === void 0) {
          icon = name;
        }
        if (label === void 0) {
          label = name;
        }
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [
              &apos;tox-icon&apos;,
              &apos;tox-control-wrap__status-icon-&apos; + name
            ],
            innerHtml: get$d(icon, providersBackstage.icons),
            attributes: __assign({
              &apos;title&apos;: providersBackstage.translate(label),
              &apos;aria-live&apos;: &apos;polite&apos;
            }, errId.fold(function () {
              return {};
            }, function (id) {
              return { id: id };
            }))
          }
        };
      };
      var memInvalidIcon = record(makeIcon(&apos;invalid&apos;, Option.some(errorId), &apos;warning&apos;));
      var memStatus = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-control-wrap__status-icon-wrap&apos;]
        },
        components: [memInvalidIcon.asSpec()]
      });
      var optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
      var browseUrlEvent = generate$1(&apos;browser.url.event&apos;);
      var memUrlBox = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-control-wrap&apos;]
        },
        components: [
          pField,
          memStatus.asSpec()
        ],
        behaviours: derive$1([Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            }
          })])
      });
      var memUrlPickerButton = record(renderButton({
        name: spec.name,
        icon: Option.some(&apos;browse&apos;),
        text: spec.label.getOr(&apos;&apos;),
        disabled: spec.disabled,
        primary: false,
        borderless: true
      }, function (component) {
        return emit(component, browseUrlEvent);
      }, providersBackstage, [], [&apos;tox-browse-url&apos;]));
      var controlHWrapper = function () {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-form__controls-h-stack&apos;]
          },
          components: flatten([
            [memUrlBox.asSpec()],
            optUrlPicker.map(function () {
              return memUrlPickerButton.asSpec();
            }).toArray()
          ])
        };
      };
      var openUrlPicker = function (comp) {
        Composing.getCurrent(comp).each(function (field) {
          var componentData = Representing.getValue(field);
          var urlData = __assign({ fieldname: spec.name }, componentData);
          optUrlPicker.each(function (picker) {
            picker(urlData).get(function (chosenData) {
              Representing.setValue(field, chosenData);
              emitWith(comp, formChangeEvent, { name: spec.name });
            });
          });
        });
      };
      return FormField.sketch({
        dom: renderFormFieldDom(),
        components: pLabel.toArray().concat([controlHWrapper()]),
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providersBackstage.isReadOnly();
            },
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
              memUrlPickerButton.getOpt(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
              memUrlPickerButton.getOpt(comp).each(Disabling.enable);
            }
          }),
          receivingConfig(),
          config(&apos;url-input-events&apos;, [run(browseUrlEvent, openUrlPicker)])
        ])
      });
    };

    var renderCheckbox = function (spec, providerBackstage) {
      var repBehaviour = Representing.config({
        store: {
          mode: &apos;manual&apos;,
          getValue: function (comp) {
            var el = comp.element().dom();
            return el.checked;
          },
          setValue: function (comp, value) {
            var el = comp.element().dom();
            el.checked = value;
          }
        }
      });
      var toggleCheckboxHandler = function (comp) {
        comp.element().dom().click();
        return Option.some(true);
      };
      var pField = FormField.parts().field({
        factory: { sketch: identity },
        dom: {
          tag: &apos;input&apos;,
          classes: [&apos;tox-checkbox__input&apos;],
          attributes: { type: &apos;checkbox&apos; }
        },
        behaviours: derive$1([
          ComposingConfigs.self(),
          Disabling.config({
            disabled: function () {
              return spec.disabled || providerBackstage.isReadOnly();
            }
          }),
          Tabstopping.config({}),
          Focusing.config({}),
          repBehaviour,
          Keying.config({
            mode: &apos;special&apos;,
            onEnter: toggleCheckboxHandler,
            onSpace: toggleCheckboxHandler,
            stopSpaceKeyup: true
          }),
          config(&apos;checkbox-events&apos;, [run(change(), function (component, _) {
              emitWith(component, formChangeEvent, { name: spec.name });
            })])
        ])
      });
      var pLabel = FormField.parts().label({
        dom: {
          tag: &apos;span&apos;,
          classes: [&apos;tox-checkbox__label&apos;],
          innerHtml: providerBackstage.translate(spec.label)
        },
        behaviours: derive$1([Unselecting.config({})])
      });
      var makeIcon = function (className) {
        var iconName = className === &apos;checked&apos; ? &apos;selected&apos; : &apos;unselected&apos;;
        return {
          dom: {
            tag: &apos;span&apos;,
            classes: [
              &apos;tox-icon&apos;,
              &apos;tox-checkbox-icon__&apos; + className
            ],
            innerHtml: get$d(iconName, providerBackstage.icons)
          }
        };
      };
      var memIcons = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-checkbox__icons&apos;]
        },
        components: [
          makeIcon(&apos;checked&apos;),
          makeIcon(&apos;unchecked&apos;)
        ]
      });
      return FormField.sketch({
        dom: {
          tag: &apos;label&apos;,
          classes: [&apos;tox-checkbox&apos;]
        },
        components: [
          pField,
          memIcons.asSpec(),
          pLabel
        ],
        fieldBehaviours: derive$1([
          Disabling.config({
            disabled: function () {
              return spec.disabled || providerBackstage.isReadOnly();
            },
            disableClass: &apos;tox-checkbox--disabled&apos;,
            onDisabled: function (comp) {
              FormField.getField(comp).each(Disabling.disable);
            },
            onEnabled: function (comp) {
              FormField.getField(comp).each(Disabling.enable);
            }
          }),
          receivingConfig()
        ])
      });
    };

    var renderHtmlPanel = function (spec) {
      if (spec.presets === &apos;presentation&apos;) {
        return Container.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-form__group&apos;],
            innerHtml: spec.html
          }
        });
      } else {
        return Container.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-form__group&apos;],
            innerHtml: spec.html,
            attributes: { role: &apos;document&apos; }
          },
          containerBehaviours: derive$1([
            Tabstopping.config({}),
            Focusing.config({})
          ])
        });
      }
    };

    var renderLabel$2 = function (spec, backstageShared) {
      var label = {
        dom: {
          tag: &apos;label&apos;,
          innerHtml: backstageShared.providers.translate(spec.label),
          classes: [&apos;tox-label&apos;]
        }
      };
      var comps = map(spec.items, backstageShared.interpreter);
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-form__group&apos;]
        },
        components: [label].concat(comps),
        behaviours: derive$1([
          ComposingConfigs.self(),
          Replacing.config({}),
          RepresentingConfigs.domHtml(Option.none()),
          Keying.config({ mode: &apos;acyclic&apos; })
        ])
      };
    };

    var renderCollection = function (spec, providersBackstage) {
      var pLabel = spec.label.map(function (label) {
        return renderLabel(label, providersBackstage);
      });
      var runOnItem = function (f) {
        return function (comp, se) {
          closest$3(se.event().target(), &apos;[data-collection-item-value]&apos;).each(function (target) {
            f(comp, se, target, get$2(target, &apos;data-collection-item-value&apos;));
          });
        };
      };
      var escapeAttribute = function (ch) {
        if (ch === &apos;&quot;&apos;) {
          return &apos;&amp;quot;&apos;;
        }
        return ch;
      };
      var setContents = function (comp, items) {
        var htmlLines = map(items, function (item) {
          var itemText = global$5.translate(item.text);
          var textContent = spec.columns === 1 ? &apos;&lt;div class=&quot;tox-collection__item-label&quot;&gt;&apos; + itemText + &apos;&lt;/div&gt;&apos; : &apos;&apos;;
          var iconContent = &apos;&lt;div class=&quot;tox-collection__item-icon&quot;&gt;&apos; + item.icon + &apos;&lt;/div&gt;&apos;;
          var mapItemName = {
            &apos;_&apos;: &apos; &apos;,
            &apos; - &apos;: &apos; &apos;,
            &apos;-&apos;: &apos; &apos;
          };
          var ariaLabel = itemText.replace(/\_| \- |\-/g, function (match) {
            return mapItemName[match];
          });
          var readonlyClass = providersBackstage.isReadOnly() ? &apos; tox-collection__item--state-disabled&apos; : &apos;&apos;;
          return &apos;&lt;div class=&quot;tox-collection__item&apos; + readonlyClass + &apos;&quot; tabindex=&quot;-1&quot; data-collection-item-value=&quot;&apos; + escapeAttribute(item.value) + &apos;&quot; title=&quot;&apos; + ariaLabel + &apos;&quot; aria-label=&quot;&apos; + ariaLabel + &apos;&quot;&gt;&apos; + iconContent + textContent + &apos;&lt;/div&gt;&apos;;
        });
        var chunks = spec.columns &gt; 1 &amp;&amp; spec.columns !== &apos;auto&apos; ? chunk(htmlLines, spec.columns) : [htmlLines];
        var html = map(chunks, function (ch) {
          return &apos;&lt;div class=&quot;tox-collection__group&quot;&gt;&apos; + ch.join(&apos;&apos;) + &apos;&lt;/div&gt;&apos;;
        });
        set(comp.element(), html.join(&apos;&apos;));
      };
      var onClick = runOnItem(function (comp, se, tgt, itemValue) {
        se.stop();
        if (!providersBackstage.isReadOnly()) {
          emitWith(comp, formActionEvent, {
            name: spec.name,
            value: itemValue
          });
        }
      });
      var collectionEvents = [
        run(mouseover(), runOnItem(function (comp, se, tgt) {
          focus$1(tgt);
        })),
        run(click(), onClick),
        run(tap(), onClick),
        run(focusin(), runOnItem(function (comp, se, tgt) {
          descendant$1(comp.element(), &apos;.&apos; + activeClass).each(function (currentActive) {
            remove$4(currentActive, activeClass);
          });
          add$2(tgt, activeClass);
        })),
        run(focusout(), runOnItem(function (comp) {
          descendant$1(comp.element(), &apos;.&apos; + activeClass).each(function (currentActive) {
            remove$4(currentActive, activeClass);
          });
        })),
        runOnExecute(runOnItem(function (comp, se, tgt, itemValue) {
          emitWith(comp, formActionEvent, {
            name: spec.name,
            value: itemValue
          });
        }))
      ];
      var iterCollectionItems = function (comp, applyAttributes) {
        return map(descendants(comp.element(), &apos;.tox-collection__item&apos;), applyAttributes);
      };
      var pField = FormField.parts().field({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-collection&apos;].concat(spec.columns !== 1 ? [&apos;tox-collection--grid&apos;] : [&apos;tox-collection--list&apos;])
        },
        components: [],
        factory: { sketch: identity },
        behaviours: derive$1([
          Disabling.config({
            disabled: providersBackstage.isReadOnly,
            onDisabled: function (comp) {
              iterCollectionItems(comp, function (childElm) {
                add$2(childElm, &apos;tox-collection__item--state-disabled&apos;);
                set$1(childElm, &apos;aria-disabled&apos;, true);
              });
            },
            onEnabled: function (comp) {
              iterCollectionItems(comp, function (childElm) {
                remove$4(childElm, &apos;tox-collection__item--state-disabled&apos;);
                remove$1(childElm, &apos;aria-disabled&apos;);
              });
            }
          }),
          receivingConfig(),
          Replacing.config({}),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: []
            },
            onSetValue: function (comp, items) {
              setContents(comp, items);
              if (spec.columns === &apos;auto&apos;) {
                detectSize(comp, 5, &apos;tox-collection__item&apos;).each(function (_a) {
                  var numRows = _a.numRows, numColumns = _a.numColumns;
                  Keying.setGridSize(comp, numRows, numColumns);
                });
              }
              emit(comp, formResizeEvent);
            }
          }),
          Tabstopping.config({}),
          Keying.config(deriveCollectionMovement(spec.columns, &apos;normal&apos;)),
          config(&apos;collection-events&apos;, collectionEvents)
        ]),
        eventOrder: {
          &apos;alloy.execute&apos;: [
            &apos;disabling&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;collection-events&apos;
          ]
        }
      });
      var extraClasses = [&apos;tox-form__group--collection&apos;];
      return renderFormFieldWith(pLabel, pField, extraClasses, []);
    };

    var renderTable = function (spec, providersBackstage) {
      var renderTh = function (text) {
        return {
          dom: {
            tag: &apos;th&apos;,
            innerHtml: providersBackstage.translate(text)
          }
        };
      };
      var renderHeader = function (header) {
        return {
          dom: { tag: &apos;thead&apos; },
          components: [{
              dom: { tag: &apos;tr&apos; },
              components: map(header, renderTh)
            }]
        };
      };
      var renderTd = function (text) {
        return {
          dom: {
            tag: &apos;td&apos;,
            innerHtml: providersBackstage.translate(text)
          }
        };
      };
      var renderTr = function (row) {
        return {
          dom: { tag: &apos;tr&apos; },
          components: map(row, renderTd)
        };
      };
      var renderRows = function (rows) {
        return {
          dom: { tag: &apos;tbody&apos; },
          components: map(rows, renderTr)
        };
      };
      return {
        dom: {
          tag: &apos;table&apos;,
          classes: [&apos;tox-dialog__table&apos;]
        },
        components: [
          renderHeader(spec.header),
          renderRows(spec.cells)
        ],
        behaviours: derive$1([
          Tabstopping.config({}),
          Focusing.config({})
        ])
      };
    };

    var renderPanel = function (spec, backstage) {
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: spec.classes
        },
        components: map(spec.items, backstage.shared.interpreter)
      };
    };

    var make$6 = function (render) {
      return function (parts, spec, backstage) {
        return get(spec, &apos;name&apos;).fold(function () {
          return render(spec, backstage);
        }, function (fieldName) {
          return parts.field(fieldName, render(spec, backstage));
        });
      };
    };
    var makeIframe = function (render) {
      return function (parts, spec, backstage) {
        var iframeSpec = deepMerge(spec, { source: &apos;dynamic&apos; });
        return make$6(render)(parts, iframeSpec, backstage);
      };
    };
    var factories = {
      bar: make$6(function (spec, backstage) {
        return renderBar(spec, backstage.shared);
      }),
      collection: make$6(function (spec, backstage) {
        return renderCollection(spec, backstage.shared.providers);
      }),
      alertbanner: make$6(function (spec, backstage) {
        return renderAlertBanner(spec, backstage.shared.providers);
      }),
      input: make$6(function (spec, backstage) {
        return renderInput(spec, backstage.shared.providers);
      }),
      textarea: make$6(function (spec, backstage) {
        return renderTextarea(spec, backstage.shared.providers);
      }),
      label: make$6(function (spec, backstage) {
        return renderLabel$2(spec, backstage.shared);
      }),
      iframe: makeIframe(function (spec, backstage) {
        return renderIFrame(spec, backstage.shared.providers);
      }),
      button: make$6(function (spec, backstage) {
        return renderDialogButton(spec, backstage.shared.providers);
      }),
      checkbox: make$6(function (spec, backstage) {
        return renderCheckbox(spec, backstage.shared.providers);
      }),
      colorinput: make$6(function (spec, backstage) {
        return renderColorInput(spec, backstage.shared, backstage.colorinput);
      }),
      colorpicker: make$6(renderColorPicker),
      dropzone: make$6(function (spec, backstage) {
        return renderDropZone(spec, backstage.shared.providers);
      }),
      grid: make$6(function (spec, backstage) {
        return renderGrid(spec, backstage.shared);
      }),
      selectbox: make$6(function (spec, backstage) {
        return renderSelectBox(spec, backstage.shared.providers);
      }),
      sizeinput: make$6(function (spec, backstage) {
        return renderSizeInput(spec, backstage.shared.providers);
      }),
      urlinput: make$6(function (spec, backstage) {
        return renderUrlInput(spec, backstage, backstage.urlinput);
      }),
      customeditor: make$6(renderCustomEditor),
      htmlpanel: make$6(renderHtmlPanel),
      imagetools: make$6(function (spec, backstage) {
        return renderImageTools(spec, backstage.shared.providers);
      }),
      table: make$6(function (spec, backstage) {
        return renderTable(spec, backstage.shared.providers);
      }),
      panel: make$6(function (spec, backstage) {
        return renderPanel(spec, backstage);
      })
    };
    var noFormParts = {
      field: function (_name, spec) {
        return spec;
      }
    };
    var interpretInForm = function (parts, spec, oldBackstage) {
      var newBackstage = deepMerge(oldBackstage, {
        shared: {
          interpreter: function (childSpec) {
            return interpretParts(parts, childSpec, newBackstage);
          }
        }
      });
      return interpretParts(parts, spec, newBackstage);
    };
    var interpretParts = function (parts, spec, backstage) {
      return get(factories, spec.type).fold(function () {
        domGlobals.console.error(&apos;Unknown factory type &quot;&apos; + spec.type + &apos;&quot;, defaulting to container: &apos;, spec);
        return spec;
      }, function (factory) {
        return factory(parts, spec, backstage);
      });
    };
    var interpretWithoutForm = function (spec, backstage) {
      var parts = noFormParts;
      return interpretParts(parts, spec, backstage);
    };

    var bubbleAlignments = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [],
      alignRight: [],
      right: [],
      left: [],
      bottom: [],
      top: []
    };
    var getInlineDialogAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {
      var bubble = nu$8(-12, 12, bubbleAlignments);
      var overrides = { maxHeightFunction: expandable() };
      var editableAreaAnchor = function () {
        return {
          anchor: &apos;node&apos;,
          root: getBody(owner(contentAreaElement())),
          node: Option.from(contentAreaElement()),
          bubble: bubble,
          layouts: {
            onRtl: function () {
              return [northwest$3];
            },
            onLtr: function () {
              return [northeast$3];
            }
          },
          overrides: overrides
        };
      };
      var standardAnchor = function () {
        return {
          anchor: &apos;hotspot&apos;,
          hotspot: lazyAnchorbar(),
          bubble: bubble,
          layouts: {
            onRtl: function () {
              return [southeast$1];
            },
            onLtr: function () {
              return [southwest$1];
            }
          },
          overrides: overrides
        };
      };
      return function () {
        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
      };
    };
    var getBannerAnchor = function (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) {
      var editableAreaAnchor = function () {
        return {
          anchor: &apos;node&apos;,
          root: getBody(owner(contentAreaElement())),
          node: Option.from(contentAreaElement()),
          layouts: {
            onRtl: function () {
              return [north$3];
            },
            onLtr: function () {
              return [north$3];
            }
          }
        };
      };
      var standardAnchor = function () {
        return {
          anchor: &apos;hotspot&apos;,
          hotspot: lazyAnchorbar(),
          layouts: {
            onRtl: function () {
              return [south$1];
            },
            onLtr: function () {
              return [south$1];
            }
          }
        };
      };
      return function () {
        return lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
      };
    };
    var getCursorAnchor = function (editor, bodyElement) {
      return function () {
        return {
          anchor: &apos;selection&apos;,
          root: bodyElement(),
          getSelection: function () {
            var rng = editor.selection.getRng();
            return Option.some(Selection.range(Element.fromDom(rng.startContainer), rng.startOffset, Element.fromDom(rng.endContainer), rng.endOffset));
          }
        };
      };
    };
    var getNodeAnchor = function (bodyElement) {
      return function (element) {
        return {
          anchor: &apos;node&apos;,
          root: bodyElement(),
          node: element
        };
      };
    };
    var getAnchors = function (editor, lazyAnchorbar, isToolbarTop) {
      var useFixedToolbarContainer = useFixedContainer(editor);
      var bodyElement = function () {
        return Element.fromDom(editor.getBody());
      };
      var contentAreaElement = function () {
        return Element.fromDom(editor.getContentAreaContainer());
      };
      var lazyUseEditableAreaAnchor = function () {
        return useFixedToolbarContainer || !isToolbarTop();
      };
      return {
        inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
        banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
        cursor: getCursorAnchor(editor, bodyElement),
        node: getNodeAnchor(bodyElement)
      };
    };

    var colorPicker = function (editor) {
      return function (callback, value) {
        var dialog = colorPickerDialog(editor);
        dialog(callback, value);
      };
    };
    var hasCustomColors$1 = function (editor) {
      return function () {
        return hasCustomColors(editor);
      };
    };
    var getColors$2 = function (editor) {
      return function () {
        return getColors(editor);
      };
    };
    var getColorCols$2 = function (editor) {
      return function () {
        return getColorCols$1(editor);
      };
    };
    var ColorInputBackstage = function (editor) {
      return {
        colorPicker: colorPicker(editor),
        hasCustomColors: hasCustomColors$1(editor),
        getColors: getColors$2(editor),
        getColorCols: getColorCols$2(editor)
      };
    };

    var isDraggableModal$1 = function (editor) {
      return function () {
        return isDraggableModal(editor);
      };
    };
    var DialogBackstage = function (editor) {
      return { isDraggableModal: isDraggableModal$1(editor) };
    };

    var HeaderBackstage = function (editor) {
      var mode = Cell(isToolbarLocationBottom(editor) ? &apos;bottom&apos; : &apos;top&apos;);
      return {
        isPositionedAtTop: function () {
          return mode.get() === &apos;top&apos;;
        },
        getDockingMode: mode.get,
        setDockingMode: mode.set
      };
    };

    var defaultStyleFormats = [
      {
        title: &apos;Headings&apos;,
        items: [
          {
            title: &apos;Heading 1&apos;,
            format: &apos;h1&apos;
          },
          {
            title: &apos;Heading 2&apos;,
            format: &apos;h2&apos;
          },
          {
            title: &apos;Heading 3&apos;,
            format: &apos;h3&apos;
          },
          {
            title: &apos;Heading 4&apos;,
            format: &apos;h4&apos;
          },
          {
            title: &apos;Heading 5&apos;,
            format: &apos;h5&apos;
          },
          {
            title: &apos;Heading 6&apos;,
            format: &apos;h6&apos;
          }
        ]
      },
      {
        title: &apos;Inline&apos;,
        items: [
          {
            title: &apos;Bold&apos;,
            format: &apos;bold&apos;
          },
          {
            title: &apos;Italic&apos;,
            format: &apos;italic&apos;
          },
          {
            title: &apos;Underline&apos;,
            format: &apos;underline&apos;
          },
          {
            title: &apos;Strikethrough&apos;,
            format: &apos;strikethrough&apos;
          },
          {
            title: &apos;Superscript&apos;,
            format: &apos;superscript&apos;
          },
          {
            title: &apos;Subscript&apos;,
            format: &apos;subscript&apos;
          },
          {
            title: &apos;Code&apos;,
            format: &apos;code&apos;
          }
        ]
      },
      {
        title: &apos;Blocks&apos;,
        items: [
          {
            title: &apos;Paragraph&apos;,
            format: &apos;p&apos;
          },
          {
            title: &apos;Blockquote&apos;,
            format: &apos;blockquote&apos;
          },
          {
            title: &apos;Div&apos;,
            format: &apos;div&apos;
          },
          {
            title: &apos;Pre&apos;,
            format: &apos;pre&apos;
          }
        ]
      },
      {
        title: &apos;Align&apos;,
        items: [
          {
            title: &apos;Left&apos;,
            format: &apos;alignleft&apos;
          },
          {
            title: &apos;Center&apos;,
            format: &apos;aligncenter&apos;
          },
          {
            title: &apos;Right&apos;,
            format: &apos;alignright&apos;
          },
          {
            title: &apos;Justify&apos;,
            format: &apos;alignjustify&apos;
          }
        ]
      }
    ];
    var isNestedFormat = function (format) {
      return has(format, &apos;items&apos;);
    };
    var isBlockFormat = function (format) {
      return has(format, &apos;block&apos;);
    };
    var isInlineFormat = function (format) {
      return has(format, &apos;inline&apos;);
    };
    var isSelectorFormat = function (format) {
      return has(format, &apos;selector&apos;);
    };
    var mapFormats = function (userFormats) {
      return foldl(userFormats, function (acc, fmt) {
        if (isNestedFormat(fmt)) {
          var result = mapFormats(fmt.items);
          return {
            customFormats: acc.customFormats.concat(result.customFormats),
            formats: acc.formats.concat([{
                title: fmt.title,
                items: result.formats
              }])
          };
        } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
          var formatName = &apos;custom-&apos; + fmt.title.toLowerCase();
          return {
            customFormats: acc.customFormats.concat([{
                name: formatName,
                format: fmt
              }]),
            formats: acc.formats.concat([{
                title: fmt.title,
                format: formatName,
                icon: fmt.icon
              }])
          };
        } else {
          return __assign(__assign({}, acc), { formats: acc.formats.concat(fmt) });
        }
      }, {
        customFormats: [],
        formats: []
      });
    };
    var registerCustomFormats = function (editor, userFormats) {
      var result = mapFormats(userFormats);
      var registerFormats = function (customFormats) {
        each(customFormats, function (fmt) {
          if (!editor.formatter.has(fmt.name)) {
            editor.formatter.register(fmt.name, fmt.format);
          }
        });
      };
      if (editor.formatter) {
        registerFormats(result.customFormats);
      } else {
        editor.on(&apos;init&apos;, function () {
          registerFormats(result.customFormats);
        });
      }
      return result.formats;
    };
    var getStyleFormats = function (editor) {
      return getUserStyleFormats(editor).map(function (userFormats) {
        var registeredUserFormats = registerCustomFormats(editor, userFormats);
        return isMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
      }).getOr(defaultStyleFormats);
    };

    var processBasic = function (item, isSelectedFor, getPreviewFor) {
      var formatterSpec = {
        type: &apos;formatter&apos;,
        isSelected: isSelectedFor(item.format),
        getStylePreview: getPreviewFor(item.format)
      };
      return deepMerge(item, formatterSpec);
    };
    var register$3 = function (editor, formats, isSelectedFor, getPreviewFor) {
      var enrichSupported = function (item) {
        return processBasic(item, isSelectedFor, getPreviewFor);
      };
      var enrichMenu = function (item) {
        var submenuSpec = { type: &apos;submenu&apos; };
        return deepMerge(item, submenuSpec);
      };
      var enrichCustom = function (item) {
        var formatName = generate$1(item.title);
        var customSpec = {
          type: &apos;formatter&apos;,
          format: formatName,
          isSelected: isSelectedFor(formatName),
          getStylePreview: getPreviewFor(formatName)
        };
        var newItem = deepMerge(item, customSpec);
        editor.formatter.register(formatName, newItem);
        return newItem;
      };
      var doEnrich = function (items) {
        return map(items, function (item) {
          var keys$1 = keys(item);
          if (hasNonNullableKey(item, &apos;items&apos;)) {
            var newItems_1 = doEnrich(item.items);
            return deepMerge(enrichMenu(item), {
              getStyleItems: function () {
                return newItems_1;
              }
            });
          } else if (hasNonNullableKey(item, &apos;format&apos;)) {
            return enrichSupported(item);
          } else if (keys$1.length === 1 &amp;&amp; contains(keys$1, &apos;title&apos;)) {
            return deepMerge(item, { type: &apos;separator&apos; });
          } else {
            return enrichCustom(item);
          }
        });
      };
      return doEnrich(formats);
    };

    var init$7 = function (editor) {
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return fmt !== undefined ? Option.some({
            tag: fmt.length &gt; 0 ? fmt[0].inline || fmt[0].block || &apos;div&apos; : &apos;div&apos;,
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          }) : Option.none();
        };
      };
      var flatten = function (fmt) {
        var subs = fmt.items;
        return subs !== undefined &amp;&amp; subs.length &gt; 0 ? bind(subs, flatten) : [fmt.format];
      };
      var settingsFormats = Cell([]);
      var settingsFlattenedFormats = Cell([]);
      var eventsFormats = Cell([]);
      var eventsFlattenedFormats = Cell([]);
      var replaceSettings = Cell(false);
      editor.on(&apos;PreInit&apos;, function (_e) {
        var formats = getStyleFormats(editor);
        var enriched = register$3(editor, formats, isSelectedFor, getPreviewFor);
        settingsFormats.set(enriched);
        settingsFlattenedFormats.set(bind(enriched, flatten));
      });
      editor.on(&apos;addStyleModifications&apos;, function (e) {
        var modifications = register$3(editor, e.items, isSelectedFor, getPreviewFor);
        eventsFormats.set(modifications);
        replaceSettings.set(e.replace);
        eventsFlattenedFormats.set(bind(modifications, flatten));
      });
      var getData = function () {
        var fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
        var fromEvents = eventsFormats.get();
        return fromSettings.concat(fromEvents);
      };
      var getFlattenedKeys = function () {
        var fromSettings = replaceSettings.get() ? [] : settingsFlattenedFormats.get();
        var fromEvents = eventsFlattenedFormats.get();
        return fromSettings.concat(fromEvents);
      };
      return {
        getData: getData,
        getFlattenedKeys: getFlattenedKeys
      };
    };

    var trim$1 = global$e.trim;
    var hasContentEditableState = function (value) {
      return function (node) {
        if (node &amp;&amp; node.nodeType === 1) {
          if (node.contentEditable === value) {
            return true;
          }
          if (node.getAttribute(&apos;data-mce-contenteditable&apos;) === value) {
            return true;
          }
        }
        return false;
      };
    };
    var isContentEditableTrue = hasContentEditableState(&apos;true&apos;);
    var isContentEditableFalse = hasContentEditableState(&apos;false&apos;);
    var create$8 = function (type, title, url, level, attach) {
      return {
        type: type,
        title: title,
        url: url,
        level: level,
        attach: attach
      };
    };
    var isChildOfContentEditableTrue = function (node) {
      while (node = node.parentNode) {
        var value = node.contentEditable;
        if (value &amp;&amp; value !== &apos;inherit&apos;) {
          return isContentEditableTrue(node);
        }
      }
      return false;
    };
    var select = function (selector, root) {
      return map(descendants(Element.fromDom(root), selector), function (element) {
        return element.dom();
      });
    };
    var getElementText = function (elm) {
      return elm.innerText || elm.textContent;
    };
    var getOrGenerateId = function (elm) {
      return elm.id ? elm.id : generate$1(&apos;h&apos;);
    };
    var isAnchor = function (elm) {
      return elm &amp;&amp; elm.nodeName === &apos;A&apos; &amp;&amp; (elm.id || elm.name) !== undefined;
    };
    var isValidAnchor = function (elm) {
      return isAnchor(elm) &amp;&amp; isEditable(elm);
    };
    var isHeader = function (elm) {
      return elm &amp;&amp; /^(H[1-6])$/.test(elm.nodeName);
    };
    var isEditable = function (elm) {
      return isChildOfContentEditableTrue(elm) &amp;&amp; !isContentEditableFalse(elm);
    };
    var isValidHeader = function (elm) {
      return isHeader(elm) &amp;&amp; isEditable(elm);
    };
    var getLevel = function (elm) {
      return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
    };
    var headerTarget = function (elm) {
      var headerId = getOrGenerateId(elm);
      var attach = function () {
        elm.id = headerId;
      };
      return create$8(&apos;header&apos;, getElementText(elm), &apos;#&apos; + headerId, getLevel(elm), attach);
    };
    var anchorTarget = function (elm) {
      var anchorId = elm.id || elm.name;
      var anchorText = getElementText(elm);
      return create$8(&apos;anchor&apos;, anchorText ? anchorText : &apos;#&apos; + anchorId, &apos;#&apos; + anchorId, 0, noop);
    };
    var getHeaderTargets = function (elms) {
      return map(filter(elms, isValidHeader), headerTarget);
    };
    var getAnchorTargets = function (elms) {
      return map(filter(elms, isValidAnchor), anchorTarget);
    };
    var getTargetElements = function (elm) {
      var elms = select(&apos;h1,h2,h3,h4,h5,h6,a:not([href])&apos;, elm);
      return elms;
    };
    var hasTitle = function (target) {
      return trim$1(target.title).length &gt; 0;
    };
    var find$5 = function (elm) {
      var elms = getTargetElements(elm);
      return filter(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
    };
    var LinkTargets = { find: find$5 };

    var STORAGE_KEY = &apos;tinymce-url-history&apos;;
    var HISTORY_LENGTH = 5;
    var isHttpUrl = function (url) {
      return isString(url) &amp;&amp; /^https?/.test(url);
    };
    var isArrayOfUrl = function (a) {
      return isArray(a) &amp;&amp; a.length &lt;= HISTORY_LENGTH &amp;&amp; forall(a, isHttpUrl);
    };
    var isRecordOfUrlArray = function (r) {
      return isObject(r) &amp;&amp; find$1(r, function (value) {
        return !isArrayOfUrl(value);
      }).isNone();
    };
    var getAllHistory = function () {
      var unparsedHistory = global$9.getItem(STORAGE_KEY);
      if (unparsedHistory === null) {
        return {};
      }
      var history;
      try {
        history = JSON.parse(unparsedHistory);
      } catch (e) {
        if (e instanceof SyntaxError) {
          domGlobals.console.log(&apos;Local storage &apos; + STORAGE_KEY + &apos; was not valid JSON&apos;, e);
          return {};
        }
        throw e;
      }
      if (!isRecordOfUrlArray(history)) {
        domGlobals.console.log(&apos;Local storage &apos; + STORAGE_KEY + &apos; was not valid format&apos;, history);
        return {};
      }
      return history;
    };
    var setAllHistory = function (history) {
      if (!isRecordOfUrlArray(history)) {
        throw new Error(&apos;Bad format for history:\n&apos; + JSON.stringify(history));
      }
      global$9.setItem(STORAGE_KEY, JSON.stringify(history));
    };
    var getHistory = function (fileType) {
      var history = getAllHistory();
      return Object.prototype.hasOwnProperty.call(history, fileType) ? history[fileType] : [];
    };
    var addToHistory = function (url, fileType) {
      if (!isHttpUrl(url)) {
        return;
      }
      var history = getAllHistory();
      var items = Object.prototype.hasOwnProperty.call(history, fileType) ? history[fileType] : [];
      var itemsWithoutUrl = filter(items, function (item) {
        return item !== url;
      });
      history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
      setAllHistory(history);
    };

    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var isTruthy = function (value) {
      return !!value;
    };
    var makeMap = function (value) {
      return map$1(global$e.makeMap(value, /[, ]/), isTruthy);
    };
    var getOpt$1 = function (obj, key) {
      return hasOwnProperty$2.call(obj, key) ? Option.some(obj[key]) : Option.none();
    };
    var getTextSetting = function (settings, name, defaultValue) {
      var value = getOpt$1(settings, name).getOr(defaultValue);
      return isString(value) ? Option.some(value) : Option.none();
    };
    var getPicker = function (settings) {
      return Option.some(settings.file_picker_callback).filter(isFunction);
    };
    var getPickerTypes = function (settings) {
      var optFileTypes = Option.some(settings.file_picker_types).filter(isTruthy);
      var optLegacyTypes = Option.some(settings.file_browser_callback_types).filter(isTruthy);
      var optTypes = optFileTypes.or(optLegacyTypes).map(makeMap);
      return getPicker(settings).fold(function () {
        return false;
      }, function (_picker) {
        return optTypes.fold(function () {
          return true;
        }, function (types) {
          return keys(types).length &gt; 0 ? types : false;
        });
      });
    };
    var getPickerSetting = function (settings, filetype) {
      var pickerTypes = getPickerTypes(settings);
      if (isBoolean(pickerTypes)) {
        return pickerTypes ? getPicker(settings) : Option.none();
      } else {
        return pickerTypes[filetype] ? getPicker(settings) : Option.none();
      }
    };
    var getUrlPicker = function (editor, filetype) {
      return getPickerSetting(editor.settings, filetype).map(function (picker) {
        return function (entry) {
          return Future.nu(function (completer) {
            var handler = function (value, meta) {
              if (!isString(value)) {
                throw new Error(&apos;Expected value to be string&apos;);
              }
              if (meta !== undefined &amp;&amp; !isObject(meta)) {
                throw new Error(&apos;Expected meta to be a object&apos;);
              }
              var r = {
                value: value,
                meta: meta
              };
              completer(r);
            };
            var meta = __assign({
              filetype: filetype,
              fieldname: entry.fieldname
            }, Option.from(entry.meta).getOr({}));
            picker.call(editor, handler, entry.value, meta);
          });
        };
      });
    };
    var getLinkInformation = function (editor) {
      if (editor.settings.typeahead_urls === false) {
        return Option.none();
      }
      return Option.some({
        targets: LinkTargets.find(editor.getBody()),
        anchorTop: getTextSetting(editor.settings, &apos;anchor_top&apos;, &apos;#top&apos;).getOrUndefined(),
        anchorBottom: getTextSetting(editor.settings, &apos;anchor_bottom&apos;, &apos;#bottom&apos;).getOrUndefined()
      });
    };
    var getValidationHandler = function (editor) {
      var optValidator = Option.from(editor.settings.file_picker_validator_handler).filter(isFunction);
      return optValidator.orThunk(function () {
        return Option.from(editor.settings.filepicker_validator_handler).filter(isFunction);
      });
    };
    var UrlInputBackstage = function (editor) {
      return {
        getHistory: getHistory,
        addToHistory: addToHistory,
        getLinkInformation: function () {
          return getLinkInformation(editor);
        },
        getValidationHandler: function () {
          return getValidationHandler(editor);
        },
        getUrlPicker: function (filetype) {
          return getUrlPicker(editor, filetype);
        }
      };
    };

    var init$8 = function (sink, editor, lazyAnchorbar) {
      var contextMenuState = Cell(false);
      var toolbar = HeaderBackstage(editor);
      var backstage = {
        shared: {
          providers: {
            icons: function () {
              return editor.ui.registry.getAll().icons;
            },
            menuItems: function () {
              return editor.ui.registry.getAll().menuItems;
            },
            translate: global$5.translate,
            isReadOnly: function () {
              return editor.mode.isReadOnly();
            }
          },
          interpreter: function (s) {
            return interpretWithoutForm(s, backstage);
          },
          anchors: getAnchors(editor, lazyAnchorbar, toolbar.isPositionedAtTop),
          header: toolbar,
          getSink: function () {
            return Result.value(sink);
          }
        },
        urlinput: UrlInputBackstage(editor),
        styleselect: init$7(editor),
        colorinput: ColorInputBackstage(editor),
        dialog: DialogBackstage(editor),
        isContextMenuOpen: function () {
          return contextMenuState.get();
        },
        setContextMenuState: function (state) {
          return contextMenuState.set(state);
        }
      };
      return backstage;
    };

    var expandable$1 = constant(function (element, available) {
      setMax$1(element, Math.floor(available));
    });

    var showContextToolbarEvent = &apos;contexttoolbar-show&apos;;
    var hideContextToolbarEvent = &apos;contexttoolbar-hide&apos;;

    var schema$k = constant([
      strict$1(&apos;items&apos;),
      markers([&apos;itemSelector&apos;]),
      field$1(&apos;tgroupBehaviours&apos;, [Keying])
    ]);
    var parts$7 = constant([group({
        name: &apos;items&apos;,
        unit: &apos;item&apos;
      })]);

    var factory$9 = function (detail, components, _spec, _externals) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.tgroupBehaviours, [Keying.config({
            mode: &apos;flow&apos;,
            selector: detail.markers.itemSelector
          })]),
        domModification: { attributes: { role: &apos;toolbar&apos; } }
      };
    };
    var ToolbarGroup = composite$1({
      name: &apos;ToolbarGroup&apos;,
      configFields: schema$k(),
      partFields: parts$7(),
      factory: factory$9
    });

    var schema$l = constant([
      strict$1(&apos;dom&apos;),
      defaulted$1(&apos;shell&apos;, true),
      field$1(&apos;toolbarBehaviours&apos;, [Replacing])
    ]);
    var enhanceGroups = function () {
      return { behaviours: derive$1([Replacing.config({})]) };
    };
    var parts$8 = constant([optional({
        name: &apos;groups&apos;,
        overrides: enhanceGroups
      })]);

    var factory$a = function (detail, components, _spec, _externals) {
      var setGroups = function (toolbar, groups) {
        getGroupContainer(toolbar).fold(function () {
          domGlobals.console.error(&apos;Toolbar was defined to not be a shell, but no groups container was specified in components&apos;);
          throw new Error(&apos;Toolbar was defined to not be a shell, but no groups container was specified in components&apos;);
        }, function (container) {
          Replacing.set(container, groups);
        });
      };
      var getGroupContainer = function (component) {
        return detail.shell ? Option.some(component) : getPart(component, detail, &apos;groups&apos;);
      };
      var extra = detail.shell ? {
        behaviours: [Replacing.config({})],
        components: []
      } : {
        behaviours: [],
        components: components
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: extra.components,
        behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
        apis: { setGroups: setGroups },
        domModification: { attributes: { role: &apos;group&apos; } }
      };
    };
    var Toolbar = composite$1({
      name: &apos;Toolbar&apos;,
      configFields: schema$l(),
      partFields: parts$8(),
      factory: factory$a,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        }
      }
    });

    var generate$6 = function (xs, f) {
      var init = {
        len: 0,
        list: []
      };
      var r = foldl(xs, function (b, a) {
        var value = f(a, b.len);
        return value.fold(constant(b), function (v) {
          return {
            len: v.finish(),
            list: b.list.concat([v])
          };
        });
      }, init);
      return r.list;
    };

    var output$1 = function (within, extra, withinWidth) {
      return {
        within: constant(within),
        extra: constant(extra),
        withinWidth: constant(withinWidth)
      };
    };
    var apportion = function (units, total, len) {
      var parray = generate$6(units, function (unit, current) {
        var width = len(unit);
        return Option.some({
          element: constant(unit),
          start: constant(current),
          finish: constant(current + width),
          width: constant(width)
        });
      });
      var within = filter(parray, function (unit) {
        return unit.finish() &lt;= total;
      });
      var withinWidth = foldr(within, function (acc, el) {
        return acc + el.width();
      }, 0);
      var extra = parray.slice(within.length);
      return {
        within: constant(within),
        extra: constant(extra),
        withinWidth: constant(withinWidth)
      };
    };
    var toUnit = function (parray) {
      return map(parray, function (unit) {
        return unit.element();
      });
    };
    var fitLast = function (within, extra, withinWidth) {
      var fits = toUnit(within.concat(extra));
      return output$1(fits, [], withinWidth);
    };
    var overflow = function (within, extra, overflower, withinWidth) {
      var fits = toUnit(within).concat([overflower]);
      return output$1(fits, toUnit(extra), withinWidth);
    };
    var fitAll = function (within, extra, withinWidth) {
      return output$1(toUnit(within), [], withinWidth);
    };
    var tryFit = function (total, units, len) {
      var divide = apportion(units, total, len);
      return divide.extra().length === 0 ? Option.some(divide) : Option.none();
    };
    var partition$3 = function (total, units, len, overflower) {
      var divide = tryFit(total, units, len).getOrThunk(function () {
        return apportion(units, total - len(overflower), len);
      });
      var within = divide.within();
      var extra = divide.extra();
      var withinWidth = divide.withinWidth();
      if (extra.length === 1 &amp;&amp; extra[0].width() &lt;= len(overflower)) {
        return fitLast(within, extra, withinWidth);
      } else if (extra.length &gt;= 1) {
        return overflow(within, extra, overflower, withinWidth);
      } else {
        return fitAll(within, extra, withinWidth);
      }
    };

    var setGroups = function (toolbar, storedGroups) {
      var bGroups = map(storedGroups, function (g) {
        return premade$1(g);
      });
      Toolbar.setGroups(toolbar, bGroups);
    };
    var findFocusedComp = function (comps) {
      return findMap(comps, function (comp) {
        return search(comp.element()).bind(function (focusedElm) {
          return comp.getSystem().getByDom(focusedElm).toOption();
        });
      });
    };
    var refresh = function (toolbar, detail, setOverflow) {
      var primary = getPartOrDie(toolbar, detail, &apos;primary&apos;);
      var overflowGroup = Coupling.getCoupled(toolbar, &apos;overflowGroup&apos;);
      set$2(primary.element(), &apos;visibility&apos;, &apos;hidden&apos;);
      var groups = detail.builtGroups.get().concat([overflowGroup]);
      var focusedComp = findFocusedComp(groups);
      setOverflow([]);
      setGroups(primary, groups);
      var availableWidth = get$7(primary.element());
      var overflows = partition$3(availableWidth, detail.builtGroups.get(), function (comp) {
        return get$7(comp.element());
      }, overflowGroup);
      if (overflows.extra().length === 0) {
        Replacing.remove(primary, overflowGroup);
        setOverflow([]);
      } else {
        setGroups(primary, overflows.within());
        setOverflow(overflows.extra());
      }
      remove$6(primary.element(), &apos;visibility&apos;);
      reflow(primary.element());
      focusedComp.each(Focusing.focus);
    };

    var schema$m = constant([
      field$1(&apos;splitToolbarBehaviours&apos;, [Coupling]),
      state$1(&apos;builtGroups&apos;, function () {
        return Cell([]);
      })
    ]);

    var schema$n = constant([
      markers([&apos;overflowToggledClass&apos;]),
      optionFunction(&apos;getOverflowBounds&apos;),
      strict$1(&apos;lazySink&apos;),
      state$1(&apos;overflowGroups&apos;, function () {
        return Cell([]);
      })
    ].concat(schema$m()));
    var parts$9 = constant([
      required({
        factory: Toolbar,
        schema: schema$l(),
        name: &apos;primary&apos;
      }),
      external$1({
        schema: schema$l(),
        name: &apos;overflow&apos;
      }),
      external$1({ name: &apos;overflow-button&apos; }),
      external$1({ name: &apos;overflow-group&apos; })
    ]);

    var schema$o = constant([
      markers([&apos;toggledClass&apos;]),
      strict$1(&apos;lazySink&apos;),
      strictFunction(&apos;fetch&apos;),
      optionFunction(&apos;getBounds&apos;),
      optionObjOf(&apos;fireDismissalEventInstead&apos;, [defaulted$1(&apos;event&apos;, dismissRequested())]),
      schema$1()
    ]);
    var parts$a = constant([
      external$1({
        name: &apos;button&apos;,
        overrides: function (detail) {
          return {
            dom: { attributes: { &apos;aria-haspopup&apos;: &apos;true&apos; } },
            buttonBehaviours: derive$1([Toggling.config({
                toggleClass: detail.markers.toggledClass,
                aria: { mode: &apos;expanded&apos; },
                toggleOnExecute: false
              })])
          };
        }
      }),
      external$1({
        factory: Toolbar,
        schema: schema$l(),
        name: &apos;toolbar&apos;,
        overrides: function (detail) {
          return {
            toolbarBehaviours: derive$1([Keying.config({
                mode: &apos;cyclic&apos;,
                onEscape: function (comp) {
                  getPart(comp, detail, &apos;button&apos;).each(Focusing.focus);
                  return Option.none();
                }
              })])
          };
        }
      })
    ]);

    var toggle$2 = function (button, externals) {
      var toolbarSandbox = Coupling.getCoupled(button, &apos;toolbarSandbox&apos;);
      if (Sandboxing.isOpen(toolbarSandbox)) {
        Sandboxing.close(toolbarSandbox);
      } else {
        Sandboxing.open(toolbarSandbox, externals.toolbar());
      }
    };
    var position$2 = function (button, toolbar, detail, layouts) {
      var bounds = detail.getBounds.map(function (bounder) {
        return bounder();
      });
      var sink = detail.lazySink(button).getOrDie();
      Positioning.positionWithinBounds(sink, {
        anchor: &apos;hotspot&apos;,
        hotspot: button,
        layouts: layouts,
        overrides: { maxWidthFunction: expandable$1() }
      }, toolbar, bounds);
    };
    var setGroups$1 = function (button, toolbar, detail, layouts, groups) {
      Toolbar.setGroups(toolbar, groups);
      position$2(button, toolbar, detail, layouts);
      Toggling.on(button);
    };
    var makeSandbox$1 = function (button, spec, detail) {
      var ariaOwner = manager();
      var onOpen = function (sandbox, toolbar) {
        detail.fetch().get(function (groups) {
          setGroups$1(button, toolbar, detail, spec.layouts, groups);
          ariaOwner.link(button.element());
          Keying.focusIn(toolbar);
        });
      };
      var onClose = function () {
        Toggling.off(button);
        Focusing.focus(button);
        ariaOwner.unlink(button.element());
      };
      return {
        dom: {
          tag: &apos;div&apos;,
          attributes: { id: ariaOwner.id }
        },
        behaviours: derive$1([
          Keying.config({
            mode: &apos;special&apos;,
            onEscape: function (comp) {
              Sandboxing.close(comp);
              return Option.some(true);
            }
          }),
          Sandboxing.config({
            onOpen: onOpen,
            onClose: onClose,
            isPartOf: function (container, data, queryElem) {
              return isPartOf(data, queryElem) || isPartOf(button, queryElem);
            },
            getAttachPoint: function () {
              return detail.lazySink(button).getOrDie();
            }
          }),
          Receiving.config({
            channels: __assign(__assign({}, receivingChannel(__assign({ isExtraPart: never }, detail.fireDismissalEventInstead.map(function (fe) {
              return { fireEventInstead: { event: fe.event } };
            }).getOr({})))), receivingChannel$1({
              doReposition: function () {
                Sandboxing.getState(Coupling.getCoupled(button, &apos;toolbarSandbox&apos;)).each(function (toolbar) {
                  position$2(button, toolbar, detail, spec.layouts);
                });
              }
            }))
          })
        ])
      };
    };
    var factory$b = function (detail, components, spec, externals) {
      return __assign(__assign({}, Button.sketch(__assign(__assign({}, externals.button()), {
        action: function (button) {
          toggle$2(button, externals);
        },
        buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({
            others: {
              toolbarSandbox: function (button) {
                return makeSandbox$1(button, spec, detail);
              }
            }
          })])
      }))), {
        apis: {
          setGroups: function (button, groups) {
            Sandboxing.getState(Coupling.getCoupled(button, &apos;toolbarSandbox&apos;)).each(function (toolbar) {
              setGroups$1(button, toolbar, detail, spec.layouts, groups);
            });
          },
          reposition: function (button) {
            Sandboxing.getState(Coupling.getCoupled(button, &apos;toolbarSandbox&apos;)).each(function (toolbar) {
              position$2(button, toolbar, detail, spec.layouts);
            });
          },
          toggle: function (button) {
            toggle$2(button, externals);
          },
          getToolbar: function (button) {
            return Sandboxing.getState(Coupling.getCoupled(button, &apos;toolbarSandbox&apos;));
          }
        }
      });
    };
    var FloatingToolbarButton = composite$1({
      name: &apos;FloatingToolbarButton&apos;,
      factory: factory$b,
      configFields: schema$o(),
      partFields: parts$a(),
      apis: {
        setGroups: function (apis, button, groups) {
          apis.setGroups(button, groups);
        },
        reposition: function (apis, button) {
          apis.reposition(button);
        },
        toggle: function (apis, button) {
          apis.toggle(button);
        },
        getToolbar: function (apis, button) {
          return apis.getToolbar(button);
        }
      }
    });

    var buildGroups = function (comps) {
      return map(comps, function (g) {
        return premade$1(g);
      });
    };
    var refresh$1 = function (toolbar, memFloatingToolbarButton, detail) {
      refresh(toolbar, detail, function (overflowGroups) {
        detail.overflowGroups.set(overflowGroups);
        memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
          FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
        });
      });
    };
    var factory$c = function (detail, components, spec, externals) {
      var memFloatingToolbarButton = record(FloatingToolbarButton.sketch({
        fetch: function () {
          return Future.nu(function (resolve) {
            resolve(buildGroups(detail.overflowGroups.get()));
          });
        },
        layouts: {
          onLtr: function () {
            return [
              southwest$1,
              southeast$1
            ];
          },
          onRtl: function () {
            return [
              southeast$1,
              southwest$1
            ];
          },
          onBottomLtr: function () {
            return [
              northwest$1,
              northeast$1
            ];
          },
          onBottomRtl: function () {
            return [
              northeast$1,
              northwest$1
            ];
          }
        },
        getBounds: spec.getOverflowBounds,
        lazySink: detail.lazySink,
        fireDismissalEventInstead: {},
        markers: { toggledClass: detail.markers.overflowToggledClass },
        parts: {
          button: externals[&apos;overflow-button&apos;](),
          toolbar: externals.overflow()
        }
      }));
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({
            others: {
              overflowGroup: function () {
                return ToolbarGroup.sketch(__assign(__assign({}, externals[&apos;overflow-group&apos;]()), { items: [memFloatingToolbarButton.asSpec()] }));
              }
            }
          })]),
        apis: {
          setGroups: function (toolbar, groups) {
            detail.builtGroups.set(map(groups, toolbar.getSystem().build));
            refresh$1(toolbar, memFloatingToolbarButton, detail);
          },
          refresh: function (toolbar) {
            return refresh$1(toolbar, memFloatingToolbarButton, detail);
          },
          toggle: function (toolbar) {
            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
              FloatingToolbarButton.toggle(floatingToolbarButton);
            });
          },
          reposition: function (toolbar) {
            memFloatingToolbarButton.getOpt(toolbar).each(function (floatingToolbarButton) {
              FloatingToolbarButton.reposition(floatingToolbarButton);
            });
          },
          getOverflow: function (toolbar) {
            return memFloatingToolbarButton.getOpt(toolbar).bind(function (floatingToolbarButton) {
              return FloatingToolbarButton.getToolbar(floatingToolbarButton);
            });
          }
        },
        domModification: { attributes: { role: &apos;group&apos; } }
      };
    };
    var SplitFloatingToolbar = composite$1({
      name: &apos;SplitFloatingToolbar&apos;,
      configFields: schema$n(),
      partFields: parts$9(),
      factory: factory$c,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        },
        refresh: function (apis, toolbar) {
          apis.refresh(toolbar);
        },
        reposition: function (apis, toolbar) {
          apis.reposition(toolbar);
        },
        toggle: function (apis, toolbar) {
          apis.toggle(toolbar);
        },
        getOverflow: function (apis, toolbar) {
          return apis.getOverflow(toolbar);
        }
      }
    });

    var getAnimationRoot = function (component, slideConfig) {
      return slideConfig.getAnimationRoot.fold(function () {
        return component.element();
      }, function (get) {
        return get(component);
      });
    };

    var getDimensionProperty = function (slideConfig) {
      return slideConfig.dimension.property;
    };
    var getDimension = function (slideConfig, elem) {
      return slideConfig.dimension.getDimension(elem);
    };
    var disableTransitions = function (component, slideConfig) {
      var root = getAnimationRoot(component, slideConfig);
      remove$5(root, [
        slideConfig.shrinkingClass,
        slideConfig.growingClass
      ]);
    };
    var setShrunk = function (component, slideConfig) {
      remove$4(component.element(), slideConfig.openClass);
      add$2(component.element(), slideConfig.closedClass);
      set$2(component.element(), getDimensionProperty(slideConfig), &apos;0px&apos;);
      reflow(component.element());
    };
    var setGrown = function (component, slideConfig) {
      remove$4(component.element(), slideConfig.closedClass);
      add$2(component.element(), slideConfig.openClass);
      remove$6(component.element(), getDimensionProperty(slideConfig));
    };
    var doImmediateShrink = function (component, slideConfig, slideState, _calculatedSize) {
      slideState.setCollapsed();
      set$2(component.element(), getDimensionProperty(slideConfig), getDimension(slideConfig, component.element()));
      reflow(component.element());
      disableTransitions(component, slideConfig);
      setShrunk(component, slideConfig);
      slideConfig.onStartShrink(component);
      slideConfig.onShrunk(component);
    };
    var doStartShrink = function (component, slideConfig, slideState, calculatedSize) {
      var size = calculatedSize.getOrThunk(function () {
        return getDimension(slideConfig, component.element());
      });
      slideState.setCollapsed();
      set$2(component.element(), getDimensionProperty(slideConfig), size);
      reflow(component.element());
      var root = getAnimationRoot(component, slideConfig);
      remove$4(root, slideConfig.growingClass);
      add$2(root, slideConfig.shrinkingClass);
      setShrunk(component, slideConfig);
      slideConfig.onStartShrink(component);
    };
    var doStartSmartShrink = function (component, slideConfig, slideState) {
      var size = getDimension(slideConfig, component.element());
      var shrinker = size === &apos;0px&apos; ? doImmediateShrink : doStartShrink;
      shrinker(component, slideConfig, slideState, Option.some(size));
    };
    var doStartGrow = function (component, slideConfig, slideState) {
      var root = getAnimationRoot(component, slideConfig);
      var wasShrinking = has$2(root, slideConfig.shrinkingClass);
      var beforeSize = getDimension(slideConfig, component.element());
      setGrown(component, slideConfig);
      var fullSize = getDimension(slideConfig, component.element());
      var startPartialGrow = function () {
        set$2(component.element(), getDimensionProperty(slideConfig), beforeSize);
        reflow(component.element());
      };
      var startCompleteGrow = function () {
        setShrunk(component, slideConfig);
      };
      var setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
      setStartSize();
      remove$4(root, slideConfig.shrinkingClass);
      add$2(root, slideConfig.growingClass);
      setGrown(component, slideConfig);
      set$2(component.element(), getDimensionProperty(slideConfig), fullSize);
      slideState.setExpanded();
      slideConfig.onStartGrow(component);
    };
    var refresh$2 = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        remove$6(component.element(), getDimensionProperty(slideConfig));
        var fullSize = getDimension(slideConfig, component.element());
        set$2(component.element(), getDimensionProperty(slideConfig), fullSize);
      }
    };
    var grow = function (component, slideConfig, slideState) {
      if (!slideState.isExpanded()) {
        doStartGrow(component, slideConfig, slideState);
      }
    };
    var shrink = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        doStartSmartShrink(component, slideConfig, slideState);
      }
    };
    var immediateShrink = function (component, slideConfig, slideState) {
      if (slideState.isExpanded()) {
        doImmediateShrink(component, slideConfig, slideState, Option.none());
      }
    };
    var hasGrown = function (component, slideConfig, slideState) {
      return slideState.isExpanded();
    };
    var hasShrunk = function (component, slideConfig, slideState) {
      return slideState.isCollapsed();
    };
    var isGrowing = function (component, slideConfig, _slideState) {
      var root = getAnimationRoot(component, slideConfig);
      return has$2(root, slideConfig.growingClass) === true;
    };
    var isShrinking = function (component, slideConfig, _slideState) {
      var root = getAnimationRoot(component, slideConfig);
      return has$2(root, slideConfig.shrinkingClass) === true;
    };
    var isTransitioning = function (component, slideConfig, slideState) {
      return isGrowing(component, slideConfig) === true || isShrinking(component, slideConfig) === true;
    };
    var toggleGrow = function (component, slideConfig, slideState) {
      var f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
      f(component, slideConfig, slideState);
    };

    var SlidingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$2,
        grow: grow,
        shrink: shrink,
        immediateShrink: immediateShrink,
        hasGrown: hasGrown,
        hasShrunk: hasShrunk,
        isGrowing: isGrowing,
        isShrinking: isShrinking,
        isTransitioning: isTransitioning,
        toggleGrow: toggleGrow,
        disableTransitions: disableTransitions
    });

    var exhibit$6 = function (base, slideConfig, _slideState) {
      var expanded = slideConfig.expanded;
      return expanded ? nu$6({
        classes: [slideConfig.openClass],
        styles: {}
      }) : nu$6({
        classes: [slideConfig.closedClass],
        styles: wrap$1(slideConfig.dimension.property, &apos;0px&apos;)
      });
    };
    var events$d = function (slideConfig, slideState) {
      return derive([runOnSource(transitionend(), function (component, simulatedEvent) {
          var raw = simulatedEvent.event().raw();
          if (raw.propertyName === slideConfig.dimension.property) {
            disableTransitions(component, slideConfig);
            if (slideState.isExpanded()) {
              remove$6(component.element(), slideConfig.dimension.property);
            }
            var notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;
            notify(component);
          }
        })]);
    };

    var ActiveSliding = /*#__PURE__*/Object.freeze({
        __proto__: null,
        exhibit: exhibit$6,
        events: events$d
    });

    var SlidingSchema = [
      strict$1(&apos;closedClass&apos;),
      strict$1(&apos;openClass&apos;),
      strict$1(&apos;shrinkingClass&apos;),
      strict$1(&apos;growingClass&apos;),
      option(&apos;getAnimationRoot&apos;),
      onHandler(&apos;onShrunk&apos;),
      onHandler(&apos;onStartShrink&apos;),
      onHandler(&apos;onGrown&apos;),
      onHandler(&apos;onStartGrow&apos;),
      defaulted$1(&apos;expanded&apos;, false),
      strictOf(&apos;dimension&apos;, choose$1(&apos;property&apos;, {
        width: [
          output(&apos;property&apos;, &apos;width&apos;),
          output(&apos;getDimension&apos;, function (elem) {
            return get$7(elem) + &apos;px&apos;;
          })
        ],
        height: [
          output(&apos;property&apos;, &apos;height&apos;),
          output(&apos;getDimension&apos;, function (elem) {
            return get$6(elem) + &apos;px&apos;;
          })
        ]
      }))
    ];

    var init$9 = function (spec) {
      var state = Cell(spec.expanded);
      var readState = function () {
        return &apos;expanded: &apos; + state.get();
      };
      return nu$5({
        isExpanded: function () {
          return state.get() === true;
        },
        isCollapsed: function () {
          return state.get() === false;
        },
        setCollapsed: curry(state.set, false),
        setExpanded: curry(state.set, true),
        readState: readState
      });
    };

    var SlidingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$9
    });

    var Sliding = create$1({
      fields: SlidingSchema,
      name: &apos;sliding&apos;,
      active: ActiveSliding,
      apis: SlidingApis,
      state: SlidingState
    });

    var schema$p = constant([
      markers([
        &apos;closedClass&apos;,
        &apos;openClass&apos;,
        &apos;shrinkingClass&apos;,
        &apos;growingClass&apos;,
        &apos;overflowToggledClass&apos;
      ]),
      onHandler(&apos;onOpened&apos;),
      onHandler(&apos;onClosed&apos;)
    ].concat(schema$m()));
    var parts$b = constant([
      required({
        factory: Toolbar,
        schema: schema$l(),
        name: &apos;primary&apos;
      }),
      required({
        factory: Toolbar,
        schema: schema$l(),
        name: &apos;overflow&apos;,
        overrides: function (detail) {
          return {
            toolbarBehaviours: derive$1([
              Sliding.config({
                dimension: { property: &apos;height&apos; },
                closedClass: detail.markers.closedClass,
                openClass: detail.markers.openClass,
                shrinkingClass: detail.markers.shrinkingClass,
                growingClass: detail.markers.growingClass,
                onShrunk: function (comp) {
                  getPart(comp, detail, &apos;overflow-button&apos;).each(function (button) {
                    Toggling.off(button);
                    Focusing.focus(button);
                  });
                  detail.onClosed(comp);
                },
                onGrown: function (comp) {
                  Keying.focusIn(comp);
                  detail.onOpened(comp);
                },
                onStartGrow: function (comp) {
                  getPart(comp, detail, &apos;overflow-button&apos;).each(Toggling.on);
                }
              }),
              Keying.config({
                mode: &apos;acyclic&apos;,
                onEscape: function (comp) {
                  getPart(comp, detail, &apos;overflow-button&apos;).each(Focusing.focus);
                  return Option.some(true);
                }
              })
            ])
          };
        }
      }),
      external$1({
        name: &apos;overflow-button&apos;,
        overrides: function (detail) {
          return {
            buttonBehaviours: derive$1([Toggling.config({
                toggleClass: detail.markers.overflowToggledClass,
                aria: { mode: &apos;pressed&apos; },
                toggleOnExecute: false
              })])
          };
        }
      }),
      external$1({ name: &apos;overflow-group&apos; })
    ]);

    var toggleToolbar = function (toolbar, detail) {
      getPart(toolbar, detail, &apos;overflow&apos;).each(function (overf) {
        refresh$3(toolbar, detail);
        Sliding.toggleGrow(overf);
      });
    };
    var refresh$3 = function (toolbar, detail) {
      getPart(toolbar, detail, &apos;overflow&apos;).each(function (overflow) {
        refresh(toolbar, detail, function (groups) {
          var builtGroups = map(groups, function (g) {
            return premade$1(g);
          });
          Toolbar.setGroups(overflow, builtGroups);
        });
        getPart(toolbar, detail, &apos;overflow-button&apos;).each(function (button) {
          if (Sliding.hasGrown(overflow)) {
            Toggling.on(button);
          }
        });
        Sliding.refresh(overflow);
      });
    };
    var factory$d = function (detail, components, spec, externals) {
      var toolbarToggleEvent = &apos;alloy.toolbar.toggle&apos;;
      var doSetGroups = function (toolbar, groups) {
        var built = map(groups, toolbar.getSystem().build);
        detail.builtGroups.set(built);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: augment(detail.splitToolbarBehaviours, [
          Coupling.config({
            others: {
              overflowGroup: function (toolbar) {
                return ToolbarGroup.sketch(__assign(__assign({}, externals[&apos;overflow-group&apos;]()), {
                  items: [Button.sketch(__assign(__assign({}, externals[&apos;overflow-button&apos;]()), {
                      action: function (_button) {
                        emit(toolbar, toolbarToggleEvent);
                      }
                    }))]
                }));
              }
            }
          }),
          config(&apos;toolbar-toggle-events&apos;, [run(toolbarToggleEvent, function (toolbar) {
              getPart(toolbar, detail, &apos;overflow&apos;).each(function (overf) {
                refresh$3(toolbar, detail);
                Sliding.toggleGrow(overf);
              });
            })])
        ]),
        apis: {
          setGroups: function (toolbar, groups) {
            doSetGroups(toolbar, groups);
            refresh$3(toolbar, detail);
          },
          refresh: function (toolbar) {
            return refresh$3(toolbar, detail);
          },
          toggle: function (toolbar) {
            return toggleToolbar(toolbar, detail);
          }
        },
        domModification: { attributes: { role: &apos;group&apos; } }
      };
    };
    var SplitSlidingToolbar = composite$1({
      name: &apos;SplitSlidingToolbar&apos;,
      configFields: schema$p(),
      partFields: parts$b(),
      factory: factory$d,
      apis: {
        setGroups: function (apis, toolbar, groups) {
          apis.setGroups(toolbar, groups);
        },
        refresh: function (apis, toolbar) {
          apis.refresh(toolbar);
        },
        toggle: function (apis, toolbar) {
          apis.toggle(toolbar);
        }
      }
    });

    var toolbarHeightChange = constant(generate$1(&apos;toolbar-height-change&apos;));

    var renderToolbarGroupCommon = function (toolbarGroup) {
      var attributes = toolbarGroup.title.fold(function () {
        return {};
      }, function (title) {
        return { attributes: { title: title } };
      });
      return {
        dom: __assign({
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar__group&apos;]
        }, attributes),
        components: [ToolbarGroup.parts().items({})],
        items: toolbarGroup.items,
        markers: { itemSelector: &apos;*:not(.tox-split-button) &gt; .tox-tbtn:not([disabled]), &apos; + &apos;.tox-split-button:not([disabled]), &apos; + &apos;.tox-toolbar-nav-js:not([disabled])&apos; },
        tgroupBehaviours: derive$1([
          Tabstopping.config({}),
          Focusing.config({})
        ])
      };
    };
    var renderToolbarGroup = function (toolbarGroup) {
      return ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
    };
    var getToolbarbehaviours = function (toolbarSpec, modeName) {
      var onAttached = runOnAttached(function (component) {
        var groups = map(toolbarSpec.initGroups, renderToolbarGroup);
        Toolbar.setGroups(component, groups);
      });
      return derive$1([
        DisablingConfigs.toolbarButton(toolbarSpec.providers.isReadOnly),
        receivingConfig(),
        Keying.config({
          mode: modeName,
          onEscape: toolbarSpec.onEscape,
          selector: &apos;.tox-toolbar__group&apos;
        }),
        config(&apos;toolbar-events&apos;, [onAttached])
      ]);
    };
    var renderMoreToolbarCommon = function (toolbarSpec) {
      var modeName = toolbarSpec.cyclicKeying ? &apos;cyclic&apos; : &apos;acyclic&apos;;
      return {
        uid: toolbarSpec.uid,
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar-overlord&apos;]
        },
        parts: {
          &apos;overflow-group&apos;: renderToolbarGroupCommon({
            title: Option.none(),
            items: []
          }),
          &apos;overflow-button&apos;: renderIconButtonSpec({
            name: &apos;more&apos;,
            icon: Option.some(&apos;more-drawer&apos;),
            disabled: false,
            tooltip: Option.some(&apos;More...&apos;),
            primary: false,
            borderless: false
          }, Option.none(), toolbarSpec.providers)
        },
        splitToolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
      };
    };
    var renderFloatingMoreToolbar = function (toolbarSpec) {
      var baseSpec = renderMoreToolbarCommon(toolbarSpec);
      var overflowXOffset = 4;
      var primary = SplitFloatingToolbar.parts().primary({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar__primary&apos;]
        }
      });
      return SplitFloatingToolbar.sketch(__assign(__assign({}, baseSpec), {
        lazySink: toolbarSpec.getSink,
        getOverflowBounds: function () {
          var headerElem = toolbarSpec.moreDrawerData.lazyHeader().element();
          var headerBounds = absolute$1(headerElem);
          var docElem = documentElement(headerElem);
          var docBounds = absolute$1(docElem);
          var height = Math.max(docElem.dom().scrollHeight, docBounds.height);
          return bounds$1(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height);
        },
        parts: __assign(__assign({}, baseSpec.parts), {
          overflow: {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-toolbar__overflow&apos;],
              attributes: toolbarSpec.attributes
            }
          }
        }),
        components: [primary],
        markers: { overflowToggledClass: &apos;tox-tbtn--enabled&apos; }
      }));
    };
    var renderSlidingMoreToolbar = function (toolbarSpec) {
      var primary = SplitSlidingToolbar.parts().primary({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar__primary&apos;]
        }
      });
      var overflow = SplitSlidingToolbar.parts().overflow({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar__overflow&apos;]
        }
      });
      var baseSpec = renderMoreToolbarCommon(toolbarSpec);
      return SplitSlidingToolbar.sketch(__assign(__assign({}, baseSpec), {
        components: [
          primary,
          overflow
        ],
        markers: {
          openClass: &apos;tox-toolbar__overflow--open&apos;,
          closedClass: &apos;tox-toolbar__overflow--closed&apos;,
          growingClass: &apos;tox-toolbar__overflow--growing&apos;,
          shrinkingClass: &apos;tox-toolbar__overflow--shrinking&apos;,
          overflowToggledClass: &apos;tox-tbtn--enabled&apos;
        },
        onOpened: function (comp) {
          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: &apos;opened&apos; });
        },
        onClosed: function (comp) {
          comp.getSystem().broadcastOn([toolbarHeightChange()], { type: &apos;closed&apos; });
        }
      }));
    };
    var renderToolbar = function (toolbarSpec) {
      var modeName = toolbarSpec.cyclicKeying ? &apos;cyclic&apos; : &apos;acyclic&apos;;
      return Toolbar.sketch({
        uid: toolbarSpec.uid,
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar&apos;].concat(toolbarSpec.type === ToolbarMode.scrolling ? [&apos;tox-toolbar--scrolling&apos;] : [])
        },
        components: [Toolbar.parts().groups({})],
        toolbarBehaviours: getToolbarbehaviours(toolbarSpec, modeName)
      });
    };

    var baseToolbarButtonFields = [
      defaultedBoolean(&apos;disabled&apos;, false),
      optionString(&apos;tooltip&apos;),
      optionString(&apos;icon&apos;),
      optionString(&apos;text&apos;),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      })
    ];
    var toolbarButtonSchema = objOf([
      strictString(&apos;type&apos;),
      strictFunction(&apos;onAction&apos;)
    ].concat(baseToolbarButtonFields));
    var createToolbarButton = function (spec) {
      return asRaw(&apos;toolbarbutton&apos;, toolbarButtonSchema, spec);
    };

    var baseMenuButtonFields = [
      optionString(&apos;text&apos;),
      optionString(&apos;tooltip&apos;),
      optionString(&apos;icon&apos;),
      strictFunction(&apos;fetch&apos;),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      })
    ];

    var MenuButtonSchema = objOf(__spreadArrays([strictString(&apos;type&apos;)], baseMenuButtonFields));
    var createMenuButton = function (spec) {
      return asRaw(&apos;menubutton&apos;, MenuButtonSchema, spec);
    };

    var splitButtonSchema = objOf([
      strictString(&apos;type&apos;),
      optionString(&apos;tooltip&apos;),
      optionString(&apos;icon&apos;),
      optionString(&apos;text&apos;),
      optionFunction(&apos;select&apos;),
      strictFunction(&apos;fetch&apos;),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      }),
      defaultedStringEnum(&apos;presets&apos;, &apos;normal&apos;, [
        &apos;normal&apos;,
        &apos;color&apos;,
        &apos;listpreview&apos;
      ]),
      defaulted$1(&apos;columns&apos;, 1),
      strictFunction(&apos;onAction&apos;),
      strictFunction(&apos;onItemAction&apos;)
    ]);
    var createSplitButton = function (spec) {
      return asRaw(&apos;SplitButton&apos;, splitButtonSchema, spec);
    };

    var baseToolbarToggleButtonFields = [defaultedBoolean(&apos;active&apos;, false)].concat(baseToolbarButtonFields);
    var toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([
      strictString(&apos;type&apos;),
      strictFunction(&apos;onAction&apos;)
    ]));
    var createToggleButton = function (spec) {
      return asRaw(&apos;ToggleButton&apos;, toggleButtonSchema, spec);
    };

    var groupToolbarButtonSchema = objOf([
      strictString(&apos;type&apos;),
      strictOf(&apos;items&apos;, oneOf([
        arrOfObj$1([
          strictString(&apos;name&apos;),
          strictArrayOf(&apos;items&apos;, string)
        ]),
        string
      ]))
    ].concat(baseToolbarButtonFields));
    var createGroupToolbarButton = function (spec) {
      return asRaw(&apos;GroupToolbarButton&apos;, groupToolbarButtonSchema, spec);
    };

    var contextBarFields = [
      defaultedFunction(&apos;predicate&apos;, function () {
        return false;
      }),
      defaultedStringEnum(&apos;scope&apos;, &apos;node&apos;, [
        &apos;node&apos;,
        &apos;editor&apos;
      ]),
      defaultedStringEnum(&apos;position&apos;, &apos;selection&apos;, [
        &apos;node&apos;,
        &apos;selection&apos;,
        &apos;line&apos;
      ])
    ];
    var contextButtonFields = baseToolbarButtonFields.concat([
      defaulted$1(&apos;type&apos;, &apos;contextformbutton&apos;),
      defaulted$1(&apos;primary&apos;, false),
      strictFunction(&apos;onAction&apos;),
      state$1(&apos;original&apos;, identity)
    ]);
    var contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
      defaulted$1(&apos;type&apos;, &apos;contextformbutton&apos;),
      defaulted$1(&apos;primary&apos;, false),
      strictFunction(&apos;onAction&apos;),
      state$1(&apos;original&apos;, identity)
    ]);
    var launchButtonFields = baseToolbarButtonFields.concat([defaulted$1(&apos;type&apos;, &apos;contextformbutton&apos;)]);
    var launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaulted$1(&apos;type&apos;, &apos;contextformtogglebutton&apos;)]);
    var toggleOrNormal = choose$1(&apos;type&apos;, {
      contextformbutton: contextButtonFields,
      contextformtogglebutton: contextToggleButtonFields
    });
    var contextFormSchema = objOf([
      defaulted$1(&apos;type&apos;, &apos;contextform&apos;),
      defaultedFunction(&apos;initValue&apos;, function () {
        return &apos;&apos;;
      }),
      optionString(&apos;label&apos;),
      strictArrayOf(&apos;commands&apos;, toggleOrNormal),
      optionOf(&apos;launch&apos;, choose$1(&apos;type&apos;, {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields
      }))
    ].concat(contextBarFields));
    var contextToolbarSchema = objOf([
      defaulted$1(&apos;type&apos;, &apos;contexttoolbar&apos;),
      strictString(&apos;items&apos;)
    ].concat(contextBarFields));
    var createContextToolbar = function (spec) {
      return asRaw(&apos;ContextToolbar&apos;, contextToolbarSchema, spec);
    };
    var createContextForm = function (spec) {
      return asRaw(&apos;ContextForm&apos;, contextFormSchema, spec);
    };

    var getState$2 = function (component, replaceConfig, reflectState) {
      return reflectState;
    };

    var ReflectingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getState: getState$2
    });

    var events$e = function (reflectingConfig, reflectingState) {
      var update = function (component, data) {
        reflectingConfig.updateState.each(function (updateState) {
          var newState = updateState(component, data);
          reflectingState.set(newState);
        });
        reflectingConfig.renderComponents.each(function (renderComponents) {
          var newComponents = renderComponents(data, reflectingState.get());
          var newChildren = map(newComponents, component.getSystem().build);
          replaceChildren(component, newChildren);
        });
      };
      return derive([
        run(receive(), function (component, message) {
          var receivingData = message;
          var channel = reflectingConfig.channel;
          if (contains(receivingData.channels(), channel)) {
            update(component, receivingData.data());
          }
        }),
        runOnAttached(function (comp, _se) {
          reflectingConfig.initialData.each(function (rawData) {
            update(comp, rawData);
          });
        })
      ]);
    };

    var ActiveReflecting = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$e
    });

    var init$a = function () {
      var cell = Cell(Option.none());
      var set = function (optS) {
        return cell.set(optS);
      };
      var clear = function () {
        return cell.set(Option.none());
      };
      var get = function () {
        return cell.get();
      };
      var readState = function () {
        return cell.get().fold(function () {
          return &apos;none&apos;;
        }, function (x) {
          return x;
        });
      };
      return {
        readState: readState,
        get: get,
        set: set,
        clear: clear
      };
    };

    var ReflectingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$a
    });

    var ReflectingSchema = [
      strict$1(&apos;channel&apos;),
      option(&apos;renderComponents&apos;),
      option(&apos;updateState&apos;),
      option(&apos;initialData&apos;)
    ];

    var Reflecting = create$1({
      fields: ReflectingSchema,
      name: &apos;reflecting&apos;,
      active: ActiveReflecting,
      apis: ReflectingApis,
      state: ReflectingState
    });

    var schema$q = constant([
      strict$1(&apos;toggleClass&apos;),
      strict$1(&apos;fetch&apos;),
      onStrictHandler(&apos;onExecute&apos;),
      defaulted$1(&apos;getHotspot&apos;, Option.some),
      defaulted$1(&apos;getAnchorOverrides&apos;, constant({})),
      schema$1(),
      onStrictHandler(&apos;onItemExecute&apos;),
      option(&apos;lazySink&apos;),
      strict$1(&apos;dom&apos;),
      onHandler(&apos;onOpen&apos;),
      field$1(&apos;splitDropdownBehaviours&apos;, [
        Coupling,
        Keying,
        Focusing
      ]),
      defaulted$1(&apos;matchWidth&apos;, false),
      defaulted$1(&apos;useMinWidth&apos;, false),
      defaulted$1(&apos;eventOrder&apos;, {}),
      option(&apos;role&apos;)
    ].concat(sandboxFields()));
    var arrowPart = required({
      factory: Button,
      schema: [strict$1(&apos;dom&apos;)],
      name: &apos;arrow&apos;,
      defaults: function () {
        return { buttonBehaviours: derive$1([Focusing.revoke()]) };
      },
      overrides: function (detail) {
        return {
          dom: {
            tag: &apos;span&apos;,
            attributes: { role: &apos;presentation&apos; }
          },
          action: function (arrow) {
            arrow.getSystem().getByUid(detail.uid).each(emitExecute);
          },
          buttonBehaviours: derive$1([Toggling.config({
              toggleOnExecute: false,
              toggleClass: detail.toggleClass
            })])
        };
      }
    });
    var buttonPart = required({
      factory: Button,
      schema: [strict$1(&apos;dom&apos;)],
      name: &apos;button&apos;,
      defaults: function () {
        return { buttonBehaviours: derive$1([Focusing.revoke()]) };
      },
      overrides: function (detail) {
        return {
          dom: {
            tag: &apos;span&apos;,
            attributes: { role: &apos;presentation&apos; }
          },
          action: function (btn) {
            btn.getSystem().getByUid(detail.uid).each(function (splitDropdown) {
              detail.onExecute(splitDropdown, btn);
            });
          }
        };
      }
    });
    var parts$c = constant([
      arrowPart,
      buttonPart,
      optional({
        factory: {
          sketch: function (spec) {
            return {
              uid: spec.uid,
              dom: {
                tag: &apos;span&apos;,
                styles: { display: &apos;none&apos; },
                attributes: { &apos;aria-hidden&apos;: &apos;true&apos; },
                innerHtml: spec.text
              }
            };
          }
        },
        schema: [strict$1(&apos;text&apos;)],
        name: &apos;aria-descriptor&apos;
      }),
      external$1({
        schema: [tieredMenuMarkers()],
        name: &apos;menu&apos;,
        defaults: function (detail) {
          return {
            onExecute: function (tmenu, item) {
              tmenu.getSystem().getByUid(detail.uid).each(function (splitDropdown) {
                detail.onItemExecute(splitDropdown, tmenu, item);
              });
            }
          };
        }
      }),
      partType()
    ]);

    var factory$e = function (detail, components, spec, externals) {
      var switchToMenu = function (sandbox) {
        Composing.getCurrent(sandbox).each(function (current) {
          Highlighting.highlightFirst(current);
          Keying.focusIn(current);
        });
      };
      var action = function (component) {
        var onOpenSync = switchToMenu;
        togglePopup(detail, function (x) {
          return x;
        }, component, externals, onOpenSync, HighlightOnOpen.HighlightFirst).get(noop);
      };
      var openMenu = function (comp) {
        action(comp);
        return Option.some(true);
      };
      var executeOnButton = function (comp) {
        var button = getPartOrDie(comp, detail, &apos;button&apos;);
        emitExecute(button);
        return Option.some(true);
      };
      var buttonEvents = __assign(__assign({}, derive([runOnAttached(function (component, _simulatedEvent) {
          var ariaDescriptor = getPart(component, detail, &apos;aria-descriptor&apos;);
          ariaDescriptor.each(function (descriptor) {
            var descriptorId = generate$1(&apos;aria&apos;);
            set$1(descriptor.element(), &apos;id&apos;, descriptorId);
            set$1(component.element(), &apos;aria-describedby&apos;, descriptorId);
          });
        })])), events$7(Option.some(action)));
      var apis = {
        repositionMenus: function (comp) {
          if (Toggling.isOn(comp)) {
            repositionMenus(comp);
          }
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: apis,
        eventOrder: __assign(__assign({}, detail.eventOrder), {
          &apos;alloy.execute&apos;: [
            &apos;disabling&apos;,
            &apos;toggling&apos;,
            &apos;alloy.base.behaviour&apos;
          ]
        }),
        events: buttonEvents,
        behaviours: augment(detail.splitDropdownBehaviours, [
          Coupling.config({
            others: {
              sandbox: function (hotspot) {
                var arrow = getPartOrDie(hotspot, detail, &apos;arrow&apos;);
                var extras = {
                  onOpen: function () {
                    Toggling.on(arrow);
                    Toggling.on(hotspot);
                  },
                  onClose: function () {
                    Toggling.off(arrow);
                    Toggling.off(hotspot);
                  }
                };
                return makeSandbox(detail, hotspot, extras);
              }
            }
          }),
          Keying.config({
            mode: &apos;special&apos;,
            onSpace: executeOnButton,
            onEnter: executeOnButton,
            onDown: openMenu
          }),
          Focusing.config({}),
          Toggling.config({
            toggleOnExecute: false,
            aria: { mode: &apos;expanded&apos; }
          })
        ]),
        domModification: {
          attributes: {
            &apos;role&apos;: detail.role.getOr(&apos;button&apos;),
            &apos;aria-haspopup&apos;: true
          }
        }
      };
    };
    var SplitDropdown = composite$1({
      name: &apos;SplitDropdown&apos;,
      configFields: schema$q(),
      partFields: parts$c(),
      factory: factory$e,
      apis: {
        repositionMenus: function (apis, comp) {
          return apis.repositionMenus(comp);
        }
      }
    });

    var getButtonApi = function (component) {
      return {
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        }
      };
    };
    var getToggleApi = function (component) {
      return {
        setActive: function (state) {
          Toggling.set(component, state);
        },
        isActive: function () {
          return Toggling.isOn(component);
        },
        isDisabled: function () {
          return Disabling.isDisabled(component);
        },
        setDisabled: function (state) {
          return Disabling.set(component, state);
        }
      };
    };
    var getTooltipAttributes = function (tooltip, providersBackstage) {
      return tooltip.map(function (tooltip) {
        return {
          &apos;aria-label&apos;: providersBackstage.translate(tooltip),
          &apos;title&apos;: providersBackstage.translate(tooltip)
        };
      }).getOr({});
    };
    var focusButtonEvent = generate$1(&apos;focus-button&apos;);
    var rtlIcon$1 = [
      &apos;checklist&apos;,
      &apos;ordered-list&apos;
    ];
    var rtlTransform$1 = [
      &apos;indent&apos;,
      &apos;outdent&apos;,
      &apos;table-insert-column-after&apos;,
      &apos;table-insert-column-before&apos;,
      &apos;unordered-list&apos;
    ];
    var renderCommonStructure = function (icon, text, tooltip, receiver, behaviours, providersBackstage) {
      var _d;
      var getIconName = function (iconName) {
        return global$5.isRtl() &amp;&amp; contains(rtlIcon$1, iconName) ? iconName + &apos;-rtl&apos; : iconName;
      };
      var needsRtlClass = global$5.isRtl() &amp;&amp; icon.exists(function (name) {
        return contains(rtlTransform$1, name);
      });
      return {
        dom: {
          tag: &apos;button&apos;,
          classes: [&apos;tox-tbtn&apos;].concat(text.isSome() ? [&apos;tox-tbtn--select&apos;] : []).concat(needsRtlClass ? [&apos;tox-tbtn__icon-rtl&apos;] : []),
          attributes: getTooltipAttributes(tooltip, providersBackstage)
        },
        components: componentRenderPipeline([
          icon.map(function (iconName) {
            return renderIconFromPack(getIconName(iconName), providersBackstage.icons);
          }),
          text.map(function (text) {
            return renderLabel$1(text, &apos;tox-tbtn&apos;, providersBackstage);
          })
        ]),
        eventOrder: (_d = {}, _d[mousedown()] = [
          &apos;focusing&apos;,
          &apos;alloy.base.behaviour&apos;,
          &apos;common-button-display-events&apos;
        ], _d),
        buttonBehaviours: derive$1([
          DisablingConfigs.toolbarButton(providersBackstage.isReadOnly),
          receivingConfig(),
          config(&apos;common-button-display-events&apos;, [run(mousedown(), function (button, se) {
              se.event().prevent();
              emit(button, focusButtonEvent);
            })])
        ].concat(receiver.map(function (r) {
          return Reflecting.config({
            channel: r,
            initialData: {
              icon: icon,
              text: text
            },
            renderComponents: function (data, _state) {
              return componentRenderPipeline([
                data.icon.map(function (iconName) {
                  return renderIconFromPack(getIconName(iconName), providersBackstage.icons);
                }),
                data.text.map(function (text) {
                  return renderLabel$1(text, &apos;tox-tbtn&apos;, providersBackstage);
                })
              ]);
            }
          });
        }).toArray()).concat(behaviours.getOr([])))
      };
    };
    var renderFloatingToolbarButton = function (spec, backstage, identifyButtons, attributes) {
      var sharedBackstage = backstage.shared;
      return FloatingToolbarButton.sketch({
        lazySink: sharedBackstage.getSink,
        fetch: function () {
          return Future.nu(function (resolve) {
            resolve(map(identifyButtons(spec.items), renderToolbarGroup));
          });
        },
        markers: { toggledClass: &apos;tox-tbtn--enabled&apos; },
        parts: {
          button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Option.none(), Option.none(), sharedBackstage.providers),
          toolbar: {
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-toolbar__overflow&apos;],
              attributes: attributes
            }
          }
        }
      });
    };
    var renderCommonToolbarButton = function (spec, specialisation, providersBackstage) {
      var editorOffCell = Cell(noop);
      var structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Option.none(), Option.none(), providersBackstage);
      return Button.sketch({
        dom: structure.dom,
        components: structure.components,
        eventOrder: toolbarButtonEventOrder,
        buttonBehaviours: derive$1([
          config(&apos;toolbar-button-events&apos;, [
            onToolbarButtonExecute({
              onAction: spec.onAction,
              getApi: specialisation.getApi
            }),
            onControlAttached(specialisation, editorOffCell),
            onControlDetached(specialisation, editorOffCell)
          ]),
          DisablingConfigs.toolbarButton(function () {
            return spec.disabled || providersBackstage.isReadOnly();
          }),
          receivingConfig()
        ].concat(specialisation.toolbarButtonBehaviours))
      });
    };
    var renderToolbarButton = function (spec, providersBackstage) {
      return renderToolbarButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarButtonWith = function (spec, providersBackstage, bonusEvents) {
      return renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: [].concat(bonusEvents.length &gt; 0 ? [config(&apos;toolbarButtonWith&apos;, bonusEvents)] : []),
        getApi: getButtonApi,
        onSetup: spec.onSetup
      }, providersBackstage);
    };
    var renderToolbarToggleButton = function (spec, providersBackstage) {
      return renderToolbarToggleButtonWith(spec, providersBackstage, []);
    };
    var renderToolbarToggleButtonWith = function (spec, providersBackstage, bonusEvents) {
      return deepMerge(renderCommonToolbarButton(spec, {
        toolbarButtonBehaviours: [
          Replacing.config({}),
          Toggling.config({
            toggleClass: &apos;tox-tbtn--enabled&apos;,
            aria: { mode: &apos;pressed&apos; },
            toggleOnExecute: false
          })
        ].concat(bonusEvents.length &gt; 0 ? [config(&apos;toolbarToggleButtonWith&apos;, bonusEvents)] : []),
        getApi: getToggleApi,
        onSetup: spec.onSetup
      }, providersBackstage));
    };
    var fetchChoices = function (getApi, spec, providersBackstage) {
      return function (comp) {
        return Future.nu(function (callback) {
          return spec.fetch(callback);
        }).map(function (items) {
          return Option.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$1(&apos;menu-value&apos;), items, function (value) {
            spec.onItemAction(getApi(comp), value);
          }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(function () {
            return false;
          }), providersBackstage), {
            movement: deriveMenuMovement(spec.columns, spec.presets),
            menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== &apos;auto&apos; ? [] : [runOnAttached(function (comp, _se) {
                detectSize(comp, 4, classForPreset(spec.presets)).each(function (_d) {
                  var numRows = _d.numRows, numColumns = _d.numColumns;
                  Keying.setGridSize(comp, numRows, numColumns);
                });
              })])
          })));
        });
      };
    };
    var renderSplitButton = function (spec, sharedBackstage) {
      var _d;
      var displayChannel = generate$1(&apos;channel-update-split-dropdown-display&apos;);
      var getApi = function (comp) {
        return {
          isDisabled: function () {
            return Disabling.isDisabled(comp);
          },
          setDisabled: function (state) {
            return Disabling.set(comp, state);
          },
          setIconFill: function (id, value) {
            descendant$1(comp.element(), &apos;svg path[id=&quot;&apos; + id + &apos;&quot;], rect[id=&quot;&apos; + id + &apos;&quot;]&apos;).each(function (underlinePath) {
              set$1(underlinePath, &apos;fill&apos;, value);
            });
          },
          setIconStroke: function (id, value) {
            descendant$1(comp.element(), &apos;svg path[id=&quot;&apos; + id + &apos;&quot;], rect[id=&quot;&apos; + id + &apos;&quot;]&apos;).each(function (underlinePath) {
              set$1(underlinePath, &apos;stroke&apos;, value);
            });
          },
          setActive: function (state) {
            set$1(comp.element(), &apos;aria-pressed&apos;, state);
            descendant$1(comp.element(), &apos;span&apos;).each(function (button) {
              comp.getSystem().getByDom(button).each(function (buttonComp) {
                return Toggling.set(buttonComp, state);
              });
            });
          },
          isActive: function () {
            return descendant$1(comp.element(), &apos;span&apos;).exists(function (button) {
              return comp.getSystem().getByDom(button).exists(Toggling.isOn);
            });
          }
        };
      };
      var editorOffCell = Cell(noop);
      var specialisation = {
        getApi: getApi,
        onSetup: spec.onSetup
      };
      return SplitDropdown.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-split-button&apos;],
          attributes: __assign({ &apos;aria-pressed&apos;: false }, getTooltipAttributes(spec.tooltip, sharedBackstage.providers))
        },
        onExecute: function (button) {
          spec.onAction(getApi(button));
        },
        onItemExecute: function (_a, _b, _c) {
        },
        splitDropdownBehaviours: derive$1([
          DisablingConfigs.splitButton(sharedBackstage.providers.isReadOnly),
          receivingConfig(),
          config(&apos;split-dropdown-events&apos;, [
            run(focusButtonEvent, Focusing.focus),
            onControlAttached(specialisation, editorOffCell),
            onControlDetached(specialisation, editorOffCell)
          ]),
          Unselecting.config({})
        ]),
        eventOrder: (_d = {}, _d[attachedToDom()] = [
          &apos;alloy.base.behaviour&apos;,
          &apos;split-dropdown-events&apos;
        ], _d),
        toggleClass: &apos;tox-tbtn--enabled&apos;,
        lazySink: sharedBackstage.getSink,
        fetch: fetchChoices(getApi, spec, sharedBackstage.providers),
        parts: { menu: part(false, spec.columns, spec.presets) },
        components: [
          SplitDropdown.parts().button(renderCommonStructure(spec.icon, spec.text, Option.none(), Option.some(displayChannel), Option.some([Toggling.config({
              toggleClass: &apos;tox-tbtn--enabled&apos;,
              toggleOnExecute: false
            })]), sharedBackstage.providers)),
          SplitDropdown.parts().arrow({
            dom: {
              tag: &apos;button&apos;,
              classes: [
                &apos;tox-tbtn&apos;,
                &apos;tox-split-button__chevron&apos;
              ],
              innerHtml: get$d(&apos;chevron-down&apos;, sharedBackstage.providers.icons)
            },
            buttonBehaviours: derive$1([
              DisablingConfigs.splitButton(sharedBackstage.providers.isReadOnly),
              receivingConfig()
            ])
          }),
          SplitDropdown.parts()[&apos;aria-descriptor&apos;]({ text: sharedBackstage.providers.translate(&apos;To open the popup, press Shift+Enter&apos;) })
        ]
      });
    };

    var getFormApi = function (input) {
      return {
        hide: function () {
          return emit(input, sandboxClose());
        },
        getValue: function () {
          return Representing.getValue(input);
        }
      };
    };
    var runOnExecute$1 = function (memInput, original) {
      return run(internalToolbarButtonExecute, function (comp, se) {
        var input = memInput.get(comp);
        var formApi = getFormApi(input);
        original.onAction(formApi, se.event().buttonApi());
      });
    };
    var renderContextButton = function (memInput, button, extras) {
      var _a = button.original, primary = _a.primary, rest = __rest(_a, [&apos;primary&apos;]);
      var bridged = getOrDie(createToolbarButton(__assign(__assign({}, rest), {
        type: &apos;button&apos;,
        onAction: function () {
        }
      })));
      return renderToolbarButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute$1(memInput, button)]);
    };
    var renderContextToggleButton = function (memInput, button, extras) {
      var _a = button.original, primary = _a.primary, rest = __rest(_a, [&apos;primary&apos;]);
      var bridged = getOrDie(createToggleButton(__assign(__assign({}, rest), {
        type: &apos;togglebutton&apos;,
        onAction: function () {
        }
      })));
      return renderToolbarToggleButtonWith(bridged, extras.backstage.shared.providers, [runOnExecute$1(memInput, button)]);
    };
    var generateOne$1 = function (memInput, button, providersBackstage) {
      var extras = { backstage: { shared: { providers: providersBackstage } } };
      if (button.type === &apos;contextformtogglebutton&apos;) {
        return renderContextToggleButton(memInput, button, extras);
      } else {
        return renderContextButton(memInput, button, extras);
      }
    };
    var generate$7 = function (memInput, buttons, providersBackstage) {
      var mementos = map(buttons, function (button) {
        return record(generateOne$1(memInput, button, providersBackstage));
      });
      var asSpecs = function () {
        return map(mementos, function (mem) {
          return mem.asSpec();
        });
      };
      var findPrimary = function (compInSystem) {
        return findMap(buttons, function (button, i) {
          if (button.primary) {
            return Option.from(mementos[i]).bind(function (mem) {
              return mem.getOpt(compInSystem);
            }).filter(not(Disabling.isDisabled));
          } else {
            return Option.none();
          }
        });
      };
      return {
        asSpecs: asSpecs,
        findPrimary: findPrimary
      };
    };

    var buildInitGroups = function (ctx, providers) {
      var inputAttributes = ctx.label.fold(function () {
        return {};
      }, function (label) {
        return { &apos;aria-label&apos;: label };
      });
      var memInput = record(Input.sketch({
        inputClasses: [
          &apos;tox-toolbar-textfield&apos;,
          &apos;tox-toolbar-nav-js&apos;
        ],
        data: ctx.initValue(),
        inputAttributes: inputAttributes,
        selectOnFocus: true,
        inputBehaviours: derive$1([Keying.config({
            mode: &apos;special&apos;,
            onEnter: function (input) {
              return commands.findPrimary(input).map(function (primary) {
                emitExecute(primary);
                return true;
              });
            },
            onLeft: function (comp, se) {
              se.cut();
              return Option.none();
            },
            onRight: function (comp, se) {
              se.cut();
              return Option.none();
            }
          })])
      }));
      var commands = generate$7(memInput, ctx.commands, providers);
      return [
        {
          title: Option.none(),
          items: [memInput.asSpec()]
        },
        {
          title: Option.none(),
          items: commands.asSpecs()
        }
      ];
    };
    var renderContextForm = function (toolbarType, ctx, providers) {
      return renderToolbar({
        type: toolbarType,
        uid: generate$1(&apos;context-toolbar&apos;),
        initGroups: buildInitGroups(ctx, providers),
        onEscape: Option.none,
        cyclicKeying: true,
        providers: providers
      });
    };
    var ContextForm = {
      renderContextForm: renderContextForm,
      buildInitGroups: buildInitGroups
    };

    var getHorizontalBounds = function (contentAreaBox, viewportBounds) {
      var x = Math.max(viewportBounds.x, contentAreaBox.x);
      var contentBoxWidth = contentAreaBox.right - x;
      var maxViewportWidth = viewportBounds.width - (x - viewportBounds.x);
      var width = Math.min(contentBoxWidth, maxViewportWidth);
      return {
        x: x,
        width: width
      };
    };
    var getVerticalBounds = function (editor, contentAreaBox, viewportBounds, isToolbarLocationTop) {
      var container = Element.fromDom(editor.getContainer());
      var header = descendant$1(container, &apos;.tox-editor-header&apos;).getOr(container);
      var headerBox = box(header);
      var isToolbarBelowContentArea = headerBox.y &gt;= contentAreaBox.bottom;
      var isToolbarAbove = isToolbarLocationTop &amp;&amp; !isToolbarBelowContentArea;
      if (editor.inline &amp;&amp; isToolbarAbove) {
        return {
          y: Math.max(headerBox.bottom, viewportBounds.y),
          bottom: viewportBounds.bottom
        };
      }
      if (editor.inline &amp;&amp; !isToolbarAbove) {
        return {
          y: viewportBounds.y,
          bottom: Math.min(headerBox.y, viewportBounds.bottom)
        };
      }
      var containerBounds = box(container);
      if (isToolbarAbove) {
        return {
          y: Math.max(headerBox.bottom, viewportBounds.y),
          bottom: Math.min(containerBounds.bottom, viewportBounds.bottom)
        };
      }
      return {
        y: Math.max(containerBounds.y, viewportBounds.y),
        bottom: Math.min(headerBox.y, viewportBounds.bottom)
      };
    };
    var getContextToolbarBounds = function (editor, sharedBackstage) {
      var viewportBounds = getBounds(domGlobals.window);
      var contentAreaBox = box(Element.fromDom(editor.getContentAreaContainer()));
      var toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
      var _a = getHorizontalBounds(contentAreaBox, viewportBounds), x = _a.x, width = _a.width;
      if (editor.inline &amp;&amp; !toolbarOrMenubarEnabled) {
        return bounds$1(x, viewportBounds.y, width, viewportBounds.height);
      } else {
        var isToolbarTop = sharedBackstage.header.isPositionedAtTop();
        var _b = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop), y = _b.y, bottom = _b.bottom;
        return bounds$1(x, y, width, bottom - y);
      }
    };

    var matchTargetWith = function (elem, candidates) {
      var ctxs = filter(candidates, function (toolbarApi) {
        return toolbarApi.predicate(elem.dom());
      });
      var _a = partition(ctxs, function (t) {
          return t.type === &apos;contexttoolbar&apos;;
        }), pass = _a.pass, fail = _a.fail;
      return {
        contextToolbars: pass,
        contextForms: fail
      };
    };
    var filterByPositionForStartNode = function (toolbars) {
      if (toolbars.length &lt;= 1) {
        return toolbars;
      } else {
        var doesPositionExist = function (value) {
          return exists(toolbars, function (t) {
            return t.position === value;
          });
        };
        var filterToolbarsByPosition = function (value) {
          return filter(toolbars, function (t) {
            return t.position === value;
          });
        };
        var hasSelectionToolbars = doesPositionExist(&apos;selection&apos;);
        var hasNodeToolbars = doesPositionExist(&apos;node&apos;);
        if (hasSelectionToolbars || hasNodeToolbars) {
          if (hasNodeToolbars &amp;&amp; hasSelectionToolbars) {
            var nodeToolbars = filterToolbarsByPosition(&apos;node&apos;);
            var selectionToolbars = map(filterToolbarsByPosition(&apos;selection&apos;), function (t) {
              return __assign(__assign({}, t), { position: &apos;node&apos; });
            });
            return nodeToolbars.concat(selectionToolbars);
          } else {
            return hasSelectionToolbars ? filterToolbarsByPosition(&apos;selection&apos;) : filterToolbarsByPosition(&apos;node&apos;);
          }
        } else {
          return filterToolbarsByPosition(&apos;line&apos;);
        }
      }
    };
    var filterByPositionForAncestorNode = function (toolbars) {
      if (toolbars.length &lt;= 1) {
        return toolbars;
      } else {
        var findPosition_1 = function (value) {
          return find(toolbars, function (t) {
            return t.position === value;
          });
        };
        var basePosition = findPosition_1(&apos;selection&apos;).orThunk(function () {
          return findPosition_1(&apos;node&apos;);
        }).orThunk(function () {
          return findPosition_1(&apos;line&apos;);
        }).map(function (t) {
          return t.position;
        });
        return basePosition.fold(function () {
          return [];
        }, function (pos) {
          return filter(toolbars, function (t) {
            return t.position === pos;
          });
        });
      }
    };
    var matchStartNode = function (elem, nodeCandidates, editorCandidates) {
      var nodeMatches = matchTargetWith(elem, nodeCandidates);
      if (nodeMatches.contextForms.length &gt; 0) {
        return Option.some({
          elem: elem,
          toolbars: [nodeMatches.contextForms[0]]
        });
      } else {
        var editorMatches = matchTargetWith(elem, editorCandidates);
        if (editorMatches.contextForms.length &gt; 0) {
          return Option.some({
            elem: elem,
            toolbars: [editorMatches.contextForms[0]]
          });
        } else if (nodeMatches.contextToolbars.length &gt; 0 || editorMatches.contextToolbars.length &gt; 0) {
          var toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
          return Option.some({
            elem: elem,
            toolbars: toolbars
          });
        } else {
          return Option.none();
        }
      }
    };
    var matchAncestor = function (isRoot, startNode, scopes) {
      if (isRoot(startNode)) {
        return Option.none();
      } else {
        return ancestor(startNode, function (ancestorElem) {
          var _a = matchTargetWith(ancestorElem, scopes.inNodeScope), contextToolbars = _a.contextToolbars, contextForms = _a.contextForms;
          var toolbars = contextForms.length &gt; 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
          return toolbars.length &gt; 0 ? Option.some({
            elem: ancestorElem,
            toolbars: toolbars
          }) : Option.none();
        }, isRoot);
      }
    };
    var lookup$1 = function (scopes, editor) {
      var rootElem = Element.fromDom(editor.getBody());
      var isRoot = function (elem) {
        return eq$1(elem, rootElem);
      };
      var isOutsideRoot = function (startNode) {
        return !isRoot(startNode) &amp;&amp; !contains$2(rootElem, startNode);
      };
      var startNode = Element.fromDom(editor.selection.getNode());
      if (isOutsideRoot(startNode)) {
        return Option.none();
      }
      return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(function () {
        return matchAncestor(isRoot, startNode, scopes);
      });
    };

    var categorise = function (contextToolbars, navigate) {
      var forms = {};
      var inNodeScope = [];
      var inEditorScope = [];
      var formNavigators = {};
      var lookupTable = {};
      var registerForm = function (key, toolbarApi) {
        var contextForm = getOrDie(createContextForm(toolbarApi));
        forms[key] = contextForm;
        contextForm.launch.map(function (launch) {
          formNavigators[&apos;form:&apos; + key + &apos;&apos;] = __assign(__assign({}, toolbarApi.launch), {
            type: launch.type === &apos;contextformtogglebutton&apos; ? &apos;togglebutton&apos; : &apos;button&apos;,
            onAction: function () {
              navigate(contextForm);
            }
          });
        });
        if (contextForm.scope === &apos;editor&apos;) {
          inEditorScope.push(contextForm);
        } else {
          inNodeScope.push(contextForm);
        }
        lookupTable[key] = contextForm;
      };
      var registerToolbar = function (key, toolbarApi) {
        createContextToolbar(toolbarApi).each(function (contextToolbar) {
          if (toolbarApi.scope === &apos;editor&apos;) {
            inEditorScope.push(contextToolbar);
          } else {
            inNodeScope.push(contextToolbar);
          }
          lookupTable[key] = contextToolbar;
        });
      };
      var keys$1 = keys(contextToolbars);
      each(keys$1, function (key) {
        var toolbarApi = contextToolbars[key];
        if (toolbarApi.type === &apos;contextform&apos;) {
          registerForm(key, toolbarApi);
        } else if (toolbarApi.type === &apos;contexttoolbar&apos;) {
          registerToolbar(key, toolbarApi);
        }
      });
      return {
        forms: forms,
        inNodeScope: inNodeScope,
        inEditorScope: inEditorScope,
        lookupTable: lookupTable,
        formNavigators: formNavigators
      };
    };

    var forwardSlideEvent = generate$1(&apos;forward-slide&apos;);
    var backSlideEvent = generate$1(&apos;backward-slide&apos;);
    var changeSlideEvent = generate$1(&apos;change-slide-event&apos;);
    var resizingClass = &apos;tox-pop--resizing&apos;;
    var renderContextToolbar = function (spec) {
      var stack = Cell([]);
      return InlineView.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-pop&apos;]
        },
        fireDismissalEventInstead: { event: &apos;doNotDismissYet&apos; },
        onShow: function (comp) {
          stack.set([]);
          InlineView.getContent(comp).each(function (c) {
            remove$6(c.element(), &apos;visibility&apos;);
          });
          remove$4(comp.element(), resizingClass);
          remove$6(comp.element(), &apos;width&apos;);
        },
        inlineBehaviours: derive$1([
          config(&apos;context-toolbar-events&apos;, [
            runOnSource(transitionend(), function (comp, _se) {
              remove$4(comp.element(), resizingClass);
              remove$6(comp.element(), &apos;width&apos;);
            }),
            run(changeSlideEvent, function (comp, se) {
              remove$6(comp.element(), &apos;width&apos;);
              var currentWidth = get$7(comp.element());
              InlineView.setContent(comp, se.event().contents());
              add$2(comp.element(), resizingClass);
              var newWidth = get$7(comp.element());
              set$2(comp.element(), &apos;width&apos;, currentWidth + &apos;px&apos;);
              InlineView.getContent(comp).each(function (newContents) {
                se.event().focus().bind(function (f) {
                  focus$1(f);
                  return search(comp.element());
                }).orThunk(function () {
                  Keying.focusIn(newContents);
                  return active();
                });
              });
              global$2.setTimeout(function () {
                set$2(comp.element(), &apos;width&apos;, newWidth + &apos;px&apos;);
              }, 0);
            }),
            run(forwardSlideEvent, function (comp, se) {
              InlineView.getContent(comp).each(function (oldContents) {
                stack.set(stack.get().concat([{
                    bar: oldContents,
                    focus: active()
                  }]));
              });
              emitWith(comp, changeSlideEvent, {
                contents: se.event().forwardContents(),
                focus: Option.none()
              });
            }),
            run(backSlideEvent, function (comp, _se) {
              last(stack.get()).each(function (last) {
                stack.set(stack.get().slice(0, stack.get().length - 1));
                emitWith(comp, changeSlideEvent, {
                  contents: premade$1(last.bar),
                  focus: last.focus
                });
              });
            })
          ]),
          Keying.config({
            mode: &apos;special&apos;,
            onEscape: function (comp) {
              return last(stack.get()).fold(function () {
                return spec.onEscape();
              }, function (_) {
                emit(comp, backSlideEvent);
                return Option.some(true);
              });
            }
          })
        ]),
        lazySink: function () {
          return Result.value(spec.sink);
        }
      });
    };

    var generateSelectItems = function (_editor, backstage, spec) {
      var generateItem = function (rawItem, response, disabled, value) {
        var translatedText = backstage.shared.providers.translate(rawItem.title);
        if (rawItem.type === &apos;separator&apos;) {
          return Option.some({
            type: &apos;separator&apos;,
            text: translatedText
          });
        } else if (rawItem.type === &apos;submenu&apos;) {
          var items = bind(rawItem.getStyleItems(), function (si) {
            return validate(si, response, value);
          });
          if (response === 0 &amp;&amp; items.length &lt;= 0) {
            return Option.none();
          } else {
            return Option.some({
              type: &apos;nestedmenuitem&apos;,
              text: translatedText,
              disabled: items.length &lt;= 0,
              getSubmenuItems: function () {
                return bind(rawItem.getStyleItems(), function (si) {
                  return validate(si, response, value);
                });
              }
            });
          }
        } else {
          return Option.some(__assign({
            type: &apos;togglemenuitem&apos;,
            text: translatedText,
            icon: rawItem.icon,
            active: rawItem.isSelected(value),
            disabled: disabled,
            onAction: spec.onAction(rawItem)
          }, rawItem.getStylePreview().fold(function () {
            return {};
          }, function (preview) {
            return { meta: { style: preview } };
          })));
        }
      };
      var validate = function (item, response, value) {
        var invalid = item.type === &apos;formatter&apos; &amp;&amp; spec.isInvalid(item);
        if (response === 0) {
          return invalid ? [] : generateItem(item, response, false, value).toArray();
        } else {
          return generateItem(item, response, invalid, value).toArray();
        }
      };
      var validateItems = function (preItems) {
        var value = spec.getCurrentValue();
        var response = spec.shouldHide ? 0 : 1;
        return bind(preItems, function (item) {
          return validate(item, response, value);
        });
      };
      var getFetch = function (backstage, getStyleItems) {
        return function (callback) {
          var preItems = getStyleItems();
          var items = validateItems(preItems);
          var menu = build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false);
          callback(menu);
        };
      };
      return {
        validateItems: validateItems,
        getFetch: getFetch
      };
    };
    var createMenuItems = function (editor, backstage, spec) {
      var dataset = spec.dataset;
      var getStyleItems = dataset.type === &apos;basic&apos; ? function () {
        return map(dataset.data, function (d) {
          return processBasic(d, spec.isSelectedFor, spec.getPreviewFor);
        });
      } : dataset.getData;
      return {
        items: generateSelectItems(editor, backstage, spec),
        getStyleItems: getStyleItems
      };
    };
    var createSelectButton = function (editor, backstage, spec) {
      var _a = createMenuItems(editor, backstage, spec), items = _a.items, getStyleItems = _a.getStyleItems;
      var getApi = function (comp) {
        return {
          getComponent: function () {
            return comp;
          }
        };
      };
      var onSetup = function (api) {
        spec.setInitialValue.each(function (f) {
          return f(api.getComponent());
        });
        return spec.nodeChangeHandler.map(function (f) {
          var handler = f(api.getComponent());
          editor.on(&apos;NodeChange&apos;, handler);
          return function () {
            editor.off(&apos;NodeChange&apos;, handler);
          };
        }).getOr(noop);
      };
      return renderCommonDropdown({
        text: spec.icon.isSome() ? Option.none() : Option.some(&apos;&apos;),
        icon: spec.icon,
        tooltip: Option.from(spec.tooltip),
        role: Option.none(),
        fetch: items.getFetch(backstage, getStyleItems),
        onSetup: onSetup,
        getApi: getApi,
        columns: 1,
        presets: &apos;normal&apos;,
        classes: spec.icon.isSome() ? [] : [&apos;bespoke&apos;],
        dropdownBehaviours: []
      }, &apos;tox-tbtn&apos;, backstage.shared);
    };

    var process = function (rawFormats) {
      return map(rawFormats, function (item) {
        var title = item, format = item;
        var values = item.split(&apos;=&apos;);
        if (values.length &gt; 1) {
          title = values[0];
          format = values[1];
        }
        return {
          title: title,
          format: format
        };
      });
    };
    var buildBasicStaticDataset = function (data) {
      return {
        type: &apos;basic&apos;,
        data: data
      };
    };
    var Delimiter;
    (function (Delimiter) {
      Delimiter[Delimiter[&apos;SemiColon&apos;] = 0] = &apos;SemiColon&apos;;
      Delimiter[Delimiter[&apos;Space&apos;] = 1] = &apos;Space&apos;;
    }(Delimiter || (Delimiter = {})));
    var split = function (rawFormats, delimiter) {
      if (delimiter === Delimiter.SemiColon) {
        return rawFormats.replace(/;$/, &apos;&apos;).split(&apos;;&apos;);
      } else {
        return rawFormats.split(&apos; &apos;);
      }
    };
    var buildBasicSettingsDataset = function (editor, settingName, defaults, delimiter) {
      var rawFormats = get(editor.settings, settingName).getOr(defaults);
      var data = process(split(rawFormats, delimiter));
      return {
        type: &apos;basic&apos;,
        data: data
      };
    };

    var alignMenuItems = [
      {
        title: &apos;Left&apos;,
        icon: &apos;align-left&apos;,
        format: &apos;alignleft&apos;,
        command: &apos;JustifyLeft&apos;
      },
      {
        title: &apos;Center&apos;,
        icon: &apos;align-center&apos;,
        format: &apos;aligncenter&apos;,
        command: &apos;JustifyCenter&apos;
      },
      {
        title: &apos;Right&apos;,
        icon: &apos;align-right&apos;,
        format: &apos;alignright&apos;,
        command: &apos;JustifyRight&apos;
      },
      {
        title: &apos;Justify&apos;,
        icon: &apos;align-justify&apos;,
        format: &apos;alignjustify&apos;,
        command: &apos;JustifyFull&apos;
      }
    ];
    var getSpec = function (editor) {
      var getMatchingValue = function () {
        return find(alignMenuItems, function (item) {
          return editor.formatter.match(item.format);
        });
      };
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (_format) {
        return function () {
          return Option.none();
        };
      };
      var updateSelectMenuIcon = function (comp) {
        var match = getMatchingValue();
        var alignment = match.fold(function () {
          return &apos;left&apos;;
        }, function (item) {
          return item.title.toLowerCase();
        });
        emitWith(comp, updateMenuIcon, { icon: &apos;align-&apos; + alignment });
      };
      var nodeChangeHandler = Option.some(function (comp) {
        return function () {
          return updateSelectMenuIcon(comp);
        };
      });
      var setInitialValue = Option.some(function (comp) {
        return updateSelectMenuIcon(comp);
      });
      var dataset = buildBasicStaticDataset(alignMenuItems);
      var onAction = function (rawItem) {
        return function () {
          return find(alignMenuItems, function (item) {
            return item.format === rawItem.format;
          }).each(function (item) {
            return editor.execCommand(item.command);
          });
        };
      };
      return {
        tooltip: &apos;Align&apos;,
        icon: Option.some(&apos;align-left&apos;),
        isSelectedFor: isSelectedFor,
        getCurrentValue: constant(Option.none()),
        getPreviewFor: getPreviewFor,
        onAction: onAction,
        setInitialValue: setInitialValue,
        nodeChangeHandler: nodeChangeHandler,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        }
      };
    };
    var createAlignSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec(editor));
    };
    var alignSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec(editor));
      editor.ui.registry.addNestedMenuItem(&apos;align&apos;, {
        text: backstage.shared.providers.translate(&apos;Align&apos;),
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var defaultFontsFormats = &apos;Andale Mono=andale mono,monospace;&apos; + &apos;Arial=arial,helvetica,sans-serif;&apos; + &apos;Arial Black=arial black,sans-serif;&apos; + &apos;Book Antiqua=book antiqua,palatino,serif;&apos; + &apos;Comic Sans MS=comic sans ms,sans-serif;&apos; + &apos;Courier New=courier new,courier,monospace;&apos; + &apos;Georgia=georgia,palatino,serif;&apos; + &apos;Helvetica=helvetica,arial,sans-serif;&apos; + &apos;Impact=impact,sans-serif;&apos; + &apos;Symbol=symbol;&apos; + &apos;Tahoma=tahoma,arial,helvetica,sans-serif;&apos; + &apos;Terminal=terminal,monaco,monospace;&apos; + &apos;Times New Roman=times new roman,times,serif;&apos; + &apos;Trebuchet MS=trebuchet ms,geneva,sans-serif;&apos; + &apos;Verdana=verdana,geneva,sans-serif;&apos; + &apos;Webdings=webdings;&apos; + &apos;Wingdings=wingdings,zapf dingbats&apos;;
    var systemStackFonts = [
      &apos;-apple-system&apos;,
      &apos;Segoe UI&apos;,
      &apos;Roboto&apos;,
      &apos;Helvetica Neue&apos;,
      &apos;sans-serif&apos;
    ];
    var splitFonts = function (fontFamily) {
      var fonts = fontFamily.split(/\s*,\s*/);
      return map(fonts, function (font) {
        return font.replace(/^[&apos;&quot;]+|[&apos;&quot;]+$/g, &apos;&apos;);
      });
    };
    var isSystemFontStack = function (fontFamily) {
      var matchesSystemStack = function () {
        var fonts = splitFonts(fontFamily.toLowerCase());
        return forall(systemStackFonts, function (font) {
          return fonts.indexOf(font.toLowerCase()) &gt; -1;
        });
      };
      return fontFamily.indexOf(&apos;-apple-system&apos;) === 0 &amp;&amp; matchesSystemStack();
    };
    var getSpec$1 = function (editor) {
      var getMatchingValue = function () {
        var getFirstFont = function (fontFamily) {
          return fontFamily ? splitFonts(fontFamily)[0] : &apos;&apos;;
        };
        var fontFamily = editor.queryCommandValue(&apos;FontName&apos;);
        var items = dataset.data;
        var font = fontFamily ? fontFamily.toLowerCase() : &apos;&apos;;
        var matchOpt = find(items, function (item) {
          var format = item.format;
          return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();
        }).orThunk(function () {
          if (isSystemFontStack(font)) {
            return Option.from({
              title: &apos;System Font&apos;,
              format: font
            });
          } else {
            return Option.none();
          }
        });
        return {
          matchOpt: matchOpt,
          font: fontFamily
        };
      };
      var isSelectedFor = function (item) {
        return function (valueOpt) {
          return valueOpt.exists(function (value) {
            return value.format === item;
          });
        };
      };
      var getCurrentValue = function () {
        var matchOpt = getMatchingValue().matchOpt;
        return matchOpt;
      };
      var getPreviewFor = function (item) {
        return function () {
          return Option.some({
            tag: &apos;div&apos;,
            styles: item.indexOf(&apos;dings&apos;) === -1 ? { &apos;font-family&apos;: item } : {}
          });
        };
      };
      var onAction = function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand(&apos;FontName&apos;, false, rawItem.format);
          });
        };
      };
      var updateSelectMenuText = function (comp) {
        var _a = getMatchingValue(), matchOpt = _a.matchOpt, font = _a.font;
        var text = matchOpt.fold(function () {
          return font;
        }, function (item) {
          return item.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var nodeChangeHandler = Option.some(function (comp) {
        return function () {
          return updateSelectMenuText(comp);
        };
      });
      var setInitialValue = Option.some(function (comp) {
        return updateSelectMenuText(comp);
      });
      var dataset = buildBasicSettingsDataset(editor, &apos;font_formats&apos;, defaultFontsFormats, Delimiter.SemiColon);
      return {
        tooltip: &apos;Fonts&apos;,
        icon: Option.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: getCurrentValue,
        getPreviewFor: getPreviewFor,
        onAction: onAction,
        setInitialValue: setInitialValue,
        nodeChangeHandler: nodeChangeHandler,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function () {
          return false;
        }
      };
    };
    var createFontSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$1(editor));
    };
    var fontSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
      editor.ui.registry.addNestedMenuItem(&apos;fontformats&apos;, {
        text: backstage.shared.providers.translate(&apos;Fonts&apos;),
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var defaultFontsizeFormats = &apos;8pt 10pt 12pt 14pt 18pt 24pt 36pt&apos;;
    var legacyFontSizes = {
      &apos;8pt&apos;: &apos;1&apos;,
      &apos;10pt&apos;: &apos;2&apos;,
      &apos;12pt&apos;: &apos;3&apos;,
      &apos;14pt&apos;: &apos;4&apos;,
      &apos;18pt&apos;: &apos;5&apos;,
      &apos;24pt&apos;: &apos;6&apos;,
      &apos;36pt&apos;: &apos;7&apos;
    };
    var round$1 = function (number, precision) {
      var factor = Math.pow(10, precision);
      return Math.round(number * factor) / factor;
    };
    var toPt = function (fontSize, precision) {
      if (/[0-9.]+px$/.test(fontSize)) {
        return round$1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + &apos;pt&apos;;
      }
      return fontSize;
    };
    var toLegacy = function (fontSize) {
      return get(legacyFontSizes, fontSize).getOr(&apos;&apos;);
    };
    var getSpec$2 = function (editor) {
      var getMatchingValue = function () {
        var matchOpt = Option.none();
        var items = dataset.data;
        var fontSize = editor.queryCommandValue(&apos;FontSize&apos;);
        if (fontSize) {
          var _loop_1 = function (precision) {
            var pt = toPt(fontSize, precision);
            var legacy = toLegacy(pt);
            matchOpt = find(items, function (item) {
              return item.format === fontSize || item.format === pt || item.format === legacy;
            });
          };
          for (var precision = 3; matchOpt.isNone() &amp;&amp; precision &gt;= 0; precision--) {
            _loop_1(precision);
          }
        }
        return {
          matchOpt: matchOpt,
          size: fontSize
        };
      };
      var isSelectedFor = function (item) {
        return function (valueOpt) {
          return valueOpt.exists(function (value) {
            return value.format === item;
          });
        };
      };
      var getCurrentValue = function () {
        var matchOpt = getMatchingValue().matchOpt;
        return matchOpt;
      };
      var getPreviewFor = constant(constant(Option.none()));
      var onAction = function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand(&apos;FontSize&apos;, false, rawItem.format);
          });
        };
      };
      var updateSelectMenuText = function (comp) {
        var _a = getMatchingValue(), matchOpt = _a.matchOpt, size = _a.size;
        var text = matchOpt.fold(function () {
          return size;
        }, function (match) {
          return match.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var nodeChangeHandler = Option.some(function (comp) {
        return function () {
          return updateSelectMenuText(comp);
        };
      });
      var setInitialValue = Option.some(function (comp) {
        return updateSelectMenuText(comp);
      });
      var dataset = buildBasicSettingsDataset(editor, &apos;fontsize_formats&apos;, defaultFontsizeFormats, Delimiter.Space);
      return {
        tooltip: &apos;Font sizes&apos;,
        icon: Option.none(),
        isSelectedFor: isSelectedFor,
        getPreviewFor: getPreviewFor,
        getCurrentValue: getCurrentValue,
        onAction: onAction,
        setInitialValue: setInitialValue,
        nodeChangeHandler: nodeChangeHandler,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function () {
          return false;
        }
      };
    };
    var createFontsizeSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$2(editor));
    };
    var fontsizeSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
      editor.ui.registry.addNestedMenuItem(&apos;fontsizes&apos;, {
        text: &apos;Font sizes&apos;,
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var findNearest = function (editor, getStyles, parents) {
      var styles = getStyles();
      return findMap(parents, function (parent) {
        return find(styles, function (fmt) {
          return editor.formatter.matchNode(parent, fmt.format);
        });
      }).orThunk(function () {
        if (editor.formatter.match(&apos;p&apos;)) {
          return Option.some({
            title: &apos;Paragraph&apos;,
            format: &apos;p&apos;
          });
        }
        return Option.none();
      });
    };
    var getCurrentSelectionParents = function (editor) {
      var currentNode = editor.selection.getStart(true) || editor.getBody();
      return editor.dom.getParents(currentNode, function () {
        return true;
      }, editor.getBody());
    };

    var onSetupFormatToggle = function (editor, name) {
      return function (api) {
        var unbindCell = Cell(Option.none());
        var init = function () {
          api.setActive(editor.formatter.match(name));
          var unbind = editor.formatter.formatChanged(name, api.setActive).unbind;
          unbindCell.set(Option.some(unbind));
        };
        editor.initialized ? init() : editor.on(&apos;init&apos;, init);
        return function () {
          return unbindCell.get().each(function (unbind) {
            return unbind();
          });
        };
      };
    };
    var onActionToggleFormat = function (editor) {
      return function (rawItem) {
        return function () {
          editor.undoManager.transact(function () {
            editor.focus();
            editor.execCommand(&apos;mceToggleFormat&apos;, false, rawItem.format);
          });
        };
      };
    };

    var defaultBlocks = &apos;Paragraph=p;&apos; + &apos;Heading 1=h1;&apos; + &apos;Heading 2=h2;&apos; + &apos;Heading 3=h3;&apos; + &apos;Heading 4=h4;&apos; + &apos;Heading 5=h5;&apos; + &apos;Heading 6=h6;&apos; + &apos;Preformatted=pre&apos;;
    var getSpec$3 = function (editor) {
      var getMatchingValue = function (nodeChangeEvent) {
        return findNearest(editor, function () {
          return dataset.data;
        }, nodeChangeEvent);
      };
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return Option.some({
            tag: fmt.length &gt; 0 ? fmt[0].inline || fmt[0].block || &apos;div&apos; : &apos;div&apos;,
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          });
        };
      };
      var updateSelectMenuText = function (parents, comp) {
        var detectedFormat = getMatchingValue(parents);
        var text = detectedFormat.fold(function () {
          return &apos;Paragraph&apos;;
        }, function (fmt) {
          return fmt.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var nodeChangeHandler = Option.some(function (comp) {
        return function (e) {
          return updateSelectMenuText(e.parents, comp);
        };
      });
      var setInitialValue = Option.some(function (comp) {
        var parents = getCurrentSelectionParents(editor);
        updateSelectMenuText(parents, comp);
      });
      var dataset = buildBasicSettingsDataset(editor, &apos;block_formats&apos;, defaultBlocks, Delimiter.SemiColon);
      return {
        tooltip: &apos;Blocks&apos;,
        icon: Option.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: constant(Option.none()),
        getPreviewFor: getPreviewFor,
        onAction: onActionToggleFormat(editor),
        setInitialValue: setInitialValue,
        nodeChangeHandler: nodeChangeHandler,
        dataset: dataset,
        shouldHide: false,
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        }
      };
    };
    var createFormatSelect = function (editor, backstage) {
      return createSelectButton(editor, backstage, getSpec$3(editor));
    };
    var formatSelectMenu = function (editor, backstage) {
      var menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
      editor.ui.registry.addNestedMenuItem(&apos;blockformats&apos;, {
        text: &apos;Blocks&apos;,
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var getSpec$4 = function (editor, dataset) {
      var isSelectedFor = function (format) {
        return function () {
          return editor.formatter.match(format);
        };
      };
      var getPreviewFor = function (format) {
        return function () {
          var fmt = editor.formatter.get(format);
          return fmt !== undefined ? Option.some({
            tag: fmt.length &gt; 0 ? fmt[0].inline || fmt[0].block || &apos;div&apos; : &apos;div&apos;,
            styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
          }) : Option.none();
        };
      };
      var updateSelectMenuText = function (parents, comp) {
        var getFormatItems = function (fmt) {
          var subs = fmt.items;
          return subs !== undefined &amp;&amp; subs.length &gt; 0 ? bind(subs, getFormatItems) : [{
              title: fmt.title,
              format: fmt.format
            }];
        };
        var flattenedItems = bind(getStyleFormats(editor), getFormatItems);
        var detectedFormat = findNearest(editor, function () {
          return flattenedItems;
        }, parents);
        var text = detectedFormat.fold(function () {
          return &apos;Paragraph&apos;;
        }, function (fmt) {
          return fmt.title;
        });
        emitWith(comp, updateMenuText, { text: text });
      };
      var nodeChangeHandler = Option.some(function (comp) {
        return function (e) {
          return updateSelectMenuText(e.parents, comp);
        };
      });
      var setInitialValue = Option.some(function (comp) {
        var parents = getCurrentSelectionParents(editor);
        updateSelectMenuText(parents, comp);
      });
      return {
        tooltip: &apos;Formats&apos;,
        icon: Option.none(),
        isSelectedFor: isSelectedFor,
        getCurrentValue: constant(Option.none()),
        getPreviewFor: getPreviewFor,
        onAction: onActionToggleFormat(editor),
        setInitialValue: setInitialValue,
        nodeChangeHandler: nodeChangeHandler,
        shouldHide: editor.getParam(&apos;style_formats_autohide&apos;, false, &apos;boolean&apos;),
        isInvalid: function (item) {
          return !editor.formatter.canApply(item.format);
        },
        dataset: dataset
      };
    };
    var createStyleSelect = function (editor, backstage) {
      var dataset = __assign({ type: &apos;advanced&apos; }, backstage.styleselect);
      return createSelectButton(editor, backstage, getSpec$4(editor, dataset));
    };
    var styleSelectMenu = function (editor, backstage) {
      var dataset = __assign({ type: &apos;advanced&apos; }, backstage.styleselect);
      var menuItems = createMenuItems(editor, backstage, getSpec$4(editor, dataset));
      editor.ui.registry.addNestedMenuItem(&apos;formats&apos;, {
        text: &apos;Formats&apos;,
        getSubmenuItems: function () {
          return menuItems.items.validateItems(menuItems.getStyleItems());
        }
      });
    };

    var defaultToolbar = [
      {
        name: &apos;history&apos;,
        items: [
          &apos;undo&apos;,
          &apos;redo&apos;
        ]
      },
      {
        name: &apos;styles&apos;,
        items: [&apos;styleselect&apos;]
      },
      {
        name: &apos;formatting&apos;,
        items: [
          &apos;bold&apos;,
          &apos;italic&apos;
        ]
      },
      {
        name: &apos;alignment&apos;,
        items: [
          &apos;alignleft&apos;,
          &apos;aligncenter&apos;,
          &apos;alignright&apos;,
          &apos;alignjustify&apos;
        ]
      },
      {
        name: &apos;indentation&apos;,
        items: [
          &apos;outdent&apos;,
          &apos;indent&apos;
        ]
      },
      {
        name: &apos;permanent pen&apos;,
        items: [&apos;permanentpen&apos;]
      },
      {
        name: &apos;comments&apos;,
        items: [&apos;addcomment&apos;]
      }
    ];
    var renderFromBridge = function (bridgeBuilder, render) {
      return function (spec, extras, editor) {
        var internal = bridgeBuilder(spec).mapError(function (errInfo) {
          return formatError(errInfo);
        }).getOrDie();
        return render(internal, extras, editor);
      };
    };
    var types = {
      button: renderFromBridge(createToolbarButton, function (s, extras) {
        return renderToolbarButton(s, extras.backstage.shared.providers);
      }),
      togglebutton: renderFromBridge(createToggleButton, function (s, extras) {
        return renderToolbarToggleButton(s, extras.backstage.shared.providers);
      }),
      menubutton: renderFromBridge(createMenuButton, function (s, extras) {
        return renderMenuButton(s, &apos;tox-tbtn&apos;, extras.backstage, Option.none());
      }),
      splitbutton: renderFromBridge(createSplitButton, function (s, extras) {
        return renderSplitButton(s, extras.backstage.shared);
      }),
      grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, function (s, extras, editor) {
        var _a;
        var buttons = editor.ui.registry.getAll().buttons;
        var identify = function (toolbar) {
          return identifyButtons(editor, {
            buttons: buttons,
            toolbar: toolbar,
            allowToolbarGroups: false
          }, extras, Option.none());
        };
        var attributes = (_a = {}, _a[Attribute] = extras.backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop, _a);
        switch (getToolbarMode(editor)) {
        case ToolbarMode.floating:
          return renderFloatingToolbarButton(s, extras.backstage, identify, attributes);
        default:
          throw new Error(&apos;Toolbar groups are only supported when using floating toolbar mode&apos;);
        }
      }),
      styleSelectButton: function (editor, extras) {
        return createStyleSelect(editor, extras.backstage);
      },
      fontsizeSelectButton: function (editor, extras) {
        return createFontsizeSelect(editor, extras.backstage);
      },
      fontSelectButton: function (editor, extras) {
        return createFontSelect(editor, extras.backstage);
      },
      formatButton: function (editor, extras) {
        return createFormatSelect(editor, extras.backstage);
      },
      alignMenuButton: function (editor, extras) {
        return createAlignSelect(editor, extras.backstage);
      }
    };
    var extractFrom = function (spec, extras, editor) {
      return get(types, spec.type).fold(function () {
        domGlobals.console.error(&apos;skipping button defined by&apos;, spec);
        return Option.none();
      }, function (render) {
        return Option.some(render(spec, extras, editor));
      });
    };
    var bespokeButtons = {
      styleselect: types.styleSelectButton,
      fontsizeselect: types.fontsizeSelectButton,
      fontselect: types.fontSelectButton,
      formatselect: types.formatButton,
      align: types.alignMenuButton
    };
    var removeUnusedDefaults = function (buttons) {
      var filteredItemGroups = map(defaultToolbar, function (group) {
        var items = filter(group.items, function (subItem) {
          return has(buttons, subItem) || has(bespokeButtons, subItem);
        });
        return {
          name: group.name,
          items: items
        };
      });
      return filter(filteredItemGroups, function (group) {
        return group.items.length &gt; 0;
      });
    };
    var convertStringToolbar = function (strToolbar) {
      var groupsStrings = strToolbar.split(&apos;|&apos;);
      return map(groupsStrings, function (g) {
        return { items: g.trim().split(&apos; &apos;) };
      });
    };
    var isToolbarGroupSettingArray = function (toolbar) {
      return isArrayOf(toolbar, function (t) {
        return has(t, &apos;name&apos;) &amp;&amp; has(t, &apos;items&apos;);
      });
    };
    var createToolbar = function (toolbarConfig) {
      var toolbar = toolbarConfig.toolbar;
      var buttons = toolbarConfig.buttons;
      if (toolbar === false) {
        return [];
      } else if (toolbar === undefined || toolbar === true) {
        return removeUnusedDefaults(buttons);
      } else if (isString(toolbar)) {
        return convertStringToolbar(toolbar);
      } else if (isToolbarGroupSettingArray(toolbar)) {
        return toolbar;
      } else {
        domGlobals.console.error(&apos;Toolbar type should be string, string[], boolean or ToolbarGroup[]&apos;);
        return [];
      }
    };
    var lookupButton = function (editor, buttons, toolbarItem, allowToolbarGroups, extras, prefixes) {
      return get(buttons, toolbarItem.toLowerCase()).orThunk(function () {
        return prefixes.bind(function (ps) {
          return findMap(ps, function (prefix) {
            return get(buttons, prefix + toolbarItem.toLowerCase());
          });
        });
      }).fold(function () {
        return get(bespokeButtons, toolbarItem.toLowerCase()).map(function (r) {
          return r(editor, extras);
        }).orThunk(function () {
          return Option.none();
        });
      }, function (spec) {
        if (spec.type === &apos;grouptoolbarbutton&apos; &amp;&amp; !allowToolbarGroups) {
          domGlobals.console.warn(&apos;Ignoring the \&apos;&apos; + toolbarItem + &apos;\&apos; toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.&apos;);
          return Option.none();
        } else {
          return extractFrom(spec, extras, editor);
        }
      });
    };
    var identifyButtons = function (editor, toolbarConfig, extras, prefixes) {
      var toolbarGroups = createToolbar(toolbarConfig);
      var groups = map(toolbarGroups, function (group) {
        var items = bind(group.items, function (toolbarItem) {
          return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, extras, prefixes).toArray();
        });
        return {
          title: Option.from(editor.translate(group.name)),
          items: items
        };
      });
      return filter(groups, function (group) {
        return group.items.length &gt; 0;
      });
    };

    var bubbleSize = 12;
    var bubbleAlignments$1 = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [&apos;tox-pop--align-left&apos;],
      alignRight: [&apos;tox-pop--align-right&apos;],
      right: [&apos;tox-pop--right&apos;],
      left: [&apos;tox-pop--left&apos;],
      bottom: [&apos;tox-pop--bottom&apos;],
      top: [&apos;tox-pop--top&apos;]
    };
    var anchorOverrides = {
      maxHeightFunction: expandable(),
      maxWidthFunction: expandable$1()
    };
    var desktopAnchorSpecLayouts = {
      onLtr: function () {
        return [
          north$1,
          south$1,
          northeast$1,
          southeast$1,
          northwest$1,
          southwest$1,
          north$3,
          south$3,
          northeast$3,
          southeast$3,
          northwest$3,
          southwest$3
        ];
      },
      onRtl: function () {
        return [
          north$1,
          south$1,
          northwest$1,
          southwest$1,
          northeast$1,
          southeast$1,
          north$3,
          south$3,
          northwest$3,
          southwest$3,
          northeast$3,
          southeast$3
        ];
      }
    };
    var mobileAnchorSpecLayouts = {
      onLtr: function () {
        return [
          south$1,
          southeast$1,
          southwest$1,
          northeast$1,
          northwest$1,
          north$1,
          north$3,
          south$3,
          northeast$3,
          southeast$3,
          northwest$3,
          southwest$3
        ];
      },
      onRtl: function () {
        return [
          south$1,
          southwest$1,
          southeast$1,
          northwest$1,
          northeast$1,
          north$1,
          north$3,
          south$3,
          northwest$3,
          southwest$3,
          northeast$3,
          southeast$3
        ];
      }
    };
    var getAnchorLayout = function (position, isTouch) {
      if (position === &apos;line&apos;) {
        return {
          bubble: nu$8(bubbleSize, 0, bubbleAlignments$1),
          layouts: {
            onLtr: function () {
              return [east$1];
            },
            onRtl: function () {
              return [west$1];
            }
          },
          overrides: anchorOverrides
        };
      } else {
        return {
          bubble: nu$8(0, bubbleSize, bubbleAlignments$1),
          layouts: isTouch ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts,
          overrides: anchorOverrides
        };
      }
    };
    var register$4 = function (editor, registryContextToolbars, sink, extras) {
      var isTouch = detect$3().deviceType.isTouch;
      var contextbar = build$1(renderContextToolbar({
        sink: sink,
        onEscape: function () {
          editor.focus();
          return Option.some(true);
        }
      }));
      var getBounds = function () {
        return getContextToolbarBounds(editor, extras.backstage.shared);
      };
      var isRangeOverlapping = function (aTop, aBottom, bTop, bBottom) {
        return Math.max(aTop, bTop) &lt;= Math.min(aBottom, bBottom);
      };
      var getLastElementVerticalBound = function () {
        var nodeBounds = lastElement.get().map(function (ele) {
          return ele.getBoundingClientRect();
        }).getOrThunk(function () {
          return editor.selection.getRng().getBoundingClientRect();
        });
        var diffTop = editor.inline ? get$8().top() : absolute$1(Element.fromDom(editor.getBody())).y;
        return {
          y: nodeBounds.top + diffTop,
          bottom: nodeBounds.bottom + diffTop
        };
      };
      var shouldContextToolbarHide = function () {
        if (isTouch() &amp;&amp; extras.backstage.isContextMenuOpen()) {
          return true;
        }
        var lastElementBounds = getLastElementVerticalBound();
        var contextToolbarBounds = getBounds();
        return !isRangeOverlapping(lastElementBounds.y, lastElementBounds.bottom, contextToolbarBounds.y, contextToolbarBounds.bottom);
      };
      var forceHide = function () {
        InlineView.hide(contextbar);
      };
      var hideOrRepositionIfNecessary = function () {
        lastAnchor.get().each(function (anchor) {
          var contextBarEle = contextbar.element();
          remove$6(contextBarEle, &apos;display&apos;);
          if (shouldContextToolbarHide()) {
            set$2(contextBarEle, &apos;display&apos;, &apos;none&apos;);
          } else {
            Positioning.positionWithinBounds(sink, anchor, contextbar, Option.some(getBounds()));
          }
        });
      };
      var lastAnchor = Cell(Option.none());
      var lastElement = Cell(Option.none());
      var timer = Cell(null);
      var wrapInPopDialog = function (toolbarSpec) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-pop__dialog&apos;]
          },
          components: [toolbarSpec],
          behaviours: derive$1([
            Keying.config({ mode: &apos;acyclic&apos; }),
            config(&apos;pop-dialog-wrap-events&apos;, [
              runOnAttached(function (comp) {
                editor.shortcuts.add(&apos;ctrl+F9&apos;, &apos;focus statusbar&apos;, function () {
                  return Keying.focusIn(comp);
                });
              }),
              runOnDetached(function (_comp) {
                editor.shortcuts.remove(&apos;ctrl+F9&apos;);
              })
            ])
          ])
        };
      };
      var getScopes = cached(function () {
        return categorise(registryContextToolbars, function (toolbarApi) {
          var alloySpec = buildToolbar([toolbarApi]);
          emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(alloySpec) });
        });
      });
      var buildContextToolbarGroups = function (allButtons, ctx) {
        return identifyButtons(editor, {
          buttons: allButtons,
          toolbar: ctx.items,
          allowToolbarGroups: false
        }, extras, Option.some([&apos;form:&apos;]));
      };
      var buildContextMenuGroups = function (ctx, providers) {
        return ContextForm.buildInitGroups(ctx, providers);
      };
      var buildToolbar = function (toolbars) {
        var buttons = editor.ui.registry.getAll().buttons;
        var scopes = getScopes();
        var allButtons = __assign(__assign({}, buttons), scopes.formNavigators);
        var toolbarType = getToolbarMode(editor) === ToolbarMode.scrolling ? ToolbarMode.scrolling : ToolbarMode.default;
        var initGroups = flatten(map(toolbars, function (ctx) {
          return ctx.type === &apos;contexttoolbar&apos; ? buildContextToolbarGroups(allButtons, ctx) : buildContextMenuGroups(ctx, extras.backstage.shared.providers);
        }));
        return renderToolbar({
          type: toolbarType,
          uid: generate$1(&apos;context-toolbar&apos;),
          initGroups: initGroups,
          onEscape: Option.none,
          cyclicKeying: true,
          providers: extras.backstage.shared.providers
        });
      };
      editor.on(showContextToolbarEvent, function (e) {
        var scopes = getScopes();
        get(scopes.lookupTable, e.toolbarKey).each(function (ctx) {
          launchContext([ctx], e.target === editor ? Option.none() : Option.some(e));
          InlineView.getContent(contextbar).each(Keying.focusIn);
        });
      });
      var getAnchor = function (position, element) {
        var anchorage = position === &apos;node&apos; ? extras.backstage.shared.anchors.node(element) : extras.backstage.shared.anchors.cursor();
        return deepMerge(anchorage, getAnchorLayout(position, isTouch()));
      };
      var launchContext = function (toolbarApi, elem) {
        clearTimer();
        if (isTouch() &amp;&amp; extras.backstage.isContextMenuOpen()) {
          return;
        }
        var toolbarSpec = buildToolbar(toolbarApi);
        var sElem = elem.map(Element.fromDom);
        var anchor = getAnchor(toolbarApi[0].position, sElem);
        lastAnchor.set(Option.some(anchor));
        lastElement.set(elem);
        var contextBarEle = contextbar.element();
        remove$6(contextBarEle, &apos;display&apos;);
        InlineView.showWithinBounds(contextbar, anchor, wrapInPopDialog(toolbarSpec), function () {
          return Option.some(getBounds());
        });
        if (shouldContextToolbarHide()) {
          set$2(contextBarEle, &apos;display&apos;, &apos;none&apos;);
        }
      };
      var launchContextToolbar = function () {
        if (!editor.hasFocus()) {
          return;
        }
        var scopes = getScopes();
        lookup$1(scopes, editor).fold(function () {
          lastAnchor.set(Option.none());
          InlineView.hide(contextbar);
        }, function (info) {
          launchContext(info.toolbars, Option.some(info.elem.dom()));
        });
      };
      var clearTimer = function () {
        var current = timer.get();
        if (current !== null) {
          global$2.clearTimeout(current);
          timer.set(null);
        }
      };
      var resetTimer = function (t) {
        clearTimer();
        timer.set(t);
      };
      editor.on(&apos;init&apos;, function () {
        editor.on(hideContextToolbarEvent, forceHide);
        editor.on(&apos;ScrollContent ScrollWindow longpress&apos;, hideOrRepositionIfNecessary);
        editor.on(&apos;click keyup focus SetContent ObjectResized ResizeEditor&apos;, function () {
          resetTimer(global$2.setEditorTimeout(editor, launchContextToolbar, 0));
        });
        editor.on(&apos;focusout&apos;, function (_e) {
          global$2.setEditorTimeout(editor, function () {
            if (search(sink.element()).isNone() &amp;&amp; search(contextbar.element()).isNone()) {
              lastAnchor.set(Option.none());
              InlineView.hide(contextbar);
            }
          }, 0);
        });
        editor.on(&apos;SwitchMode&apos;, function () {
          if (editor.mode.isReadOnly()) {
            lastAnchor.set(Option.none());
            InlineView.hide(contextbar);
          }
        });
        editor.on(&apos;NodeChange&apos;, function (_e) {
          search(contextbar.element()).fold(function () {
            resetTimer(global$2.setEditorTimeout(editor, launchContextToolbar, 0));
          }, function (_) {
          });
        });
      });
    };

    var setup$3 = function (editor, mothership, uiMothership) {
      var broadcastEvent = function (name, evt) {
        each([
          mothership,
          uiMothership
        ], function (ship) {
          ship.broadcastEvent(name, evt);
        });
      };
      var broadcastOn = function (channel, message) {
        each([
          mothership,
          uiMothership
        ], function (ship) {
          ship.broadcastOn([channel], message);
        });
      };
      var fireDismissPopups = function (evt) {
        return broadcastOn(dismissPopups(), { target: evt.target() });
      };
      var onTouchstart = bind$3(Element.fromDom(domGlobals.document), &apos;touchstart&apos;, fireDismissPopups);
      var onTouchmove = bind$3(Element.fromDom(domGlobals.document), &apos;touchmove&apos;, function (evt) {
        return broadcastEvent(documentTouchmove(), evt);
      });
      var onTouchend = bind$3(Element.fromDom(domGlobals.document), &apos;touchend&apos;, function (evt) {
        return broadcastEvent(documentTouchend(), evt);
      });
      var onMousedown = bind$3(Element.fromDom(domGlobals.document), &apos;mousedown&apos;, fireDismissPopups);
      var onMouseup = bind$3(Element.fromDom(domGlobals.document), &apos;mouseup&apos;, function (evt) {
        if (evt.raw().button === 0) {
          broadcastOn(mouseReleased(), { target: evt.target() });
        }
      });
      var onContentClick = function (raw) {
        return broadcastOn(dismissPopups(), { target: Element.fromDom(raw.target) });
      };
      var onContentMouseup = function (raw) {
        if (raw.button === 0) {
          broadcastOn(mouseReleased(), { target: Element.fromDom(raw.target) });
        }
      };
      var onWindowScroll = function (evt) {
        return broadcastEvent(windowScroll(), fromRawEvent$1(evt));
      };
      var onWindowResize = function (evt) {
        broadcastOn(repositionPopups(), {});
        broadcastEvent(windowResize(), fromRawEvent$1(evt));
      };
      var onEditorResize = function () {
        return broadcastOn(repositionPopups(), {});
      };
      editor.on(&apos;PostRender&apos;, function () {
        editor.on(&apos;click&apos;, onContentClick);
        editor.on(&apos;tap&apos;, onContentClick);
        editor.on(&apos;mouseup&apos;, onContentMouseup);
        editor.on(&apos;ScrollWindow&apos;, onWindowScroll);
        editor.on(&apos;ResizeWindow&apos;, onWindowResize);
        editor.on(&apos;ResizeEditor&apos;, onEditorResize);
      });
      editor.on(&apos;remove&apos;, function () {
        editor.off(&apos;click&apos;, onContentClick);
        editor.off(&apos;tap&apos;, onContentClick);
        editor.off(&apos;mouseup&apos;, onContentMouseup);
        editor.off(&apos;ScrollWindow&apos;, onWindowScroll);
        editor.off(&apos;ResizeWindow&apos;, onWindowResize);
        editor.off(&apos;ResizeEditor&apos;, onEditorResize);
        onMousedown.unbind();
        onTouchstart.unbind();
        onTouchmove.unbind();
        onTouchend.unbind();
        onMouseup.unbind();
      });
      editor.on(&apos;detach&apos;, function () {
        detachSystem(mothership);
        detachSystem(uiMothership);
        mothership.destroy();
        uiMothership.destroy();
      });
    };

    var parts$d = AlloyParts;
    var partType$1 = PartType;

    var schema$r = constant([
      defaulted$1(&apos;shell&apos;, false),
      strict$1(&apos;makeItem&apos;),
      defaulted$1(&apos;setupItem&apos;, noop),
      SketchBehaviours.field(&apos;listBehaviours&apos;, [Replacing])
    ]);
    var customListDetail = function () {
      return { behaviours: derive$1([Replacing.config({})]) };
    };
    var itemsPart = optional({
      name: &apos;items&apos;,
      overrides: customListDetail
    });
    var parts$e = constant([itemsPart]);
    var name$2 = constant(&apos;CustomList&apos;);

    var factory$f = function (detail, components, _spec, _external) {
      var setItems = function (list, items) {
        getListContainer(list).fold(function () {
          domGlobals.console.error(&apos;Custom List was defined to not be a shell, but no item container was specified in components&apos;);
          throw new Error(&apos;Custom List was defined to not be a shell, but no item container was specified in components&apos;);
        }, function (container) {
          var itemComps = Replacing.contents(container);
          var numListsRequired = items.length;
          var numListsToAdd = numListsRequired - itemComps.length;
          var itemsToAdd = numListsToAdd &gt; 0 ? range(numListsToAdd, function () {
            return detail.makeItem();
          }) : [];
          var itemsToRemove = itemComps.slice(numListsRequired);
          each(itemsToRemove, function (item) {
            return Replacing.remove(container, item);
          });
          each(itemsToAdd, function (item) {
            return Replacing.append(container, item);
          });
          var builtLists = Replacing.contents(container);
          each(builtLists, function (item, i) {
            detail.setupItem(list, item, items[i], i);
          });
        });
      };
      var extra = detail.shell ? {
        behaviours: [Replacing.config({})],
        components: []
      } : {
        behaviours: [],
        components: components
      };
      var getListContainer = function (component) {
        return detail.shell ? Option.some(component) : getPart(component, detail, &apos;items&apos;);
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: extra.components,
        behaviours: augment(detail.listBehaviours, extra.behaviours),
        apis: { setItems: setItems }
      };
    };
    var CustomList = composite$1({
      name: name$2(),
      configFields: schema$r(),
      partFields: parts$e(),
      factory: factory$f,
      apis: {
        setItems: function (apis, list, items) {
          apis.setItems(list, items);
        }
      }
    });

    var getOffsetParent = function (element) {
      var isFixed = getRaw(element, &apos;position&apos;).is(&apos;fixed&apos;);
      var offsetParent$1 = isFixed ? Option.none() : offsetParent(element);
      return offsetParent$1.orThunk(function () {
        var marker = Element.fromTag(&apos;span&apos;);
        return parent(element).bind(function (parent) {
          append(parent, marker);
          var offsetParent$1 = offsetParent(marker);
          remove(marker);
          return offsetParent$1;
        });
      });
    };
    var getOrigin = function (element) {
      return getOffsetParent(element).map(absolute).getOrThunk(function () {
        return Position(0, 0);
      });
    };

    var morphAdt = Adt.generate([
      { static: [] },
      { absolute: [&apos;positionCss&apos;] },
      { fixed: [&apos;positionCss&apos;] }
    ]);
    var appear = function (component, contextualInfo) {
      var elem = component.element();
      add$2(elem, contextualInfo.transitionClass);
      remove$4(elem, contextualInfo.fadeOutClass);
      add$2(elem, contextualInfo.fadeInClass);
      contextualInfo.onShow(component);
    };
    var disappear = function (component, contextualInfo) {
      var elem = component.element();
      add$2(elem, contextualInfo.transitionClass);
      remove$4(elem, contextualInfo.fadeInClass);
      add$2(elem, contextualInfo.fadeOutClass);
      contextualInfo.onHide(component);
    };
    var isPartiallyVisible = function (box, viewport) {
      return box.y &lt; viewport.bottom &amp;&amp; box.bottom &gt; viewport.y;
    };
    var isTopCompletelyVisible = function (box, viewport) {
      return box.y &gt;= viewport.y;
    };
    var isBottomCompletelyVisible = function (box, viewport) {
      return box.bottom &lt;= viewport.bottom;
    };
    var isVisibleForModes = function (modes, box, viewport) {
      return forall(modes, function (mode) {
        switch (mode) {
        case &apos;bottom&apos;:
          return isBottomCompletelyVisible(box, viewport);
        case &apos;top&apos;:
          return isTopCompletelyVisible(box, viewport);
        }
      });
    };
    var getPrior = function (elem, state) {
      return state.getInitialPosition().map(function (pos) {
        return bounds$1(pos.bounds.x, pos.bounds.y, get$7(elem), get$6(elem));
      });
    };
    var storePrior = function (elem, box, state) {
      state.setInitialPosition(Option.some({
        style: getAllRaw(elem),
        position: get$4(elem, &apos;position&apos;) || &apos;static&apos;,
        bounds: box
      }));
    };
    var revertToOriginal = function (elem, box$1, state) {
      return state.getInitialPosition().bind(function (position) {
        state.setInitialPosition(Option.none());
        switch (position.position) {
        case &apos;static&apos;:
          return Option.some(morphAdt.static());
        case &apos;absolute&apos;:
          var offsetBox_1 = getOffsetParent(elem).map(box).getOrThunk(function () {
            return box(body());
          });
          return Option.some(morphAdt.absolute(NuPositionCss(&apos;absolute&apos;, get(position.style, &apos;left&apos;).map(function (_left) {
            return box$1.x - offsetBox_1.x;
          }), get(position.style, &apos;top&apos;).map(function (_top) {
            return box$1.y - offsetBox_1.y;
          }), get(position.style, &apos;right&apos;).map(function (_right) {
            return offsetBox_1.right - box$1.right;
          }), get(position.style, &apos;bottom&apos;).map(function (_bottom) {
            return offsetBox_1.bottom - box$1.bottom;
          }))));
        default:
          return Option.none();
        }
      });
    };
    var morphToOriginal = function (elem, viewport, state) {
      return getPrior(elem, state).filter(function (box) {
        return isVisibleForModes(state.getModes(), box, viewport);
      }).bind(function (box) {
        return revertToOriginal(elem, box, state);
      });
    };
    var morphToFixed = function (elem, viewport, state) {
      var box$1 = box(elem);
      if (!isVisibleForModes(state.getModes(), box$1, viewport)) {
        storePrior(elem, box$1, state);
        var winBox = win();
        var left = box$1.x - winBox.x;
        var top = viewport.y - winBox.y;
        var bottom = winBox.bottom - viewport.bottom;
        var isTop = box$1.y &lt;= viewport.y;
        return Option.some(morphAdt.fixed(NuPositionCss(&apos;fixed&apos;, Option.some(left), isTop ? Option.some(top) : Option.none(), Option.none(), !isTop ? Option.some(bottom) : Option.none())));
      } else {
        return Option.none();
      }
    };
    var getMorph = function (component, viewport, state) {
      var elem = component.element();
      var isDocked = getRaw(elem, &apos;position&apos;).is(&apos;fixed&apos;);
      return isDocked ? morphToOriginal(elem, viewport, state) : morphToFixed(elem, viewport, state);
    };
    var getMorphToOriginal = function (component, state) {
      var elem = component.element();
      return getPrior(elem, state).bind(function (box) {
        return revertToOriginal(elem, box, state);
      });
    };

    var morphToStatic = function (component, config) {
      each([
        &apos;left&apos;,
        &apos;right&apos;,
        &apos;top&apos;,
        &apos;bottom&apos;,
        &apos;position&apos;
      ], function (prop) {
        return remove$6(component.element(), prop);
      });
      config.onUndocked(component);
    };
    var morphToCoord = function (component, config, position) {
      applyPositionCss(component.element(), position);
      var method = position.position() === &apos;fixed&apos; ? config.onDocked : config.onUndocked;
      method(component);
    };
    var updateVisibility = function (component, config, state, viewport, morphToDocked) {
      if (morphToDocked === void 0) {
        morphToDocked = false;
      }
      config.contextual.each(function (contextInfo) {
        contextInfo.lazyContext(component).each(function (box) {
          var isVisible = isPartiallyVisible(box, viewport);
          if (isVisible !== state.isVisible()) {
            state.setVisible(isVisible);
            if (morphToDocked &amp;&amp; !isVisible) {
              add$3(component.element(), [contextInfo.fadeOutClass]);
              contextInfo.onHide(component);
            } else {
              var method = isVisible ? appear : disappear;
              method(component, contextInfo);
            }
          }
        });
      });
    };
    var refreshInternal = function (component, config, state) {
      var viewport = config.lazyViewport(component);
      var isDocked = state.isDocked();
      if (isDocked) {
        updateVisibility(component, config, state, viewport);
      }
      getMorph(component, viewport, state).each(function (morph) {
        state.setDocked(!isDocked);
        morph.fold(function () {
          return morphToStatic(component, config);
        }, function (position) {
          return morphToCoord(component, config, position);
        }, function (position) {
          updateVisibility(component, config, state, viewport, true);
          morphToCoord(component, config, position);
        });
      });
    };
    var resetInternal = function (component, config, state) {
      var elem = component.element();
      state.setDocked(false);
      getMorphToOriginal(component, state).each(function (morph) {
        morph.fold(function () {
          return morphToStatic(component, config);
        }, function (position) {
          return morphToCoord(component, config, position);
        }, noop);
      });
      state.setVisible(true);
      config.contextual.each(function (contextInfo) {
        remove$5(elem, [
          contextInfo.fadeInClass,
          contextInfo.fadeOutClass,
          contextInfo.transitionClass
        ]);
        contextInfo.onShow(component);
      });
      refresh$4(component, config, state);
    };
    var refresh$4 = function (component, config, state) {
      if (component.getSystem().isConnected()) {
        refreshInternal(component, config, state);
      }
    };
    var reset = function (component, config, state) {
      if (state.isDocked()) {
        resetInternal(component, config, state);
      }
    };
    var isDocked = function (component, config, state) {
      return state.isDocked();
    };
    var setModes = function (component, config, state, modes) {
      return state.setModes(modes);
    };
    var getModes = function (component, config, state) {
      return state.getModes();
    };

    var DockingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        refresh: refresh$4,
        reset: reset,
        isDocked: isDocked,
        getModes: getModes,
        setModes: setModes
    });

    var events$f = function (dockInfo, dockState) {
      return derive([
        runOnSource(transitionend(), function (component, simulatedEvent) {
          dockInfo.contextual.each(function (contextInfo) {
            if (has$2(component.element(), contextInfo.transitionClass)) {
              remove$5(component.element(), [
                contextInfo.transitionClass,
                contextInfo.fadeInClass
              ]);
              var notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;
              notify(component);
            }
            simulatedEvent.stop();
          });
        }),
        run(windowScroll(), function (component, _) {
          refresh$4(component, dockInfo, dockState);
        }),
        run(windowResize(), function (component, _) {
          reset(component, dockInfo, dockState);
        })
      ]);
    };

    var ActiveDocking = /*#__PURE__*/Object.freeze({
        __proto__: null,
        events: events$f
    });

    var DockingSchema = [
      optionObjOf(&apos;contextual&apos;, [
        strictString(&apos;fadeInClass&apos;),
        strictString(&apos;fadeOutClass&apos;),
        strictString(&apos;transitionClass&apos;),
        strictFunction(&apos;lazyContext&apos;),
        onHandler(&apos;onShow&apos;),
        onHandler(&apos;onShown&apos;),
        onHandler(&apos;onHide&apos;),
        onHandler(&apos;onHidden&apos;)
      ]),
      defaultedFunction(&apos;lazyViewport&apos;, win),
      defaultedArrayOf(&apos;modes&apos;, [
        &apos;top&apos;,
        &apos;bottom&apos;
      ], string),
      onHandler(&apos;onDocked&apos;),
      onHandler(&apos;onUndocked&apos;)
    ];

    var init$b = function (spec) {
      var docked = Cell(false);
      var visible = Cell(true);
      var initialBounds = Cell(Option.none());
      var modes = Cell(spec.modes);
      var readState = function () {
        return &apos;docked:  &apos; + docked.get() + &apos;, visible: &apos; + visible.get() + &apos;, modes: &apos; + modes.get().join(&apos;,&apos;);
      };
      return nu$5({
        isDocked: docked.get,
        setDocked: docked.set,
        getInitialPosition: initialBounds.get,
        setInitialPosition: initialBounds.set,
        isVisible: visible.get,
        setVisible: visible.set,
        getModes: modes.get,
        setModes: modes.set,
        readState: readState
      });
    };

    var DockingState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$b
    });

    var Docking = create$1({
      fields: DockingSchema,
      name: &apos;docking&apos;,
      active: ActiveDocking,
      apis: DockingApis,
      state: DockingState
    });

    var visibility = {
      fadeInClass: &apos;tox-editor-dock-fadein&apos;,
      fadeOutClass: &apos;tox-editor-dock-fadeout&apos;,
      transitionClass: &apos;tox-editor-dock-transition&apos;
    };
    var editorStickyOnClass = &apos;tox-tinymce--toolbar-sticky-on&apos;;
    var editorStickyOffClass = &apos;tox-tinymce--toolbar-sticky-off&apos;;
    var scrollFromBehindHeader = function (e, containerHeader) {
      var doc = owner(containerHeader);
      var viewHeight = doc.dom().defaultView.innerHeight;
      var scrollPos = get$8(doc);
      var markerElement = Element.fromDom(e.elm);
      var markerPos = absolute$1(markerElement);
      var markerHeight = get$6(markerElement);
      var markerTop = markerPos.y;
      var markerBottom = markerTop + markerHeight;
      var editorHeaderPos = absolute(containerHeader);
      var editorHeaderHeight = get$6(containerHeader);
      var editorHeaderTop = editorHeaderPos.top();
      var editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
      var editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top()) &lt; 2;
      var editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top() + viewHeight)) &lt; 2;
      if (editorHeaderDockedAtTop &amp;&amp; markerTop &lt; editorHeaderBottom) {
        to(scrollPos.left(), markerTop - editorHeaderHeight, doc);
      } else if (editorHeaderDockedAtBottom &amp;&amp; markerBottom &gt; editorHeaderTop) {
        var y = markerTop - viewHeight + markerHeight + editorHeaderHeight;
        to(scrollPos.left(), y, doc);
      }
    };
    var isDockedMode = function (header, mode) {
      return contains(Docking.getModes(header), mode);
    };
    var updateIframeContentFlow = function (header) {
      var getOccupiedHeight = function (elm) {
        return getOuter$1(elm) + (parseInt(get$4(elm, &apos;margin-top&apos;), 10) || 0) + (parseInt(get$4(elm, &apos;margin-bottom&apos;), 10) || 0);
      };
      var elm = header.element();
      parent(elm).each(function (parentElem) {
        var padding = &apos;padding-&apos; + Docking.getModes(header)[0];
        if (Docking.isDocked(header)) {
          var parentWidth = get$7(parentElem);
          set$2(elm, &apos;width&apos;, parentWidth + &apos;px&apos;);
          set$2(parentElem, padding, getOccupiedHeight(elm) + &apos;px&apos;);
        } else {
          remove$6(elm, &apos;width&apos;);
          remove$6(parentElem, padding);
        }
      });
    };
    var updateSinkVisibility = function (sinkElem, visible) {
      if (visible) {
        remove$4(sinkElem, visibility.fadeOutClass);
        add$3(sinkElem, [
          visibility.transitionClass,
          visibility.fadeInClass
        ]);
      } else {
        remove$4(sinkElem, visibility.fadeInClass);
        add$3(sinkElem, [
          visibility.fadeOutClass,
          visibility.transitionClass
        ]);
      }
    };
    var updateEditorClasses = function (editor, docked) {
      var editorContainer = Element.fromDom(editor.getContainer());
      if (docked) {
        add$2(editorContainer, editorStickyOnClass);
        remove$4(editorContainer, editorStickyOffClass);
      } else {
        add$2(editorContainer, editorStickyOffClass);
        remove$4(editorContainer, editorStickyOnClass);
      }
    };
    var restoreFocus = function (headerElem, focusedElem) {
      var ownerDoc = owner(focusedElem);
      active(ownerDoc).filter(function (activeElm) {
        return !eq$1(focusedElem, activeElm);
      }).filter(function (activeElm) {
        return eq$1(activeElm, Element.fromDom(ownerDoc.dom().body)) || contains$2(headerElem, activeElm);
      }).each(function () {
        return focus$1(focusedElem);
      });
    };
    var findFocusedElem = function (rootElm, lazySink) {
      return search(rootElm).orThunk(function () {
        return lazySink().toOption().bind(function (sink) {
          return search(sink.element());
        });
      });
    };
    var setup$4 = function (editor, sharedBackstage, lazyHeader) {
      if (!editor.inline) {
        if (!sharedBackstage.header.isPositionedAtTop()) {
          editor.on(&apos;ResizeEditor&apos;, function () {
            lazyHeader().each(Docking.reset);
          });
        }
        editor.on(&apos;ResizeWindow ResizeEditor&apos;, function () {
          lazyHeader().each(updateIframeContentFlow);
        });
        editor.on(&apos;SkinLoaded&apos;, function () {
          lazyHeader().each(function (comp) {
            Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
          });
        });
        editor.on(&apos;FullscreenStateChanged&apos;, function () {
          lazyHeader().each(Docking.reset);
        });
      }
      editor.on(&apos;AfterScrollIntoView&apos;, function (e) {
        lazyHeader().each(function (header) {
          Docking.refresh(header);
          var headerElem = header.element();
          if (isVisible(headerElem)) {
            scrollFromBehindHeader(e, headerElem);
          }
        });
      });
      editor.on(&apos;PostRender&apos;, function () {
        updateEditorClasses(editor, false);
      });
    };
    var isDocked$1 = function (lazyHeader) {
      return lazyHeader().map(Docking.isDocked).getOr(false);
    };
    var getIframeBehaviours = function () {
      var _a;
      return [Receiving.config({ channels: (_a = {}, _a[toolbarHeightChange()] = { onReceive: updateIframeContentFlow }, _a) })];
    };
    var getBehaviours$2 = function (editor, sharedBackstage) {
      var focusedElm = Cell(Option.none());
      var lazySink = sharedBackstage.getSink;
      var runOnSinkElement = function (f) {
        lazySink().each(function (sink) {
          return f(sink.element());
        });
      };
      var onDockingSwitch = function (comp) {
        if (!editor.inline) {
          updateIframeContentFlow(comp);
        }
        updateEditorClasses(editor, Docking.isDocked(comp));
        comp.getSystem().broadcastOn([repositionPopups()], {});
        lazySink().each(function (sink) {
          return sink.getSystem().broadcastOn([repositionPopups()], {});
        });
      };
      var additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
      return __spreadArrays([
        Focusing.config({}),
        Docking.config({
          contextual: __assign({
            lazyContext: function (comp) {
              var headerHeight = getOuter$1(comp.element());
              var container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
              var box$1 = box(Element.fromDom(container));
              var boxHeight = box$1.height - headerHeight;
              var topBound = box$1.y + (isDockedMode(comp, &apos;top&apos;) ? 0 : headerHeight);
              return Option.some(bounds$1(box$1.x, topBound, box$1.width, boxHeight));
            },
            onShow: function () {
              runOnSinkElement(function (elem) {
                return updateSinkVisibility(elem, true);
              });
            },
            onShown: function (comp) {
              runOnSinkElement(function (elem) {
                return remove$5(elem, [
                  visibility.transitionClass,
                  visibility.fadeInClass
                ]);
              });
              focusedElm.get().each(function (elem) {
                restoreFocus(comp.element(), elem);
                focusedElm.set(Option.none());
              });
            },
            onHide: function (comp) {
              focusedElm.set(findFocusedElem(comp.element(), lazySink));
              runOnSinkElement(function (elem) {
                return updateSinkVisibility(elem, false);
              });
            },
            onHidden: function () {
              runOnSinkElement(function (elem) {
                return remove$5(elem, [visibility.transitionClass]);
              });
            }
          }, visibility),
          modes: [sharedBackstage.header.getDockingMode()],
          onDocked: onDockingSwitch,
          onUndocked: onDockingSwitch
        })
      ], additionalBehaviours);
    };

    var StickyHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$4,
        isDocked: isDocked$1,
        getBehaviours: getBehaviours$2
    });

    var setup$5 = noop;
    var isDocked$2 = never;
    var getBehaviours$3 = constant([]);

    var StaticHeader = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setup: setup$5,
        isDocked: isDocked$2,
        getBehaviours: getBehaviours$3
    });

    var renderHeader = function (spec) {
      var editor = spec.editor;
      var getBehaviours = spec.sticky ? getBehaviours$2 : getBehaviours$3;
      return {
        uid: spec.uid,
        dom: spec.dom,
        components: spec.components,
        behaviours: derive$1(getBehaviours(editor, spec.sharedBackstage))
      };
    };

    var factory$g = function (detail, spec) {
      var setMenus = function (comp, menus) {
        var newMenus = map(menus, function (m) {
          var buttonSpec = {
            type: &apos;menubutton&apos;,
            text: m.text,
            fetch: function (callback) {
              callback(m.getItems());
            }
          };
          var internal = createMenuButton(buttonSpec).mapError(function (errInfo) {
            return formatError(errInfo);
          }).getOrDie();
          return renderMenuButton(internal, &apos;tox-mbtn&apos;, spec.backstage, Option.some(&apos;menuitem&apos;));
        });
        Replacing.set(comp, newMenus);
      };
      var apis = {
        focus: Keying.focusIn,
        setMenus: setMenus
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: [],
        behaviours: derive$1([
          Replacing.config({}),
          config(&apos;menubar-events&apos;, [
            runOnAttached(function (component) {
              detail.onSetup(component);
            }),
            run(mouseover(), function (comp, se) {
              descendant$1(comp.element(), &apos;.&apos; + &apos;tox-mbtn--active&apos;).each(function (activeButton) {
                closest$3(se.event().target(), &apos;.&apos; + &apos;tox-mbtn&apos;).each(function (hoveredButton) {
                  if (!eq$1(activeButton, hoveredButton)) {
                    comp.getSystem().getByDom(activeButton).each(function (activeComp) {
                      comp.getSystem().getByDom(hoveredButton).each(function (hoveredComp) {
                        Dropdown.expand(hoveredComp);
                        Dropdown.close(activeComp);
                        Focusing.focus(hoveredComp);
                      });
                    });
                  }
                });
              });
            }),
            run(focusShifted(), function (comp, se) {
              se.event().prevFocus().bind(function (prev) {
                return comp.getSystem().getByDom(prev).toOption();
              }).each(function (prev) {
                se.event().newFocus().bind(function (nu) {
                  return comp.getSystem().getByDom(nu).toOption();
                }).each(function (nu) {
                  if (Dropdown.isOpen(prev)) {
                    Dropdown.expand(nu);
                    Dropdown.close(prev);
                  }
                });
              });
            })
          ]),
          Keying.config({
            mode: &apos;flow&apos;,
            selector: &apos;.&apos; + &apos;tox-mbtn&apos;,
            onEscape: function (comp) {
              detail.onEscape(comp);
              return Option.some(true);
            }
          }),
          Tabstopping.config({})
        ]),
        apis: apis,
        domModification: { attributes: { role: &apos;menubar&apos; } }
      };
    };
    var SilverMenubar = single$2({
      factory: factory$g,
      name: &apos;silver.Menubar&apos;,
      configFields: [
        strict$1(&apos;dom&apos;),
        strict$1(&apos;uid&apos;),
        strict$1(&apos;onEscape&apos;),
        strict$1(&apos;backstage&apos;),
        defaulted$1(&apos;onSetup&apos;, noop)
      ],
      apis: {
        focus: function (apis, comp) {
          apis.focus(comp);
        },
        setMenus: function (apis, comp, menus) {
          apis.setMenus(comp, menus);
        }
      }
    });

    var owner$4 = &apos;container&apos;;
    var schema$s = [field$1(&apos;slotBehaviours&apos;, [])];
    var getPartName$1 = function (name) {
      return &apos;&lt;alloy.field.&apos; + name + &apos;&gt;&apos;;
    };
    var sketch$2 = function (sSpec) {
      var parts = function () {
        var record = [];
        var slot = function (name, config) {
          record.push(name);
          return generateOne(owner$4, getPartName$1(name), config);
        };
        return {
          slot: slot,
          record: function () {
            return record;
          }
        };
      }();
      var spec = sSpec(parts);
      var partNames = parts.record();
      var fieldParts = map(partNames, function (n) {
        return required({
          name: n,
          pname: getPartName$1(n)
        });
      });
      return composite(owner$4, schema$s, fieldParts, make$7, spec);
    };
    var make$7 = function (detail, components) {
      var getSlotNames = function (_) {
        return getAllPartNames(detail);
      };
      var getSlot = function (container, key) {
        return getPart(container, detail, key);
      };
      var onSlot = function (f, def) {
        return function (container, key) {
          return getPart(container, detail, key).map(function (slot) {
            return f(slot, key);
          }).getOr(def);
        };
      };
      var onSlots = function (f) {
        return function (container, keys) {
          each(keys, function (key) {
            return f(container, key);
          });
        };
      };
      var doShowing = function (comp, _key) {
        return get$2(comp.element(), &apos;aria-hidden&apos;) !== &apos;true&apos;;
      };
      var doShow = function (comp, key) {
        if (!doShowing(comp)) {
          var element = comp.element();
          remove$6(element, &apos;display&apos;);
          remove$1(element, &apos;aria-hidden&apos;);
          emitWith(comp, slotVisibility(), {
            name: key,
            visible: true
          });
        }
      };
      var doHide = function (comp, key) {
        if (doShowing(comp)) {
          var element = comp.element();
          set$2(element, &apos;display&apos;, &apos;none&apos;);
          set$1(element, &apos;aria-hidden&apos;, &apos;true&apos;);
          emitWith(comp, slotVisibility(), {
            name: key,
            visible: false
          });
        }
      };
      var isShowing = onSlot(doShowing, false);
      var hideSlot = onSlot(doHide);
      var hideSlots = onSlots(hideSlot);
      var hideAllSlots = function (container) {
        return hideSlots(container, getSlotNames());
      };
      var showSlot = onSlot(doShow);
      var apis = {
        getSlotNames: getSlotNames,
        getSlot: getSlot,
        isShowing: isShowing,
        hideSlot: hideSlot,
        hideAllSlots: hideAllSlots,
        showSlot: showSlot
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: get$c(detail.slotBehaviours),
        apis: apis
      };
    };
    var slotApis = map$1({
      getSlotNames: function (apis, c) {
        return apis.getSlotNames(c);
      },
      getSlot: function (apis, c, key) {
        return apis.getSlot(c, key);
      },
      isShowing: function (apis, c, key) {
        return apis.isShowing(c, key);
      },
      hideSlot: function (apis, c, key) {
        return apis.hideSlot(c, key);
      },
      hideAllSlots: function (apis, c) {
        return apis.hideAllSlots(c);
      },
      showSlot: function (apis, c, key) {
        return apis.showSlot(c, key);
      }
    }, function (value) {
      return makeApi(value);
    });
    var SlotContainer = __assign(__assign({}, slotApis), { sketch: sketch$2 });

    var sidebarSchema = objOf([
      optionString(&apos;icon&apos;),
      optionString(&apos;tooltip&apos;),
      defaultedFunction(&apos;onShow&apos;, noop),
      defaultedFunction(&apos;onHide&apos;, noop),
      defaultedFunction(&apos;onSetup&apos;, function () {
        return noop;
      })
    ]);
    var createSidebar = function (spec) {
      return asRaw(&apos;sidebar&apos;, sidebarSchema, spec);
    };

    var setup$6 = function (editor) {
      var sidebars = editor.ui.registry.getAll().sidebars;
      each(keys(sidebars), function (name) {
        var spec = sidebars[name];
        var isActive = function () {
          return Option.from(editor.queryCommandValue(&apos;ToggleSidebar&apos;)).is(name);
        };
        editor.ui.registry.addToggleButton(name, {
          icon: spec.icon,
          tooltip: spec.tooltip,
          onAction: function (buttonApi) {
            editor.execCommand(&apos;ToggleSidebar&apos;, false, name);
            buttonApi.setActive(isActive());
          },
          onSetup: function (buttonApi) {
            var handleToggle = function () {
              return buttonApi.setActive(isActive());
            };
            editor.on(&apos;ToggleSidebar&apos;, handleToggle);
            return function () {
              editor.off(&apos;ToggleSidebar&apos;, handleToggle);
            };
          }
        });
      });
    };
    var getApi = function (comp) {
      return {
        element: function () {
          return comp.element().dom();
        }
      };
    };
    var makePanels = function (parts, panelConfigs) {
      var specs = map(keys(panelConfigs), function (name) {
        var spec = panelConfigs[name];
        var bridged = getOrDie(createSidebar(spec));
        return {
          name: name,
          getApi: getApi,
          onSetup: bridged.onSetup,
          onShow: bridged.onShow,
          onHide: bridged.onHide
        };
      });
      return map(specs, function (spec) {
        var editorOffCell = Cell(noop);
        return parts.slot(spec.name, {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-sidebar__pane&apos;]
          },
          behaviours: SimpleBehaviours.unnamedEvents([
            onControlAttached(spec, editorOffCell),
            onControlDetached(spec, editorOffCell),
            run(slotVisibility(), function (sidepanel, se) {
              var data = se.event();
              var optSidePanelSpec = find(specs, function (config) {
                return config.name === data.name();
              });
              optSidePanelSpec.each(function (sidePanelSpec) {
                var handler = data.visible() ? sidePanelSpec.onShow : sidePanelSpec.onHide;
                handler(sidePanelSpec.getApi(sidepanel));
              });
            })
          ])
        });
      });
    };
    var makeSidebar = function (panelConfigs) {
      return SlotContainer.sketch(function (parts) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-sidebar__pane-container&apos;]
          },
          components: makePanels(parts, panelConfigs),
          slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached(function (slotContainer) {
              return SlotContainer.hideAllSlots(slotContainer);
            })])
        };
      });
    };
    var setSidebar = function (sidebar, panelConfigs) {
      var optSlider = Composing.getCurrent(sidebar);
      optSlider.each(function (slider) {
        return Replacing.set(slider, [makeSidebar(panelConfigs)]);
      });
    };
    var toggleSidebar = function (sidebar, name) {
      var optSlider = Composing.getCurrent(sidebar);
      optSlider.each(function (slider) {
        var optSlotContainer = Composing.getCurrent(slider);
        optSlotContainer.each(function (slotContainer) {
          if (Sliding.hasGrown(slider)) {
            if (SlotContainer.isShowing(slotContainer, name)) {
              Sliding.shrink(slider);
            } else {
              SlotContainer.hideAllSlots(slotContainer);
              SlotContainer.showSlot(slotContainer, name);
            }
          } else {
            SlotContainer.hideAllSlots(slotContainer);
            SlotContainer.showSlot(slotContainer, name);
            Sliding.grow(slider);
          }
        });
      });
    };
    var whichSidebar = function (sidebar) {
      var optSlider = Composing.getCurrent(sidebar);
      return optSlider.bind(function (slider) {
        var sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
        if (sidebarOpen) {
          var optSlotContainer = Composing.getCurrent(slider);
          return optSlotContainer.bind(function (slotContainer) {
            return find(SlotContainer.getSlotNames(slotContainer), function (name) {
              return SlotContainer.isShowing(slotContainer, name);
            });
          });
        } else {
          return Option.none();
        }
      });
    };
    var fixSize = generate$1(&apos;FixSizeEvent&apos;);
    var autoSize = generate$1(&apos;AutoSizeEvent&apos;);
    var renderSidebar = function (spec) {
      return {
        uid: spec.uid,
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-sidebar&apos;],
          attributes: { role: &apos;complementary&apos; }
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-sidebar__slider&apos;]
            },
            components: [],
            behaviours: derive$1([
              Tabstopping.config({}),
              Focusing.config({}),
              Sliding.config({
                dimension: { property: &apos;width&apos; },
                closedClass: &apos;tox-sidebar--sliding-closed&apos;,
                openClass: &apos;tox-sidebar--sliding-open&apos;,
                shrinkingClass: &apos;tox-sidebar--sliding-shrinking&apos;,
                growingClass: &apos;tox-sidebar--sliding-growing&apos;,
                onShrunk: function (slider) {
                  var optSlotContainer = Composing.getCurrent(slider);
                  optSlotContainer.each(SlotContainer.hideAllSlots);
                  emit(slider, autoSize);
                },
                onGrown: function (slider) {
                  emit(slider, autoSize);
                },
                onStartGrow: function (slider) {
                  emitWith(slider, fixSize, { width: getRaw(slider.element(), &apos;width&apos;).getOr(&apos;&apos;) });
                },
                onStartShrink: function (slider) {
                  emitWith(slider, fixSize, { width: get$7(slider.element()) + &apos;px&apos; });
                }
              }),
              Replacing.config({}),
              Composing.config({
                find: function (comp) {
                  var children = Replacing.contents(comp);
                  return head(children);
                }
              })
            ])
          }],
        behaviours: derive$1([
          ComposingConfigs.childAt(0),
          config(&apos;sidebar-sliding-events&apos;, [
            run(fixSize, function (comp, se) {
              set$2(comp.element(), &apos;width&apos;, se.event().width());
            }),
            run(autoSize, function (comp, _se) {
              remove$6(comp.element(), &apos;width&apos;);
            })
          ])
        ])
      };
    };

    var getAttrs = function (elem) {
      var attributes = elem.dom().attributes !== undefined ? elem.dom().attributes : [];
      return foldl(attributes, function (b, attr) {
        var _a;
        if (attr.name === &apos;class&apos;) {
          return b;
        } else {
          return __assign(__assign({}, b), (_a = {}, _a[attr.name] = attr.value, _a));
        }
      }, {});
    };
    var getClasses = function (elem) {
      return Array.prototype.slice.call(elem.dom().classList, 0);
    };
    var fromHtml$2 = function (html) {
      var elem = Element.fromHtml(html);
      var children$1 = children(elem);
      var attrs = getAttrs(elem);
      var classes = getClasses(elem);
      var contents = children$1.length === 0 ? {} : { innerHtml: get$1(elem) };
      return __assign({
        tag: name(elem),
        classes: classes,
        attributes: attrs
      }, contents);
    };

    var renderSpinner = function (providerBackstage) {
      return {
        dom: {
          tag: &apos;div&apos;,
          attributes: { &apos;aria-label&apos;: providerBackstage.translate(&apos;Loading...&apos;) },
          classes: [&apos;tox-throbber__busy-spinner&apos;]
        },
        components: [{ dom: fromHtml$2(&apos;&lt;div class=&quot;tox-spinner&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&apos;) }],
        behaviours: derive$1([
          Keying.config({
            mode: &apos;special&apos;,
            onTab: function () {
              return Option.some(true);
            },
            onShiftTab: function () {
              return Option.some(true);
            }
          }),
          Focusing.config({})
        ])
      };
    };
    var toggleThrobber = function (comp, state, providerBackstage) {
      var element = comp.element();
      if (state === true) {
        Replacing.set(comp, [renderSpinner(providerBackstage)]);
        remove$6(element, &apos;display&apos;);
        remove$1(element, &apos;aria-hidden&apos;);
      } else {
        Replacing.set(comp, []);
        set$2(element, &apos;display&apos;, &apos;none&apos;);
        set$1(element, &apos;aria-hidden&apos;, &apos;true&apos;);
      }
    };
    var renderThrobber = function (spec) {
      return {
        uid: spec.uid,
        dom: {
          tag: &apos;div&apos;,
          attributes: { &apos;aria-hidden&apos;: &apos;true&apos; },
          classes: [&apos;tox-throbber&apos;],
          styles: { display: &apos;none&apos; }
        },
        behaviours: derive$1([Replacing.config({})]),
        components: []
      };
    };
    var setup$7 = function (editor, lazyThrobber, sharedBackstage) {
      var throbberState = Cell(false);
      var timer = Cell(Option.none());
      var toggle = function (state) {
        if (state !== throbberState.get()) {
          toggleThrobber(lazyThrobber(), state, sharedBackstage.providers);
          throbberState.set(state);
        }
      };
      editor.on(&apos;ProgressState&apos;, function (e) {
        timer.get().each(global$2.clearTimeout);
        if (isNumber(e.time)) {
          var timerId = global$2.setEditorTimeout(editor, function () {
            return toggle(e.state);
          }, e.time);
          timer.set(Option.some(timerId));
        } else {
          toggle(e.state);
          timer.set(Option.none());
        }
      });
    };

    var factory$h = function (detail, components, _spec) {
      var apis = {
        getSocket: function (comp) {
          return parts$d.getPart(comp, detail, &apos;socket&apos;);
        },
        setSidebar: function (comp, panelConfigs) {
          parts$d.getPart(comp, detail, &apos;sidebar&apos;).each(function (sidebar) {
            return setSidebar(sidebar, panelConfigs);
          });
        },
        toggleSidebar: function (comp, name) {
          parts$d.getPart(comp, detail, &apos;sidebar&apos;).each(function (sidebar) {
            return toggleSidebar(sidebar, name);
          });
        },
        whichSidebar: function (comp) {
          return parts$d.getPart(comp, detail, &apos;sidebar&apos;).bind(whichSidebar).getOrNull();
        },
        getHeader: function (comp) {
          return parts$d.getPart(comp, detail, &apos;header&apos;);
        },
        getToolbar: function (comp) {
          return parts$d.getPart(comp, detail, &apos;toolbar&apos;);
        },
        setToolbar: function (comp, groups) {
          parts$d.getPart(comp, detail, &apos;toolbar&apos;).each(function (toolbar) {
            toolbar.getApis().setGroups(toolbar, groups);
          });
        },
        setToolbars: function (comp, toolbars) {
          parts$d.getPart(comp, detail, &apos;multiple-toolbar&apos;).each(function (mToolbar) {
            CustomList.setItems(mToolbar, toolbars);
          });
        },
        refreshToolbar: function (comp) {
          var toolbar = parts$d.getPart(comp, detail, &apos;toolbar&apos;);
          toolbar.each(function (toolbar) {
            return toolbar.getApis().refresh(toolbar);
          });
        },
        getThrobber: function (comp) {
          return parts$d.getPart(comp, detail, &apos;throbber&apos;);
        },
        focusToolbar: function (comp) {
          var optToolbar = parts$d.getPart(comp, detail, &apos;toolbar&apos;).orThunk(function () {
            return parts$d.getPart(comp, detail, &apos;multiple-toolbar&apos;);
          });
          optToolbar.each(function (toolbar) {
            Keying.focusIn(toolbar);
          });
        },
        setMenubar: function (comp, menus) {
          parts$d.getPart(comp, detail, &apos;menubar&apos;).each(function (menubar) {
            SilverMenubar.setMenus(menubar, menus);
          });
        },
        focusMenubar: function (comp) {
          parts$d.getPart(comp, detail, &apos;menubar&apos;).each(function (menubar) {
            SilverMenubar.focus(menubar);
          });
        }
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: apis,
        behaviours: detail.behaviours
      };
    };
    var partMenubar = partType$1.optional({
      factory: SilverMenubar,
      name: &apos;menubar&apos;,
      schema: [strict$1(&apos;backstage&apos;)]
    });
    var toolbarFactory = function (spec) {
      if (spec.type === ToolbarMode.sliding) {
        return renderSlidingMoreToolbar;
      } else if (spec.type === ToolbarMode.floating) {
        return renderFloatingMoreToolbar;
      } else {
        return renderToolbar;
      }
    };
    var partMultipleToolbar = partType$1.optional({
      factory: {
        sketch: function (spec) {
          return CustomList.sketch({
            uid: spec.uid,
            dom: spec.dom,
            listBehaviours: derive$1([Keying.config({
                mode: &apos;acyclic&apos;,
                selector: &apos;.tox-toolbar&apos;
              })]),
            makeItem: function () {
              return renderToolbar({
                type: spec.type,
                uid: generate$1(&apos;multiple-toolbar-item&apos;),
                cyclicKeying: false,
                initGroups: [],
                providers: spec.providers,
                onEscape: function () {
                  return Option.none();
                }
              });
            },
            setupItem: function (_mToolbar, tc, data, _index) {
              Toolbar.setGroups(tc, data);
            },
            shell: true
          });
        }
      },
      name: &apos;multiple-toolbar&apos;,
      schema: [
        strict$1(&apos;dom&apos;),
        strict$1(&apos;onEscape&apos;)
      ]
    });
    var partToolbar = partType$1.optional({
      factory: {
        sketch: function (spec) {
          var renderer = toolbarFactory(spec);
          var toolbarSpec = {
            type: spec.type,
            uid: spec.uid,
            onEscape: function () {
              spec.onEscape();
              return Option.some(true);
            },
            cyclicKeying: false,
            initGroups: [],
            getSink: spec.getSink,
            providers: spec.providers,
            moreDrawerData: {
              lazyToolbar: spec.lazyToolbar,
              lazyMoreButton: spec.lazyMoreButton,
              lazyHeader: spec.lazyHeader
            },
            attributes: spec.attributes
          };
          return renderer(toolbarSpec);
        }
      },
      name: &apos;toolbar&apos;,
      schema: [
        strict$1(&apos;dom&apos;),
        strict$1(&apos;onEscape&apos;),
        strict$1(&apos;getSink&apos;)
      ]
    });
    var partHeader = partType$1.optional({
      factory: { sketch: renderHeader },
      name: &apos;header&apos;,
      schema: [strict$1(&apos;dom&apos;)]
    });
    var partSocket = partType$1.optional({
      name: &apos;socket&apos;,
      schema: [strict$1(&apos;dom&apos;)]
    });
    var partSidebar = partType$1.optional({
      factory: { sketch: renderSidebar },
      name: &apos;sidebar&apos;,
      schema: [strict$1(&apos;dom&apos;)]
    });
    var partThrobber = partType$1.optional({
      factory: { sketch: renderThrobber },
      name: &apos;throbber&apos;,
      schema: [strict$1(&apos;dom&apos;)]
    });
    var OuterContainer = composite$1({
      name: &apos;OuterContainer&apos;,
      factory: factory$h,
      configFields: [
        strict$1(&apos;dom&apos;),
        strict$1(&apos;behaviours&apos;)
      ],
      partFields: [
        partHeader,
        partMenubar,
        partToolbar,
        partMultipleToolbar,
        partSocket,
        partSidebar,
        partThrobber
      ],
      apis: {
        getSocket: function (apis, comp) {
          return apis.getSocket(comp);
        },
        setSidebar: function (apis, comp, panelConfigs) {
          apis.setSidebar(comp, panelConfigs);
        },
        toggleSidebar: function (apis, comp, name) {
          apis.toggleSidebar(comp, name);
        },
        whichSidebar: function (apis, comp) {
          return apis.whichSidebar(comp);
        },
        getHeader: function (apis, comp) {
          return apis.getHeader(comp);
        },
        getToolbar: function (apis, comp) {
          return apis.getToolbar(comp);
        },
        setToolbar: function (apis, comp, grps) {
          var groups = map(grps, function (grp) {
            return renderToolbarGroup(grp);
          });
          apis.setToolbar(comp, groups);
        },
        setToolbars: function (apis, comp, ts) {
          var renderedToolbars = map(ts, function (g) {
            return map(g, renderToolbarGroup);
          });
          apis.setToolbars(comp, renderedToolbars);
        },
        refreshToolbar: function (apis, comp) {
          return apis.refreshToolbar(comp);
        },
        getThrobber: function (apis, comp) {
          return apis.getThrobber(comp);
        },
        setMenubar: function (apis, comp, menus) {
          apis.setMenubar(comp, menus);
        },
        focusMenubar: function (apis, comp) {
          apis.focusMenubar(comp);
        },
        focusToolbar: function (apis, comp) {
          apis.focusToolbar(comp);
        }
      }
    });

    var defaultMenubar = &apos;file edit view insert format tools table help&apos;;
    var defaultMenus = {
      file: {
        title: &apos;File&apos;,
        items: &apos;newdocument restoredraft | preview | print | deleteallconversations&apos;
      },
      edit: {
        title: &apos;Edit&apos;,
        items: &apos;undo redo | cut copy paste pastetext | selectall | searchreplace&apos;
      },
      view: {
        title: &apos;View&apos;,
        items: &apos;code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments&apos;
      },
      insert: {
        title: &apos;Insert&apos;,
        items: &apos;image link media addcomment pageembed template codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor toc | insertdatetime&apos;
      },
      format: {
        title: &apos;Format&apos;,
        items: &apos;bold italic underline strikethrough superscript subscript codeformat | formats blockformats fontformats fontsizes align | forecolor backcolor | removeformat&apos;
      },
      tools: {
        title: &apos;Tools&apos;,
        items: &apos;spellchecker spellcheckerlanguage | a11ycheck code wordcount&apos;
      },
      table: {
        title: &apos;Table&apos;,
        items: &apos;inserttable | cell row column | advtablesort | tableprops deletetable&apos;
      },
      help: {
        title: &apos;Help&apos;,
        items: &apos;help&apos;
      }
    };
    var make$8 = function (menu, registry, editor) {
      var removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
      return {
        text: menu.title,
        getItems: function () {
          return bind(menu.items, function (i) {
            var itemName = i.toLowerCase();
            if (itemName.trim().length === 0) {
              return [];
            } else if (exists(removedMenuItems, function (removedMenuItem) {
                return removedMenuItem === itemName;
              })) {
              return [];
            } else if (itemName === &apos;separator&apos; || itemName === &apos;|&apos;) {
              return [{ type: &apos;separator&apos; }];
            } else if (registry.menuItems[itemName]) {
              return [registry.menuItems[itemName]];
            } else {
              return [];
            }
          });
        }
      };
    };
    var parseItemsString = function (items) {
      if (typeof items === &apos;string&apos;) {
        return items.split(&apos; &apos;);
      }
      return items;
    };
    var identifyMenus = function (editor, registry) {
      var rawMenuData = __assign(__assign({}, defaultMenus), registry.menus);
      var userDefinedMenus = keys(registry.menus).length &gt; 0;
      var menubar = registry.menubar === undefined || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? &apos;&apos; : registry.menubar);
      var validMenus = filter(menubar, function (menuName) {
        return userDefinedMenus ? registry.menus.hasOwnProperty(menuName) &amp;&amp; registry.menus[menuName].hasOwnProperty(&apos;items&apos;) || defaultMenus.hasOwnProperty(menuName) : defaultMenus.hasOwnProperty(menuName);
      });
      var menus = map(validMenus, function (menuName) {
        var menuData = rawMenuData[menuName];
        return make$8({
          title: menuData.title,
          items: parseItemsString(menuData.items)
        }, registry, editor);
      });
      return filter(menus, function (menu) {
        var isNotSeparator = function (item) {
          return item.type !== &apos;separator&apos;;
        };
        return menu.getItems().length &gt; 0 &amp;&amp; exists(menu.getItems(), isNotSeparator);
      });
    };

    var fireSkinLoaded$1 = function (editor) {
      var done = function () {
        editor._skinLoaded = true;
        fireSkinLoaded(editor);
      };
      return function () {
        if (editor.initialized) {
          done();
        } else {
          editor.on(&apos;init&apos;, done);
        }
      };
    };
    var fireSkinLoadError$1 = function (editor, err) {
      return function () {
        return fireSkinLoadError(editor, { message: err });
      };
    };

    var loadSkin = function (isInline, editor) {
      var skinUrl = getSkinUrl(editor);
      var skinUiCss;
      if (skinUrl) {
        skinUiCss = skinUrl + &apos;/skin.min.css&apos;;
        editor.contentCSS.push(skinUrl + (isInline ? &apos;/content.inline&apos; : &apos;/content&apos;) + &apos;.min.css&apos;);
      }
      if (isSkinDisabled(editor) === false &amp;&amp; skinUiCss) {
        global$7.DOM.styleSheetLoader.load(skinUiCss, fireSkinLoaded$1(editor), fireSkinLoadError$1(editor, &apos;Skin could not be loaded&apos;));
      } else {
        fireSkinLoaded$1(editor)();
      }
    };
    var iframe = curry(loadSkin, false);
    var inline = curry(loadSkin, true);

    var setToolbar = function (editor, uiComponents, rawUiConfig, backstage) {
      var comp = uiComponents.outerContainer;
      var toolbarConfig = rawUiConfig.toolbar;
      var toolbarButtonsConfig = rawUiConfig.buttons;
      if (isArrayOf(toolbarConfig, isString)) {
        var toolbars = toolbarConfig.map(function (t) {
          var config = {
            toolbar: t,
            buttons: toolbarButtonsConfig,
            allowToolbarGroups: rawUiConfig.allowToolbarGroups
          };
          return identifyButtons(editor, config, { backstage: backstage }, Option.none());
        });
        OuterContainer.setToolbars(comp, toolbars);
      } else {
        OuterContainer.setToolbar(comp, identifyButtons(editor, rawUiConfig, { backstage: backstage }, Option.none()));
      }
    };

    var DOM = global$7.DOM;
    var detection = detect$3();
    var isiOS12 = detection.os.isiOS() &amp;&amp; detection.os.version.major &lt;= 12;
    var setupEvents = function (editor) {
      var contentWindow = editor.getWin();
      var initialDocEle = editor.getDoc().documentElement;
      var lastWindowDimensions = Cell(Position(contentWindow.innerWidth, contentWindow.innerHeight));
      var lastDocumentDimensions = Cell(Position(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
      var resizeWindow = function (e) {
        var outer = lastWindowDimensions.get();
        if (outer.left() !== contentWindow.innerWidth || outer.top() !== contentWindow.innerHeight) {
          lastWindowDimensions.set(Position(contentWindow.innerWidth, contentWindow.innerHeight));
          fireResizeContent(editor, e);
        }
      };
      var resizeDocument = function (e) {
        var docEle = editor.getDoc().documentElement;
        var inner = lastDocumentDimensions.get();
        if (inner.left() !== docEle.offsetWidth || inner.top() !== docEle.offsetHeight) {
          lastDocumentDimensions.set(Position(docEle.offsetWidth, docEle.offsetHeight));
          fireResizeContent(editor, e);
        }
      };
      var scroll = function (e) {
        return fireScrollContent(editor, e);
      };
      DOM.bind(contentWindow, &apos;resize&apos;, resizeWindow);
      DOM.bind(contentWindow, &apos;scroll&apos;, scroll);
      var elementLoad = capture$1(Element.fromDom(editor.getBody()), &apos;load&apos;, resizeDocument);
      editor.on(&apos;NodeChange&apos;, resizeDocument);
      editor.on(&apos;remove&apos;, function () {
        elementLoad.unbind();
        DOM.unbind(contentWindow, &apos;resize&apos;, resizeWindow);
        DOM.unbind(contentWindow, &apos;scroll&apos;, scroll);
      });
    };
    var render = function (editor, uiComponents, rawUiConfig, backstage, args) {
      var lastToolbarWidth = Cell(0);
      iframe(editor);
      attachSystemAfter(Element.fromDom(args.targetNode), uiComponents.mothership);
      attachSystem(body(), uiComponents.uiMothership);
      editor.on(&apos;PostRender&apos;, function () {
        setToolbar(editor, uiComponents, rawUiConfig, backstage);
        lastToolbarWidth.set(editor.getWin().innerWidth);
        OuterContainer.setMenubar(uiComponents.outerContainer, identifyMenus(editor, rawUiConfig));
        OuterContainer.setSidebar(uiComponents.outerContainer, rawUiConfig.sidebar);
        setupEvents(editor);
      });
      var socket = OuterContainer.getSocket(uiComponents.outerContainer).getOrDie(&apos;Could not find expected socket element&apos;);
      if (isiOS12 === true) {
        setAll$1(socket.element(), {
          &apos;overflow&apos;: &apos;scroll&apos;,
          &apos;-webkit-overflow-scrolling&apos;: &apos;touch&apos;
        });
        var limit = first(function () {
          editor.fire(&apos;ScrollContent&apos;);
        }, 20);
        bind$3(socket.element(), &apos;scroll&apos;, limit.throttle);
      }
      setupReadonlyModeSwitch(editor, uiComponents);
      editor.addCommand(&apos;ToggleSidebar&apos;, function (ui, value) {
        OuterContainer.toggleSidebar(uiComponents.outerContainer, value);
        editor.fire(&apos;ToggleSidebar&apos;);
      });
      editor.addQueryValueHandler(&apos;ToggleSidebar&apos;, function () {
        return OuterContainer.whichSidebar(uiComponents.outerContainer);
      });
      var toolbarMode = getToolbarMode(editor);
      var refreshDrawer = function () {
        OuterContainer.refreshToolbar(uiComponents.outerContainer);
      };
      if (toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating) {
        editor.on(&apos;ResizeWindow ResizeEditor ResizeContent&apos;, function () {
          var width = editor.getWin().innerWidth;
          if (width !== lastToolbarWidth.get()) {
            refreshDrawer();
            lastToolbarWidth.set(width);
          }
        });
      }
      return {
        iframeContainer: socket.element().dom(),
        editorContainer: uiComponents.outerContainer.element().dom()
      };
    };

    var Iframe = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render
    });

    var revocable = function (doRevoke) {
      var subject = Cell(Option.none());
      var revoke = function () {
        subject.get().each(doRevoke);
      };
      var clear = function () {
        revoke();
        subject.set(Option.none());
      };
      var set = function (s) {
        revoke();
        subject.set(Option.some(s));
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      return {
        clear: clear,
        isSet: isSet,
        set: set
      };
    };
    var unbindable = function () {
      return revocable(function (s) {
        s.unbind();
      });
    };
    var value$3 = function () {
      var subject = Cell(Option.none());
      var clear = function () {
        subject.set(Option.none());
      };
      var set = function (s) {
        subject.set(Option.some(s));
      };
      var on = function (f) {
        subject.get().each(f);
      };
      var isSet = function () {
        return subject.get().isSome();
      };
      return {
        clear: clear,
        set: set,
        isSet: isSet,
        on: on
      };
    };

    var parseToInt = function (val) {
      var re = /^[0-9\.]+(|px)$/i;
      if (re.test(&apos;&apos; + val)) {
        return Option.some(parseInt(&apos;&apos; + val, 10));
      }
      return Option.none();
    };
    var numToPx = function (val) {
      return isNumber(val) ? val + &apos;px&apos; : val;
    };
    var calcCappedSize = function (size, minSize, maxSize) {
      var minOverride = minSize.filter(function (min) {
        return size &lt; min;
      });
      var maxOverride = maxSize.filter(function (max) {
        return size &gt; max;
      });
      return minOverride.or(maxOverride).getOr(size);
    };

    var getHeight$1 = function (editor) {
      var baseHeight = getHeightSetting(editor);
      var minHeight = getMinHeightSetting(editor);
      var maxHeight = getMaxHeightSetting(editor);
      return parseToInt(baseHeight).map(function (height) {
        return calcCappedSize(height, minHeight, maxHeight);
      });
    };
    var getHeightWithFallback = function (editor) {
      var height = getHeight$1(editor);
      return height.getOr(getHeightSetting(editor));
    };
    var getWidth$1 = function (editor) {
      var baseWidth = getWidthSetting(editor);
      var minWidth = getMinWidthSetting(editor);
      var maxWidth = getMaxWidthSetting(editor);
      return parseToInt(baseWidth).map(function (width) {
        return calcCappedSize(width, minWidth, maxWidth);
      });
    };
    var getWidthWithFallback = function (editor) {
      var width = getWidth$1(editor);
      return width.getOr(getWidthSetting(editor));
    };

    var InlineHeader = function (editor, targetElm, uiComponents, backstage, floatContainer) {
      var uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;
      var DOM = global$7.DOM;
      var useFixedToolbarContainer = useFixedContainer(editor);
      var isSticky = isStickyToolbar(editor);
      var editorMaxWidthOpt = getMaxWidthSetting(editor).or(getWidth$1(editor));
      var headerBackstage = backstage.shared.header;
      var isPositionedAtTop = headerBackstage.isPositionedAtTop;
      var toolbarMode = getToolbarMode(editor);
      var isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;
      var visible = Cell(false);
      var isVisible = function () {
        return visible.get() &amp;&amp; !editor.removed;
      };
      var calcToolbarOffset = function (toolbar) {
        return isSplitToolbar ? toolbar.fold(function () {
          return 0;
        }, function (tbar) {
          return tbar.components().length &gt; 1 ? get$6(tbar.components()[1].element()) : 0;
        }) : 0;
      };
      var calcMode = function (container) {
        switch (getToolbarLocation(editor)) {
        case ToolbarLocation.auto:
          var toolbar_1 = OuterContainer.getToolbar(outerContainer);
          var offset = calcToolbarOffset(toolbar_1);
          var toolbarHeight = get$6(container.element()) - offset;
          var targetBounds = box(targetElm);
          var roomAtTop = targetBounds.y &gt; toolbarHeight;
          if (roomAtTop) {
            return &apos;top&apos;;
          } else {
            var doc = documentElement(targetElm);
            var docHeight = Math.max(doc.dom().scrollHeight, get$6(doc));
            var roomAtBottom = targetBounds.bottom &lt; docHeight - toolbarHeight;
            if (roomAtBottom) {
              return &apos;bottom&apos;;
            } else {
              var winBounds = win();
              var isRoomAtBottomViewport = winBounds.bottom &lt; targetBounds.bottom - toolbarHeight;
              return isRoomAtBottomViewport ? &apos;bottom&apos; : &apos;top&apos;;
            }
          }
        case ToolbarLocation.bottom:
          return &apos;bottom&apos;;
        case ToolbarLocation.top:
        default:
          return &apos;top&apos;;
        }
      };
      var setupMode = function (mode) {
        var container = floatContainer.get();
        Docking.setModes(container, [mode]);
        headerBackstage.setDockingMode(mode);
        var verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;
        set$1(container.element(), Attribute, verticalDir);
      };
      var updateChromeWidth = function () {
        var maxWidth = editorMaxWidthOpt.getOrThunk(function () {
          var bodyMargin = parseToInt(get$4(body(), &apos;margin-left&apos;)).getOr(0);
          return get$7(body()) - absolute(targetElm).left() + bodyMargin;
        });
        set$2(floatContainer.get().element(), &apos;max-width&apos;, maxWidth + &apos;px&apos;);
      };
      var updateChromePosition = function () {
        var toolbar = OuterContainer.getToolbar(outerContainer);
        var offset = calcToolbarOffset(toolbar);
        var targetBounds = box(targetElm);
        var top = isPositionedAtTop() ? Math.max(targetBounds.y - get$6(floatContainer.get().element()) + offset, 0) : targetBounds.bottom;
        setAll$1(outerContainer.element(), {
          position: &apos;absolute&apos;,
          top: Math.round(top) + &apos;px&apos;,
          left: Math.round(targetBounds.x) + &apos;px&apos;
        });
      };
      var repositionPopups$1 = function () {
        uiMothership.broadcastOn([repositionPopups()], {});
      };
      var updateChromeUi = function (resetDocking) {
        if (resetDocking === void 0) {
          resetDocking = false;
        }
        if (!isVisible()) {
          return;
        }
        if (!useFixedToolbarContainer) {
          updateChromeWidth();
        }
        if (isSplitToolbar) {
          OuterContainer.refreshToolbar(outerContainer);
        }
        if (!useFixedToolbarContainer) {
          updateChromePosition();
        }
        if (isSticky) {
          var floatContainerComp = floatContainer.get();
          resetDocking ? Docking.reset(floatContainerComp) : Docking.refresh(floatContainerComp);
        }
        repositionPopups$1();
      };
      var updateMode = function (updateUi) {
        if (updateUi === void 0) {
          updateUi = true;
        }
        if (useFixedToolbarContainer || !isSticky || !isVisible()) {
          return;
        }
        var currentMode = headerBackstage.getDockingMode();
        var newMode = calcMode(floatContainer.get());
        if (newMode !== currentMode) {
          setupMode(newMode);
          if (updateUi) {
            updateChromeUi(true);
          }
        }
      };
      var show = function () {
        visible.set(true);
        set$2(outerContainer.element(), &apos;display&apos;, &apos;flex&apos;);
        DOM.addClass(editor.getBody(), &apos;mce-edit-focus&apos;);
        remove$6(uiMothership.element(), &apos;display&apos;);
        updateMode(false);
        updateChromeUi();
      };
      var hide = function () {
        visible.set(false);
        if (uiComponents.outerContainer) {
          set$2(outerContainer.element(), &apos;display&apos;, &apos;none&apos;);
          DOM.removeClass(editor.getBody(), &apos;mce-edit-focus&apos;);
        }
        set$2(uiMothership.element(), &apos;display&apos;, &apos;none&apos;);
      };
      return {
        isVisible: isVisible,
        isPositionedAtTop: isPositionedAtTop,
        show: show,
        hide: hide,
        update: updateChromeUi,
        updateMode: updateMode,
        repositionPopups: repositionPopups$1
      };
    };

    var getTargetPosAndBounds = function (targetElm, isToolbarTop) {
      var bounds = box(targetElm);
      return {
        pos: isToolbarTop ? bounds.y : bounds.bottom,
        bounds: bounds
      };
    };
    var setupEvents$1 = function (editor, targetElm, ui) {
      var prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
      var resizeContent = function (e) {
        var _a = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()), pos = _a.pos, bounds = _a.bounds;
        var _b = prevPosAndBounds.get(), prevPos = _b.pos, prevBounds = _b.bounds;
        var hasResized = bounds.height !== prevBounds.height || bounds.width !== prevBounds.width;
        prevPosAndBounds.set({
          pos: pos,
          bounds: bounds
        });
        if (hasResized) {
          fireResizeContent(editor, e);
        }
        if (ui.isVisible()) {
          if (prevPos !== pos) {
            ui.update(true);
          } else if (hasResized) {
            ui.updateMode();
            ui.repositionPopups();
          }
        }
      };
      editor.on(&apos;activate&apos;, ui.show);
      editor.on(&apos;deactivate&apos;, ui.hide);
      editor.on(&apos;SkinLoaded ResizeWindow&apos;, function () {
        return ui.update(true);
      });
      editor.on(&apos;NodeChange keydown&apos;, function (e) {
        global$2.requestAnimationFrame(function () {
          return resizeContent(e);
        });
      });
      editor.on(&apos;ScrollWindow&apos;, function () {
        return ui.updateMode();
      });
      var elementLoad = unbindable();
      elementLoad.set(capture$1(Element.fromDom(editor.getBody()), &apos;load&apos;, resizeContent));
      editor.on(&apos;remove&apos;, function () {
        elementLoad.clear();
      });
    };
    var render$1 = function (editor, uiComponents, rawUiConfig, backstage, args) {
      var mothership = uiComponents.mothership, uiMothership = uiComponents.uiMothership, outerContainer = uiComponents.outerContainer;
      var floatContainer = Cell(null);
      var targetElm = Element.fromDom(args.targetNode);
      var ui = InlineHeader(editor, targetElm, uiComponents, backstage, floatContainer);
      inline(editor);
      var render = function () {
        if (floatContainer.get()) {
          ui.show();
          return;
        }
        floatContainer.set(OuterContainer.getHeader(outerContainer).getOrDie());
        var uiContainer = getUiContainer(editor);
        attachSystem(uiContainer, mothership);
        attachSystem(uiContainer, uiMothership);
        setToolbar(editor, uiComponents, rawUiConfig, backstage);
        OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
        ui.show();
        setupEvents$1(editor, targetElm, ui);
        editor.nodeChanged();
      };
      editor.on(&apos;focus&apos;, render);
      editor.on(&apos;blur hide&apos;, ui.hide);
      editor.on(&apos;init&apos;, function () {
        if (editor.hasFocus()) {
          render();
        }
      });
      setupReadonlyModeSwitch(editor, uiComponents);
      return { editorContainer: outerContainer.element().dom() };
    };

    var Inline = /*#__PURE__*/Object.freeze({
        __proto__: null,
        render: render$1
    });

    var register$5 = function (editor) {
      var alignToolbarButtons = [
        {
          name: &apos;alignleft&apos;,
          text: &apos;Align left&apos;,
          cmd: &apos;JustifyLeft&apos;,
          icon: &apos;align-left&apos;
        },
        {
          name: &apos;aligncenter&apos;,
          text: &apos;Align center&apos;,
          cmd: &apos;JustifyCenter&apos;,
          icon: &apos;align-center&apos;
        },
        {
          name: &apos;alignright&apos;,
          text: &apos;Align right&apos;,
          cmd: &apos;JustifyRight&apos;,
          icon: &apos;align-right&apos;
        },
        {
          name: &apos;alignjustify&apos;,
          text: &apos;Justify&apos;,
          cmd: &apos;JustifyFull&apos;,
          icon: &apos;align-justify&apos;
        }
      ];
      global$e.each(alignToolbarButtons, function (item) {
        editor.ui.registry.addToggleButton(item.name, {
          tooltip: item.text,
          onAction: function () {
            return editor.execCommand(item.cmd);
          },
          icon: item.icon,
          onSetup: onSetupFormatToggle(editor, item.name)
        });
      });
      var alignNoneToolbarButton = {
        name: &apos;alignnone&apos;,
        text: &apos;No alignment&apos;,
        cmd: &apos;JustifyNone&apos;,
        icon: &apos;align-none&apos;
      };
      editor.ui.registry.addButton(alignNoneToolbarButton.name, {
        tooltip: alignNoneToolbarButton.text,
        onAction: function () {
          return editor.execCommand(alignNoneToolbarButton.cmd);
        },
        icon: alignNoneToolbarButton.icon
      });
    };

    var toggleFormat = function (editor, fmt) {
      return function () {
        editor.execCommand(&apos;mceToggleFormat&apos;, false, fmt);
      };
    };
    var registerFormatButtons = function (editor) {
      global$e.each([
        {
          name: &apos;bold&apos;,
          text: &apos;Bold&apos;,
          icon: &apos;bold&apos;
        },
        {
          name: &apos;italic&apos;,
          text: &apos;Italic&apos;,
          icon: &apos;italic&apos;
        },
        {
          name: &apos;underline&apos;,
          text: &apos;Underline&apos;,
          icon: &apos;underline&apos;
        },
        {
          name: &apos;strikethrough&apos;,
          text: &apos;Strikethrough&apos;,
          icon: &apos;strike-through&apos;
        },
        {
          name: &apos;subscript&apos;,
          text: &apos;Subscript&apos;,
          icon: &apos;subscript&apos;
        },
        {
          name: &apos;superscript&apos;,
          text: &apos;Superscript&apos;,
          icon: &apos;superscript&apos;
        }
      ], function (btn, _idx) {
        editor.ui.registry.addToggleButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onSetup: onSetupFormatToggle(editor, btn.name),
          onAction: toggleFormat(editor, btn.name)
        });
      });
      for (var i = 1; i &lt;= 6; i++) {
        var name_1 = &apos;h&apos; + i;
        editor.ui.registry.addToggleButton(name_1, {
          text: name_1.toUpperCase(),
          tooltip: &apos;Heading &apos; + i,
          onSetup: onSetupFormatToggle(editor, name_1),
          onAction: toggleFormat(editor, name_1)
        });
      }
    };
    var registerCommandButtons = function (editor) {
      global$e.each([
        {
          name: &apos;cut&apos;,
          text: &apos;Cut&apos;,
          action: &apos;Cut&apos;,
          icon: &apos;cut&apos;
        },
        {
          name: &apos;copy&apos;,
          text: &apos;Copy&apos;,
          action: &apos;Copy&apos;,
          icon: &apos;copy&apos;
        },
        {
          name: &apos;paste&apos;,
          text: &apos;Paste&apos;,
          action: &apos;Paste&apos;,
          icon: &apos;paste&apos;
        },
        {
          name: &apos;help&apos;,
          text: &apos;Help&apos;,
          action: &apos;mceHelp&apos;,
          icon: &apos;help&apos;
        },
        {
          name: &apos;selectall&apos;,
          text: &apos;Select all&apos;,
          action: &apos;SelectAll&apos;,
          icon: &apos;select-all&apos;
        },
        {
          name: &apos;newdocument&apos;,
          text: &apos;New document&apos;,
          action: &apos;mceNewDocument&apos;,
          icon: &apos;new-document&apos;
        },
        {
          name: &apos;removeformat&apos;,
          text: &apos;Clear formatting&apos;,
          action: &apos;RemoveFormat&apos;,
          icon: &apos;remove-formatting&apos;
        },
        {
          name: &apos;remove&apos;,
          text: &apos;Remove&apos;,
          action: &apos;Delete&apos;,
          icon: &apos;remove&apos;
        }
      ], function (btn) {
        editor.ui.registry.addButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onAction: function () {
            return editor.execCommand(btn.action);
          }
        });
      });
    };
    var registerCommandToggleButtons = function (editor) {
      global$e.each([{
          name: &apos;blockquote&apos;,
          text: &apos;Blockquote&apos;,
          action: &apos;mceBlockQuote&apos;,
          icon: &apos;quote&apos;
        }], function (btn) {
        editor.ui.registry.addToggleButton(btn.name, {
          tooltip: btn.text,
          icon: btn.icon,
          onAction: function () {
            return editor.execCommand(btn.action);
          },
          onSetup: onSetupFormatToggle(editor, btn.name)
        });
      });
    };
    var registerButtons = function (editor) {
      registerFormatButtons(editor);
      registerCommandButtons(editor);
      registerCommandToggleButtons(editor);
    };
    var registerMenuItems = function (editor) {
      global$e.each([
        {
          name: &apos;bold&apos;,
          text: &apos;Bold&apos;,
          action: &apos;Bold&apos;,
          icon: &apos;bold&apos;,
          shortcut: &apos;Meta+B&apos;
        },
        {
          name: &apos;italic&apos;,
          text: &apos;Italic&apos;,
          action: &apos;Italic&apos;,
          icon: &apos;italic&apos;,
          shortcut: &apos;Meta+I&apos;
        },
        {
          name: &apos;underline&apos;,
          text: &apos;Underline&apos;,
          action: &apos;Underline&apos;,
          icon: &apos;underline&apos;,
          shortcut: &apos;Meta+U&apos;
        },
        {
          name: &apos;strikethrough&apos;,
          text: &apos;Strikethrough&apos;,
          action: &apos;Strikethrough&apos;,
          icon: &apos;strike-through&apos;,
          shortcut: &apos;&apos;
        },
        {
          name: &apos;subscript&apos;,
          text: &apos;Subscript&apos;,
          action: &apos;Subscript&apos;,
          icon: &apos;subscript&apos;,
          shortcut: &apos;&apos;
        },
        {
          name: &apos;superscript&apos;,
          text: &apos;Superscript&apos;,
          action: &apos;Superscript&apos;,
          icon: &apos;superscript&apos;,
          shortcut: &apos;&apos;
        },
        {
          name: &apos;removeformat&apos;,
          text: &apos;Clear formatting&apos;,
          action: &apos;RemoveFormat&apos;,
          icon: &apos;remove-formatting&apos;,
          shortcut: &apos;&apos;
        },
        {
          name: &apos;newdocument&apos;,
          text: &apos;New document&apos;,
          action: &apos;mceNewDocument&apos;,
          icon: &apos;new-document&apos;,
          shortcut: &apos;&apos;
        },
        {
          name: &apos;cut&apos;,
          text: &apos;Cut&apos;,
          action: &apos;Cut&apos;,
          icon: &apos;cut&apos;,
          shortcut: &apos;Meta+X&apos;
        },
        {
          name: &apos;copy&apos;,
          text: &apos;Copy&apos;,
          action: &apos;Copy&apos;,
          icon: &apos;copy&apos;,
          shortcut: &apos;Meta+C&apos;
        },
        {
          name: &apos;paste&apos;,
          text: &apos;Paste&apos;,
          action: &apos;Paste&apos;,
          icon: &apos;paste&apos;,
          shortcut: &apos;Meta+V&apos;
        },
        {
          name: &apos;selectall&apos;,
          text: &apos;Select all&apos;,
          action: &apos;SelectAll&apos;,
          icon: &apos;select-all&apos;,
          shortcut: &apos;Meta+A&apos;
        }
      ], function (btn) {
        editor.ui.registry.addMenuItem(btn.name, {
          text: btn.text,
          icon: btn.icon,
          shortcut: btn.shortcut,
          onAction: function () {
            return editor.execCommand(btn.action);
          }
        });
      });
      editor.ui.registry.addMenuItem(&apos;codeformat&apos;, {
        text: &apos;Code&apos;,
        icon: &apos;sourcecode&apos;,
        onAction: toggleFormat(editor, &apos;code&apos;)
      });
    };
    var register$6 = function (editor) {
      registerButtons(editor);
      registerMenuItems(editor);
    };

    var toggleUndoRedoState = function (api, editor, type) {
      var checkState = function () {
        return editor.undoManager ? editor.undoManager[type]() : false;
      };
      var onUndoStateChange = function () {
        api.setDisabled(editor.mode.isReadOnly() || !checkState());
      };
      api.setDisabled(!checkState());
      editor.on(&apos;Undo Redo AddUndo TypingUndo ClearUndos SwitchMode&apos;, onUndoStateChange);
      return function () {
        return editor.off(&apos;Undo Redo AddUndo TypingUndo ClearUndos SwitchMode&apos;, onUndoStateChange);
      };
    };
    var registerMenuItems$1 = function (editor) {
      editor.ui.registry.addMenuItem(&apos;undo&apos;, {
        text: &apos;Undo&apos;,
        icon: &apos;undo&apos;,
        shortcut: &apos;Meta+Z&apos;,
        onSetup: function (api) {
          return toggleUndoRedoState(api, editor, &apos;hasUndo&apos;);
        },
        onAction: function () {
          return editor.execCommand(&apos;undo&apos;);
        }
      });
      editor.ui.registry.addMenuItem(&apos;redo&apos;, {
        text: &apos;Redo&apos;,
        icon: &apos;redo&apos;,
        shortcut: &apos;Meta+Y&apos;,
        onSetup: function (api) {
          return toggleUndoRedoState(api, editor, &apos;hasRedo&apos;);
        },
        onAction: function () {
          return editor.execCommand(&apos;redo&apos;);
        }
      });
    };
    var registerButtons$1 = function (editor) {
      editor.ui.registry.addButton(&apos;undo&apos;, {
        tooltip: &apos;Undo&apos;,
        icon: &apos;undo&apos;,
        onSetup: function (api) {
          return toggleUndoRedoState(api, editor, &apos;hasUndo&apos;);
        },
        onAction: function () {
          return editor.execCommand(&apos;undo&apos;);
        }
      });
      editor.ui.registry.addButton(&apos;redo&apos;, {
        tooltip: &apos;Redo&apos;,
        icon: &apos;redo&apos;,
        onSetup: function (api) {
          return toggleUndoRedoState(api, editor, &apos;hasRedo&apos;);
        },
        onAction: function () {
          return editor.execCommand(&apos;redo&apos;);
        }
      });
    };
    var register$7 = function (editor) {
      registerMenuItems$1(editor);
      registerButtons$1(editor);
    };

    var toggleVisualAidState = function (api, editor) {
      api.setActive(editor.hasVisual);
      var onVisualAid = function (e) {
        api.setActive(e.hasVisual);
      };
      editor.on(&apos;VisualAid&apos;, onVisualAid);
      return function () {
        return editor.off(&apos;VisualAid&apos;, onVisualAid);
      };
    };
    var registerMenuItems$2 = function (editor) {
      editor.ui.registry.addToggleMenuItem(&apos;visualaid&apos;, {
        text: &apos;Visual aids&apos;,
        onSetup: function (api) {
          return toggleVisualAidState(api, editor);
        },
        onAction: function () {
          editor.execCommand(&apos;mceToggleVisualAid&apos;);
        }
      });
    };
    var registerToolbarButton = function (editor) {
      editor.ui.registry.addButton(&apos;visualaid&apos;, {
        tooltip: &apos;Visual aids&apos;,
        text: &apos;Visual aids&apos;,
        onAction: function () {
          return editor.execCommand(&apos;mceToggleVisualAid&apos;);
        }
      });
    };
    var register$8 = function (editor) {
      registerToolbarButton(editor);
      registerMenuItems$2(editor);
    };

    var toggleOutdentState = function (api, editor) {
      api.setDisabled(!editor.queryCommandState(&apos;outdent&apos;));
      var onNodeChange = function () {
        api.setDisabled(!editor.queryCommandState(&apos;outdent&apos;));
      };
      editor.on(&apos;NodeChange&apos;, onNodeChange);
      return function () {
        return editor.off(&apos;NodeChange&apos;, onNodeChange);
      };
    };
    var registerButtons$2 = function (editor) {
      editor.ui.registry.addButton(&apos;outdent&apos;, {
        tooltip: &apos;Decrease indent&apos;,
        icon: &apos;outdent&apos;,
        onSetup: function (api) {
          return toggleOutdentState(api, editor);
        },
        onAction: function () {
          return editor.execCommand(&apos;outdent&apos;);
        }
      });
      editor.ui.registry.addButton(&apos;indent&apos;, {
        tooltip: &apos;Increase indent&apos;,
        icon: &apos;indent&apos;,
        onAction: function () {
          return editor.execCommand(&apos;indent&apos;);
        }
      });
    };
    var register$9 = function (editor) {
      registerButtons$2(editor);
    };

    var register$a = function (editor, backstage) {
      alignSelectMenu(editor, backstage);
      fontSelectMenu(editor, backstage);
      styleSelectMenu(editor, backstage);
      formatSelectMenu(editor, backstage);
      fontsizeSelectMenu(editor, backstage);
    };

    var setup$8 = function (editor, backstage) {
      register$5(editor);
      register$6(editor);
      register$a(editor, backstage);
      register$7(editor);
      register$1(editor);
      register$8(editor);
      register$9(editor);
    };

    var nu$d = function (x, y) {
      return {
        anchor: &apos;makeshift&apos;,
        x: x,
        y: y
      };
    };
    var transpose$1 = function (pos, dx, dy) {
      return nu$d(pos.x + dx, pos.y + dy);
    };
    var isTouchEvent$1 = function (e) {
      return e.type === &apos;longpress&apos; || e.type.indexOf(&apos;touch&apos;) === 0;
    };
    var fromPageXY = function (e) {
      if (isTouchEvent$1(e)) {
        var touch = e.touches[0];
        return nu$d(touch.pageX, touch.pageY);
      } else {
        return nu$d(e.pageX, e.pageY);
      }
    };
    var fromClientXY = function (e) {
      if (isTouchEvent$1(e)) {
        var touch = e.touches[0];
        return nu$d(touch.clientX, touch.clientY);
      } else {
        return nu$d(e.clientX, e.clientY);
      }
    };
    var transposeContentAreaContainer = function (element, pos) {
      var containerPos = global$7.DOM.getPos(element);
      return transpose$1(pos, containerPos.x, containerPos.y);
    };
    var getPointAnchor = function (editor, e) {
      if (e.type === &apos;contextmenu&apos; || e.type === &apos;longpress&apos;) {
        if (editor.inline) {
          return fromPageXY(e);
        } else {
          return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
        }
      } else {
        return getSelectionAnchor(editor);
      }
    };
    var getSelectionAnchor = function (editor) {
      return {
        anchor: &apos;selection&apos;,
        root: Element.fromDom(editor.selection.getNode())
      };
    };
    var getNodeAnchor$1 = function (editor) {
      return {
        anchor: &apos;node&apos;,
        node: Option.some(Element.fromDom(editor.selection.getNode())),
        root: Element.fromDom(editor.getBody())
      };
    };

    var getAnchorSpec = function (editor, e, isTriggeredByKeyboardEvent) {
      return isTriggeredByKeyboardEvent ? getNodeAnchor$1(editor) : getPointAnchor(editor, e);
    };
    var initAndShow = function (editor, e, buildMenu, backstage, contextmenu, isTriggeredByKeyboardEvent) {
      var items = buildMenu();
      var anchorSpec = getAnchorSpec(editor, e, isTriggeredByKeyboardEvent);
      build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, false).map(function (menuData) {
        e.preventDefault();
        InlineView.showMenuAt(contextmenu, anchorSpec, {
          menu: { markers: markers$1(&apos;normal&apos;) },
          data: menuData
        });
      });
    };

    var layouts = {
      onLtr: function () {
        return [
          south$1,
          southeast$1,
          southwest$1,
          northeast$1,
          northwest$1,
          north$1,
          north$3,
          south$3,
          northeast$3,
          southeast$3,
          northwest$3,
          southwest$3
        ];
      },
      onRtl: function () {
        return [
          south$1,
          southwest$1,
          southeast$1,
          northwest$1,
          northeast$1,
          north$1,
          north$3,
          south$3,
          northwest$3,
          southwest$3,
          northeast$3,
          southeast$3
        ];
      }
    };
    var bubbleSize$1 = 12;
    var bubbleAlignments$2 = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [&apos;tox-pop--align-left&apos;],
      alignRight: [&apos;tox-pop--align-right&apos;],
      right: [&apos;tox-pop--right&apos;],
      left: [&apos;tox-pop--left&apos;],
      bottom: [&apos;tox-pop--bottom&apos;],
      top: [&apos;tox-pop--top&apos;]
    };
    var isTouchWithinSelection = function (editor, e) {
      var selection = editor.selection;
      if (selection.isCollapsed() || e.touches.length &lt; 1) {
        return false;
      } else {
        var touch_1 = e.touches[0];
        var rng = selection.getRng();
        var rngRectOpt = getFirstRect$1(editor.getWin(), Selection.domRange(rng));
        return rngRectOpt.exists(function (rngRect) {
          return rngRect.left() &lt;= touch_1.clientX &amp;&amp; rngRect.right() &gt;= touch_1.clientX &amp;&amp; rngRect.top() &lt;= touch_1.clientY &amp;&amp; rngRect.bottom() &gt;= touch_1.clientY;
        });
      }
    };
    var getAnchorSpec$1 = function (editor, isTriggeredByKeyboardEvent, e) {
      var anchorSpec = isTriggeredByKeyboardEvent ? getNodeAnchor$1(editor) : getPointAnchor(editor, e);
      return __assign({
        bubble: nu$8(0, bubbleSize$1, bubbleAlignments$2),
        layouts: layouts,
        overrides: {
          maxWidthFunction: expandable$1(),
          maxHeightFunction: expandable()
        }
      }, anchorSpec);
    };
    var setupiOSOverrides = function (editor) {
      var originalSelection = editor.selection.getRng();
      var selectionReset = function () {
        global$2.setEditorTimeout(editor, function () {
          editor.selection.setRng(originalSelection);
        }, 10);
        unbindEventListeners();
      };
      editor.once(&apos;touchend&apos;, selectionReset);
      var preventMousedown = function (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      editor.on(&apos;mousedown&apos;, preventMousedown, true);
      var clearSelectionReset = function () {
        return unbindEventListeners();
      };
      editor.once(&apos;longpresscancel&apos;, clearSelectionReset);
      var unbindEventListeners = function () {
        editor.off(&apos;touchend&apos;, selectionReset);
        editor.off(&apos;longpresscancel&apos;, clearSelectionReset);
        editor.off(&apos;mousedown&apos;, preventMousedown);
      };
    };
    var show = function (editor, e, items, backstage, contextmenu, isTriggeredByKeyboardEvent, highlightImmediately) {
      var anchorSpec = getAnchorSpec$1(editor, isTriggeredByKeyboardEvent, e);
      build$2(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, true).map(function (menuData) {
        e.preventDefault();
        InlineView.showMenuWithinBounds(contextmenu, anchorSpec, {
          menu: {
            markers: markers$1(&apos;normal&apos;),
            highlightImmediately: highlightImmediately
          },
          data: menuData,
          type: &apos;horizontal&apos;
        }, function () {
          return Option.some(getContextToolbarBounds(editor, backstage.shared));
        });
        editor.fire(hideContextToolbarEvent);
      });
    };
    var initAndShow$1 = function (editor, e, buildMenu, backstage, contextmenu, isTriggeredByKeyboardEvent) {
      var detection = detect$3();
      var isiOS = detection.os.isiOS();
      var isOSX = detection.os.isOSX();
      var isAndroid = detection.os.isAndroid();
      var isTouch = detection.deviceType.isTouch();
      var shouldHighlightImmediately = function () {
        return !(isAndroid || isiOS || isOSX &amp;&amp; isTouch);
      };
      var open = function () {
        var items = buildMenu();
        show(editor, e, items, backstage, contextmenu, isTriggeredByKeyboardEvent, shouldHighlightImmediately());
      };
      if ((isOSX || isiOS) &amp;&amp; !isTriggeredByKeyboardEvent) {
        var openiOS_1 = function () {
          setupiOSOverrides(editor);
          open();
        };
        if (isTouchWithinSelection(editor, e)) {
          openiOS_1();
        } else {
          editor.once(&apos;selectionchange&apos;, openiOS_1);
          editor.once(&apos;touchend&apos;, function () {
            return editor.off(&apos;selectionchange&apos;, openiOS_1);
          });
        }
      } else {
        if (isAndroid &amp;&amp; !isTriggeredByKeyboardEvent) {
          editor.selection.setCursorLocation(e.target, 0);
        }
        open();
      }
    };

    var patchPipeConfig = function (config) {
      return typeof config === &apos;string&apos; ? config.split(/[ ,]/) : config;
    };
    var shouldNeverUseNative = function (editor) {
      return editor.settings.contextmenu_never_use_native || false;
    };
    var getMenuItems = function (editor, name, defaultItems) {
      var contextMenus = editor.ui.registry.getAll().contextMenus;
      return get(editor.settings, name).map(patchPipeConfig).getOrThunk(function () {
        return filter(patchPipeConfig(defaultItems), function (item) {
          return has(contextMenus, item);
        });
      });
    };
    var isContextMenuDisabled = function (editor) {
      return editor.getParam(&apos;contextmenu&apos;) === false;
    };
    var getContextMenu = function (editor) {
      return getMenuItems(editor, &apos;contextmenu&apos;, &apos;link linkchecker image imagetools table spellchecker configurepermanentpen&apos;);
    };

    var isSeparator$1 = function (item) {
      return isString(item) ? item === &apos;|&apos; : item.type === &apos;separator&apos;;
    };
    var separator$3 = { type: &apos;separator&apos; };
    var makeContextItem = function (item) {
      if (isString(item)) {
        return item;
      } else {
        switch (item.type) {
        case &apos;separator&apos;:
          return separator$3;
        case &apos;submenu&apos;:
          return {
            type: &apos;nestedmenuitem&apos;,
            text: item.text,
            icon: item.icon,
            getSubmenuItems: function () {
              var items = item.getSubmenuItems();
              if (isString(items)) {
                return items;
              } else {
                return map(items, makeContextItem);
              }
            }
          };
        default:
          return {
            type: &apos;menuitem&apos;,
            text: item.text,
            icon: item.icon,
            onAction: noarg(item.onAction)
          };
        }
      }
    };
    var addContextMenuGroup = function (xs, groupItems) {
      if (groupItems.length === 0) {
        return xs;
      }
      var lastMenuItem = last(xs).filter(function (item) {
        return !isSeparator$1(item);
      });
      var before = lastMenuItem.fold(function () {
        return [];
      }, function (_) {
        return [separator$3];
      });
      return xs.concat(before).concat(groupItems).concat([separator$3]);
    };
    var generateContextMenu = function (contextMenus, menuConfig, selectedElement) {
      var sections = foldl(menuConfig, function (acc, name) {
        if (has(contextMenus, name)) {
          var items = contextMenus[name].update(selectedElement);
          if (isString(items)) {
            return addContextMenuGroup(acc, items.split(&apos; &apos;));
          } else if (items.length &gt; 0) {
            var allItems = map(items, makeContextItem);
            return addContextMenuGroup(acc, allItems);
          } else {
            return acc;
          }
        } else {
          return acc.concat([name]);
        }
      }, []);
      if (sections.length &gt; 0 &amp;&amp; isSeparator$1(sections[sections.length - 1])) {
        sections.pop();
      }
      return sections;
    };
    var isNativeOverrideKeyEvent = function (editor, e) {
      return e.ctrlKey &amp;&amp; !shouldNeverUseNative(editor);
    };
    var isTriggeredByKeyboard = function (editor, e) {
      return e.type !== &apos;longpress&apos; &amp;&amp; (e.button !== 2 || e.target === editor.getBody() &amp;&amp; e.pointerType === &apos;&apos;);
    };
    var setup$9 = function (editor, lazySink, backstage) {
      var detection = detect$3();
      var isTouch = detection.deviceType.isTouch;
      var contextmenu = build$1(InlineView.sketch({
        dom: { tag: &apos;div&apos; },
        lazySink: lazySink,
        onEscape: function () {
          return editor.focus();
        },
        onShow: function () {
          return backstage.setContextMenuState(true);
        },
        onHide: function () {
          return backstage.setContextMenuState(false);
        },
        fireDismissalEventInstead: {},
        inlineBehaviours: derive$1([config(&apos;dismissContextMenu&apos;, [run(dismissRequested(), function (comp, _se) {
              Sandboxing.close(comp);
              editor.focus();
            })])])
      }));
      var hideContextMenu = function (_e) {
        return InlineView.hide(contextmenu);
      };
      var showContextMenu = function (e) {
        if (shouldNeverUseNative(editor)) {
          e.preventDefault();
        }
        if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {
          return;
        }
        var isTriggeredByKeyboardEvent = isTriggeredByKeyboard(editor, e);
        var buildMenu = function () {
          var selectedElement = isTriggeredByKeyboardEvent ? editor.selection.getStart(true) : e.target;
          var registry = editor.ui.registry.getAll();
          var menuConfig = getContextMenu(editor);
          return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
        };
        var initAndShow$2 = isTouch() ? initAndShow$1 : initAndShow;
        initAndShow$2(editor, e, buildMenu, backstage, contextmenu, isTriggeredByKeyboardEvent);
      };
      editor.on(&apos;init&apos;, function () {
        var hideEvents = &apos;ResizeEditor ScrollContent ScrollWindow longpresscancel&apos; + (isTouch() ? &apos;&apos; : &apos; ResizeWindow&apos;);
        editor.on(hideEvents, hideContextMenu);
        editor.on(&apos;longpress contextmenu&apos;, showContextMenu);
      });
    };

    var adt$c = Adt.generate([
      {
        offset: [
          &apos;x&apos;,
          &apos;y&apos;
        ]
      },
      {
        absolute: [
          &apos;x&apos;,
          &apos;y&apos;
        ]
      },
      {
        fixed: [
          &apos;x&apos;,
          &apos;y&apos;
        ]
      }
    ]);
    var subtract = function (change) {
      return function (point) {
        return point.translate(-change.left(), -change.top());
      };
    };
    var add$4 = function (change) {
      return function (point) {
        return point.translate(change.left(), change.top());
      };
    };
    var transform$1 = function (changes) {
      return function (x, y) {
        return foldl(changes, function (rest, f) {
          return f(rest);
        }, Position(x, y));
      };
    };
    var asFixed = function (coord, scroll, origin) {
      return coord.fold(transform$1([
        add$4(origin),
        subtract(scroll)
      ]), transform$1([subtract(scroll)]), transform$1([]));
    };
    var asAbsolute = function (coord, scroll, origin) {
      return coord.fold(transform$1([add$4(origin)]), transform$1([]), transform$1([add$4(scroll)]));
    };
    var asOffset = function (coord, scroll, origin) {
      return coord.fold(transform$1([]), transform$1([subtract(origin)]), transform$1([
        add$4(scroll),
        subtract(origin)
      ]));
    };
    var withinRange = function (coord1, coord2, xRange, yRange, scroll, origin) {
      var a1 = asAbsolute(coord1, scroll, origin);
      var a2 = asAbsolute(coord2, scroll, origin);
      return Math.abs(a1.left() - a2.left()) &lt;= xRange &amp;&amp; Math.abs(a1.top() - a2.top()) &lt;= yRange;
    };
    var getDeltas = function (coord1, coord2, xRange, yRange, scroll, origin) {
      var a1 = asAbsolute(coord1, scroll, origin);
      var a2 = asAbsolute(coord2, scroll, origin);
      var left = Math.abs(a1.left() - a2.left());
      var top = Math.abs(a1.top() - a2.top());
      return Position(left, top);
    };
    var toStyles = function (coord, scroll, origin) {
      var stylesOpt = coord.fold(function (x, y) {
        return {
          position: Option.some(&apos;absolute&apos;),
          left: Option.some(x + &apos;px&apos;),
          top: Option.some(y + &apos;px&apos;)
        };
      }, function (x, y) {
        return {
          position: Option.some(&apos;absolute&apos;),
          left: Option.some(x - origin.left() + &apos;px&apos;),
          top: Option.some(y - origin.top() + &apos;px&apos;)
        };
      }, function (x, y) {
        return {
          position: Option.some(&apos;fixed&apos;),
          left: Option.some(x + &apos;px&apos;),
          top: Option.some(y + &apos;px&apos;)
        };
      });
      return __assign({
        right: Option.none(),
        bottom: Option.none()
      }, stylesOpt);
    };
    var translate$2 = function (coord, deltaX, deltaY) {
      return coord.fold(function (x, y) {
        return offset(x + deltaX, y + deltaY);
      }, function (x, y) {
        return absolute$3(x + deltaX, y + deltaY);
      }, function (x, y) {
        return fixed$1(x + deltaX, y + deltaY);
      });
    };
    var absorb = function (partialCoord, originalCoord, scroll, origin) {
      var absorbOne = function (stencil, nu) {
        return function (optX, optY) {
          var original = stencil(originalCoord, scroll, origin);
          return nu(optX.getOr(original.left()), optY.getOr(original.top()));
        };
      };
      return partialCoord.fold(absorbOne(asOffset, offset), absorbOne(asAbsolute, absolute$3), absorbOne(asFixed, fixed$1));
    };
    var offset = adt$c.offset;
    var absolute$3 = adt$c.absolute;
    var fixed$1 = adt$c.fixed;

    var parseAttrToInt = function (element, name) {
      var value = get$2(element, name);
      return isUndefined(value) ? NaN : parseInt(value, 10);
    };
    var get$e = function (component, snapsInfo) {
      var element = component.element();
      var x = parseAttrToInt(element, snapsInfo.leftAttr);
      var y = parseAttrToInt(element, snapsInfo.topAttr);
      return isNaN(x) || isNaN(y) ? Option.none() : Option.some(Position(x, y));
    };
    var set$8 = function (component, snapsInfo, pt) {
      var element = component.element();
      set$1(element, snapsInfo.leftAttr, pt.left() + &apos;px&apos;);
      set$1(element, snapsInfo.topAttr, pt.top() + &apos;px&apos;);
    };
    var clear = function (component, snapsInfo) {
      var element = component.element();
      remove$1(element, snapsInfo.leftAttr);
      remove$1(element, snapsInfo.topAttr);
    };

    var getCoords = function (component, snapInfo, coord, delta) {
      return get$e(component, snapInfo).fold(function () {
        return coord;
      }, function (fixed) {
        return fixed$1(fixed.left() + delta.left(), fixed.top() + delta.top());
      });
    };
    var moveOrSnap = function (component, snapInfo, coord, delta, scroll, origin) {
      var newCoord = getCoords(component, snapInfo, coord, delta);
      var snap = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);
      var fixedCoord = asFixed(newCoord, scroll, origin);
      set$8(component, snapInfo, fixedCoord);
      return snap.fold(function () {
        return {
          coord: fixed$1(fixedCoord.left(), fixedCoord.top()),
          extra: Option.none()
        };
      }, function (spanned) {
        return {
          coord: spanned.output,
          extra: spanned.extra
        };
      });
    };
    var stopDrag = function (component, snapInfo) {
      clear(component, snapInfo);
    };
    var findMatchingSnap = function (snaps, newCoord, scroll, origin) {
      return findMap(snaps, function (snap) {
        var sensor = snap.sensor;
        var inRange = withinRange(newCoord, sensor, snap.range.left(), snap.range.top(), scroll, origin);
        return inRange ? Option.some({
          output: absorb(snap.output, newCoord, scroll, origin),
          extra: snap.extra
        }) : Option.none();
      });
    };
    var findClosestSnap = function (component, snapInfo, newCoord, scroll, origin) {
      var snaps = snapInfo.getSnapPoints(component);
      var matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
      return matchSnap.orThunk(function () {
        var bestSnap = foldl(snaps, function (acc, snap) {
          var sensor = snap.sensor;
          var deltas = getDeltas(newCoord, sensor, snap.range.left(), snap.range.top(), scroll, origin);
          return acc.deltas.fold(function () {
            return {
              deltas: Option.some(deltas),
              snap: Option.some(snap)
            };
          }, function (bestDeltas) {
            var currAvg = (deltas.left() + deltas.top()) / 2;
            var bestAvg = (bestDeltas.left() + bestDeltas.top()) / 2;
            if (currAvg &lt;= bestAvg) {
              return {
                deltas: Option.some(deltas),
                snap: Option.some(snap)
              };
            } else {
              return acc;
            }
          });
        }, {
          deltas: Option.none(),
          snap: Option.none()
        });
        return bestSnap.snap.map(function (snap) {
          return {
            output: absorb(snap.output, newCoord, scroll, origin),
            extra: snap.extra
          };
        });
      });
    };
    var findSnap = function (component, snapInfo, newCoord, scroll, origin) {
      var snaps = snapInfo.getSnapPoints(component);
      return findMatchingSnap(snaps, newCoord, scroll, origin);
    };
    var snapTo = function (snap, scroll, origin) {
      return {
        coord: absorb(snap.output, snap.output, scroll, origin),
        extra: snap.extra
      };
    };

    var snapTo$1 = function (component, dragConfig, _state, snap) {
      var target = dragConfig.getTarget(component.element());
      if (dragConfig.repositionTarget) {
        var doc = owner(component.element());
        var scroll = get$8(doc);
        var origin = getOrigin(target);
        var snapPin = snapTo(snap, scroll, origin);
        var styles = toStyles(snapPin.coord, scroll, origin);
        setOptions(target, styles);
      }
    };

    var DraggingApis = /*#__PURE__*/Object.freeze({
        __proto__: null,
        snapTo: snapTo$1
    });

    var initialAttribute = &apos;data-initial-z-index&apos;;
    var resetZIndex = function (blocker) {
      parent(blocker.element()).filter(isElement).each(function (root) {
        getOpt(root, initialAttribute).fold(function () {
          return remove$6(root, &apos;z-index&apos;);
        }, function (zIndex) {
          return set$2(root, &apos;z-index&apos;, zIndex);
        });
        remove$1(root, initialAttribute);
      });
    };
    var changeZIndex = function (blocker) {
      parent(blocker.element()).filter(isElement).each(function (root) {
        getRaw(root, &apos;z-index&apos;).each(function (zindex) {
          set$1(root, initialAttribute, zindex);
        });
        set$2(root, &apos;z-index&apos;, get$4(blocker.element(), &apos;z-index&apos;));
      });
    };
    var instigate = function (anyComponent, blocker) {
      anyComponent.getSystem().addToGui(blocker);
      changeZIndex(blocker);
    };
    var discard = function (blocker) {
      resetZIndex(blocker);
      blocker.getSystem().removeFromGui(blocker);
    };
    var createComponent = function (component, blockerClass, blockerEvents) {
      return component.getSystem().build(Container.sketch({
        dom: {
          styles: {
            &apos;left&apos;: &apos;0px&apos;,
            &apos;top&apos;: &apos;0px&apos;,
            &apos;width&apos;: &apos;100%&apos;,
            &apos;height&apos;: &apos;100%&apos;,
            &apos;position&apos;: &apos;fixed&apos;,
            &apos;z-index&apos;: &apos;1000000000000000&apos;
          },
          classes: [blockerClass]
        },
        events: blockerEvents
      }));
    };

    var SnapSchema = optionObjOf(&apos;snaps&apos;, [
      strict$1(&apos;getSnapPoints&apos;),
      onHandler(&apos;onSensor&apos;),
      strict$1(&apos;leftAttr&apos;),
      strict$1(&apos;topAttr&apos;),
      defaulted$1(&apos;lazyViewport&apos;, win),
      defaulted$1(&apos;mustSnap&apos;, false)
    ]);

    var schema$t = [
      defaulted$1(&apos;useFixed&apos;, never),
      strict$1(&apos;blockerClass&apos;),
      defaulted$1(&apos;getTarget&apos;, identity),
      defaulted$1(&apos;onDrag&apos;, noop),
      defaulted$1(&apos;repositionTarget&apos;, true),
      defaulted$1(&apos;onDrop&apos;, noop),
      defaultedFunction(&apos;getBounds&apos;, win),
      SnapSchema
    ];

    var getCurrentCoord = function (target) {
      return lift3(getRaw(target, &apos;left&apos;), getRaw(target, &apos;top&apos;), getRaw(target, &apos;position&apos;), function (left, top, position) {
        var nu = position === &apos;fixed&apos; ? fixed$1 : offset;
        return nu(parseInt(left, 10), parseInt(top, 10));
      }).getOrThunk(function () {
        var location = absolute(target);
        return absolute$3(location.left(), location.top());
      });
    };
    var clampCoords = function (component, coords, scroll, origin, startData) {
      var bounds = startData.bounds;
      var absoluteCoord = asAbsolute(coords, scroll, origin);
      var newX = clamp(absoluteCoord.left(), bounds.x, bounds.x + bounds.width - startData.width);
      var newY = clamp(absoluteCoord.top(), bounds.y, bounds.y + bounds.height - startData.height);
      var newCoords = absolute$3(newX, newY);
      return coords.fold(function () {
        var offset$1 = asOffset(newCoords, scroll, origin);
        return offset(offset$1.left(), offset$1.top());
      }, function () {
        return newCoords;
      }, function () {
        var fixed = asFixed(newCoords, scroll, origin);
        return fixed$1(fixed.left(), fixed.top());
      });
    };
    var calcNewCoord = function (component, optSnaps, currentCoord, scroll, origin, delta, startData) {
      var newCoord = optSnaps.fold(function () {
        var translated = translate$2(currentCoord, delta.left(), delta.top());
        var fixedCoord = asFixed(translated, scroll, origin);
        return fixed$1(fixedCoord.left(), fixedCoord.top());
      }, function (snapInfo) {
        var snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
        snapping.extra.each(function (extra) {
          snapInfo.onSensor(component, extra);
        });
        return snapping.coord;
      });
      return clampCoords(component, newCoord, scroll, origin, startData);
    };
    var dragBy = function (component, dragConfig, startData, delta) {
      var target = dragConfig.getTarget(component.element());
      if (dragConfig.repositionTarget) {
        var doc = owner(component.element());
        var scroll = get$8(doc);
        var origin = getOrigin(target);
        var currentCoord = getCurrentCoord(target);
        var newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
        var styles = toStyles(newCoord, scroll, origin);
        setOptions(target, styles);
      }
      dragConfig.onDrag(component, target, delta);
    };

    var calcStartData = function (dragConfig, comp) {
      return {
        bounds: dragConfig.getBounds(),
        height: getOuter$1(comp.element()),
        width: getOuter$2(comp.element())
      };
    };
    var move$1 = function (component, dragConfig, dragState, dragMode, event) {
      var delta = dragState.update(dragMode, event);
      var dragStartData = dragState.getStartData().getOrThunk(function () {
        return calcStartData(dragConfig, component);
      });
      delta.each(function (dlt) {
        dragBy(component, dragConfig, dragStartData, dlt);
      });
    };
    var stop = function (component, blocker, dragConfig, dragState) {
      blocker.each(discard);
      dragConfig.snaps.each(function (snapInfo) {
        stopDrag(component, snapInfo);
      });
      var target = dragConfig.getTarget(component.element());
      dragState.reset();
      dragConfig.onDrop(component, target);
    };
    var handlers = function (events) {
      return function (dragConfig, dragState) {
        var updateStartState = function (comp) {
          dragState.setStartData(calcStartData(dragConfig, comp));
        };
        return derive(__spreadArrays([run(windowScroll(), function (comp) {
            dragState.getStartData().each(function () {
              return updateStartState(comp);
            });
          })], events(dragConfig, dragState, updateStartState)));
      };
    };

    var init$c = function (dragApi) {
      return derive([
        run(mousedown(), dragApi.forceDrop),
        run(mouseup(), dragApi.drop),
        run(mousemove(), function (comp, simulatedEvent) {
          dragApi.move(simulatedEvent.event());
        }),
        run(mouseout(), dragApi.delayDrop)
      ]);
    };

    var getData$1 = function (event) {
      return Option.from(Position(event.x(), event.y()));
    };
    var getDelta$1 = function (old, nu) {
      return Position(nu.left() - old.left(), nu.top() - old.top());
    };

    var MouseData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData$1,
        getDelta: getDelta$1
    });

    var events$g = function (dragConfig, dragState, updateStartState) {
      return [run(mousedown(), function (component, simulatedEvent) {
          var raw = simulatedEvent.event().raw();
          if (raw.button !== 0) {
            return;
          }
          simulatedEvent.stop();
          var stop$1 = function () {
            return stop(component, Option.some(blocker), dragConfig, dragState);
          };
          var delayDrop = DelayedFunction(stop$1, 200);
          var dragApi = {
            drop: stop$1,
            delayDrop: delayDrop.schedule,
            forceDrop: stop$1,
            move: function (event) {
              delayDrop.cancel();
              move$1(component, dragConfig, dragState, MouseData, event);
            }
          };
          var blocker = createComponent(component, dragConfig.blockerClass, init$c(dragApi));
          var start = function () {
            updateStartState(component);
            instigate(component, blocker);
          };
          start();
        })];
    };
    var schema$u = __spreadArrays(schema$t, [output(&apos;dragger&apos;, { handlers: handlers(events$g) })]);

    var init$d = function (dragApi) {
      return derive([
        run(touchstart(), dragApi.forceDrop),
        run(touchend(), dragApi.drop),
        run(touchcancel(), dragApi.drop),
        run(touchmove(), function (comp, simulatedEvent) {
          dragApi.move(simulatedEvent.event());
        })
      ]);
    };

    var getDataFrom = function (touches) {
      var touch = touches[0];
      return Option.some(Position(touch.clientX, touch.clientY));
    };
    var getData$2 = function (event) {
      var raw = event.raw();
      var touches = raw.touches;
      return touches.length === 1 ? getDataFrom(touches) : Option.none();
    };
    var getDelta$2 = function (old, nu) {
      return Position(nu.left() - old.left(), nu.top() - old.top());
    };

    var TouchData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        getData: getData$2,
        getDelta: getDelta$2
    });

    var events$h = function (dragConfig, dragState, updateStartState) {
      var blockerCell = Cell(Option.none());
      return [
        run(touchstart(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          var stop$1 = function () {
            stop(component, blockerCell.get(), dragConfig, dragState);
            blockerCell.set(Option.none());
          };
          var dragApi = {
            drop: stop$1,
            delayDrop: function () {
            },
            forceDrop: stop$1,
            move: function (event) {
              move$1(component, dragConfig, dragState, TouchData, event);
            }
          };
          var blocker = createComponent(component, dragConfig.blockerClass, init$d(dragApi));
          blockerCell.set(Option.some(blocker));
          var start = function () {
            updateStartState(component);
            instigate(component, blocker);
          };
          start();
        }),
        run(touchmove(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          move$1(component, dragConfig, dragState, TouchData, simulatedEvent.event());
        }),
        run(touchend(), function (component, simulatedEvent) {
          simulatedEvent.stop();
          stop(component, blockerCell.get(), dragConfig, dragState);
          blockerCell.set(Option.none());
        }),
        run(touchcancel(), function (component) {
          stop(component, blockerCell.get(), dragConfig, dragState);
          blockerCell.set(Option.none());
        })
      ];
    };
    var schema$v = __spreadArrays(schema$t, [output(&apos;dragger&apos;, { handlers: handlers(events$h) })]);

    var events$i = function (dragConfig, dragState, updateStartState) {
      return __spreadArrays(events$g(dragConfig, dragState, updateStartState), events$h(dragConfig, dragState, updateStartState));
    };
    var schema$w = __spreadArrays(schema$t, [output(&apos;dragger&apos;, { handlers: handlers(events$i) })]);

    var mouse = schema$u;
    var touch = schema$v;
    var mouseOrTouch = schema$w;

    var DraggingBranches = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mouse: mouse,
        touch: touch,
        mouseOrTouch: mouseOrTouch
    });

    var init$e = function () {
      var previous = Option.none();
      var startData = Option.none();
      var reset = function () {
        previous = Option.none();
        startData = Option.none();
      };
      var calculateDelta = function (mode, nu) {
        var result = previous.map(function (old) {
          return mode.getDelta(old, nu);
        });
        previous = Option.some(nu);
        return result;
      };
      var update = function (mode, dragEvent) {
        return mode.getData(dragEvent).bind(function (nuData) {
          return calculateDelta(mode, nuData);
        });
      };
      var setStartData = function (data) {
        startData = Option.some(data);
      };
      var getStartData = function () {
        return startData;
      };
      var readState = constant({});
      return nu$5({
        readState: readState,
        reset: reset,
        update: update,
        getStartData: getStartData,
        setStartData: setStartData
      });
    };

    var DragState = /*#__PURE__*/Object.freeze({
        __proto__: null,
        init: init$e
    });

    var Dragging = createModes$1({
      branchKey: &apos;mode&apos;,
      branches: DraggingBranches,
      name: &apos;dragging&apos;,
      active: {
        events: function (dragConfig, dragState) {
          var dragger = dragConfig.dragger;
          return dragger.handlers(dragConfig, dragState);
        }
      },
      extra: {
        snap: function (sConfig) {
          return {
            sensor: sConfig.sensor,
            range: sConfig.range,
            output: sConfig.output,
            extra: Option.from(sConfig.extra)
          };
        }
      },
      state: DragState,
      apis: DraggingApis
    });

    var snapWidth = 40;
    var snapOffset = snapWidth / 2;
    var calcSnap = function (selectorOpt, td, x, y, width, height) {
      return selectorOpt.fold(function () {
        return Dragging.snap({
          sensor: absolute$3(x - snapOffset, y - snapOffset),
          range: Position(width, height),
          output: absolute$3(Option.some(x), Option.some(y)),
          extra: { td: td }
        });
      }, function (selectorHandle) {
        var sensorLeft = x - snapOffset;
        var sensorTop = y - snapOffset;
        var sensorWidth = snapWidth;
        var sensorHeight = snapWidth;
        var rect = selectorHandle.element().dom().getBoundingClientRect();
        return Dragging.snap({
          sensor: absolute$3(sensorLeft, sensorTop),
          range: Position(sensorWidth, sensorHeight),
          output: absolute$3(Option.some(x - rect.width / 2), Option.some(y - rect.height / 2)),
          extra: { td: td }
        });
      });
    };
    var getSnapsConfig = function (getSnapPoints, cell, onChange) {
      var isSameCell = function (cellOpt, td) {
        return cellOpt.exists(function (currentTd) {
          return eq$1(currentTd, td);
        });
      };
      return {
        getSnapPoints: getSnapPoints,
        leftAttr: &apos;data-drag-left&apos;,
        topAttr: &apos;data-drag-top&apos;,
        onSensor: function (component, extra) {
          var td = extra.td;
          if (!isSameCell(cell.get(), td)) {
            cell.set(Option.some(td));
            onChange(td);
          }
        },
        mustSnap: true
      };
    };
    var createSelector = function (snaps) {
      return record(Button.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-selector&apos;]
        },
        buttonBehaviours: derive$1([
          Dragging.config({
            mode: &apos;mouseOrTouch&apos;,
            blockerClass: &apos;blocker&apos;,
            snaps: snaps
          }),
          Unselecting.config({})
        ]),
        eventOrder: {
          mousedown: [
            &apos;dragging&apos;,
            &apos;alloy.base.behaviour&apos;
          ],
          touchstart: [
            &apos;dragging&apos;,
            &apos;alloy.base.behaviour&apos;
          ]
        }
      }));
    };
    var setup$a = function (editor, sink) {
      var tlTds = Cell([]);
      var brTds = Cell([]);
      var isVisible = Cell(false);
      var startCell = Cell(Option.none());
      var finishCell = Cell(Option.none());
      var getTopLeftSnap = function (td) {
        var box = absolute$1(td);
        return calcSnap(memTopLeft.getOpt(sink), td, box.x, box.y, box.width, box.height);
      };
      var getTopLeftSnaps = function () {
        return map(tlTds.get(), function (td) {
          return getTopLeftSnap(td);
        });
      };
      var getBottomRightSnap = function (td) {
        var box = absolute$1(td);
        return calcSnap(memBottomRight.getOpt(sink), td, box.right, box.bottom, box.width, box.height);
      };
      var getBottomRightSnaps = function () {
        return map(brTds.get(), function (td) {
          return getBottomRightSnap(td);
        });
      };
      var topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, function (start) {
        finishCell.get().each(function (finish) {
          editor.fire(&apos;TableSelectorChange&apos;, {
            start: start,
            finish: finish
          });
        });
      });
      var bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, function (finish) {
        startCell.get().each(function (start) {
          editor.fire(&apos;TableSelectorChange&apos;, {
            start: start,
            finish: finish
          });
        });
      });
      var memTopLeft = createSelector(topLeftSnaps);
      var memBottomRight = createSelector(bottomRightSnaps);
      var topLeft = build$1(memTopLeft.asSpec());
      var bottomRight = build$1(memBottomRight.asSpec());
      var showOrHideHandle = function (selector, cell, isAbove, isBelow) {
        var cellRect = cell.dom().getBoundingClientRect();
        remove$6(selector.element(), &apos;display&apos;);
        var viewportHeight = defaultView(Element.fromDom(editor.getBody())).dom().innerHeight;
        var aboveViewport = isAbove(cellRect);
        var belowViewport = isBelow(cellRect, viewportHeight);
        if (aboveViewport || belowViewport) {
          set$2(selector.element(), &apos;display&apos;, &apos;none&apos;);
        }
      };
      var snapTo = function (selector, cell, getSnapConfig, pos) {
        var snap = getSnapConfig(cell);
        Dragging.snapTo(selector, snap);
        var isAbove = function (rect) {
          return rect[pos] &lt; 0;
        };
        var isBelow = function (rect, viewportHeight) {
          return rect[pos] &gt; viewportHeight;
        };
        showOrHideHandle(selector, cell, isAbove, isBelow);
      };
      var snapTopLeft = function (cell) {
        return snapTo(topLeft, cell, getTopLeftSnap, &apos;top&apos;);
      };
      var snapLastTopLeft = function () {
        return startCell.get().each(snapTopLeft);
      };
      var snapBottomRight = function (cell) {
        return snapTo(bottomRight, cell, getBottomRightSnap, &apos;bottom&apos;);
      };
      var snapLastBottomRight = function () {
        return finishCell.get().each(snapBottomRight);
      };
      if (detect$3().deviceType.isTouch()) {
        editor.on(&apos;TableSelectionChange&apos;, function (e) {
          if (!isVisible.get()) {
            attach$1(sink, topLeft);
            attach$1(sink, bottomRight);
            isVisible.set(true);
          }
          startCell.set(Option.some(e.start));
          finishCell.set(Option.some(e.finish));
          e.otherCells.each(function (otherCells) {
            tlTds.set(otherCells.upOrLeftCells);
            brTds.set(otherCells.downOrRightCells);
            snapTopLeft(e.start);
            snapBottomRight(e.finish);
          });
        });
        editor.on(&apos;ResizeEditor ResizeWindow ScrollContent&apos;, function () {
          snapLastTopLeft();
          snapLastBottomRight();
        });
        editor.on(&apos;TableSelectionClear&apos;, function () {
          if (isVisible.get()) {
            detach(topLeft);
            detach(bottomRight);
            isVisible.set(false);
          }
          startCell.set(Option.none());
          finishCell.set(Option.none());
        });
      }
    };

    var ResizeTypes;
    (function (ResizeTypes) {
      ResizeTypes[ResizeTypes[&apos;None&apos;] = 0] = &apos;None&apos;;
      ResizeTypes[ResizeTypes[&apos;Both&apos;] = 1] = &apos;Both&apos;;
      ResizeTypes[ResizeTypes[&apos;Vertical&apos;] = 2] = &apos;Vertical&apos;;
    }(ResizeTypes || (ResizeTypes = {})));
    var getDimensions = function (editor, deltas, resizeType, originalHeight, originalWidth) {
      var dimensions = {};
      dimensions.height = calcCappedSize(originalHeight + deltas.top(), getMinHeightSetting(editor), getMaxHeightSetting(editor));
      if (resizeType === ResizeTypes.Both) {
        dimensions.width = calcCappedSize(originalWidth + deltas.left(), getMinWidthSetting(editor), getMaxWidthSetting(editor));
      }
      return dimensions;
    };
    var resize$3 = function (editor, deltas, resizeType) {
      var container = Element.fromDom(editor.getContainer());
      var dimensions = getDimensions(editor, deltas, resizeType, get$6(container), get$7(container));
      each$1(dimensions, function (val, dim) {
        return set$2(container, dim, numToPx(val));
      });
      fireResizeEditor(editor);
    };

    var isHidden$1 = function (elm) {
      if (elm.nodeType === 1) {
        if (elm.nodeName === &apos;BR&apos; || !!elm.getAttribute(&apos;data-mce-bogus&apos;)) {
          return true;
        }
        if (elm.getAttribute(&apos;data-mce-type&apos;) === &apos;bookmark&apos;) {
          return true;
        }
      }
      return false;
    };
    var renderElementPath = function (editor, settings, providersBackstage) {
      if (!settings.delimiter) {
        settings.delimiter = &apos;\xBB&apos;;
      }
      var getDataPath = function (data) {
        var parts = data || [];
        var newPathElements = map(parts, function (part, index) {
          return Button.sketch({
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-statusbar__path-item&apos;],
              attributes: {
                &apos;role&apos;: &apos;button&apos;,
                &apos;data-index&apos;: index,
                &apos;tab-index&apos;: -1,
                &apos;aria-level&apos;: index + 1
              },
              innerHtml: part.name
            },
            action: function (_btn) {
              editor.focus();
              editor.selection.select(part.element);
              editor.nodeChanged();
            },
            buttonBehaviours: derive$1([
              DisablingConfigs.button(providersBackstage.isReadOnly),
              receivingConfig()
            ])
          });
        });
        var divider = {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-statusbar__path-divider&apos;],
            attributes: { &apos;aria-hidden&apos;: true },
            innerHtml: &apos; &apos; + settings.delimiter + &apos; &apos;
          }
        };
        return foldl(newPathElements.slice(1), function (acc, element) {
          var newAcc = acc;
          newAcc.push(divider);
          newAcc.push(element);
          return newAcc;
        }, [newPathElements[0]]);
      };
      var updatePath = function (parents) {
        var newPath = [];
        var i = parents.length;
        while (i-- &gt; 0) {
          var parent_1 = parents[i];
          if (parent_1.nodeType === 1 &amp;&amp; !isHidden$1(parent_1)) {
            var args = editor.fire(&apos;ResolveName&apos;, {
              name: parent_1.nodeName.toLowerCase(),
              target: parent_1
            });
            if (!args.isDefaultPrevented()) {
              newPath.push({
                name: args.name,
                element: parent_1
              });
            }
            if (args.isPropagationStopped()) {
              break;
            }
          }
        }
        return newPath;
      };
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-statusbar__path&apos;],
          attributes: { role: &apos;navigation&apos; }
        },
        behaviours: derive$1([
          Keying.config({
            mode: &apos;flow&apos;,
            selector: &apos;div[role=button]&apos;
          }),
          Disabling.config({ disabled: providersBackstage.isReadOnly }),
          receivingConfig(),
          Tabstopping.config({}),
          Replacing.config({}),
          config(&apos;elementPathEvents&apos;, [runOnAttached(function (comp, _e) {
              editor.shortcuts.add(&apos;alt+F11&apos;, &apos;focus statusbar elementpath&apos;, function () {
                return Keying.focusIn(comp);
              });
              editor.on(&apos;NodeChange&apos;, function (e) {
                var newPath = updatePath(e.parents);
                if (newPath.length &gt; 0) {
                  Replacing.set(comp, getDataPath(newPath));
                } else {
                  Replacing.set(comp, []);
                }
              });
            })])
        ]),
        components: []
      };
    };

    var renderWordCount = function (editor, providersBackstage) {
      var replaceCountText = function (comp, count, mode) {
        return Replacing.set(comp, [text(providersBackstage.translate([
            &apos;{0} &apos; + mode,
            count[mode]
          ]))]);
      };
      return Button.sketch({
        dom: {
          tag: &apos;button&apos;,
          classes: [&apos;tox-statusbar__wordcount&apos;]
        },
        components: [],
        buttonBehaviours: derive$1([
          DisablingConfigs.button(providersBackstage.isReadOnly),
          receivingConfig(),
          Tabstopping.config({}),
          Replacing.config({}),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: {
                mode: &apos;words&apos;,
                count: {
                  words: 0,
                  characters: 0
                }
              }
            }
          }),
          config(&apos;wordcount-events&apos;, [
            runOnExecute(function (comp) {
              var currentVal = Representing.getValue(comp);
              var newMode = currentVal.mode === &apos;words&apos; ? &apos;characters&apos; : &apos;words&apos;;
              Representing.setValue(comp, {
                mode: newMode,
                count: currentVal.count
              });
              replaceCountText(comp, currentVal.count, newMode);
            }),
            runOnAttached(function (comp) {
              editor.on(&apos;wordCountUpdate&apos;, function (e) {
                var mode = Representing.getValue(comp).mode;
                Representing.setValue(comp, {
                  mode: mode,
                  count: e.wordCount
                });
                replaceCountText(comp, e.wordCount, mode);
              });
            })
          ])
        ]),
        eventOrder: {
          &apos;alloy.execute&apos;: [
            &apos;disabling&apos;,
            &apos;alloy.base.behaviour&apos;,
            &apos;wordcount-events&apos;
          ]
        }
      });
    };

    var renderStatusbar = function (editor, providersBackstage) {
      var renderResizeHandlerIcon = function (resizeType) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-statusbar__resize-handle&apos;],
            attributes: {
              &apos;title&apos;: providersBackstage.translate(&apos;Resize&apos;),
              &apos;aria-hidden&apos;: &apos;true&apos;
            },
            innerHtml: get$d(&apos;resize-handle&apos;, providersBackstage.icons)
          },
          behaviours: derive$1([Dragging.config({
              mode: &apos;mouse&apos;,
              repositionTarget: false,
              onDrag: function (comp, target, delta) {
                resize$3(editor, delta, resizeType);
              },
              blockerClass: &apos;tox-blocker&apos;
            })])
        };
      };
      var renderBranding = function () {
        var label = global$5.translate([
          &apos;Powered by {0}&apos;,
          &apos;Tiny&apos;
        ]);
        var linkHtml = &apos;&lt;a href=&quot;https://www.tiny.cloud/?utm_campaign=editor_referral&amp;amp;utm_medium=poweredby&amp;amp;utm_source=tinymce&amp;amp;utm_content=v5&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot; tabindex=&quot;-1&quot; aria-label=&quot;&apos; + label + &apos;&quot;&gt;&apos; + label + &apos;&lt;/a&gt;&apos;;
        return {
          dom: {
            tag: &apos;span&apos;,
            classes: [&apos;tox-statusbar__branding&apos;],
            innerHtml: linkHtml
          }
        };
      };
      var getResizeType = function (editor) {
        var fallback = !contains$1(editor.settings.plugins, &apos;autoresize&apos;);
        var resize = editor.getParam(&apos;resize&apos;, fallback);
        if (resize === false) {
          return ResizeTypes.None;
        } else if (resize === &apos;both&apos;) {
          return ResizeTypes.Both;
        } else {
          return ResizeTypes.Vertical;
        }
      };
      var getTextComponents = function () {
        var components = [];
        if (editor.getParam(&apos;elementpath&apos;, true, &apos;boolean&apos;)) {
          components.push(renderElementPath(editor, {}, providersBackstage));
        }
        if (contains$1(editor.settings.plugins, &apos;wordcount&apos;)) {
          components.push(renderWordCount(editor, providersBackstage));
        }
        if (editor.getParam(&apos;branding&apos;, true, &apos;boolean&apos;)) {
          components.push(renderBranding());
        }
        if (components.length &gt; 0) {
          return [{
              dom: {
                tag: &apos;div&apos;,
                classes: [&apos;tox-statusbar__text-container&apos;]
              },
              components: components
            }];
        }
        return [];
      };
      var getComponents = function () {
        var components = getTextComponents();
        var resizeType = getResizeType(editor);
        if (resizeType !== ResizeTypes.None) {
          components.push(renderResizeHandlerIcon(resizeType));
        }
        return components;
      };
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-statusbar&apos;]
        },
        components: getComponents()
      };
    };

    var setup$b = function (editor) {
      var _a;
      var isInline = editor.inline;
      var mode = isInline ? Inline : Iframe;
      var header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
      var lazyOuterContainer = Option.none();
      var platform = detect$3();
      var isIE = platform.browser.isIE();
      var platformClasses = isIE ? [&apos;tox-platform-ie&apos;] : [];
      var isTouch = platform.deviceType.isTouch();
      var touchPlatformClass = &apos;tox-platform-touch&apos;;
      var deviceClasses = isTouch ? [touchPlatformClass] : [];
      var isToolbarBottom = isToolbarLocationBottom(editor);
      var dirAttributes = global$5.isRtl() ? { attributes: { dir: &apos;rtl&apos; } } : {};
      var verticalDirAttributes = { attributes: (_a = {}, _a[Attribute] = isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom, _a) };
      var lazyHeader = function () {
        return lazyOuterContainer.bind(OuterContainer.getHeader);
      };
      var isHeaderDocked = function () {
        return header.isDocked(lazyHeader);
      };
      var sink = build$1({
        dom: __assign({
          tag: &apos;div&apos;,
          classes: [
            &apos;tox&apos;,
            &apos;tox-silver-sink&apos;,
            &apos;tox-tinymce-aux&apos;
          ].concat(platformClasses).concat(deviceClasses)
        }, dirAttributes),
        behaviours: derive$1([Positioning.config({
            useFixed: function () {
              return isHeaderDocked();
            }
          })])
      });
      var lazySink = function () {
        return Result.value(sink);
      };
      var memAnchorBar = record({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-anchorbar&apos;]
        }
      });
      var lazyAnchorBar = function () {
        return lazyOuterContainer.bind(function (container) {
          return memAnchorBar.getOpt(container);
        }).getOrDie(&apos;Could not find a anchor bar element&apos;);
      };
      var lazyToolbar = function () {
        return lazyOuterContainer.bind(function (container) {
          return OuterContainer.getToolbar(container);
        }).getOrDie(&apos;Could not find more toolbar element&apos;);
      };
      var lazyThrobber = function () {
        return lazyOuterContainer.bind(function (container) {
          return OuterContainer.getThrobber(container);
        }).getOrDie(&apos;Could not find throbber element&apos;);
      };
      var backstage = init$8(sink, editor, lazyAnchorBar);
      var partMenubar = OuterContainer.parts().menubar({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-menubar&apos;]
        },
        backstage: backstage,
        onEscape: function () {
          editor.focus();
        }
      });
      var toolbarMode = getToolbarMode(editor);
      var partToolbar = OuterContainer.parts().toolbar(__assign({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar&apos;]
        },
        getSink: lazySink,
        providers: backstage.shared.providers,
        onEscape: function () {
          editor.focus();
        },
        type: toolbarMode,
        lazyToolbar: lazyToolbar,
        lazyHeader: function () {
          return lazyHeader().getOrDie(&apos;Could not find header element&apos;);
        }
      }, verticalDirAttributes));
      var partMultipleToolbar = OuterContainer.parts()[&apos;multiple-toolbar&apos;]({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-toolbar-overlord&apos;]
        },
        providers: backstage.shared.providers,
        onEscape: function () {
        },
        type: toolbarMode
      });
      var partSocket = OuterContainer.parts().socket({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-edit-area&apos;]
        }
      });
      var partSidebar = OuterContainer.parts().sidebar({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-sidebar&apos;]
        }
      });
      var partThrobber = OuterContainer.parts().throbber({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-throbber&apos;]
        },
        backstage: backstage
      });
      var sb = editor.getParam(&apos;statusbar&apos;, true, &apos;boolean&apos;);
      var statusbar = sb &amp;&amp; !isInline ? Option.some(renderStatusbar(editor, backstage.shared.providers)) : Option.none();
      var socketSidebarContainer = {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-sidebar-wrap&apos;]
        },
        components: [
          partSocket,
          partSidebar
        ]
      };
      var hasMultipleToolbar = isMultipleToolbars(editor);
      var hasToolbar = isToolbarEnabled(editor);
      var hasMenubar = isMenubarEnabled(editor);
      var getPartToolbar = function () {
        if (hasMultipleToolbar) {
          return [partMultipleToolbar];
        } else if (hasToolbar) {
          return [partToolbar];
        } else {
          return [];
        }
      };
      var partHeader = OuterContainer.parts().header({
        dom: __assign({
          tag: &apos;div&apos;,
          classes: [&apos;tox-editor-header&apos;]
        }, verticalDirAttributes),
        components: flatten([
          hasMenubar ? [partMenubar] : [],
          getPartToolbar(),
          useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]
        ]),
        sticky: isStickyToolbar(editor),
        editor: editor,
        sharedBackstage: backstage.shared
      });
      var editorComponents = flatten([
        isToolbarBottom ? [] : [partHeader],
        isInline ? [] : [socketSidebarContainer],
        isToolbarBottom ? [partHeader] : []
      ]);
      var editorContainer = {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-editor-container&apos;]
        },
        components: editorComponents
      };
      var containerComponents = flatten([
        [editorContainer],
        isInline ? [] : statusbar.toArray(),
        [partThrobber]
      ]);
      var isHidden = isDistractionFree(editor);
      var attributes = __assign(__assign({ role: &apos;application&apos; }, global$5.isRtl() ? { dir: &apos;rtl&apos; } : {}), isHidden ? { &apos;aria-hidden&apos;: &apos;true&apos; } : {});
      var outerContainer = build$1(OuterContainer.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox&apos;,
            &apos;tox-tinymce&apos;
          ].concat(isInline ? [&apos;tox-tinymce-inline&apos;] : []).concat(isToolbarBottom ? [&apos;tox-tinymce--toolbar-bottom&apos;] : []).concat(deviceClasses).concat(platformClasses),
          styles: __assign({ visibility: &apos;hidden&apos; }, isHidden ? {
            opacity: &apos;0&apos;,
            border: &apos;0&apos;
          } : {}),
          attributes: attributes
        },
        components: containerComponents,
        behaviours: derive$1([Keying.config({
            mode: &apos;cyclic&apos;,
            selector: &apos;.tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a&apos;
          })])
      }));
      lazyOuterContainer = Option.some(outerContainer);
      editor.shortcuts.add(&apos;alt+F9&apos;, &apos;focus menubar&apos;, function () {
        OuterContainer.focusMenubar(outerContainer);
      });
      editor.shortcuts.add(&apos;alt+F10&apos;, &apos;focus toolbar&apos;, function () {
        OuterContainer.focusToolbar(outerContainer);
      });
      var mothership = takeover(outerContainer);
      var uiMothership = takeover(sink);
      setup$3(editor, mothership, uiMothership);
      var getUi = function () {
        var channels = {
          broadcastAll: uiMothership.broadcast,
          broadcastOn: uiMothership.broadcastOn,
          register: function () {
          }
        };
        return { channels: channels };
      };
      var setEditorSize = function () {
        var parsedHeight = numToPx(getHeightWithFallback(editor));
        var parsedWidth = numToPx(getWidthWithFallback(editor));
        if (!editor.inline) {
          if (isValidValue(&apos;div&apos;, &apos;width&apos;, parsedWidth)) {
            set$2(outerContainer.element(), &apos;width&apos;, parsedWidth);
          }
          if (isValidValue(&apos;div&apos;, &apos;height&apos;, parsedHeight)) {
            set$2(outerContainer.element(), &apos;height&apos;, parsedHeight);
          } else {
            set$2(outerContainer.element(), &apos;height&apos;, &apos;200px&apos;);
          }
        }
        return parsedHeight;
      };
      var renderUI = function () {
        header.setup(editor, backstage.shared, lazyHeader);
        setup$8(editor, backstage);
        setup$9(editor, lazySink, backstage);
        setup$6(editor);
        setup$7(editor, lazyThrobber, backstage.shared);
        map$1(getToolbarGroups(editor), function (toolbarGroupButtonConfig, name) {
          editor.ui.registry.addGroupToolbarButton(name, toolbarGroupButtonConfig);
        });
        var _a = editor.ui.registry.getAll(), buttons = _a.buttons, menuItems = _a.menuItems, contextToolbars = _a.contextToolbars, sidebars = _a.sidebars;
        var toolbarOpt = getMultipleToolbarsSetting(editor);
        var rawUiConfig = {
          menuItems: menuItems,
          menus: !editor.settings.menu ? {} : map$1(editor.settings.menu, function (menu) {
            return __assign(__assign({}, menu), { items: menu.items });
          }),
          menubar: editor.settings.menubar,
          toolbar: toolbarOpt.getOrThunk(function () {
            return editor.getParam(&apos;toolbar&apos;, true);
          }),
          allowToolbarGroups: toolbarMode === ToolbarMode.floating,
          buttons: buttons,
          sidebar: sidebars
        };
        register$4(editor, contextToolbars, sink, { backstage: backstage });
        setup$a(editor, sink);
        var elm = editor.getElement();
        var height = setEditorSize();
        var uiComponents = {
          mothership: mothership,
          uiMothership: uiMothership,
          outerContainer: outerContainer
        };
        var args = {
          targetNode: elm,
          height: height
        };
        return mode.render(editor, uiComponents, rawUiConfig, backstage, args);
      };
      return {
        mothership: mothership,
        uiMothership: uiMothership,
        backstage: backstage,
        renderUI: renderUI,
        getUi: getUi
      };
    };

    var describedBy = function (describedElement, describeElement) {
      var describeId = Option.from(get$2(describedElement, &apos;id&apos;)).fold(function () {
        var id = generate$1(&apos;dialog-describe&apos;);
        set$1(describeElement, &apos;id&apos;, id);
        return id;
      }, identity);
      set$1(describedElement, &apos;aria-describedby&apos;, describeId);
    };

    var labelledBy = function (labelledElement, labelElement) {
      var labelId = Option.from(get$2(labelledElement, &apos;id&apos;)).fold(function () {
        var id = generate$1(&apos;dialog-label&apos;);
        set$1(labelElement, &apos;id&apos;, id);
        return id;
      }, identity);
      set$1(labelledElement, &apos;aria-labelledby&apos;, labelId);
    };

    var schema$x = constant([
      strict$1(&apos;lazySink&apos;),
      option(&apos;dragBlockClass&apos;),
      defaultedFunction(&apos;getBounds&apos;, win),
      defaulted$1(&apos;useTabstopAt&apos;, constant(true)),
      defaulted$1(&apos;eventOrder&apos;, {}),
      field$1(&apos;modalBehaviours&apos;, [Keying]),
      onKeyboardHandler(&apos;onExecute&apos;),
      onStrictKeyboardHandler(&apos;onEscape&apos;)
    ]);
    var basic = { sketch: identity };
    var parts$f = constant([
      optional({
        name: &apos;draghandle&apos;,
        overrides: function (detail, spec) {
          return {
            behaviours: derive$1([Dragging.config({
                mode: &apos;mouse&apos;,
                getTarget: function (handle) {
                  return ancestor$2(handle, &apos;[role=&quot;dialog&quot;]&apos;).getOr(handle);
                },
                blockerClass: detail.dragBlockClass.getOrDie(new Error(&apos;The drag blocker class was not specified for a dialog with a drag handle: \n&apos; + JSON.stringify(spec, null, 2)).message),
                getBounds: detail.getDragBounds
              })])
          };
        }
      }),
      required({
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;title&apos;
      }),
      required({
        factory: basic,
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;close&apos;
      }),
      required({
        factory: basic,
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;body&apos;
      }),
      optional({
        factory: basic,
        schema: [strict$1(&apos;dom&apos;)],
        name: &apos;footer&apos;
      }),
      external$1({
        factory: {
          sketch: function (spec, detail) {
            return __assign(__assign({}, spec), {
              dom: detail.dom,
              components: detail.components
            });
          }
        },
        schema: [
          defaulted$1(&apos;dom&apos;, {
            tag: &apos;div&apos;,
            styles: {
              position: &apos;fixed&apos;,
              left: &apos;0px&apos;,
              top: &apos;0px&apos;,
              right: &apos;0px&apos;,
              bottom: &apos;0px&apos;
            }
          }),
          defaulted$1(&apos;components&apos;, [])
        ],
        name: &apos;blocker&apos;
      })
    ]);

    var factory$i = function (detail, components, spec, externals) {
      var dialogBusyEvent = generate$1(&apos;alloy.dialog.busy&apos;);
      var dialogIdleEvent = generate$1(&apos;alloy.dialog.idle&apos;);
      var busyBehaviours = derive$1([
        Keying.config({
          mode: &apos;special&apos;,
          onTab: function () {
            return Option.some(true);
          },
          onShiftTab: function () {
            return Option.some(true);
          }
        }),
        Focusing.config({})
      ]);
      var showDialog = function (dialog) {
        var sink = detail.lazySink(dialog).getOrDie();
        var busyComp = Cell(Option.none());
        var externalBlocker = externals.blocker();
        var blocker = sink.getSystem().build(__assign(__assign({}, externalBlocker), {
          components: externalBlocker.components.concat([premade$1(dialog)]),
          behaviours: derive$1([
            Focusing.config({}),
            config(&apos;dialog-blocker-events&apos;, [
              runOnSource(focusin(), function () {
                Keying.focusIn(dialog);
              }),
              run(dialogIdleEvent, function (_blocker, _se) {
                if (has$1(dialog.element(), &apos;aria-busy&apos;)) {
                  remove$1(dialog.element(), &apos;aria-busy&apos;);
                  busyComp.get().each(function (bc) {
                    return Replacing.remove(dialog, bc);
                  });
                }
              }),
              run(dialogBusyEvent, function (blocker, se) {
                set$1(dialog.element(), &apos;aria-busy&apos;, &apos;true&apos;);
                var getBusySpec = se.event().getBusySpec();
                busyComp.get().each(function (bc) {
                  Replacing.remove(dialog, bc);
                });
                var busySpec = getBusySpec(dialog, busyBehaviours);
                var busy = blocker.getSystem().build(busySpec);
                busyComp.set(Option.some(busy));
                Replacing.append(dialog, premade$1(busy));
                if (busy.hasConfigured(Keying)) {
                  Keying.focusIn(busy);
                }
              })
            ])
          ])
        }));
        attach$1(sink, blocker);
        Keying.focusIn(dialog);
      };
      var hideDialog = function (dialog) {
        parent(dialog.element()).each(function (blockerDom) {
          dialog.getSystem().getByDom(blockerDom).each(function (blocker) {
            detach(blocker);
          });
        });
      };
      var getDialogBody = function (dialog) {
        return getPartOrDie(dialog, detail, &apos;body&apos;);
      };
      var getDialogFooter = function (dialog) {
        return getPartOrDie(dialog, detail, &apos;footer&apos;);
      };
      var setBusy = function (dialog, getBusySpec) {
        emitWith(dialog, dialogBusyEvent, { getBusySpec: getBusySpec });
      };
      var setIdle = function (dialog) {
        emit(dialog, dialogIdleEvent);
      };
      var modalEventsId = generate$1(&apos;modal-events&apos;);
      var eventOrder = __assign(__assign({}, detail.eventOrder), { &apos;alloy.system.attached&apos;: [modalEventsId].concat(detail.eventOrder[&apos;alloy.system.attached&apos;] || []) });
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        apis: {
          show: showDialog,
          hide: hideDialog,
          getBody: getDialogBody,
          getFooter: getDialogFooter,
          setIdle: setIdle,
          setBusy: setBusy
        },
        eventOrder: eventOrder,
        domModification: {
          attributes: {
            &apos;role&apos;: &apos;dialog&apos;,
            &apos;aria-modal&apos;: &apos;true&apos;
          }
        },
        behaviours: augment(detail.modalBehaviours, [
          Replacing.config({}),
          Keying.config({
            mode: &apos;cyclic&apos;,
            onEnter: detail.onExecute,
            onEscape: detail.onEscape,
            useTabstopAt: detail.useTabstopAt
          }),
          config(modalEventsId, [runOnAttached(function (c) {
              labelledBy(c.element(), getPartOrDie(c, detail, &apos;title&apos;).element());
              describedBy(c.element(), getPartOrDie(c, detail, &apos;body&apos;).element());
            })])
        ])
      };
    };
    var ModalDialog = composite$1({
      name: &apos;ModalDialog&apos;,
      configFields: schema$x(),
      partFields: parts$f(),
      factory: factory$i,
      apis: {
        show: function (apis, dialog) {
          apis.show(dialog);
        },
        hide: function (apis, dialog) {
          apis.hide(dialog);
        },
        getBody: function (apis, dialog) {
          return apis.getBody(dialog);
        },
        getFooter: function (apis, dialog) {
          return apis.getFooter(dialog);
        },
        setBusy: function (apis, dialog, getBusySpec) {
          apis.setBusy(dialog, getBusySpec);
        },
        setIdle: function (apis, dialog) {
          apis.setIdle(dialog);
        }
      }
    });

    var alertBannerFields = [
      strictString(&apos;type&apos;),
      strictString(&apos;text&apos;),
      strictStringEnum(&apos;level&apos;, [
        &apos;info&apos;,
        &apos;warn&apos;,
        &apos;error&apos;,
        &apos;success&apos;
      ]),
      strictString(&apos;icon&apos;),
      defaulted$1(&apos;url&apos;, &apos;&apos;)
    ];
    var alertBannerSchema = objOf(alertBannerFields);

    var createBarFields = function (itemsField) {
      return [
        strictString(&apos;type&apos;),
        itemsField
      ];
    };

    var buttonFields = [
      strictString(&apos;type&apos;),
      strictString(&apos;text&apos;),
      defaultedBoolean(&apos;disabled&apos;, false),
      defaultedBoolean(&apos;primary&apos;, false),
      field(&apos;name&apos;, &apos;name&apos;, defaultedThunk(function () {
        return generate$1(&apos;button-name&apos;);
      }), string),
      optionString(&apos;icon&apos;),
      defaultedBoolean(&apos;borderless&apos;, false)
    ];
    var buttonSchema = objOf(buttonFields);

    var checkboxFields = [
      strictString(&apos;type&apos;),
      strictString(&apos;name&apos;),
      strictString(&apos;label&apos;),
      defaultedBoolean(&apos;disabled&apos;, false)
    ];
    var checkboxSchema = objOf(checkboxFields);
    var checkboxDataProcessor = boolean;

    var formComponentFields = [
      strictString(&apos;type&apos;),
      strictString(&apos;name&apos;)
    ];
    var formComponentWithLabelFields = formComponentFields.concat([optionString(&apos;label&apos;)]);

    var colorInputFields = formComponentWithLabelFields;
    var colorInputSchema = objOf(colorInputFields);
    var colorInputDataProcessor = string;

    var colorPickerFields = formComponentWithLabelFields;
    var colorPickerSchema = objOf(colorPickerFields);
    var colorPickerDataProcessor = string;

    var dropZoneFields = formComponentWithLabelFields;
    var dropZoneSchema = objOf(dropZoneFields);
    var dropZoneDataProcessor = arrOfVal();

    var createGridFields = function (itemsField) {
      return [
        strictString(&apos;type&apos;),
        strictNumber(&apos;columns&apos;),
        itemsField
      ];
    };

    var iframeFields = formComponentWithLabelFields.concat([defaultedBoolean(&apos;sandboxed&apos;, true)]);
    var iframeSchema = objOf(iframeFields);
    var iframeDataProcessor = string;

    var inputFields = formComponentWithLabelFields.concat([
      optionString(&apos;inputMode&apos;),
      optionString(&apos;placeholder&apos;),
      defaultedBoolean(&apos;maximized&apos;, false),
      defaultedBoolean(&apos;disabled&apos;, false)
    ]);
    var inputSchema = objOf(inputFields);
    var inputDataProcessor = string;

    var selectBoxFields = formComponentWithLabelFields.concat([
      strictArrayOfObj(&apos;items&apos;, [
        strictString(&apos;text&apos;),
        strictString(&apos;value&apos;)
      ]),
      defaultedNumber(&apos;size&apos;, 1),
      defaultedBoolean(&apos;disabled&apos;, false)
    ]);
    var selectBoxSchema = objOf(selectBoxFields);
    var selectBoxDataProcessor = string;

    var sizeInputFields = formComponentWithLabelFields.concat([
      defaultedBoolean(&apos;constrain&apos;, true),
      defaultedBoolean(&apos;disabled&apos;, false)
    ]);
    var sizeInputSchema = objOf(sizeInputFields);
    var sizeInputDataProcessor = objOf([
      strictString(&apos;width&apos;),
      strictString(&apos;height&apos;)
    ]);

    var textAreaFields = formComponentWithLabelFields.concat([
      optionString(&apos;placeholder&apos;),
      defaultedBoolean(&apos;maximized&apos;, false),
      defaultedBoolean(&apos;disabled&apos;, false)
    ]);
    var textAreaSchema = objOf(textAreaFields);
    var textAreaDataProcessor = string;

    var urlInputFields = formComponentWithLabelFields.concat([
      defaultedStringEnum(&apos;filetype&apos;, &apos;file&apos;, [
        &apos;image&apos;,
        &apos;media&apos;,
        &apos;file&apos;
      ]),
      defaulted$1(&apos;disabled&apos;, false)
    ]);
    var urlInputSchema = objOf(urlInputFields);
    var urlInputDataProcessor = objOf([
      strictString(&apos;value&apos;),
      defaulted$1(&apos;meta&apos;, {})
    ]);

    var customEditorFields = formComponentFields.concat([
      defaultedString(&apos;tag&apos;, &apos;textarea&apos;),
      strictString(&apos;scriptId&apos;),
      strictString(&apos;scriptUrl&apos;),
      defaultedPostMsg(&apos;settings&apos;, undefined)
    ]);
    var customEditorFieldsOld = formComponentFields.concat([
      defaultedString(&apos;tag&apos;, &apos;textarea&apos;),
      strictFunction(&apos;init&apos;)
    ]);
    var customEditorSchema = valueOf(function (v) {
      return asRaw(&apos;customeditor.old&apos;, objOfOnly(customEditorFieldsOld), v).orThunk(function () {
        return asRaw(&apos;customeditor.new&apos;, objOfOnly(customEditorFields), v);
      });
    });
    var customEditorDataProcessor = string;

    var htmlPanelFields = [
      strictString(&apos;type&apos;),
      strictString(&apos;html&apos;),
      defaultedStringEnum(&apos;presets&apos;, &apos;presentation&apos;, [
        &apos;presentation&apos;,
        &apos;document&apos;
      ])
    ];
    var htmlPanelSchema = objOf(htmlPanelFields);

    var imageToolsFields = formComponentWithLabelFields.concat([strictOf(&apos;currentState&apos;, objOf([
        strict$1(&apos;blob&apos;),
        strictString(&apos;url&apos;)
      ]))]);
    var imageToolsSchema = objOf(imageToolsFields);

    var collectionFields = formComponentWithLabelFields.concat([defaulted$1(&apos;columns&apos;, &apos;auto&apos;)]);
    var collectionSchema = objOf(collectionFields);
    var collectionDataProcessor = arrOfObj$1([
      strictString(&apos;value&apos;),
      strictString(&apos;text&apos;),
      strictString(&apos;icon&apos;)
    ]);

    var createLabelFields = function (itemsField) {
      return [
        strictString(&apos;type&apos;),
        strictString(&apos;label&apos;),
        itemsField
      ];
    };

    var tableFields = [
      strictString(&apos;type&apos;),
      strictArrayOf(&apos;header&apos;, string),
      strictArrayOf(&apos;cells&apos;, arrOf(string))
    ];
    var tableSchema = objOf(tableFields);

    var createItemsField = function (name) {
      return field(&apos;items&apos;, &apos;items&apos;, strict(), arrOf(valueOf(function (v) {
        return asRaw(&apos;Checking item of &apos; + name, itemSchema$2, v).fold(function (sErr) {
          return Result.error(formatError(sErr));
        }, function (passValue) {
          return Result.value(passValue);
        });
      })));
    };
    var itemSchema$2 = valueThunkOf(function () {
      return chooseProcessor(&apos;type&apos;, {
        alertbanner: alertBannerSchema,
        bar: objOf(createBarFields(createItemsField(&apos;bar&apos;))),
        button: buttonSchema,
        checkbox: checkboxSchema,
        colorinput: colorInputSchema,
        colorpicker: colorPickerSchema,
        dropzone: dropZoneSchema,
        grid: objOf(createGridFields(createItemsField(&apos;grid&apos;))),
        iframe: iframeSchema,
        input: inputSchema,
        selectbox: selectBoxSchema,
        sizeinput: sizeInputSchema,
        textarea: textAreaSchema,
        urlinput: urlInputSchema,
        customeditor: customEditorSchema,
        htmlpanel: htmlPanelSchema,
        imagetools: imageToolsSchema,
        collection: collectionSchema,
        label: objOf(createLabelFields(createItemsField(&apos;label&apos;))),
        table: tableSchema,
        panel: panelSchema
      });
    });
    var panelFields = [
      strictString(&apos;type&apos;),
      defaulted$1(&apos;classes&apos;, []),
      strictArrayOf(&apos;items&apos;, itemSchema$2)
    ];
    var panelSchema = objOf(panelFields);

    var tabFields = [
      field(&apos;name&apos;, &apos;name&apos;, defaultedThunk(function () {
        return generate$1(&apos;tab-name&apos;);
      }), string),
      strictString(&apos;title&apos;),
      strictArrayOf(&apos;items&apos;, itemSchema$2)
    ];
    var tabPanelFields = [
      strictString(&apos;type&apos;),
      strictArrayOfObj(&apos;tabs&apos;, tabFields)
    ];
    var tabPanelSchema = objOf(tabPanelFields);

    var dialogToggleMenuItemSchema = objOf([
      strictString(&apos;type&apos;),
      strictString(&apos;name&apos;)
    ].concat(commonMenuItemFields));
    var dialogToggleMenuItemDataProcessor = boolean;

    var baseButtonFields = [
      field(&apos;name&apos;, &apos;name&apos;, defaultedThunk(function () {
        return generate$1(&apos;button-name&apos;);
      }), string),
      optionString(&apos;icon&apos;),
      defaultedStringEnum(&apos;align&apos;, &apos;end&apos;, [
        &apos;start&apos;,
        &apos;end&apos;
      ]),
      defaultedBoolean(&apos;primary&apos;, false),
      defaultedBoolean(&apos;disabled&apos;, false)
    ];
    var dialogButtonFields = __spreadArrays(baseButtonFields, [strictString(&apos;text&apos;)]);
    var normalButtonFields = __spreadArrays([strictStringEnum(&apos;type&apos;, [
        &apos;submit&apos;,
        &apos;cancel&apos;,
        &apos;custom&apos;
      ])], dialogButtonFields);
    var menuButtonFields = __spreadArrays([
      strictStringEnum(&apos;type&apos;, [&apos;menu&apos;]),
      optionString(&apos;text&apos;),
      optionString(&apos;tooltip&apos;),
      optionString(&apos;icon&apos;),
      strictArrayOf(&apos;items&apos;, dialogToggleMenuItemSchema)
    ], baseButtonFields);
    var dialogButtonSchema = choose$1(&apos;type&apos;, {
      submit: normalButtonFields,
      cancel: normalButtonFields,
      custom: normalButtonFields,
      menu: menuButtonFields
    });

    var dialogButtonFields$1 = dialogButtonFields;
    var dialogButtonSchema$1 = dialogButtonSchema;
    var dialogSchema = objOf([
      strictString(&apos;title&apos;),
      strictOf(&apos;body&apos;, chooseProcessor(&apos;type&apos;, {
        panel: panelSchema,
        tabpanel: tabPanelSchema
      })),
      defaultedString(&apos;size&apos;, &apos;normal&apos;),
      strictArrayOf(&apos;buttons&apos;, dialogButtonSchema$1),
      defaulted$1(&apos;initialData&apos;, {}),
      defaultedFunction(&apos;onAction&apos;, noop),
      defaultedFunction(&apos;onChange&apos;, noop),
      defaultedFunction(&apos;onSubmit&apos;, noop),
      defaultedFunction(&apos;onClose&apos;, noop),
      defaultedFunction(&apos;onCancel&apos;, noop),
      defaulted$1(&apos;onTabChange&apos;, noop)
    ]);
    var createDialog = function (spec) {
      return asRaw(&apos;dialog&apos;, dialogSchema, spec);
    };

    var getAllObjects = function (obj) {
      if (isObject(obj)) {
        return [obj].concat(bind(values(obj), getAllObjects));
      } else if (isArray(obj)) {
        return bind(obj, getAllObjects);
      } else {
        return [];
      }
    };

    var isNamedItem = function (obj) {
      return isString(obj.type) &amp;&amp; isString(obj.name);
    };
    var dataProcessors = {
      checkbox: checkboxDataProcessor,
      colorinput: colorInputDataProcessor,
      colorpicker: colorPickerDataProcessor,
      dropzone: dropZoneDataProcessor,
      input: inputDataProcessor,
      iframe: iframeDataProcessor,
      sizeinput: sizeInputDataProcessor,
      selectbox: selectBoxDataProcessor,
      size: sizeInputDataProcessor,
      textarea: textAreaDataProcessor,
      urlinput: urlInputDataProcessor,
      customeditor: customEditorDataProcessor,
      collection: collectionDataProcessor,
      togglemenuitem: dialogToggleMenuItemDataProcessor
    };
    var getDataProcessor = function (item) {
      return Option.from(dataProcessors[item.type]);
    };
    var getNamedItems = function (structure) {
      return filter(getAllObjects(structure), isNamedItem);
    };

    var createDataValidator = function (structure) {
      var namedItems = getNamedItems(structure);
      var fields = bind(namedItems, function (item) {
        return getDataProcessor(item).fold(function () {
          return [];
        }, function (schema) {
          return [strictOf(item.name, schema)];
        });
      });
      return objOf(fields);
    };

    var urlDialogButtonSchema = objOf(__spreadArrays([strictStringEnum(&apos;type&apos;, [
        &apos;cancel&apos;,
        &apos;custom&apos;
      ])], dialogButtonFields$1));
    var urlDialogSchema = objOf([
      strictString(&apos;title&apos;),
      strictString(&apos;url&apos;),
      optionNumber(&apos;height&apos;),
      optionNumber(&apos;width&apos;),
      optionArrayOf(&apos;buttons&apos;, urlDialogButtonSchema),
      defaultedFunction(&apos;onAction&apos;, noop),
      defaultedFunction(&apos;onCancel&apos;, noop),
      defaultedFunction(&apos;onClose&apos;, noop),
      defaultedFunction(&apos;onMessage&apos;, noop)
    ]);
    var createUrlDialog = function (spec) {
      return asRaw(&apos;dialog&apos;, urlDialogSchema, spec);
    };

    var extract$1 = function (structure) {
      var internalDialog = getOrDie(createDialog(structure));
      var dataValidator = createDataValidator(structure);
      var initialData = structure.initialData;
      return {
        internalDialog: internalDialog,
        dataValidator: dataValidator,
        initialData: initialData
      };
    };
    var DialogManager = {
      open: function (factory, structure) {
        var extraction = extract$1(structure);
        return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
      },
      openUrl: function (factory, structure) {
        var internalDialog = getOrDie(createUrlDialog(structure));
        return factory(internalDialog);
      },
      redial: function (structure) {
        return extract$1(structure);
      }
    };

    var toValidValues = function (values) {
      var errors = [];
      var result = {};
      each$1(values, function (value, name) {
        value.fold(function () {
          errors.push(name);
        }, function (v) {
          result[name] = v;
        });
      });
      return errors.length &gt; 0 ? Result.error(errors) : Result.value(result);
    };

    var renderBodyPanel = function (spec, backstage) {
      var memForm = record(Form.sketch(function (parts) {
        return {
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-form&apos;].concat(spec.classes)
          },
          components: map(spec.items, function (item) {
            return interpretInForm(parts, item, backstage);
          })
        };
      }));
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__body&apos;]
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-dialog__body-content&apos;]
            },
            components: [memForm.asSpec()]
          }],
        behaviours: derive$1([
          Keying.config({
            mode: &apos;acyclic&apos;,
            useTabstopAt: not(isPseudoStop)
          }),
          ComposingConfigs.memento(memForm),
          RepresentingConfigs.memento(memForm, {
            postprocess: function (formValue) {
              return toValidValues(formValue).fold(function (err) {
                domGlobals.console.error(err);
                return {};
              }, function (vals) {
                return vals;
              });
            }
          })
        ])
      };
    };

    var factory$j = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: detail.components,
        events: events$7(detail.action),
        behaviours: augment(detail.tabButtonBehaviours, [
          Focusing.config({}),
          Keying.config({
            mode: &apos;execution&apos;,
            useSpace: true,
            useEnter: true
          }),
          Representing.config({
            store: {
              mode: &apos;memory&apos;,
              initialValue: detail.value
            }
          })
        ]),
        domModification: detail.domModification
      };
    };
    var TabButton = single$2({
      name: &apos;TabButton&apos;,
      configFields: [
        defaulted$1(&apos;uid&apos;, undefined),
        strict$1(&apos;value&apos;),
        field(&apos;dom&apos;, &apos;dom&apos;, mergeWithThunk(function () {
          return {
            attributes: {
              &apos;role&apos;: &apos;tab&apos;,
              &apos;id&apos;: generate$1(&apos;aria&apos;),
              &apos;aria-selected&apos;: &apos;false&apos;
            }
          };
        }), anyValue$1()),
        option(&apos;action&apos;),
        defaulted$1(&apos;domModification&apos;, {}),
        field$1(&apos;tabButtonBehaviours&apos;, [
          Focusing,
          Keying,
          Representing
        ]),
        strict$1(&apos;view&apos;)
      ],
      factory: factory$j
    });

    var schema$y = constant([
      strict$1(&apos;tabs&apos;),
      strict$1(&apos;dom&apos;),
      defaulted$1(&apos;clickToDismiss&apos;, false),
      field$1(&apos;tabbarBehaviours&apos;, [
        Highlighting,
        Keying
      ]),
      markers([
        &apos;tabClass&apos;,
        &apos;selectedClass&apos;
      ])
    ]);
    var tabsPart = group({
      factory: TabButton,
      name: &apos;tabs&apos;,
      unit: &apos;tab&apos;,
      overrides: function (barDetail) {
        var dismissTab$1 = function (tabbar, button) {
          Highlighting.dehighlight(tabbar, button);
          emitWith(tabbar, dismissTab(), {
            tabbar: tabbar,
            button: button
          });
        };
        var changeTab$1 = function (tabbar, button) {
          Highlighting.highlight(tabbar, button);
          emitWith(tabbar, changeTab(), {
            tabbar: tabbar,
            button: button
          });
        };
        return {
          action: function (button) {
            var tabbar = button.getSystem().getByUid(barDetail.uid).getOrDie();
            var activeButton = Highlighting.isHighlighted(tabbar, button);
            var response = function () {
              if (activeButton &amp;&amp; barDetail.clickToDismiss) {
                return dismissTab$1;
              } else if (!activeButton) {
                return changeTab$1;
              } else {
                return noop;
              }
            }();
            response(tabbar, button);
          },
          domModification: { classes: [barDetail.markers.tabClass] }
        };
      }
    });
    var parts$g = constant([tabsPart]);

    var factory$k = function (detail, components, _spec, _externals) {
      return {
        &apos;uid&apos;: detail.uid,
        &apos;dom&apos;: detail.dom,
        components: components,
        &apos;debug.sketcher&apos;: &apos;Tabbar&apos;,
        &apos;domModification&apos;: { attributes: { role: &apos;tablist&apos; } },
        &apos;behaviours&apos;: augment(detail.tabbarBehaviours, [
          Highlighting.config({
            highlightClass: detail.markers.selectedClass,
            itemClass: detail.markers.tabClass,
            onHighlight: function (tabbar, tab) {
              set$1(tab.element(), &apos;aria-selected&apos;, &apos;true&apos;);
            },
            onDehighlight: function (tabbar, tab) {
              set$1(tab.element(), &apos;aria-selected&apos;, &apos;false&apos;);
            }
          }),
          Keying.config({
            mode: &apos;flow&apos;,
            getInitial: function (tabbar) {
              return Highlighting.getHighlighted(tabbar).map(function (tab) {
                return tab.element();
              });
            },
            selector: &apos;.&apos; + detail.markers.tabClass,
            executeOnMove: true
          })
        ])
      };
    };
    var Tabbar = composite$1({
      name: &apos;Tabbar&apos;,
      configFields: schema$y(),
      partFields: parts$g(),
      factory: factory$k
    });

    var factory$l = function (detail, _spec) {
      return {
        uid: detail.uid,
        dom: detail.dom,
        behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),
        domModification: { attributes: { role: &apos;tabpanel&apos; } }
      };
    };
    var Tabview = single$2({
      name: &apos;Tabview&apos;,
      configFields: [field$1(&apos;tabviewBehaviours&apos;, [Replacing])],
      factory: factory$l
    });

    var schema$z = constant([
      defaulted$1(&apos;selectFirst&apos;, true),
      onHandler(&apos;onChangeTab&apos;),
      onHandler(&apos;onDismissTab&apos;),
      defaulted$1(&apos;tabs&apos;, []),
      field$1(&apos;tabSectionBehaviours&apos;, [])
    ]);
    var barPart = required({
      factory: Tabbar,
      schema: [
        strict$1(&apos;dom&apos;),
        strictObjOf(&apos;markers&apos;, [
          strict$1(&apos;tabClass&apos;),
          strict$1(&apos;selectedClass&apos;)
        ])
      ],
      name: &apos;tabbar&apos;,
      defaults: function (detail) {
        return { tabs: detail.tabs };
      }
    });
    var viewPart = required({
      factory: Tabview,
      name: &apos;tabview&apos;
    });
    var parts$h = constant([
      barPart,
      viewPart
    ]);

    var factory$m = function (detail, components, _spec, _externals) {
      var changeTab$1 = function (button) {
        var tabValue = Representing.getValue(button);
        getPart(button, detail, &apos;tabview&apos;).each(function (tabview) {
          var tabWithValue = find(detail.tabs, function (t) {
            return t.value === tabValue;
          });
          tabWithValue.each(function (tabData) {
            var panel = tabData.view();
            getOpt(button.element(), &apos;id&apos;).each(function (id) {
              set$1(tabview.element(), &apos;aria-labelledby&apos;, id);
            });
            Replacing.set(tabview, panel);
            detail.onChangeTab(tabview, button, panel);
          });
        });
      };
      var changeTabBy = function (section, byPred) {
        getPart(section, detail, &apos;tabbar&apos;).each(function (tabbar) {
          byPred(tabbar).each(emitExecute);
        });
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: components,
        behaviours: get$c(detail.tabSectionBehaviours),
        events: derive(flatten([
          detail.selectFirst ? [runOnAttached(function (section, _simulatedEvent) {
              changeTabBy(section, Highlighting.getFirst);
            })] : [],
          [
            run(changeTab(), function (section, simulatedEvent) {
              var button = simulatedEvent.event().button();
              changeTab$1(button);
            }),
            run(dismissTab(), function (section, simulatedEvent) {
              var button = simulatedEvent.event().button();
              detail.onDismissTab(section, button);
            })
          ]
        ])),
        apis: {
          getViewItems: function (section) {
            return getPart(section, detail, &apos;tabview&apos;).map(function (tabview) {
              return Replacing.contents(tabview);
            }).getOr([]);
          },
          showTab: function (section, tabKey) {
            var getTabIfNotActive = function (tabbar) {
              var candidates = Highlighting.getCandidates(tabbar);
              var optTab = find(candidates, function (c) {
                return Representing.getValue(c) === tabKey;
              });
              return optTab.filter(function (tab) {
                return !Highlighting.isHighlighted(tabbar, tab);
              });
            };
            changeTabBy(section, getTabIfNotActive);
          }
        }
      };
    };
    var TabSection = composite$1({
      name: &apos;TabSection&apos;,
      configFields: schema$z(),
      partFields: parts$h(),
      factory: factory$m,
      apis: {
        getViewItems: function (apis, component) {
          return apis.getViewItems(component);
        },
        showTab: function (apis, component, tabKey) {
          apis.showTab(component, tabKey);
        }
      }
    });

    var measureHeights = function (allTabs, tabview, tabviewComp) {
      return map(allTabs, function (_tab, i) {
        Replacing.set(tabviewComp, allTabs[i].view());
        var rect = tabview.dom().getBoundingClientRect();
        Replacing.set(tabviewComp, []);
        return rect.height;
      });
    };
    var getMaxHeight = function (heights) {
      return head(sort(heights, function (a, b) {
        if (a &gt; b) {
          return -1;
        } else if (a &lt; b) {
          return +1;
        } else {
          return 0;
        }
      }));
    };
    var getMaxTabviewHeight = function (dialog, tabview, tablist) {
      var documentElement$1 = documentElement(dialog).dom();
      var rootElm = ancestor$2(dialog, &apos;.tox-dialog-wrap&apos;).getOr(dialog);
      var isFixed = get$4(rootElm, &apos;position&apos;) === &apos;fixed&apos;;
      var maxHeight;
      if (isFixed) {
        maxHeight = Math.max(documentElement$1.clientHeight, domGlobals.window.innerHeight);
      } else {
        maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
      }
      var tabviewHeight = get$6(tabview);
      var isTabListBeside = tabview.dom().offsetLeft &gt;= tablist.dom().offsetLeft + get$7(tablist);
      var currentTabHeight = isTabListBeside ? Math.max(get$6(tablist), tabviewHeight) : tabviewHeight;
      var dialogTopMargin = parseInt(get$4(dialog, &apos;margin-top&apos;), 10) || 0;
      var dialogBottomMargin = parseInt(get$4(dialog, &apos;margin-bottom&apos;), 10) || 0;
      var dialogHeight = get$6(dialog) + dialogTopMargin + dialogBottomMargin;
      var chromeHeight = dialogHeight - currentTabHeight;
      return maxHeight - chromeHeight;
    };
    var showTab = function (allTabs, comp) {
      head(allTabs).each(function (tab) {
        return TabSection.showTab(comp, tab.value);
      });
    };
    var setTabviewHeight = function (tabview, height) {
      set$2(tabview, &apos;height&apos;, height + &apos;px&apos;);
      if (!detect$3().browser.isIE()) {
        set$2(tabview, &apos;flex-basis&apos;, height + &apos;px&apos;);
      } else {
        remove$6(tabview, &apos;flex-basis&apos;);
      }
    };
    var updateTabviewHeight = function (dialogBody, tabview, maxTabHeight) {
      ancestor$2(dialogBody, &apos;[role=&quot;dialog&quot;]&apos;).each(function (dialog) {
        descendant$1(dialog, &apos;[role=&quot;tablist&quot;]&apos;).each(function (tablist) {
          maxTabHeight.get().map(function (height) {
            set$2(tabview, &apos;height&apos;, &apos;0&apos;);
            set$2(tabview, &apos;flex-basis&apos;, &apos;0&apos;);
            return Math.min(height, getMaxTabviewHeight(dialog, tabview, tablist));
          }).each(function (height) {
            setTabviewHeight(tabview, height);
          });
        });
      });
    };
    var getTabview = function (dialog) {
      return descendant$1(dialog, &apos;[role=&quot;tabpanel&quot;]&apos;);
    };
    var setMode = function (allTabs) {
      var smartTabHeight = function () {
        var maxTabHeight = Cell(Option.none());
        var extraEvents = [
          runOnAttached(function (comp) {
            var dialog = comp.element();
            getTabview(dialog).each(function (tabview) {
              set$2(tabview, &apos;visibility&apos;, &apos;hidden&apos;);
              comp.getSystem().getByDom(tabview).toOption().each(function (tabviewComp) {
                var heights = measureHeights(allTabs, tabview, tabviewComp);
                var maxTabHeightOpt = getMaxHeight(heights);
                maxTabHeight.set(maxTabHeightOpt);
              });
              updateTabviewHeight(dialog, tabview, maxTabHeight);
              remove$6(tabview, &apos;visibility&apos;);
              showTab(allTabs, comp);
              global$2.requestAnimationFrame(function () {
                updateTabviewHeight(dialog, tabview, maxTabHeight);
              });
            });
          }),
          run(windowResize(), function (comp) {
            var dialog = comp.element();
            getTabview(dialog).each(function (tabview) {
              updateTabviewHeight(dialog, tabview, maxTabHeight);
            });
          }),
          run(formResizeEvent, function (comp, _se) {
            var dialog = comp.element();
            getTabview(dialog).each(function (tabview) {
              var oldFocus = active();
              set$2(tabview, &apos;visibility&apos;, &apos;hidden&apos;);
              var oldHeight = getRaw(tabview, &apos;height&apos;).map(function (h) {
                return parseInt(h, 10);
              });
              remove$6(tabview, &apos;height&apos;);
              remove$6(tabview, &apos;flex-basis&apos;);
              var newHeight = tabview.dom().getBoundingClientRect().height;
              var hasGrown = oldHeight.forall(function (h) {
                return newHeight &gt; h;
              });
              if (hasGrown) {
                maxTabHeight.set(Option.from(newHeight));
                updateTabviewHeight(dialog, tabview, maxTabHeight);
              } else {
                oldHeight.each(function (h) {
                  setTabviewHeight(tabview, h);
                });
              }
              remove$6(tabview, &apos;visibility&apos;);
              oldFocus.each(focus$1);
            });
          })
        ];
        var selectFirst = false;
        return {
          extraEvents: extraEvents,
          selectFirst: selectFirst
        };
      }();
      var naiveTabHeight = function () {
        var extraEvents = [];
        var selectFirst = true;
        return {
          extraEvents: extraEvents,
          selectFirst: selectFirst
        };
      }();
      return {
        smartTabHeight: smartTabHeight,
        naiveTabHeight: naiveTabHeight
      };
    };

    var SendDataToSectionChannel = &apos;send-data-to-section&apos;;
    var SendDataToViewChannel = &apos;send-data-to-view&apos;;
    var renderTabPanel = function (spec, backstage) {
      var storedValue = Cell({});
      var updateDataWithForm = function (form) {
        var formData = Representing.getValue(form);
        var validData = toValidValues(formData).getOr({});
        var currentData = storedValue.get();
        var newData = deepMerge(currentData, validData);
        storedValue.set(newData);
      };
      var setDataOnForm = function (form) {
        var tabData = storedValue.get();
        Representing.setValue(form, tabData);
      };
      var oldTab = Cell(null);
      var allTabs = map(spec.tabs, function (tab) {
        return {
          value: tab.name,
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-dialog__body-nav-item&apos;],
            innerHtml: backstage.shared.providers.translate(tab.title)
          },
          view: function () {
            return [Form.sketch(function (parts) {
                return {
                  dom: {
                    tag: &apos;div&apos;,
                    classes: [&apos;tox-form&apos;]
                  },
                  components: map(tab.items, function (item) {
                    return interpretInForm(parts, item, backstage);
                  }),
                  formBehaviours: derive$1([
                    Keying.config({
                      mode: &apos;acyclic&apos;,
                      useTabstopAt: not(isPseudoStop)
                    }),
                    config(&apos;TabView.form.events&apos;, [
                      runOnAttached(setDataOnForm),
                      runOnDetached(updateDataWithForm)
                    ]),
                    Receiving.config({
                      channels: wrapAll$1([
                        {
                          key: SendDataToSectionChannel,
                          value: { onReceive: updateDataWithForm }
                        },
                        {
                          key: SendDataToViewChannel,
                          value: { onReceive: setDataOnForm }
                        }
                      ])
                    })
                  ])
                };
              })];
          }
        };
      });
      var tabMode = setMode(allTabs).smartTabHeight;
      return TabSection.sketch({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__body&apos;]
        },
        onChangeTab: function (section, button, _viewItems) {
          var name = Representing.getValue(button);
          emitWith(section, formTabChangeEvent, {
            name: name,
            oldName: oldTab.get()
          });
          oldTab.set(name);
        },
        tabs: allTabs,
        components: [
          TabSection.parts().tabbar({
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-dialog__body-nav&apos;]
            },
            components: [Tabbar.parts().tabs({})],
            markers: {
              tabClass: &apos;tox-tab&apos;,
              selectedClass: &apos;tox-dialog__body-nav-item--active&apos;
            },
            tabbarBehaviours: derive$1([Tabstopping.config({})])
          }),
          TabSection.parts().tabview({
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-dialog__body-content&apos;]
            }
          })
        ],
        selectFirst: tabMode.selectFirst,
        tabSectionBehaviours: derive$1([
          config(&apos;tabpanel&apos;, tabMode.extraEvents),
          Keying.config({ mode: &apos;acyclic&apos; }),
          Composing.config({
            find: function (comp) {
              return head(TabSection.getViewItems(comp));
            }
          }),
          Representing.config({
            store: {
              mode: &apos;manual&apos;,
              getValue: function (tsection) {
                tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});
                return storedValue.get();
              },
              setValue: function (tsection, value) {
                storedValue.set(value);
                tsection.getSystem().broadcastOn([SendDataToViewChannel], {});
              }
            }
          })
        ])
      });
    };

    var dialogChannel = generate$1(&apos;update-dialog&apos;);
    var titleChannel = generate$1(&apos;update-title&apos;);
    var bodyChannel = generate$1(&apos;update-body&apos;);
    var footerChannel = generate$1(&apos;update-footer&apos;);
    var bodySendMessageChannel = generate$1(&apos;body-send-message&apos;);

    var renderBody = function (spec, id, backstage, ariaAttrs) {
      var renderComponents = function (incoming) {
        switch (incoming.body.type) {
        case &apos;tabpanel&apos;: {
            return [renderTabPanel(incoming.body, backstage)];
          }
        default: {
            return [renderBodyPanel(incoming.body, backstage)];
          }
        }
      };
      var updateState = function (_comp, incoming) {
        return Option.some({
          isTabPanel: function () {
            return incoming.body.type === &apos;tabpanel&apos;;
          }
        });
      };
      var ariaAttributes = { &apos;aria-live&apos;: &apos;polite&apos; };
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__content-js&apos;],
          attributes: __assign(__assign({}, id.map(function (x) {
            return { id: x };
          }).getOr({})), ariaAttrs ? ariaAttributes : {})
        },
        components: [],
        behaviours: derive$1([
          ComposingConfigs.childAt(0),
          Reflecting.config({
            channel: bodyChannel,
            updateState: updateState,
            renderComponents: renderComponents,
            initialData: spec
          })
        ])
      };
    };
    var renderInlineBody = function (spec, contentId, backstage, ariaAttrs) {
      return renderBody(spec, Option.some(contentId), backstage, ariaAttrs);
    };
    var renderModalBody = function (spec, backstage) {
      var bodySpec = renderBody(spec, Option.none(), backstage, false);
      return ModalDialog.parts().body(bodySpec);
    };
    var renderIframeBody = function (spec) {
      var bodySpec = {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__content-js&apos;]
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-dialog__body-iframe&apos;]
            },
            components: [craft({
                dom: {
                  tag: &apos;iframe&apos;,
                  attributes: { src: spec.url }
                },
                behaviours: derive$1([
                  Tabstopping.config({}),
                  Focusing.config({})
                ])
              })]
          }],
        behaviours: derive$1([Keying.config({
            mode: &apos;acyclic&apos;,
            useTabstopAt: not(isPseudoStop)
          })])
      };
      return ModalDialog.parts().body(bodySpec);
    };

    var isTouch = global$6.deviceType.isTouch();
    var hiddenHeader = function (title, close) {
      return {
        dom: {
          tag: &apos;div&apos;,
          styles: { display: &apos;none&apos; },
          classes: [&apos;tox-dialog__header&apos;]
        },
        components: [
          title,
          close
        ]
      };
    };
    var pClose = function (onClose, providersBackstage) {
      return ModalDialog.parts().close(Button.sketch({
        dom: {
          tag: &apos;button&apos;,
          classes: [
            &apos;tox-button&apos;,
            &apos;tox-button--icon&apos;,
            &apos;tox-button--naked&apos;
          ],
          attributes: {
            &apos;type&apos;: &apos;button&apos;,
            &apos;aria-label&apos;: providersBackstage.translate(&apos;Close&apos;)
          }
        },
        action: onClose,
        buttonBehaviours: derive$1([Tabstopping.config({})])
      }));
    };
    var pUntitled = function () {
      return ModalDialog.parts().title({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__title&apos;],
          innerHtml: &apos;&apos;,
          styles: { display: &apos;none&apos; }
        }
      });
    };
    var pBodyMessage = function (message, providersBackstage) {
      return ModalDialog.parts().body({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__body&apos;]
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-dialog__body-content&apos;]
            },
            components: [{ dom: fromHtml$2(&apos;&lt;p&gt;&apos; + providersBackstage.translate(message) + &apos;&lt;/p&gt;&apos;) }]
          }]
      });
    };
    var pFooter = function (buttons) {
      return ModalDialog.parts().footer({
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__footer&apos;]
        },
        components: buttons
      });
    };
    var pFooterGroup = function (startButtons, endButtons) {
      return [
        Container.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-dialog__footer-start&apos;]
          },
          components: startButtons
        }),
        Container.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-dialog__footer-end&apos;]
          },
          components: endButtons
        })
      ];
    };
    var renderDialog = function (spec) {
      var _a;
      var dialogClass = &apos;tox-dialog&apos;;
      var blockerClass = dialogClass + &apos;-wrap&apos;;
      var blockerBackdropClass = blockerClass + &apos;__backdrop&apos;;
      var scrollLockClass = dialogClass + &apos;__disable-scroll&apos;;
      return ModalDialog.sketch({
        lazySink: spec.lazySink,
        onEscape: function (comp) {
          spec.onEscape(comp);
          return Option.some(true);
        },
        useTabstopAt: function (elem) {
          return !isPseudoStop(elem);
        },
        dom: {
          tag: &apos;div&apos;,
          classes: [dialogClass].concat(spec.extraClasses),
          styles: __assign({ position: &apos;relative&apos; }, spec.extraStyles)
        },
        components: __spreadArrays([
          spec.header,
          spec.body
        ], spec.footer.toArray()),
        parts: {
          blocker: {
            dom: fromHtml$2(&apos;&lt;div class=&quot;&apos; + blockerClass + &apos;&quot;&gt;&lt;/div&gt;&apos;),
            components: [{
                dom: {
                  tag: &apos;div&apos;,
                  classes: isTouch ? [
                    blockerBackdropClass,
                    blockerBackdropClass + &apos;--opaque&apos;
                  ] : [blockerBackdropClass]
                }
              }]
          }
        },
        dragBlockClass: blockerClass,
        modalBehaviours: derive$1(__spreadArrays([
          Focusing.config({}),
          config(&apos;dialog-events&apos;, spec.dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {
              Keying.focusIn(comp);
            })])),
          config(&apos;scroll-lock&apos;, [
            runOnAttached(function () {
              add$2(body(), scrollLockClass);
            }),
            runOnDetached(function () {
              remove$4(body(), scrollLockClass);
            })
          ])
        ], spec.extraBehaviours)),
        eventOrder: __assign((_a = {}, _a[execute()] = [&apos;dialog-events&apos;], _a[attachedToDom()] = [
          &apos;scroll-lock&apos;,
          &apos;dialog-events&apos;,
          &apos;alloy.base.behaviour&apos;
        ], _a[detachedFromDom()] = [
          &apos;alloy.base.behaviour&apos;,
          &apos;dialog-events&apos;,
          &apos;scroll-lock&apos;
        ], _a), spec.eventOrder)
      });
    };

    var renderClose = function (providersBackstage) {
      return Button.sketch({
        dom: {
          tag: &apos;button&apos;,
          classes: [
            &apos;tox-button&apos;,
            &apos;tox-button--icon&apos;,
            &apos;tox-button--naked&apos;
          ],
          attributes: {
            &apos;type&apos;: &apos;button&apos;,
            &apos;aria-label&apos;: providersBackstage.translate(&apos;Close&apos;),
            &apos;title&apos;: providersBackstage.translate(&apos;Close&apos;)
          }
        },
        components: [{
            dom: {
              tag: &apos;div&apos;,
              classes: [&apos;tox-icon&apos;],
              innerHtml: &apos;&lt;svg width=&quot;24&quot; height=&quot;24&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&apos; + &apos;&lt;path d=&quot;M17.953 7.453L13.422 12l4.531 4.547-1.406 1.406L12 &apos; + &apos;13.422l-4.547 4.531-1.406-1.406L10.578 12 6.047 &apos; + &apos;7.453l1.406-1.406L12 10.578l4.547-4.531z&quot; &apos; + &apos;fill-rule=&quot;evenodd&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&apos;
            }
          }],
        action: function (comp) {
          emit(comp, formCancelEvent);
        }
      });
    };
    var renderTitle = function (spec, id, providersBackstage) {
      var renderComponents = function (data) {
        return [text(providersBackstage.translate(data.title))];
      };
      return {
        dom: {
          tag: &apos;div&apos;,
          classes: [&apos;tox-dialog__title&apos;],
          attributes: __assign({}, id.map(function (x) {
            return { id: x };
          }).getOr({}))
        },
        components: renderComponents(spec),
        behaviours: derive$1([Reflecting.config({
            channel: titleChannel,
            renderComponents: renderComponents
          })])
      };
    };
    var renderDragHandle = function () {
      return { dom: fromHtml$2(&apos;&lt;div class=&quot;tox-dialog__draghandle&quot;&gt;&lt;/div&gt;&apos;) };
    };
    var renderInlineHeader = function (spec, titleId, providersBackstage) {
      return Container.sketch({
        dom: fromHtml$2(&apos;&lt;div class=&quot;tox-dialog__header&quot;&gt;&lt;/div&gt;&apos;),
        components: [
          renderTitle(spec, Option.some(titleId), providersBackstage),
          renderDragHandle(),
          renderClose(providersBackstage)
        ],
        containerBehaviours: derive$1([Dragging.config({
            mode: &apos;mouse&apos;,
            blockerClass: &apos;blocker&apos;,
            getTarget: function (handle) {
              return closest$3(handle, &apos;[role=&quot;dialog&quot;]&apos;).getOrDie();
            },
            snaps: {
              getSnapPoints: function () {
                return [];
              },
              leftAttr: &apos;data-drag-left&apos;,
              topAttr: &apos;data-drag-top&apos;
            }
          })])
      });
    };
    var renderModalHeader = function (spec, providersBackstage) {
      var pTitle = ModalDialog.parts().title(renderTitle(spec, Option.none(), providersBackstage));
      var pHandle = ModalDialog.parts().draghandle(renderDragHandle());
      var pClose = ModalDialog.parts().close(renderClose(providersBackstage));
      var components = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose]);
      return Container.sketch({
        dom: fromHtml$2(&apos;&lt;div class=&quot;tox-dialog__header&quot;&gt;&lt;/div&gt;&apos;),
        components: components
      });
    };

    var getHeader = function (title, backstage) {
      return renderModalHeader({
        title: backstage.shared.providers.translate(title),
        draggable: backstage.dialog.isDraggableModal()
      }, backstage.shared.providers);
    };
    var getEventExtras = function (lazyDialog, extra) {
      return {
        onClose: function () {
          return extra.closeWindow();
        },
        onBlock: function (blockEvent) {
          ModalDialog.setBusy(lazyDialog(), function (d, bs) {
            return {
              dom: {
                tag: &apos;div&apos;,
                classes: [&apos;tox-dialog__busy-spinner&apos;],
                attributes: { &apos;aria-label&apos;: blockEvent.message() },
                styles: {
                  left: &apos;0px&apos;,
                  right: &apos;0px&apos;,
                  bottom: &apos;0px&apos;,
                  top: &apos;0px&apos;,
                  position: &apos;absolute&apos;
                }
              },
              behaviours: bs,
              components: [{ dom: fromHtml$2(&apos;&lt;div class=&quot;tox-spinner&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&apos;) }]
            };
          });
        },
        onUnblock: function () {
          ModalDialog.setIdle(lazyDialog());
        }
      };
    };
    var renderModalDialog = function (spec, initialData, dialogEvents, backstage) {
      var _a;
      var updateState = function (_comp, incoming) {
        return Option.some(incoming);
      };
      return build$1(renderDialog(__assign(__assign({}, spec), {
        lazySink: backstage.shared.getSink,
        extraBehaviours: __spreadArrays([
          Reflecting.config({
            channel: dialogChannel,
            updateState: updateState,
            initialData: initialData
          }),
          RepresentingConfigs.memory({})
        ], spec.extraBehaviours),
        onEscape: function (comp) {
          emit(comp, formCancelEvent);
        },
        dialogEvents: dialogEvents,
        eventOrder: (_a = {}, _a[receive()] = [
          &apos;reflecting&apos;,
          &apos;receiving&apos;
        ], _a[attachedToDom()] = [
          &apos;scroll-lock&apos;,
          &apos;reflecting&apos;,
          &apos;messages&apos;,
          &apos;dialog-events&apos;,
          &apos;alloy.base.behaviour&apos;
        ], _a[detachedFromDom()] = [
          &apos;alloy.base.behaviour&apos;,
          &apos;dialog-events&apos;,
          &apos;messages&apos;,
          &apos;reflecting&apos;,
          &apos;scroll-lock&apos;
        ], _a)
      })));
    };
    var mapMenuButtons = function (buttons) {
      var mapItems = function (button) {
        var items = map(button.items, function (item) {
          var cell = Cell(false);
          return __assign(__assign({}, item), { storage: cell });
        });
        return __assign(__assign({}, button), { items: items });
      };
      return map(buttons, function (button) {
        if (button.type === &apos;menu&apos;) {
          return mapItems(button);
        }
        return button;
      });
    };
    var extractCellsToObject = function (buttons) {
      return foldl(buttons, function (acc, button) {
        if (button.type === &apos;menu&apos;) {
          var menuButton = button;
          return foldl(menuButton.items, function (innerAcc, item) {
            innerAcc[item.name] = item.storage;
            return innerAcc;
          }, acc);
        }
        return acc;
      }, {});
    };

    var initCommonEvents = function (fireApiEvent, extras) {
      return [
        runWithTarget(focusin(), onFocus$1),
        fireApiEvent(formCloseEvent, function (_api, spec) {
          extras.onClose();
          spec.onClose();
        }),
        fireApiEvent(formCancelEvent, function (api, spec, _event, self) {
          spec.onCancel(api);
          emit(self, formCloseEvent);
        }),
        run(formUnblockEvent, function (_c, _se) {
          return extras.onUnblock();
        }),
        run(formBlockEvent, function (_c, se) {
          return extras.onBlock(se.event());
        })
      ];
    };
    var initUrlDialog = function (getInstanceApi, extras) {
      var fireApiEvent = function (eventName, f) {
        return run(eventName, function (c, se) {
          withSpec(c, function (spec, _c) {
            f(getInstanceApi(), spec, se.event(), c);
          });
        });
      };
      var withSpec = function (c, f) {
        Reflecting.getState(c).get().each(function (currentDialog) {
          f(currentDialog, c);
        });
      };
      return __spreadArrays(initCommonEvents(fireApiEvent, extras), [fireApiEvent(formActionEvent, function (api, spec, event) {
          spec.onAction(api, { name: event.name() });
        })]);
    };
    var initDialog = function (getInstanceApi, extras, getSink) {
      var fireApiEvent = function (eventName, f) {
        return run(eventName, function (c, se) {
          withSpec(c, function (spec, _c) {
            f(getInstanceApi(), spec, se.event(), c);
          });
        });
      };
      var withSpec = function (c, f) {
        Reflecting.getState(c).get().each(function (currentDialogInit) {
          f(currentDialogInit.internalDialog, c);
        });
      };
      return __spreadArrays(initCommonEvents(fireApiEvent, extras), [
        fireApiEvent(formSubmitEvent, function (api, spec) {
          return spec.onSubmit(api);
        }),
        fireApiEvent(formChangeEvent, function (api, spec, event) {
          spec.onChange(api, { name: event.name() });
        }),
        fireApiEvent(formActionEvent, function (api, spec, event, component) {
          var focusIn = function () {
            return Keying.focusIn(component);
          };
          var isDisabled = function (focused) {
            return has$1(focused, &apos;disabled&apos;) || getOpt(focused, &apos;aria-disabled&apos;).exists(function (val) {
              return val === &apos;true&apos;;
            });
          };
          var current = active();
          spec.onAction(api, {
            name: event.name(),
            value: event.value()
          });
          active().fold(focusIn, function (focused) {
            if (isDisabled(focused)) {
              focusIn();
            } else if (current.exists(function (cur) {
                return contains$2(focused, cur) &amp;&amp; isDisabled(cur);
              })) {
              focusIn();
            } else {
              getSink().toOption().filter(function (sink) {
                return !contains$2(sink.element(), focused);
              }).each(focusIn);
            }
          });
        }),
        fireApiEvent(formTabChangeEvent, function (api, spec, event) {
          spec.onTabChange(api, {
            newTabName: event.name(),
            oldTabName: event.oldName()
          });
        }),
        runOnDetached(function (component) {
          var api = getInstanceApi();
          Representing.setValue(component, api.getData());
        })
      ]);
    };
    var SilverDialogEvents = {
      initUrlDialog: initUrlDialog,
      initDialog: initDialog
    };

    var makeButton = function (button, backstage) {
      return renderFooterButton(button, button.type, backstage);
    };
    var lookup$2 = function (compInSystem, footerButtons, buttonName) {
      return find(footerButtons, function (button) {
        return button.name === buttonName;
      }).bind(function (memButton) {
        return memButton.memento.getOpt(compInSystem);
      });
    };
    var renderComponents = function (_data, state) {
      var footerButtons = state.map(function (s) {
        return s.footerButtons;
      }).getOr([]);
      var buttonGroups = partition(footerButtons, function (button) {
        return button.align === &apos;start&apos;;
      });
      var makeGroup = function (edge, buttons) {
        return Container.sketch({
          dom: {
            tag: &apos;div&apos;,
            classes: [&apos;tox-dialog__footer-&apos; + edge]
          },
          components: map(buttons, function (button) {
            return button.memento.asSpec();
          })
        });
      };
      var startButtons = makeGroup(&apos;start&apos;, buttonGroups.pass);
      var endButtons = makeGroup(&apos;end&apos;, buttonGroups.fail);
      return [
        startButtons,
        endButtons
      ];
    };
    var renderFooter = function (initSpec, backstage) {
      var updateState = function (_comp, data) {
        var footerButtons = map(data.buttons, function (button) {
          var memButton = record(makeButton(button, backstage));
          return {
            name: button.name,
            align: button.align,
            memento: memButton
          };
        });
        var lookupByName = function (compInSystem, buttonName) {
          return lookup$2(compInSystem, footerButtons, buttonName);
        };
        return Option.some({
          lookupByName: lookupByName,
          footerButtons: footerButtons
        });
      };
      return {
        dom: fromHtml$2(&apos;&lt;div class=&quot;tox-dialog__footer&quot;&gt;&lt;/div&gt;&apos;),
        components: [],
        behaviours: derive$1([Reflecting.config({
            channel: footerChannel,
            initialData: initSpec,
            updateState: updateState,
            renderComponents: renderComponents
          })])
      };
    };
    var renderInlineFooter = function (initSpec, backstage) {
      return renderFooter(initSpec, backstage);
    };
    var renderModalFooter = function (initSpec, backstage) {
      return ModalDialog.parts().footer(renderFooter(initSpec, backstage));
    };

    var getCompByName = function (access, name) {
      var root = access.getRoot();
      if (root.getSystem().isConnected()) {
        var form_1 = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
        return Form.getField(form_1, name).fold(function () {
          var footer = access.getFooter();
          var footerState = Reflecting.getState(footer);
          return footerState.get().bind(function (f) {
            return f.lookupByName(form_1, name);
          });
        }, function (comp) {
          return Option.some(comp);
        });
      } else {
        return Option.none();
      }
    };
    var validateData = function (access, data) {
      var root = access.getRoot();
      return Reflecting.getState(root).get().map(function (dialogState) {
        return getOrDie(asRaw(&apos;data&apos;, dialogState.dataValidator, data));
      }).getOr(data);
    };
    var getDialogApi = function (access, doRedial, menuItemStates) {
      var withRoot = function (f) {
        var root = access.getRoot();
        if (root.getSystem().isConnected()) {
          f(root);
        }
      };
      var getData = function () {
        var root = access.getRoot();
        var valueComp = root.getSystem().isConnected() ? access.getFormWrapper() : root;
        var representedValues = Representing.getValue(valueComp);
        var menuItemCurrentState = map$1(menuItemStates, function (cell) {
          return cell.get();
        });
        return __assign(__assign({}, representedValues), menuItemCurrentState);
      };
      var setData = function (newData) {
        withRoot(function (_) {
          var prevData = instanceApi.getData();
          var mergedData = __assign(__assign({}, prevData), newData);
          var newInternalData = validateData(access, mergedData);
          var form = access.getFormWrapper();
          Representing.setValue(form, newInternalData);
          each$1(menuItemStates, function (v, k) {
            if (has(mergedData, k)) {
              v.set(mergedData[k]);
            }
          });
        });
      };
      var disable = function (name) {
        getCompByName(access, name).each(Disabling.disable);
      };
      var enable = function (name) {
        getCompByName(access, name).each(Disabling.enable);
      };
      var focus = function (name) {
        getCompByName(access, name).each(Focusing.focus);
      };
      var block = function (message) {
        if (!isString(message)) {
          throw new Error(&apos;The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument&apos;);
        }
        withRoot(function (root) {
          emitWith(root, formBlockEvent, { message: message });
        });
      };
      var unblock = function () {
        withRoot(function (root) {
          emit(root, formUnblockEvent);
        });
      };
      var showTab = function (name) {
        withRoot(function (_) {
          var body = access.getBody();
          var bodyState = Reflecting.getState(body);
          if (bodyState.get().exists(function (b) {
              return b.isTabPanel();
            })) {
            Composing.getCurrent(body).each(function (tabSection) {
              TabSection.showTab(tabSection, name);
            });
          }
        });
      };
      var redial = function (d) {
        withRoot(function (root) {
          var dialogInit = doRedial(d);
          root.getSystem().broadcastOn([dialogChannel], dialogInit);
          root.getSystem().broadcastOn([titleChannel], dialogInit.internalDialog);
          root.getSystem().broadcastOn([bodyChannel], dialogInit.internalDialog);
          root.getSystem().broadcastOn([footerChannel], dialogInit.internalDialog);
          instanceApi.setData(dialogInit.initialData);
        });
      };
      var close = function () {
        withRoot(function (root) {
          emit(root, formCloseEvent);
        });
      };
      var instanceApi = {
        getData: getData,
        setData: setData,
        disable: disable,
        enable: enable,
        focus: focus,
        block: block,
        unblock: unblock,
        showTab: showTab,
        redial: redial,
        close: close
      };
      return instanceApi;
    };

    var renderDialog$1 = function (dialogInit, extra, backstage) {
      var header = getHeader(dialogInit.internalDialog.title, backstage);
      var body = renderModalBody({ body: dialogInit.internalDialog.body }, backstage);
      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);
      var objOfCells = extractCellsToObject(storagedMenuButtons);
      var footer = renderModalFooter({ buttons: storagedMenuButtons }, backstage);
      var dialogEvents = SilverDialogEvents.initDialog(function () {
        return instanceApi;
      }, getEventExtras(function () {
        return dialog;
      }, extra), backstage.shared.getSink);
      var dialogSize = dialogInit.internalDialog.size !== &apos;normal&apos; ? dialogInit.internalDialog.size === &apos;large&apos; ? [&apos;tox-dialog--width-lg&apos;] : [&apos;tox-dialog--width-md&apos;] : [];
      var spec = {
        header: header,
        body: body,
        footer: Option.some(footer),
        extraClasses: dialogSize,
        extraBehaviours: [],
        extraStyles: {}
      };
      var dialog = renderModalDialog(spec, dialogInit, dialogEvents, backstage);
      var modalAccess = function () {
        var getForm = function () {
          var outerForm = ModalDialog.getBody(dialog);
          return Composing.getCurrent(outerForm).getOr(outerForm);
        };
        return {
          getRoot: function () {
            return dialog;
          },
          getBody: function () {
            return ModalDialog.getBody(dialog);
          },
          getFooter: function () {
            return ModalDialog.getFooter(dialog);
          },
          getFormWrapper: getForm
        };
      }();
      var instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var renderInlineDialog = function (dialogInit, extra, backstage, ariaAttrs) {
      var _a, _b;
      var dialogLabelId = generate$1(&apos;dialog-label&apos;);
      var dialogContentId = generate$1(&apos;dialog-content&apos;);
      var updateState = function (_comp, incoming) {
        return Option.some(incoming);
      };
      var memHeader = record(renderInlineHeader({
        title: dialogInit.internalDialog.title,
        draggable: true
      }, dialogLabelId, backstage.shared.providers));
      var memBody = record(renderInlineBody({ body: dialogInit.internalDialog.body }, dialogContentId, backstage, ariaAttrs));
      var storagedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons);
      var objOfCells = extractCellsToObject(storagedMenuButtons);
      var memFooter = record(renderInlineFooter({ buttons: storagedMenuButtons }, backstage));
      var dialogEvents = SilverDialogEvents.initDialog(function () {
        return instanceApi;
      }, {
        onBlock: function () {
        },
        onUnblock: function () {
        },
        onClose: function () {
          return extra.closeWindow();
        }
      }, backstage.shared.getSink);
      var dialog = build$1({
        dom: {
          tag: &apos;div&apos;,
          classes: [
            &apos;tox-dialog&apos;,
            &apos;tox-dialog-inline&apos;
          ],
          attributes: (_a = { role: &apos;dialog&apos; }, _a[&apos;aria-labelledby&apos;] = dialogLabelId, _a[&apos;aria-describedby&apos;] = &apos;&apos; + dialogContentId, _a)
        },
        eventOrder: (_b = {}, _b[receive()] = [
          Reflecting.name(),
          Receiving.name()
        ], _b[execute()] = [&apos;execute-on-form&apos;], _b[attachedToDom()] = [
          &apos;reflecting&apos;,
          &apos;execute-on-form&apos;
        ], _b),
        behaviours: derive$1([
          Keying.config({
            mode: &apos;cyclic&apos;,
            onEscape: function (c) {
              emit(c, formCloseEvent);
              return Option.some(true);
            },
            useTabstopAt: function (elem) {
              return !isPseudoStop(elem) &amp;&amp; (name(elem) !== &apos;button&apos; || get$2(elem, &apos;disabled&apos;) !== &apos;disabled&apos;);
            }
          }),
          Reflecting.config({
            channel: dialogChannel,
            updateState: updateState,
            initialData: dialogInit
          }),
          Focusing.config({}),
          config(&apos;execute-on-form&apos;, dialogEvents.concat([runOnSource(focusin(), function (comp, _se) {
              Keying.focusIn(comp);
            })])),
          RepresentingConfigs.memory({})
        ]),
        components: [
          memHeader.asSpec(),
          memBody.asSpec(),
          memFooter.asSpec()
        ]
      });
      var instanceApi = getDialogApi({
        getRoot: function () {
          return dialog;
        },
        getFooter: function () {
          return memFooter.get(dialog);
        },
        getBody: function () {
          return memBody.get(dialog);
        },
        getFormWrapper: function () {
          var body = memBody.get(dialog);
          return Composing.getCurrent(body).getOr(body);
        }
      }, extra.redial, objOfCells);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var global$g = tinymce.util.Tools.resolve(&apos;tinymce.util.URI&apos;);

    var getUrlDialogApi = function (root) {
      var withRoot = function (f) {
        if (root.getSystem().isConnected()) {
          f(root);
        }
      };
      var block = function (message) {
        if (!isString(message)) {
          throw new Error(&apos;The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument&apos;);
        }
        withRoot(function (root) {
          emitWith(root, formBlockEvent, { message: message });
        });
      };
      var unblock = function () {
        withRoot(function (root) {
          emit(root, formUnblockEvent);
        });
      };
      var close = function () {
        withRoot(function (root) {
          emit(root, formCloseEvent);
        });
      };
      var sendMessage = function (data) {
        withRoot(function (root) {
          root.getSystem().broadcastOn([bodySendMessageChannel], data);
        });
      };
      return {
        block: block,
        unblock: unblock,
        close: close,
        sendMessage: sendMessage
      };
    };

    var SUPPORTED_MESSAGE_ACTIONS = [
      &apos;insertContent&apos;,
      &apos;setContent&apos;,
      &apos;execCommand&apos;,
      &apos;close&apos;,
      &apos;block&apos;,
      &apos;unblock&apos;
    ];
    var isSupportedMessage = function (data) {
      return isObject(data) &amp;&amp; SUPPORTED_MESSAGE_ACTIONS.indexOf(data.mceAction) !== -1;
    };
    var isCustomMessage = function (data) {
      return !isSupportedMessage(data) &amp;&amp; isObject(data) &amp;&amp; has(data, &apos;mceAction&apos;);
    };
    var handleMessage = function (editor, api, data) {
      switch (data.mceAction) {
      case &apos;insertContent&apos;:
        editor.insertContent(data.content);
        break;
      case &apos;setContent&apos;:
        editor.setContent(data.content);
        break;
      case &apos;execCommand&apos;:
        var ui = isBoolean(data.ui) ? data.ui : false;
        editor.execCommand(data.cmd, ui, data.value);
        break;
      case &apos;close&apos;:
        api.close();
        break;
      case &apos;block&apos;:
        api.block(data.message);
        break;
      case &apos;unblock&apos;:
        api.unblock();
        break;
      }
    };
    var renderUrlDialog = function (internalDialog, extra, editor, backstage) {
      var _a;
      var header = getHeader(internalDialog.title, backstage);
      var body = renderIframeBody(internalDialog);
      var footer = internalDialog.buttons.bind(function (buttons) {
        if (buttons.length === 0) {
          return Option.none();
        } else {
          return Option.some(renderModalFooter({ buttons: buttons }, backstage));
        }
      });
      var dialogEvents = SilverDialogEvents.initUrlDialog(function () {
        return instanceApi;
      }, getEventExtras(function () {
        return dialog;
      }, extra));
      var styles = __assign(__assign({}, internalDialog.height.fold(function () {
        return {};
      }, function (height) {
        return {
          &apos;height&apos;: height + &apos;px&apos;,
          &apos;max-height&apos;: height + &apos;px&apos;
        };
      })), internalDialog.width.fold(function () {
        return {};
      }, function (width) {
        return {
          &apos;width&apos;: width + &apos;px&apos;,
          &apos;max-width&apos;: width + &apos;px&apos;
        };
      }));
      var classes = internalDialog.width.isNone() &amp;&amp; internalDialog.height.isNone() ? [&apos;tox-dialog--width-lg&apos;] : [];
      var iframeUri = new global$g(internalDialog.url, { base_uri: new global$g(domGlobals.window.location.href) });
      var iframeDomain = iframeUri.protocol + &apos;://&apos; + iframeUri.host + (iframeUri.port ? &apos;:&apos; + iframeUri.port : &apos;&apos;);
      var messageHandlerUnbinder = Cell(Option.none());
      var extraBehaviours = [
        config(&apos;messages&apos;, [
          runOnAttached(function () {
            var unbind = bind$3(Element.fromDom(domGlobals.window), &apos;message&apos;, function (e) {
              if (iframeUri.isSameOrigin(new global$g(e.raw().origin))) {
                var data = e.raw().data;
                if (isSupportedMessage(data)) {
                  handleMessage(editor, instanceApi, data);
                } else if (isCustomMessage(data)) {
                  internalDialog.onMessage(instanceApi, data);
                }
              }
            });
            messageHandlerUnbinder.set(Option.some(unbind));
          }),
          runOnDetached(function () {
            messageHandlerUnbinder.get().each(function (unbinder) {
              return unbinder.unbind();
            });
          })
        ]),
        Receiving.config({
          channels: (_a = {}, _a[bodySendMessageChannel] = {
            onReceive: function (comp, data) {
              descendant$1(comp.element(), &apos;iframe&apos;).each(function (iframeEle) {
                var iframeWin = iframeEle.dom().contentWindow;
                iframeWin.postMessage(data, iframeDomain);
              });
            }
          }, _a)
        })
      ];
      var spec = {
        header: header,
        body: body,
        footer: footer,
        extraClasses: classes,
        extraBehaviours: extraBehaviours,
        extraStyles: styles
      };
      var dialog = renderModalDialog(spec, internalDialog, dialogEvents, backstage);
      var instanceApi = getUrlDialogApi(dialog);
      return {
        dialog: dialog,
        instanceApi: instanceApi
      };
    };

    var setup$c = function (extras) {
      var sharedBackstage = extras.backstage.shared;
      var open = function (message, callback) {
        var closeDialog = function () {
          ModalDialog.hide(alertDialog);
          callback();
        };
        var memFooterClose = record(renderFooterButton({
          name: &apos;close-alert&apos;,
          text: &apos;OK&apos;,
          primary: true,
          align: &apos;end&apos;,
          disabled: false,
          icon: Option.none()
        }, &apos;cancel&apos;, extras.backstage));
        var titleSpec = pUntitled();
        var closeSpec = pClose(closeDialog, sharedBackstage.providers);
        var alertDialog = build$1(renderDialog({
          lazySink: function () {
            return sharedBackstage.getSink();
          },
          header: hiddenHeader(titleSpec, closeSpec),
          body: pBodyMessage(message, sharedBackstage.providers),
          footer: Option.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),
          onEscape: closeDialog,
          extraClasses: [&apos;tox-alert-dialog&apos;],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [run(formCancelEvent, closeDialog)],
          eventOrder: {}
        }));
        ModalDialog.show(alertDialog);
        var footerCloseButton = memFooterClose.get(alertDialog);
        Focusing.focus(footerCloseButton);
      };
      return { open: open };
    };

    var setup$d = function (extras) {
      var sharedBackstage = extras.backstage.shared;
      var open = function (message, callback) {
        var closeDialog = function (state) {
          ModalDialog.hide(confirmDialog);
          callback(state);
        };
        var memFooterYes = record(renderFooterButton({
          name: &apos;yes&apos;,
          text: &apos;Yes&apos;,
          primary: true,
          align: &apos;end&apos;,
          disabled: false,
          icon: Option.none()
        }, &apos;submit&apos;, extras.backstage));
        var footerNo = renderFooterButton({
          name: &apos;no&apos;,
          text: &apos;No&apos;,
          primary: false,
          align: &apos;end&apos;,
          disabled: false,
          icon: Option.none()
        }, &apos;cancel&apos;, extras.backstage);
        var titleSpec = pUntitled();
        var closeSpec = pClose(function () {
          return closeDialog(false);
        }, sharedBackstage.providers);
        var confirmDialog = build$1(renderDialog({
          lazySink: function () {
            return sharedBackstage.getSink();
          },
          header: hiddenHeader(titleSpec, closeSpec),
          body: pBodyMessage(message, sharedBackstage.providers),
          footer: Option.some(pFooter(pFooterGroup([], [
            footerNo,
            memFooterYes.asSpec()
          ]))),
          onEscape: function () {
            return closeDialog(false);
          },
          extraClasses: [&apos;tox-confirm-dialog&apos;],
          extraBehaviours: [],
          extraStyles: {},
          dialogEvents: [
            run(formCancelEvent, function () {
              return closeDialog(false);
            }),
            run(formSubmitEvent, function () {
              return closeDialog(true);
            })
          ],
          eventOrder: {}
        }));
        ModalDialog.show(confirmDialog);
        var footerYesButton = memFooterYes.get(confirmDialog);
        Focusing.focus(footerYesButton);
      };
      return { open: open };
    };

    var validateData$1 = function (data, validator) {
      return getOrDie(asRaw(&apos;data&apos;, validator, data));
    };
    var isAlertOrConfirmDialog = function (target) {
      return closest$4(target, &apos;.tox-alert-dialog&apos;) || closest$4(target, &apos;.tox-confirm-dialog&apos;);
    };
    var inlineAdditionalBehaviours = function (editor, isStickyToolbar, isToolbarLocationTop) {
      if (isStickyToolbar &amp;&amp; isToolbarLocationTop) {
        return [];
      } else {
        return [Docking.config({
            contextual: {
              lazyContext: function () {
                return Option.some(box(Element.fromDom(editor.getContentAreaContainer())));
              },
              fadeInClass: &apos;tox-dialog-dock-fadein&apos;,
              fadeOutClass: &apos;tox-dialog-dock-fadeout&apos;,
              transitionClass: &apos;tox-dialog-dock-transition&apos;
            },
            modes: [&apos;top&apos;]
          })];
      }
    };
    var setup$e = function (extras) {
      var backstage = extras.backstage;
      var editor = extras.editor;
      var isStickyToolbar$1 = isStickyToolbar(editor);
      var alertDialog = setup$c(extras);
      var confirmDialog = setup$d(extras);
      var open = function (config, params, closeWindow) {
        if (params !== undefined &amp;&amp; params.inline === &apos;toolbar&apos;) {
          return openInlineDialog(config, backstage.shared.anchors.inlineDialog(), closeWindow, params.ariaAttrs);
        } else if (params !== undefined &amp;&amp; params.inline === &apos;cursor&apos;) {
          return openInlineDialog(config, backstage.shared.anchors.cursor(), closeWindow, params.ariaAttrs);
        } else {
          return openModalDialog(config, closeWindow);
        }
      };
      var openUrl = function (config, closeWindow) {
        return openModalUrlDialog(config, closeWindow);
      };
      var openModalUrlDialog = function (config, closeWindow) {
        var factory = function (contents) {
          var dialog = renderUrlDialog(contents, {
            closeWindow: function () {
              ModalDialog.hide(dialog.dialog);
              closeWindow(dialog.instanceApi);
            }
          }, editor, backstage);
          ModalDialog.show(dialog.dialog);
          return dialog.instanceApi;
        };
        return DialogManager.openUrl(factory, config);
      };
      var openModalDialog = function (config, closeWindow) {
        var factory = function (contents, internalInitialData, dataValidator) {
          var initialData = internalInitialData;
          var dialogInit = {
            dataValidator: dataValidator,
            initialData: initialData,
            internalDialog: contents
          };
          var dialog = renderDialog$1(dialogInit, {
            redial: DialogManager.redial,
            closeWindow: function () {
              ModalDialog.hide(dialog.dialog);
              closeWindow(dialog.instanceApi);
            }
          }, backstage);
          ModalDialog.show(dialog.dialog);
          dialog.instanceApi.setData(initialData);
          return dialog.instanceApi;
        };
        return DialogManager.open(factory, config);
      };
      var openInlineDialog = function (config$1, anchor, closeWindow, ariaAttrs) {
        var factory = function (contents, internalInitialData, dataValidator) {
          var initialData = validateData$1(internalInitialData, dataValidator);
          var inlineDialog = value$3();
          var isToolbarLocationTop = backstage.shared.header.isPositionedAtTop();
          var dialogInit = {
            dataValidator: dataValidator,
            initialData: initialData,
            internalDialog: contents
          };
          var refreshDocking = function () {
            return inlineDialog.on(function (dialog) {
              InlineView.reposition(dialog);
              Docking.refresh(dialog);
            });
          };
          var dialogUi = renderInlineDialog(dialogInit, {
            redial: DialogManager.redial,
            closeWindow: function () {
              inlineDialog.on(InlineView.hide);
              editor.off(&apos;ResizeEditor&apos;, refreshDocking);
              inlineDialog.clear();
              closeWindow(dialogUi.instanceApi);
            }
          }, backstage, ariaAttrs);
          var inlineDialogComp = build$1(InlineView.sketch(__assign(__assign({
            lazySink: backstage.shared.getSink,
            dom: {
              tag: &apos;div&apos;,
              classes: []
            },
            fireDismissalEventInstead: {}
          }, isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} }), {
            inlineBehaviours: derive$1(__spreadArrays([config(&apos;window-manager-inline-events&apos;, [run(dismissRequested(), function (_comp, _se) {
                  emit(dialogUi.dialog, formCancelEvent);
                })])], inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop))),
            isExtraPart: function (_comp, target) {
              return isAlertOrConfirmDialog(target);
            }
          })));
          inlineDialog.set(inlineDialogComp);
          InlineView.showWithin(inlineDialogComp, anchor, premade$1(dialogUi.dialog), Option.some(body()));
          if (!isStickyToolbar$1 || !isToolbarLocationTop) {
            Docking.refresh(inlineDialogComp);
            editor.on(&apos;ResizeEditor&apos;, refreshDocking);
          }
          dialogUi.instanceApi.setData(initialData);
          Keying.focusIn(dialogUi.dialog);
          return dialogUi.instanceApi;
        };
        return DialogManager.open(factory, config$1);
      };
      var confirm = function (message, callback) {
        confirmDialog.open(message, function (state) {
          callback(state);
        });
      };
      var alert = function (message, callback) {
        alertDialog.open(message, function () {
          callback();
        });
      };
      var close = function (instanceApi) {
        instanceApi.close();
      };
      return {
        open: open,
        openUrl: openUrl,
        alert: alert,
        close: close,
        confirm: confirm
      };
    };

    function Theme () {
      global$1.add(&apos;silver&apos;, function (editor) {
        var _a = setup$b(editor), uiMothership = _a.uiMothership, backstage = _a.backstage, renderUI = _a.renderUI, getUi = _a.getUi;
        Autocompleter.register(editor, backstage.shared);
        var windowMgr = setup$e({
          editor: editor,
          backstage: backstage
        });
        return {
          renderUI: renderUI,
          getWindowManagerImpl: constant(windowMgr),
          getNotificationManagerImpl: function () {
            return NotificationManagerImpl(editor, { backstage: backstage }, uiMothership);
          },
          ui: getUi()
        };
      });
    }

    Theme();

}(window));
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
