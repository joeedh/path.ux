<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="./">
  <title data-ice="title">Manual | path.ux</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="this is awesome library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="path.ux"><meta property="twitter:description" content="this is awesome library"></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/joeedh/path.ux.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#introduction" data-ice="link">Introduction</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#history" data-ice="link">History</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html" data-ice="link">NStructJS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#control-how-fields-are-saved" data-ice="link">Control How Fields Are Saved</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#versioning" data-ice="link">Versioning</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html" data-ice="link">Tool System</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#undo" data-ice="link">Undo</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tooldef--" data-ice="link">tooldef()</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tool-properties" data-ice="link">Tool Properties</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#simple-controller-js" data-ice="link">simple_controller.js</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#type-in-place-api" data-ice="link">Type-In-Place API</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#object-wrapping-example" data-ice="link">Object Wrapping Example</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/context.html"><a href="manual/context.html" data-ice="link">Context design:</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#required-fields" data-ice="link">Required fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#context-overlay-" data-ice="link">Context Overlay:</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#locked-contexts" data-ice="link">Locked contexts</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#tool-contexts" data-ice="link">Tool Contexts</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#introduction" data-ice="link">Introduction</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#history" data-ice="link">History</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/context.html"><a href="manual/context.html" data-ice="link">Context design:</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#required-fields" data-ice="link">Required fields</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#context-overlay-" data-ice="link">Context Overlay:</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#locked-contexts" data-ice="link">Locked contexts</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/context.html"><a href="manual/context.html#tool-contexts" data-ice="link">Tool Contexts</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#simple-controller-js" data-ice="link">simple_controller.js</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#type-in-place-api" data-ice="link">Type-In-Place API</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controller.html"><a href="manual/controller.html#object-wrapping-example" data-ice="link">Object Wrapping Example</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/FrameManager.html"><a href="manual/FrameManager.html" data-ice="link">FrameManager Module</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/index.html"><a href="manual/index.html#introduction" data-ice="link">Introduction</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/index.html"><a href="manual/index.html#architecture" data-ice="link">Architecture</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html" data-ice="link">NStructJS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#control-how-fields-are-saved" data-ice="link">Control How Fields Are Saved</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#versioning" data-ice="link">Versioning</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html" data-ice="link">Tool System</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#undo" data-ice="link">Undo</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tooldef--" data-ice="link">tooldef()</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tool-properties" data-ice="link">Tool Properties</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="introduction">Introduction</h1><p>Path.ux is a small app framework inspired by the architecture of 
Blender, a 3D animation/modeling/visualization app.  </p>
<h1 id="architecture">Architecture</h1><ul>
<li><a href="manual/architecture.html">Overview</a></li>
<li><a href="manual/context.html">Context</a></li>
<li><a href="manual/controller.html">Controller</a></li>
<li><a href="manual/toolprop.html">Tool Properties</a></li>
<li><a href="manual/toolsystem.html">Tool System</a></li>
<li><a href="manual/nstructjs.html">STRUCT</a></li>
<li><a href="manual/FrameManager.html">FrameManager</a></li>
</ul>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>History</h1><p>Path.ux is roughly based on <a href="http://www.blender.org">Blender&apos;s</a> architecture.</p><p><a href="./manual/manual/controller.html">Main page</a></p><p>The Blender 2.5 project refactored the internal architecture into a rough MVC pattern.  The model is the core code, the view is the UI, and the controller is the glue between them.</p><p>The controller is called &quot;RNA&quot; and it uses the concept of object paths. So if you have an object, you could look up type information (and the value of) a property with a simple path, e.g. &quot;object.subobject.some_property&quot;.  Blender uses RNA for its user interface, its python api and its animation system (you can associate object paths with animation curves).</p><p>Internally the controller has a special wrapper API for blender&apos;s c-struct-based pseudo-objects.  This works extremely well as it keeps type information that&apos;s only used by the UI out of the model codebase (e.g. the model might not care that a specific color should be clamped to 0-2 instead of 0-1).  Even better, the object model presented by the controller need not match the internal data structures.</p><p>Since the controller provides type info to the UI a lot of messy boilerplate is avoided, leading to very consise layout code:</p><pre><code><code class="source-code prettyprint">def panel(layout, context):
    row = layout.row
    row.prop(context.object, &quot;some_object_property&quot;)
    row.tool(&quot;mesh.subdivide&quot;)</code>
</code></pre></div>
        <a data-ice="link" href="manual/architecture.html#history"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>NStructJS</h1><p>NStructJS is a little library for saving/loading highly structured JS objects as binary data
(for more info, see the <a href="https://github.com/joeedh/STRUCT/wiki">official documentation</a> ).
It is not suited for unstructed data (use JSON for that).<br>NStructJS arose out of the following shortcomings of JSON:</p><ul>
<li>JSON allocates objects twice.</li>
<li>JSON is slow compared to what you can get with a structured binary format</li>
</ul><p>The idea of NStructJS is to attach little scripts to your classes that define that 
class&apos;s data and how it is saved.  For example:</p><pre><code><code class="source-code prettyprint">class SomeClass {
  constructor() {
    this.data1 = 0;
    this.data2 = [1, 2, 3];
    this.obj = [some object];
  }

  //reader &quot;fills in&quot; fields in a newly created object with loaded data
  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
}
SomeClass.STRUCT = `
my_module.SomeClass {
  data1 : int;
  data2 : array;
  obj   : int | this.obj.id;
}
`;
nstructjs.manager.add_class(SomeClass);</code>
</code></pre><h2>Control How Fields Are Saved</h2><p>You can use little code snippets to control how fields are saved.
For example, if you want to save an integer ID instead of a reference for an 
object property, you might do this:</p><pre><code><code class="source-code prettyprint">my_module.AnotherClass {
  someclass : int | this.someclass !== undefined ? this.someclass.id : -1;
}</code>
</code></pre><h2>Versioning</h2><p>To a certain extend nstructjs will gracefully handle version changes.  The basic idea is to save a
copy of your struct scripts with each file, that way each file knows how to load itself.</p></div>
        <a data-ice="link" href="manual/nstructjs.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Tool System</h1><p>Tools are what the user uses to change state in the model.  They handle undo, can take control of events if needed and 
in general are foundational to path.ux and it&apos;s associated projects.  </p><p>Tools all inherit from <a href="./manual/../class/scripts/toolsys/simple_toolsys.js~ToolOp.html">ToolOp</a>, which roughly looks like this (see Context section for an 
explanation for what the &quot;ctx&quot; parameters are):</p><pre><code><code class="source-code prettyprint">class SomeTool extends ToolOp {
  static tooldef() {return {
    uiname   : &quot;Tool&quot;,
    path     : &quot;module.tool&quot;
    inputs   : ToolOp.inherit({}), //inherit properties from base class
    outputs  : {}
  }}
  static invoke(ctx, args) {
    /*create a new tool instance.
      args is simple key:val mapping
      where val is either a string, a number
      or a boolean.*/
    return new ToolOp()
  }
  undoPre(ctx) {
    //create undo data
  }
  undo(ctx) {
    //execute undo with data made in previous call to this.undoPre
  }
  exec(ctx) {
    //execute tool
  }
  modalStart(ctx) {
    //start interactice mode
  }
  modalEnd(ctx) {
    //end interactive mode
  }
  on_[mousedown/mousemove/mouseup/keydown](ctx) {
    //interactive mode event
  }

  ToolOp.register(SomeTool);
}</code>
</code></pre><h2>Context</h2><p>The foundation of the tool system is a special Context struct that&apos;s provided by client code.  Think of it as defining &quot;arguments&quot; for tools.  Path.ux can use any context struct, but requires the following properties be defined:</p><pre><code><code class="source-code prettyprint">class Context {
  get api() {
    //return reference to a controller.ModelInterface
  }

  get appstate() {
    //return reference to main appstate global
  }

  get screen() {
    //return reference to main FrameManager.screen
  }
}</code>
</code></pre><p>In addition, path.ux has hooks to provide UI context, specifically which are is currently active.  To do this,
either override the following methods in ScreenArea.Area.prototype, or subclass Area:</p><pre><code><code class="source-code prettyprint">  //called when area should be considered &quot;active&quot;
  push_ctx_active() {
  }

  //called when area should be considered &quot;inactive&quot;
  pop_ctx_active() {
  }</code>
</code></pre><h2>Undo</h2><p>Typically tools will inherit from a base class with a general, brute-force undo (i.e. saving the 
entire application and then reloading it on undo).  Additionally to save on speed and memory subclasses 
can override undoPre and undo with their own implementation.</p><h2>tooldef()</h2><p>Tools have a special tooldef() static function that &quot;defines&quot; the tool.  It returns things like
what properties the tool has, it&apos;s name, it&apos;s path in the data path system, etc.</p><h2>Tool Properties</h2><p>Tools have input and output slots.  See toolprop.js.  There are integer properties, float properties, 
various linear algebra properties (vectors, matrices), enumerations, bitflags, and in addition client code
may provide it&apos;s own property classes.</p></div>
        <a data-ice="link" href="manual/toolsystem.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Context design:</h1><p>Context is a simplified API to access the application model.  Contexts are passed around
to ToolOps and used by path.ux.</p><h2>Required fields</h2><p>Call contexts are required to have the following fields:</p><ul>
<li>screen -- the active FrameManager.Screen (or a subclass of it)</li>
<li>api -- the data path controller, (controller.ModelInterface)</li>
<li>toolstack -- The tool operator stack (simple_toolsys.ToolStack)</li>
</ul><h2>Context Overlay:</h2><p>A <a href="./manual/../class/scripts/controller/context.js~ContextOverlay.html">context overlay</a> is a class that overrides context fields.  It has a validate()
method that is polled regularly; if it returns false the overlay is removed.</p><p>Contexts can be &quot;frozen&quot; with .lock.  When frozen they should <em>have no direct object 
references at all</em>, other then .state, .datalib and .api.  </p><p>Properties can control this with &quot;_save&quot; and &quot;_load&quot; methods inside
of the overlay classes, as well as overriding saveProperty and loadProperty
inside of Context subclasses.</p><p>Example of a context overlay:</p><pre><code><code class="source-code prettyprint">class ContextOverlay {
  validate() {
    //check if this overlay is still valid or needs to be removed
  }

  static contextDefine() {return {
    flag    :   0 //see ContextFlags

    //an example of inheritance.  inheritance is automatic for fields
    //that are missing from contextDefine().
    flag    :   Context.inherit([a bitmask to or with parent])
  }}

  get selectedObjects() {
    /*
      if you want to get a property from below the stack in the ctx
      use this.ctx or return Context.super
    */
    if (some_reason) {
        //tell ctx to 
        return Context.super();
    } else {
        //this will also work
        return this.ctx.selectedObjects;
    }

    return this.ctx.scene.objects.selected.editable;
  }

  selectedObjects_save() {
    let ret = [];
    for (let ob of this.selectedObjects) {
        ret.push(ob.id);        
    }

    return ret;
  }

  selectedObjects_load(ctx, data) {
    let ret = [];

    for (let id of data) {
        ret.push([lookup object from data using (possible new) context ctx])
    }

    return ret;
  }
}</code>
</code></pre><h2>Locked contexts</h2><p>Locked contexts are contexts whose properties are &quot;saved&quot;, but not as direct references.
Instead, each property is (ideally) saved as some sort of ID or datapath to look up
the true value on property access.</p><p>We suggest you subclass Context and implement saveProperty and loadProperty methods.</p><pre><code><code class="source-code prettyprint">class Overlay extends ContextOverlay {
  get something() {
    return something;
  }

  something_save() {
    return this.state.something.id;
  }

  something_load(ctx, id) {
    return [lookup id somewhere to get something];
  }
}</code>
</code></pre><h2>Tool Contexts</h2><p>We encourage you to put Context properties related to the view inside
a separate ContextOverlay.  That way you can keep ToolOps from accessing
the view by feeding them a special context that lacks that overlay
(but note that tools in modal mode should always get a full context). </p><pre><code><code class="source-code prettyprint">class ToolOverlay extends ContextOverlay {
    static contextDefine() {return {
        name : &quot;tool&quot;
    }}

    get mesh() {
        return this.state.mesh;
    }

    get material() {
        return this.state.material;
    }
}
Context.register(ToolOverlay);

class ViewOverlay extends ContextOverlay {
    static contextDefine() {return {
        name : &quot;view&quot;,
        flag : ContextFlags.IS_VIEW
    }}

    get screen() {
        return this.state.screen;
    }

    get textEditor() {
        return 
    }
}
Context.register(ToolOverlay);</code>
</code></pre></div>
        <a data-ice="link" href="manual/context.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>History</h1><p>Path.ux is roughly based on <a href="http://www.blender.org">Blender&apos;s</a> architecture.</p><p><a href="./manual/manual/controller.html">Main page</a></p><p>The Blender 2.5 project refactored the internal architecture into a rough MVC pattern.  The model is the core code, the view is the UI, and the controller is the glue between them.</p><p>The controller is called &quot;RNA&quot; and it uses the concept of object paths. So if you have an object, you could look up type information (and the value of) a property with a simple path, e.g. &quot;object.subobject.some_property&quot;.  Blender uses RNA for its user interface, its python api and its animation system (you can associate object paths with animation curves).</p><p>Internally the controller has a special wrapper API for blender&apos;s c-struct-based pseudo-objects.  This works extremely well as it keeps type information that&apos;s only used by the UI out of the model codebase (e.g. the model might not care that a specific color should be clamped to 0-2 instead of 0-1).  Even better, the object model presented by the controller need not match the internal data structures.</p><p>Since the controller provides type info to the UI a lot of messy boilerplate is avoided, leading to very consise layout code:</p><pre><code><code class="source-code prettyprint">def panel(layout, context):
    row = layout.row
    row.prop(context.object, &quot;some_object_property&quot;)
    row.tool(&quot;mesh.subdivide&quot;)</code>
</code></pre></div>
        <a data-ice="link" href="manual/architecture.html#history"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Context design:</h1><p>Context is a simplified API to access the application model.  Contexts are passed around
to ToolOps and used by path.ux.</p><h2>Required fields</h2><p>Call contexts are required to have the following fields:</p><ul>
<li>screen -- the active FrameManager.Screen (or a subclass of it)</li>
<li>api -- the data path controller, (controller.ModelInterface)</li>
<li>toolstack -- The tool operator stack (simple_toolsys.ToolStack)</li>
</ul><h2>Context Overlay:</h2><p>A <a href="./manual/../class/scripts/controller/context.js~ContextOverlay.html">context overlay</a> is a class that overrides context fields.  It has a validate()
method that is polled regularly; if it returns false the overlay is removed.</p><p>Contexts can be &quot;frozen&quot; with .lock.  When frozen they should <em>have no direct object 
references at all</em>, other then .state, .datalib and .api.  </p><p>Properties can control this with &quot;_save&quot; and &quot;_load&quot; methods inside
of the overlay classes, as well as overriding saveProperty and loadProperty
inside of Context subclasses.</p><p>Example of a context overlay:</p><pre><code><code class="source-code prettyprint">class ContextOverlay {
  validate() {
    //check if this overlay is still valid or needs to be removed
  }

  static contextDefine() {return {
    flag    :   0 //see ContextFlags

    //an example of inheritance.  inheritance is automatic for fields
    //that are missing from contextDefine().
    flag    :   Context.inherit([a bitmask to or with parent])
  }}

  get selectedObjects() {
    /*
      if you want to get a property from below the stack in the ctx
      use this.ctx or return Context.super
    */
    if (some_reason) {
        //tell ctx to 
        return Context.super();
    } else {
        //this will also work
        return this.ctx.selectedObjects;
    }

    return this.ctx.scene.objects.selected.editable;
  }

  selectedObjects_save() {
    let ret = [];
    for (let ob of this.selectedObjects) {
        ret.push(ob.id);        
    }

    return ret;
  }

  selectedObjects_load(ctx, data) {
    let ret = [];

    for (let id of data) {
        ret.push([lookup object from data using (possible new) context ctx])
    }

    return ret;
  }
}</code>
</code></pre><h2>Locked contexts</h2><p>Locked contexts are contexts whose properties are &quot;saved&quot;, but not as direct references.
Instead, each property is (ideally) saved as some sort of ID or datapath to look up
the true value on property access.</p><p>We suggest you subclass Context and implement saveProperty and loadProperty methods.</p><pre><code><code class="source-code prettyprint">class Overlay extends ContextOverlay {
  get something() {
    return something;
  }

  something_save() {
    return this.state.something.id;
  }

  something_load(ctx, id) {
    return [lookup id somewhere to get something];
  }
}</code>
</code></pre><h2>Tool Contexts</h2><p>We encourage you to put Context properties related to the view inside
a separate ContextOverlay.  That way you can keep ToolOps from accessing
the view by feeding them a special context that lacks that overlay
(but note that tools in modal mode should always get a full context). </p><pre><code><code class="source-code prettyprint">class ToolOverlay extends ContextOverlay {
    static contextDefine() {return {
        name : &quot;tool&quot;
    }}

    get mesh() {
        return this.state.mesh;
    }

    get material() {
        return this.state.material;
    }
}
Context.register(ToolOverlay);

class ViewOverlay extends ContextOverlay {
    static contextDefine() {return {
        name : &quot;view&quot;,
        flag : ContextFlags.IS_VIEW
    }}

    get screen() {
        return this.state.screen;
    }

    get textEditor() {
        return 
    }
}
Context.register(ToolOverlay);</code>
</code></pre></div>
        <a data-ice="link" href="manual/context.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>FrameManager Module</h1><p>The FrameManager module has two core classes: <a href="./manual/../class/scripts/screen/FrameManager.js~Screen.html">Screen</a>, and <a href="./manual/../class/scripts/screen/ScreenArea.js~Area.html">Area</a>.</p></div>
        <a data-ice="link" href="manual/FrameManager.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Architecture</h1><ul>
<li><a href="./manual/manual/architecture.html">Overview</a></li>
<li><a href="./manual/manual/context.html">Context</a></li>
<li><a href="./manual/manual/controller.html">Controller</a></li>
<li><a href="./manual/manual/toolprop.html">Tool Properties</a></li>
<li><a href="./manual/manual/toolsystem.html">Tool System</a></li>
<li><a href="./manual/manual/nstructjs.html">STRUCT</a></li>
<li><a href="./manual/manual/FrameManager.html">FrameManager</a></li>
</ul></div>
        <a data-ice="link" href="manual/index.html#architecture"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>NStructJS</h1><p>NStructJS is a little library for saving/loading highly structured JS objects as binary data
(for more info, see the <a href="https://github.com/joeedh/STRUCT/wiki">official documentation</a> ).
It is not suited for unstructed data (use JSON for that).<br>NStructJS arose out of the following shortcomings of JSON:</p><ul>
<li>JSON allocates objects twice.</li>
<li>JSON is slow compared to what you can get with a structured binary format</li>
</ul><p>The idea of NStructJS is to attach little scripts to your classes that define that 
class&apos;s data and how it is saved.  For example:</p><pre><code><code class="source-code prettyprint">class SomeClass {
  constructor() {
    this.data1 = 0;
    this.data2 = [1, 2, 3];
    this.obj = [some object];
  }

  //reader &quot;fills in&quot; fields in a newly created object with loaded data
  loadSTRUCT(reader) {
    reader(this);
    super.loadSTRUCT(reader);
  }
}
SomeClass.STRUCT = `
my_module.SomeClass {
  data1 : int;
  data2 : array;
  obj   : int | this.obj.id;
}
`;
nstructjs.manager.add_class(SomeClass);</code>
</code></pre><h2>Control How Fields Are Saved</h2><p>You can use little code snippets to control how fields are saved.
For example, if you want to save an integer ID instead of a reference for an 
object property, you might do this:</p><pre><code><code class="source-code prettyprint">my_module.AnotherClass {
  someclass : int | this.someclass !== undefined ? this.someclass.id : -1;
}</code>
</code></pre><h2>Versioning</h2><p>To a certain extend nstructjs will gracefully handle version changes.  The basic idea is to save a
copy of your struct scripts with each file, that way each file knows how to load itself.</p></div>
        <a data-ice="link" href="manual/nstructjs.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Tool System</h1><p>Tools are what the user uses to change state in the model.  They handle undo, can take control of events if needed and 
in general are foundational to path.ux and it&apos;s associated projects.  </p><p>Tools all inherit from <a href="./manual/../class/scripts/toolsys/simple_toolsys.js~ToolOp.html">ToolOp</a>, which roughly looks like this (see Context section for an 
explanation for what the &quot;ctx&quot; parameters are):</p><pre><code><code class="source-code prettyprint">class SomeTool extends ToolOp {
  static tooldef() {return {
    uiname   : &quot;Tool&quot;,
    path     : &quot;module.tool&quot;
    inputs   : ToolOp.inherit({}), //inherit properties from base class
    outputs  : {}
  }}
  static invoke(ctx, args) {
    /*create a new tool instance.
      args is simple key:val mapping
      where val is either a string, a number
      or a boolean.*/
    return new ToolOp()
  }
  undoPre(ctx) {
    //create undo data
  }
  undo(ctx) {
    //execute undo with data made in previous call to this.undoPre
  }
  exec(ctx) {
    //execute tool
  }
  modalStart(ctx) {
    //start interactice mode
  }
  modalEnd(ctx) {
    //end interactive mode
  }
  on_[mousedown/mousemove/mouseup/keydown](ctx) {
    //interactive mode event
  }

  ToolOp.register(SomeTool);
}</code>
</code></pre><h2>Context</h2><p>The foundation of the tool system is a special Context struct that&apos;s provided by client code.  Think of it as defining &quot;arguments&quot; for tools.  Path.ux can use any context struct, but requires the following properties be defined:</p><pre><code><code class="source-code prettyprint">class Context {
  get api() {
    //return reference to a controller.ModelInterface
  }

  get appstate() {
    //return reference to main appstate global
  }

  get screen() {
    //return reference to main FrameManager.screen
  }
}</code>
</code></pre><p>In addition, path.ux has hooks to provide UI context, specifically which are is currently active.  To do this,
either override the following methods in ScreenArea.Area.prototype, or subclass Area:</p><pre><code><code class="source-code prettyprint">  //called when area should be considered &quot;active&quot;
  push_ctx_active() {
  }

  //called when area should be considered &quot;inactive&quot;
  pop_ctx_active() {
  }</code>
</code></pre><h2>Undo</h2><p>Typically tools will inherit from a base class with a general, brute-force undo (i.e. saving the 
entire application and then reloading it on undo).  Additionally to save on speed and memory subclasses 
can override undoPre and undo with their own implementation.</p><h2>tooldef()</h2><p>Tools have a special tooldef() static function that &quot;defines&quot; the tool.  It returns things like
what properties the tool has, it&apos;s name, it&apos;s path in the data path system, etc.</p><h2>Tool Properties</h2><p>Tools have input and output slots.  See toolprop.js.  There are integer properties, float properties, 
various linear algebra properties (vectors, matrices), enumerations, bitflags, and in addition client code
may provide it&apos;s own property classes.</p></div>
        <a data-ice="link" href="manual/toolsystem.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
